<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OrcaSlicer: src/mcut/source/kernel.cpp File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../OrcaSlicer_32px.png"/></td>
  <td id="projectalign">
   <div id="projectname">OrcaSlicer<span id="projectnumber">&#160;1.6.3</span>
   </div>
   <div id="projectbrief">OrcaSlicer</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('dd/d24/kernel_8cpp.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">kernel.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;functional&gt;</code><br />
<code>#include &lt;iterator&gt;</code><br />
<code>#include &lt;numeric&gt;</code><br />
<code>#include &lt;queue&gt;</code><br />
<code>#include &lt;set&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;tuple&gt;</code><br />
<code>#include &lt;unordered_map&gt;</code><br />
<code>#include &quot;<a class="el" href="../../">mcut/internal/bvh.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../">mcut/internal/hmesh.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../">mcut/internal/kernel.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../">mcut/internal/math.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../">mcut/internal/timer.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../">mcut/internal/utils.h</a>&quot;</code><br />
</div><div class="textblock"><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="../../closed.png" alt="+"/> Include dependency graph for kernel.cpp:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="../../d9/d79/kernel_8cpp__incl.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
</div>
<p><a href="">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:d7/dd7/structconnected__component__info__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/kernel_8cpp.html#d7/dd7/structconnected__component__info__t">connected_component_info_t</a></td></tr>
<tr class="separator:d7/dd7/structconnected__component__info__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:d8/dcc/namespacestd"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dcc/namespacestd.html">std</a></td></tr>
<tr class="memdesc:d8/dcc/namespacestd"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:afee332fde04478605c5c0dc0105d50a9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/kernel_8cpp.html#afee332fde04478605c5c0dc0105d50a9">lmsg</a>()&#160;&#160;&#160;printf(&quot;NOTE: MCUT is copyrighted and may not be sold or included <a class="el" href="../../d7/da4/testmini_8c.html#a6355bd7e1f3a9e910ff48e2c374fc62a">in</a> commercial products without a license.\n&quot;)</td></tr>
<tr class="separator:afee332fde04478605c5c0dc0105d50a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad844a6457581698e69ccfa3e5199ebc9"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a></td></tr>
<tr class="separator:ad844a6457581698e69ccfa3e5199ebc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af4bc231d061945eb59dbba98a117ece9"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af4bc231d061945eb59dbba98a117ece9"><td class="memTemplItemLeft" align="right" valign="top">edge_array_iterator_t::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a> (<a class="el" href="../../df/d77/hmesh_8h.html#affed9b0e2b4a24bed7ad71f77832a25f">edge_array_iterator_t</a> first, <a class="el" href="../../df/d77/hmesh_8h.html#affed9b0e2b4a24bed7ad71f77832a25f">edge_array_iterator_t</a> last)</td></tr>
<tr class="separator:af4bc231d061945eb59dbba98a117ece9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac170ee95cd3318133c47c23a4a4412b8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/kernel_8cpp.html#ac170ee95cd3318133c47c23a4a4412b8">to_string</a> (const <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1">sm_frag_location_t</a> &amp;v)</td></tr>
<tr class="separator:ac170ee95cd3318133c47c23a4a4412b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeec0701cfd56cb95323d088cd3d39e1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/kernel_8cpp.html#aaeec0701cfd56cb95323d088cd3d39e1">to_string</a> (const <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956">cm_patch_location_t</a> &amp;v)</td></tr>
<tr class="separator:aaeec0701cfd56cb95323d088cd3d39e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26a7aae724ffde0eb556f68a46d59af"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/kernel_8cpp.html#ae26a7aae724ffde0eb556f68a46d59af">to_string</a> (const <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> &amp;v)</td></tr>
<tr class="separator:ae26a7aae724ffde0eb556f68a46d59af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f43e5a2eced0af01dc1143d0e70bc64"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/kernel_8cpp.html#a9f43e5a2eced0af01dc1143d0e70bc64">to_string</a> (const <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#afff2632fef27a069a33f81a0b51400f3">cm_patch_winding_order_t</a> &amp;v)</td></tr>
<tr class="separator:a9f43e5a2eced0af01dc1143d0e70bc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7de49b10bd8663a91f01e3beef776ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a> (const <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &amp;ps_vd, const <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> ps_vtx_cnt)</td></tr>
<tr class="separator:aa7de49b10bd8663a91f01e3beef776ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426849b7f7105963c5e2767bdd31b155"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/kernel_8cpp.html#a426849b7f7105963c5e2767bdd31b155">ps_is_cutmesh_vertex</a> (const <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &amp;ps_vd, const <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> sm_vtx_cnt)</td></tr>
<tr class="separator:a426849b7f7105963c5e2767bdd31b155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf65fb11520f9cb197774e79efeddfbb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/kernel_8cpp.html#aaf65fb11520f9cb197774e79efeddfbb">ps_is_cutmesh_face</a> (const <a class="el" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a> &amp;ps_fd, const <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> sm_face_count)</td></tr>
<tr class="separator:aaf65fb11520f9cb197774e79efeddfbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb440c35b34b7ecd91a6ce4eca6941e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d95/glu-libtess_8h.html#a4292190e3f1f6b373a760c7d9316ad3c">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/kernel_8cpp.html#a9bb440c35b34b7ecd91a6ce4eca6941e">dump_mesh</a> (const <a class="el" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> &amp;mesh, const char *fbasename)</td></tr>
<tr class="separator:a9bb440c35b34b7ecd91a6ce4eca6941e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e2380a93538369c59261853c0921ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d95/glu-libtess_8h.html#a4292190e3f1f6b373a760c7d9316ad3c">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/kernel_8cpp.html#a46e2380a93538369c59261853c0921ab">dfs_cc</a> (<a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> u, const <a class="el" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> &amp;mesh, std::vector&lt; <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> &gt; &amp;visited, <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> connected_component_id)</td></tr>
<tr class="separator:a46e2380a93538369c59261853c0921ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa563464e84f5a01cf43a91cc350fd920"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/kernel_8cpp.html#aa563464e84f5a01cf43a91cc350fd920">find_connected_components</a> (std::vector&lt; <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> &gt; &amp;fccmap, const <a class="el" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> &amp;mesh, std::vector&lt; <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> &gt; &amp;cc_to_vertex_count, std::vector&lt; <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> &gt; &amp;cc_to_face_count)</td></tr>
<tr class="separator:aa563464e84f5a01cf43a91cc350fd920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7095d6c7279faa9121a2a2722a51a814"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d95/glu-libtess_8h.html#a4292190e3f1f6b373a760c7d9316ad3c">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/kernel_8cpp.html#a7095d6c7279faa9121a2a2722a51a814">mark_seam_vertices</a> (std::vector&lt; bool &gt; &amp;mesh_seam_vertices, <a class="el" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> &amp;mesh, const <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> ps_num_vertices, const <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> m1_num_vertices_after_srcmesh_partitioning=std::numeric_limits&lt; <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> &gt;<a class="el" href="../../df/db1/math_8h.html#a5083c48fbfb60dd70808789479f4db53">::max</a>())</td></tr>
<tr class="separator:a7095d6c7279faa9121a2a2722a51a814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34276907046e706af5626787b2e2b05a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d7/d63/classhmesh__t.html">hmesh_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/kernel_8cpp.html#a34276907046e706af5626787b2e2b05a">extract_connected_components</a> (std::map&lt; std::size_t, std::vector&lt; std::pair&lt; std::shared_ptr&lt; <a class="el" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> &gt;, <a class="el" href="../../dd/d24/kernel_8cpp.html#d7/dd7/structconnected__component__info__t">connected_component_info_t</a> &gt; &gt; &gt; &amp;connected_components, const <a class="el" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> &amp;<a class="el" href="../../d7/da4/testmini_8c.html#a6355bd7e1f3a9e910ff48e2c374fc62a">in</a>, const <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> traced_polygons_base_offset, const std::vector&lt; std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a> &gt; &gt; &amp;mX_traced_polygons, const std::vector&lt; <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> &gt; &amp;sm_polygons_below_cs, const std::vector&lt; <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> &gt; &amp;sm_polygons_above_cs, const std::vector&lt; bool &gt; &amp;mesh_vertex_to_seam_flag, const std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &gt; &amp;m1_to_m0_sm_ovtx_colored, const std::unordered_map&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a>, <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &gt; &amp;m1_to_m0_cm_ovtx_colored, std::unordered_map&lt; <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>, <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> &gt; &amp;m1_to_m0_face_colored, const std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &gt; &amp;m0_to_ps_vtx, std::unordered_map&lt; <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>, <a class="el" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a> &gt; &amp;m0_to_ps_face, const std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &gt; &amp;ps_to_sm_vtx, const std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a> &gt; &amp;ps_to_sm_face, const std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &gt; &amp;ps_to_cm_vtx, const std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a> &gt; &amp;ps_to_cm_face, const <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> sm_vtx_cnt, const <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> sm_face_count, bool popuplate_vertex_maps, bool popuplate_face_maps, bool keep_fragments_below_cutmesh, bool keep_fragments_above_cutmesh, bool keep_fragments_partially_cut)</td></tr>
<tr class="separator:a34276907046e706af5626787b2e2b05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7bbc0e3b52fd64237a4e3525cbc09e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/kernel_8cpp.html#a0a7bbc0e3b52fd64237a4e3525cbc09e">is_virtual_face</a> (const <a class="el" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a> &amp;face)</td></tr>
<tr class="separator:a0a7bbc0e3b52fd64237a4e3525cbc09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c800ed2d7c13bb98e4f4fb2be59b53e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/kernel_8cpp.html#a9c800ed2d7c13bb98e4f4fb2be59b53e">have_same_coordinate</a> (const std::vector&lt; std::pair&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a>, <a class="el" href="../../df/db1/math_8h.html#aad22bf610529d452b5b6ba5b758cb39c">vec3</a> &gt; &gt; &amp;bin_vertices_sorted, const <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> coordinate_index=0)</td></tr>
<tr class="separator:a9c800ed2d7c13bb98e4f4fb2be59b53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e7884ca4d03bad54f0f83d198676e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/kernel_8cpp.html#ad0e7884ca4d03bad54f0f83d198676e5">m0_is_polygon_boundary_halfedge</a> (const <a class="el" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a> &amp;h, <a class="el" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> m0_num_cutpath_halfedges)</td></tr>
<tr class="separator:ad0e7884ca4d03bad54f0f83d198676e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b4325eac03e592fece787fdf95fec8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/kernel_8cpp.html#ab4b4325eac03e592fece787fdf95fec8">m0_is_polygon_boundary_edge</a> (const <a class="el" href="../../df/d77/hmesh_8h.html#a92abe1b30dc402b94e53318479d8b242">ed_t</a> &amp;e, <a class="el" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> m0_num_cutpath_edges)</td></tr>
<tr class="separator:ab4b4325eac03e592fece787fdf95fec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0299dc00caf656e5713f528574c77a02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/kernel_8cpp.html#a0299dc00caf656e5713f528574c77a02">resolve_intersection_point_descriptor</a> (const <a class="el" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> &amp;ps, const <a class="el" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> &amp;m0, <a class="el" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> &amp;m1, const <a class="el" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a> &amp;m0_h, const <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &amp;m0_h_tgt, const <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &amp;m1_h_tgt, const bool m0_h_is_ox, std::vector&lt; std::vector&lt; <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> &gt; &gt; &amp;m0_h_to_ply, std::unordered_map&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a>, std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a> &gt; &gt; &amp;ivtx_to_incoming_hlist, std::unordered_map&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a>, bool &gt; &amp;m0_sm_ihe_to_flag, const std::vector&lt; std::pair&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a92abe1b30dc402b94e53318479d8b242">ed_t</a>, <a class="el" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a> &gt; &gt; &amp;m0_ivtx_to_intersection_registry_entry, std::unordered_map&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a>, <a class="el" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a> &gt; &amp;m0_to_m1_ihe, const std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &gt; &amp;m0_to_ps_vtx, const <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> ps_vtx_cnt, const <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> sm_vtx_cnt, const <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> sm_face_count, const <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> m0_num_cutpath_halfedges)</td></tr>
<tr class="separator:a0299dc00caf656e5713f528574c77a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcaa230eb10486e26a5167bae360d451"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/kernel_8cpp.html#abcaa230eb10486e26a5167bae360d451">ps_get_ivtx_registry_entry_faces</a> (const <a class="el" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> &amp;ps, const std::pair&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a92abe1b30dc402b94e53318479d8b242">ed_t</a>, <a class="el" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a> &gt; &amp;ivtx_registry_entry)</td></tr>
<tr class="separator:abcaa230eb10486e26a5167bae360d451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263f562fbe3843b93d07f1b41eb4362e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d95/glu-libtess_8h.html#a4292190e3f1f6b373a760c7d9316ad3c">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/kernel_8cpp.html#a263f562fbe3843b93d07f1b41eb4362e">update_neighouring_ps_iface_m0_edge_list</a> (const <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &amp;src_vertex, const <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &amp;tgt_vertex, const <a class="el" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> &amp;ps, const <a class="el" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a> sm_face, const <a class="el" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a> cs_face, const std::vector&lt; std::pair&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a92abe1b30dc402b94e53318479d8b242">ed_t</a>, <a class="el" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a> &gt; &gt; &amp;m0_ivtx_to_intersection_registry_entry, std::unordered_map&lt; <a class="el" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a>, std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a92abe1b30dc402b94e53318479d8b242">ed_t</a> &gt; &gt; &amp;ps_iface_to_m0_edge_list, const std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a92abe1b30dc402b94e53318479d8b242">ed_t</a> &gt; &amp;m0_cutpath_edges)</td></tr>
<tr class="separator:a263f562fbe3843b93d07f1b41eb4362e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88bf8cfd20dbb5a5910da29eb700947"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/kernel_8cpp.html#ae88bf8cfd20dbb5a5910da29eb700947">mesh_is_closed</a> (const <a class="el" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> &amp;mesh)</td></tr>
<tr class="separator:ae88bf8cfd20dbb5a5910da29eb700947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b55223f27099f06cf4ef4442552eb3e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/kernel_8cpp.html#a1b55223f27099f06cf4ef4442552eb3e">linear_projection_sort</a> (const std::vector&lt; std::pair&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a>, <a class="el" href="../../df/db1/math_8h.html#aad22bf610529d452b5b6ba5b758cb39c">vec3</a> &gt; &gt; &amp;points)</td></tr>
<tr class="separator:a1b55223f27099f06cf4ef4442552eb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c30c80a68a0e6cab12250e5cd7b0d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d95/glu-libtess_8h.html#a4292190e3f1f6b373a760c7d9316ad3c">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/kernel_8cpp.html#a16c30c80a68a0e6cab12250e5cd7b0d6">dispatch</a> (<a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#dd/d30/structoutput__t">output_t</a> &amp;output, const <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#d4/dac/structinput__t">input_t</a> &amp;input)</td></tr>
<tr class="separator:a16c30c80a68a0e6cab12250e5cd7b0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a22191ac3d02f34a43e21432ad2289f14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d8/d0d/classlogger__t.html">logger_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d24/kernel_8cpp.html#a22191ac3d02f34a43e21432ad2289f14">logger_ptr</a> = nullptr</td></tr>
<tr class="separator:a22191ac3d02f34a43e21432ad2289f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="d7/dd7/structconnected__component__info__t" id="d7/dd7/structconnected__component__info__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d7/dd7/structconnected__component__info__t">&#9670;&#160;</a></span>connected_component_info_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct connected_component_info_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="../../closed.png" alt="+"/> Collaboration diagram for connected_component_info_t:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../dd/d54/structconnected__component__info__t__coll__graph.svg" width="476" height="526"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="../../graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a1bc542fb79db59847263709ec2552648" name="a1bc542fb79db59847263709ec2552648"></a><a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#d2/d46/structoutput__mesh__data__maps__t">output_mesh_data_maps_t</a></td>
<td class="fieldname">
data_maps</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="afa3c2c427f966ebf58df76bf2a70cb2a" name="afa3c2c427f966ebf58df76bf2a70cb2a"></a><a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1">sm_frag_location_t</a></td>
<td class="fieldname">
location = <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1a0db45d2a4141101bdfe48e3314cfbca3">sm_frag_location_t::UNDEFINED</a></td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a468cb4ae49fdbb1d4c3d9f1482d357c8" name="a468cb4ae49fdbb1d4c3d9f1482d357c8"></a>vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &gt;</td>
<td class="fieldname">
seam_vertices</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="afee332fde04478605c5c0dc0105d50a9" name="afee332fde04478605c5c0dc0105d50a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee332fde04478605c5c0dc0105d50a9">&#9670;&#160;</a></span>lmsg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lmsg</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;printf(&quot;NOTE: MCUT is copyrighted and may not be sold or included <a class="el" href="../../d7/da4/testmini_8c.html#a6355bd7e1f3a9e910ff48e2c374fc62a">in</a> commercial products without a license.\n&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copyright (c) 2021-2022 Floyd M. Chitalu. All rights reserved.</p>
<p>NOTE: This file is licensed under GPL-3.0-or-later (default). A commercial license can be purchased from Floyd M. Chitalu.</p>
<p>License details:</p>
<p>(A) GNU General Public License ("GPL"); a copy of which you should have recieved with this file.</p><ul>
<li>see also: <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a> (B) Commercial license.</li>
</ul>
<p>email: <a href="#" onclick="location.href='mai'+'lto:'+'flo'+'yd'+'.m.'+'ch'+'ita'+'lu'+'@gm'+'ai'+'l.c'+'om'; return false;">floyd<span class="obfuscator">.nosp@m.</span>.m.c<span class="obfuscator">.nosp@m.</span>hital<span class="obfuscator">.nosp@m.</span>u@gm<span class="obfuscator">.nosp@m.</span>ail.c<span class="obfuscator">.nosp@m.</span>om</a></p>
<p>The commercial license options is for users that wish to use MCUT in their products for comercial purposes but do not wish to release their software products under the GPL license.</p>
<p>Author(s) : Floyd M. Chitalu </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ad844a6457581698e69ccfa3e5199ebc9" name="ad844a6457581698e69ccfa3e5199ebc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad844a6457581698e69ccfa3e5199ebc9">&#9670;&#160;</a></span>traced_polygon_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a>&gt; <a class="el" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a46e2380a93538369c59261853c0921ab" name="a46e2380a93538369c59261853c0921ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e2380a93538369c59261853c0921ab">&#9670;&#160;</a></span>dfs_cc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d95/glu-libtess_8h.html#a4292190e3f1f6b373a760c7d9316ad3c">void</a> dfs_cc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>visited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>connected_component_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  217</span>{</div>
<div class="line"><span class="lineno">  218</span>    std::vector&lt;vd_t&gt; verts = mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ae892c101bd2816b0e18cf2e0405c16cb">get_vertices_around_vertex</a>(u);</div>
<div class="line"><span class="lineno">  219</span>    <span class="keywordflow">for</span> (std::vector&lt;vd_t&gt;::const_iterator v = verts.cbegin(); v != verts.cend(); ++v) {</div>
<div class="line"><span class="lineno">  220</span>        <span class="keywordflow">if</span> (<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(visited, *v) == -1) {</div>
<div class="line"><span class="lineno">  221</span>            visited[*v] = connected_component_id;</div>
<div class="line"><span class="lineno">  222</span>            <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a46e2380a93538369c59261853c0921ab">dfs_cc</a>(*v, mesh, visited, connected_component_id);</div>
<div class="line"><span class="lineno">  223</span>        }</div>
<div class="line"><span class="lineno">  224</span>    }</div>
<div class="line"><span class="lineno">  225</span>}</div>
<div class="ttc" id="aclasshmesh__t_html_ae892c101bd2816b0e18cf2e0405c16cb"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#ae892c101bd2816b0e18cf2e0405c16cb">hmesh_t::get_vertices_around_vertex</a></div><div class="ttdeci">std::vector&lt; vertex_descriptor_t &gt; get_vertices_around_vertex(const vertex_descriptor_t v) const</div><div class="ttdef"><b>Definition</b> hmesh.cpp:713</div></div>
<div class="ttc" id="akernel_8cpp_html_a46e2380a93538369c59261853c0921ab"><div class="ttname"><a href="../../dd/d24/kernel_8cpp.html#a46e2380a93538369c59261853c0921ab">dfs_cc</a></div><div class="ttdeci">void dfs_cc(vd_t u, const hmesh_t &amp;mesh, std::vector&lt; int &gt; &amp;visited, int connected_component_id)</div><div class="ttdef"><b>Definition</b> kernel.cpp:216</div></div>
<div class="ttc" id="autils_8h_html_af39e5a34a17cb0b2960384bdb2654831"><div class="ttname"><a href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a></div><div class="ttdeci">#define SAFE_ACCESS(var, i)</div><div class="ttdef"><b>Definition</b> utils.h:97</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00216">dfs_cc()</a>, <a class="el" href="../../#l00713">hmesh_t::get_vertices_around_vertex()</a>, and <a class="el" href="../../#l00097">SAFE_ACCESS</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../#l00216">dfs_cc()</a>.</p>
<div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="../../dd/d24/kernel_8cpp_a46e2380a93538369c59261853c0921ab_cgraph.svg" width="100%" height="414"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<div id="dynsection-3" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-3-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-3-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-3-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../dd/d24/kernel_8cpp_a46e2380a93538369c59261853c0921ab_icgraph.svg" width="71" height="60"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a16c30c80a68a0e6cab12250e5cd7b0d6" name="a16c30c80a68a0e6cab12250e5cd7b0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c30c80a68a0e6cab12250e5cd7b0d6">&#9670;&#160;</a></span>dispatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d95/glu-libtess_8h.html#a4292190e3f1f6b373a760c7d9316ad3c">void</a> dispatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#dd/d30/structoutput__t">output_t</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#d4/dac/structinput__t">input_t</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>vd_t, // intersection point</p>
<p>vd_t, // intersection point vec3 // the normal vector of intersected face from which intersection point came from</p>
<p>interior_edge_exists(m0, first_new_ivertex, second_new_ivertex /*, m0_cutpath_edges*&zwj;/)</p>
<p>ps_is_cutmesh_face(ps_face, sm_face_count)</p>
<p>is_ambiguious_boundary_edge_case || is_valid_ambiguious_boundary_edge</p>
<p>}</p>
<div class="fragment"><div class="line"><span class="lineno"> 1559</span>{</div>
<div class="line"><span class="lineno"> 1560</span>    <a class="code hl_define" href="../../dd/d24/kernel_8cpp.html#afee332fde04478605c5c0dc0105d50a9">lmsg</a>();</div>
<div class="line"><span class="lineno"> 1561</span> </div>
<div class="line"><span class="lineno"> 1562</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(__FUNCTION__);</div>
<div class="line"><span class="lineno"> 1563</span> </div>
<div class="line"><span class="lineno"> 1564</span>    <a class="code hl_class" href="../../d8/d0d/classlogger__t.html">logger_t</a>&amp; lg = output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a05468f8c497387b56c09f9b6105ec418">logger</a>;</div>
<div class="line"><span class="lineno"> 1565</span>    <a class="code hl_variable" href="../../dd/d24/kernel_8cpp.html#a22191ac3d02f34a43e21432ad2289f14">logger_ptr</a> = &amp;output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a05468f8c497387b56c09f9b6105ec418">logger</a>;</div>
<div class="line"><span class="lineno"> 1566</span>    lg.<a class="code hl_function" href="../../d8/d0d/classlogger__t.html#a1722aff1cd74b1f30e9fdc4e07602fa2">reset</a>();</div>
<div class="line"><span class="lineno"> 1567</span>    lg.<a class="code hl_function" href="../../d8/d0d/classlogger__t.html#a17b13679ad4d72b4b62c12e6083051ac">set_verbose</a>(input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#acbacc55f2163529291e5a45671fed3d1">verbose</a>);</div>
<div class="line"><span class="lineno"> 1568</span> </div>
<div class="line"><span class="lineno"> 1569</span><span class="preprocessor">#if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 1570</span>    output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a7d4c902daa6f0439e388496967885dd9">status</a>.store(<a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586ad0749aaba8b833466dfcbb0428e4f89c">status_t::SUCCESS</a>);</div>
<div class="line"><span class="lineno"> 1571</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 1572</span> </div>
<div class="line"><span class="lineno"> 1573</span>    <span class="keyword">const</span> <a class="code hl_class" href="../../d7/d63/classhmesh__t.html">hmesh_t</a>&amp; sm = (*input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#afee9c1311968896d08db6237842de68d">src_mesh</a>);</div>
<div class="line"><span class="lineno"> 1574</span>    <span class="keyword">const</span> <a class="code hl_class" href="../../d7/d63/classhmesh__t.html">hmesh_t</a>&amp; cs = (*input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#ac2f62986e978053577e509597be851e7">cut_mesh</a>);</div>
<div class="line"><span class="lineno"> 1575</span> </div>
<div class="line"><span class="lineno"> 1576</span>    <span class="keywordflow">if</span> (input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#acbacc55f2163529291e5a45671fed3d1">verbose</a>) {</div>
<div class="line"><span class="lineno"> 1577</span>        <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a9bb440c35b34b7ecd91a6ce4eca6941e">dump_mesh</a>(sm, <span class="stringliteral">&quot;src-mesh&quot;</span>);</div>
<div class="line"><span class="lineno"> 1578</span>        <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a9bb440c35b34b7ecd91a6ce4eca6941e">dump_mesh</a>(cs, <span class="stringliteral">&quot;cut-mesh&quot;</span>);</div>
<div class="line"><span class="lineno"> 1579</span>    }</div>
<div class="line"><span class="lineno"> 1580</span> </div>
<div class="line"><span class="lineno"> 1581</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> sm_vtx_cnt = sm.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a35ce6de1cc36d41e9eb48edb3e23e795">number_of_vertices</a>();</div>
<div class="line"><span class="lineno"> 1582</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> sm_face_count = sm.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a08178cf3f846017dbec208b96c970ac7">number_of_faces</a>();</div>
<div class="line"><span class="lineno"> 1583</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> cs_face_count = cs.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a08178cf3f846017dbec208b96c970ac7">number_of_faces</a>();</div>
<div class="line"><span class="lineno"> 1584</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> cs_vtx_count = cs.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a35ce6de1cc36d41e9eb48edb3e23e795">number_of_vertices</a>();</div>
<div class="line"><span class="lineno"> 1585</span> </div>
<div class="line"><span class="lineno"> 1586</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Check source mesh is closed&quot;</span>);</div>
<div class="line"><span class="lineno"> 1587</span>    <span class="keyword">const</span> <span class="keywordtype">bool</span> sm_is_watertight = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#ae88bf8cfd20dbb5a5910da29eb700947">mesh_is_closed</a>(</div>
<div class="line"><span class="lineno"> 1588</span>#<span class="keywordflow">if</span> 0 <span class="comment">//defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 1589</span>        *input.scheduler,</div>
<div class="line"><span class="lineno"> 1590</span>#endif</div>
<div class="line"><span class="lineno"> 1591</span>        sm);</div>
<div class="line"><span class="lineno"> 1592</span> </div>
<div class="line"><span class="lineno"> 1593</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 1594</span> </div>
<div class="line"><span class="lineno"> 1595</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Check cut mesh is closed&quot;</span>);</div>
<div class="line"><span class="lineno"> 1596</span>    <span class="keyword">const</span> <span class="keywordtype">bool</span> cm_is_watertight = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#ae88bf8cfd20dbb5a5910da29eb700947">mesh_is_closed</a>(</div>
<div class="line"><span class="lineno"> 1597</span>#<span class="keywordflow">if</span> 0<span class="comment">// defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 1598</span>        *input.scheduler,</div>
<div class="line"><span class="lineno"> 1599</span>#endif</div>
<div class="line"><span class="lineno"> 1600</span>        cs);</div>
<div class="line"><span class="lineno"> 1601</span> </div>
<div class="line"><span class="lineno"> 1602</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 1603</span> </div>
<div class="line"><span class="lineno"> 1605</span>    <span class="comment">// create polygon soup</span></div>
<div class="line"><span class="lineno"> 1607</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 1608</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Create ps&quot;</span>);</div>
<div class="line"><span class="lineno"> 1609</span>    <a class="code hl_class" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> ps = sm; <span class="comment">// copy</span></div>
<div class="line"><span class="lineno"> 1610</span> </div>
<div class="line"><span class="lineno"> 1611</span>    ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a0c71c904363d4a3932bd674812f8478e">reserve_for_additional_elements</a>(cs.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a35ce6de1cc36d41e9eb48edb3e23e795">number_of_vertices</a>()); <span class="comment">// hint</span></div>
<div class="line"><span class="lineno"> 1612</span> </div>
<div class="line"><span class="lineno"> 1613</span>    <span class="comment">// std::map&lt;vd_t, vd_t&gt; ps_to_sm_vtx;</span></div>
<div class="line"><span class="lineno"> 1614</span>    std::vector&lt;vd_t&gt; ps_to_sm_vtx((std::size_t)sm_vtx_cnt + cs.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a35ce6de1cc36d41e9eb48edb3e23e795">number_of_vertices</a>());</div>
<div class="line"><span class="lineno"> 1615</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 1616</span>    std::iota(std::begin(ps_to_sm_vtx), std::end(ps_to_sm_vtx), <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a>(0));</div>
<div class="line"><span class="lineno"> 1617</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno"> 1618</span><span class="preprocessor">#if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 1619</span>    {</div>
<div class="line"><span class="lineno"> 1620</span>        <span class="keyword">auto</span> fn_iota = [&amp;](<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">vertex_array_iterator_t</a> block_start_, <a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">vertex_array_iterator_t</a> block_end_) {</div>
<div class="line"><span class="lineno"> 1621</span>            <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">vertex_array_iterator_t</a> v = block_start_; v != block_end_; ++v) {</div>
<div class="line"><span class="lineno"> 1622</span>                ps_to_sm_vtx[*v] = *v;</div>
<div class="line"><span class="lineno"> 1623</span>            }</div>
<div class="line"><span class="lineno"> 1624</span>        };</div>
<div class="line"><span class="lineno"> 1625</span> </div>
<div class="line"><span class="lineno"> 1626</span>        <a class="code hl_function" href="../../df/d05/tpool_8h.html#a48d2e68725f7691f1422697f4c359827">parallel_for</a>(</div>
<div class="line"><span class="lineno"> 1627</span>            *input.scheduler,</div>
<div class="line"><span class="lineno"> 1628</span>            sm.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a0bf160ae73193f77064cc3d8f01e63a3">vertices_begin</a>(),</div>
<div class="line"><span class="lineno"> 1629</span>            sm.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a80ac49a03f1085744f5b121cc4acbf2c">vertices_end</a>(),</div>
<div class="line"><span class="lineno"> 1630</span>            fn_iota);</div>
<div class="line"><span class="lineno"> 1631</span>    }</div>
<div class="line"><span class="lineno"> 1632</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno"> 1633</span>    <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">vertex_array_iterator_t</a> v = sm.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a0bf160ae73193f77064cc3d8f01e63a3">vertices_begin</a>(); v != sm.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a80ac49a03f1085744f5b121cc4acbf2c">vertices_end</a>(); ++v) {</div>
<div class="line"><span class="lineno"> 1634</span>        ps_to_sm_vtx[*v] = *v; <span class="comment">// one to one mapping since ps is initially a copy of sm!</span></div>
<div class="line"><span class="lineno"> 1635</span>    }</div>
<div class="line"><span class="lineno"> 1636</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 1637</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 1638</span>    <span class="comment">// std::map&lt;fd_t, fd_t&gt; ps_to_sm_face;</span></div>
<div class="line"><span class="lineno"> 1639</span>    std::vector&lt;fd_t&gt; ps_to_sm_face((std::size_t)sm.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a08178cf3f846017dbec208b96c970ac7">number_of_faces</a>() + cs.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a08178cf3f846017dbec208b96c970ac7">number_of_faces</a>());</div>
<div class="line"><span class="lineno"> 1640</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 1641</span>    std::iota(std::begin(ps_to_sm_face), std::end(ps_to_sm_face), <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a>(0));</div>
<div class="line"><span class="lineno"> 1642</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno"> 1643</span><span class="preprocessor">#if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 1644</span>    {</div>
<div class="line"><span class="lineno"> 1645</span>        <span class="keyword">auto</span> fn_iota = [&amp;](<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">face_array_iterator_t</a> block_start_, <a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">face_array_iterator_t</a> block_end_) {</div>
<div class="line"><span class="lineno"> 1646</span>            <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">face_array_iterator_t</a> f = block_start_; f != block_end_; ++f) {</div>
<div class="line"><span class="lineno"> 1647</span>                ps_to_sm_face[*f] = *f;</div>
<div class="line"><span class="lineno"> 1648</span>            }</div>
<div class="line"><span class="lineno"> 1649</span>        };</div>
<div class="line"><span class="lineno"> 1650</span> </div>
<div class="line"><span class="lineno"> 1651</span>        <a class="code hl_function" href="../../df/d05/tpool_8h.html#a48d2e68725f7691f1422697f4c359827">parallel_for</a>(</div>
<div class="line"><span class="lineno"> 1652</span>            *input.scheduler,</div>
<div class="line"><span class="lineno"> 1653</span>            sm.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a913e50afe2e1dc220a379b1dbf8050d2">faces_begin</a>(),</div>
<div class="line"><span class="lineno"> 1654</span>            sm.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a89e4f1f34dda0bdeced26bc71cb4a4fc">faces_end</a>(),</div>
<div class="line"><span class="lineno"> 1655</span>            fn_iota);</div>
<div class="line"><span class="lineno"> 1656</span>    }</div>
<div class="line"><span class="lineno"> 1657</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno"> 1658</span>    <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">face_array_iterator_t</a> f = sm.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a913e50afe2e1dc220a379b1dbf8050d2">faces_begin</a>(); f != sm.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a89e4f1f34dda0bdeced26bc71cb4a4fc">faces_end</a>(); ++f) {</div>
<div class="line"><span class="lineno"> 1659</span>        ps_to_sm_face[*f] = *f; <span class="comment">// one to one mapping since ps is initially a copy of sm!</span></div>
<div class="line"><span class="lineno"> 1660</span>    }</div>
<div class="line"><span class="lineno"> 1661</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 1662</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 1663</span>    <span class="comment">// std::map&lt;vd_t, vd_t&gt; cs_to_ps_vtx;</span></div>
<div class="line"><span class="lineno"> 1664</span>    <span class="comment">// std::map&lt;vd_t, vd_t&gt; ps_to_cm_vtx;</span></div>
<div class="line"><span class="lineno"> 1665</span>    <span class="comment">// std::vector&lt;vd_t&gt; cs_to_ps_vtx(cs.number_of_vertices());</span></div>
<div class="line"><span class="lineno"> 1666</span>    std::vector&lt;vd_t&gt; ps_to_cm_vtx((std::size_t)sm_vtx_cnt + cs.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a35ce6de1cc36d41e9eb48edb3e23e795">number_of_vertices</a>());</div>
<div class="line"><span class="lineno"> 1667</span> </div>
<div class="line"><span class="lineno"> 1668</span>    <span class="comment">// merge cm vertices</span></div>
<div class="line"><span class="lineno"> 1669</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = cs.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a0bf160ae73193f77064cc3d8f01e63a3">vertices_begin</a>(); i != cs.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a80ac49a03f1085744f5b121cc4acbf2c">vertices_end</a>(); ++i) {</div>
<div class="line"><span class="lineno"> 1670</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> v = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a0d2a1a79406b7352af07d4fc56707782">add_vertex</a>(cs.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(*i));</div>
<div class="line"><span class="lineno"> 1671</span> </div>
<div class="line"><span class="lineno"> 1672</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(v != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ab448d0b9684fd2f648195b2e5edb83f2">hmesh_t::null_vertex</a>());</div>
<div class="line"><span class="lineno"> 1673</span> </div>
<div class="line"><span class="lineno"> 1674</span>        <span class="comment">// cs_to_ps_vtx.insert(std::make_pair(*i, v));</span></div>
<div class="line"><span class="lineno"> 1675</span>        <span class="comment">// cs_to_ps_vtx[*i] = v;</span></div>
<div class="line"><span class="lineno"> 1676</span>        ps_to_cm_vtx[v] = *i;</div>
<div class="line"><span class="lineno"> 1677</span>    }</div>
<div class="line"><span class="lineno"> 1678</span> </div>
<div class="line"><span class="lineno"> 1679</span>    <span class="comment">// std::map&lt;fd_t, fd_t&gt; ps_to_cm_face;</span></div>
<div class="line"><span class="lineno"> 1680</span>    std::vector&lt;fd_t&gt; ps_to_cm_face((std::size_t)sm_face_count + cs_face_count);</div>
<div class="line"><span class="lineno"> 1681</span> </div>
<div class="line"><span class="lineno"> 1682</span>    <span class="comment">// merge cm faces</span></div>
<div class="line"><span class="lineno"> 1683</span>    {</div>
<div class="line"><span class="lineno"> 1684</span><span class="preprocessor">#if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 1685</span>        {</div>
<div class="line"><span class="lineno"> 1686</span>            <span class="keyword">auto</span> fn_remap_ps_faces = [&amp;](<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">face_array_iterator_t</a> block_start_, <a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">face_array_iterator_t</a> block_end_) {</div>
<div class="line"><span class="lineno"> 1687</span>                std::vector&lt;std::pair&lt;fd_t, std::vector&lt;vd_t&gt;&gt;&gt; result(<a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(block_start_, block_end_));</div>
<div class="line"><span class="lineno"> 1688</span> </div>
<div class="line"><span class="lineno"> 1689</span>                <a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> counter = 0;</div>
<div class="line"><span class="lineno"> 1690</span>                <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">face_array_iterator_t</a> i = block_start_; i != block_end_; ++i) {</div>
<div class="line"><span class="lineno"> 1691</span>                    std::pair&lt;fd_t, std::vector&lt;vd_t&gt;&gt;&amp; p = result[counter++];</div>
<div class="line"><span class="lineno"> 1692</span>                    std::vector&lt;vd_t&gt;&amp; remapped_face_vertices = p.second;</div>
<div class="line"><span class="lineno"> 1693</span>                    cs.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a765a6f3b7249eb47135d246f6d301102">get_vertices_around_face</a>(remapped_face_vertices, *i, sm_vtx_cnt);</div>
<div class="line"><span class="lineno"> 1694</span>                    p.first = *i;</div>
<div class="line"><span class="lineno"> 1695</span>                }</div>
<div class="line"><span class="lineno"> 1696</span> </div>
<div class="line"><span class="lineno"> 1697</span>                <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno"> 1698</span>            };</div>
<div class="line"><span class="lineno"> 1699</span> </div>
<div class="line"><span class="lineno"> 1700</span>            std::vector&lt;std::future&lt;std::vector&lt;std::pair&lt;fd_t, std::vector&lt;vd_t&gt;&gt;&gt;&gt;&gt; futures;</div>
<div class="line"><span class="lineno"> 1701</span>            std::vector&lt;std::pair&lt;fd_t, std::vector&lt;vd_t&gt;&gt;&gt; master_thread_res;</div>
<div class="line"><span class="lineno"> 1702</span> </div>
<div class="line"><span class="lineno"> 1703</span>            <a class="code hl_function" href="../../df/d05/tpool_8h.html#a48d2e68725f7691f1422697f4c359827">parallel_for</a>(</div>
<div class="line"><span class="lineno"> 1704</span>                *input.scheduler,</div>
<div class="line"><span class="lineno"> 1705</span>                cs.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a913e50afe2e1dc220a379b1dbf8050d2">faces_begin</a>(),</div>
<div class="line"><span class="lineno"> 1706</span>                cs.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a89e4f1f34dda0bdeced26bc71cb4a4fc">faces_end</a>(),</div>
<div class="line"><span class="lineno"> 1707</span>                fn_remap_ps_faces,</div>
<div class="line"><span class="lineno"> 1708</span>                master_thread_res,</div>
<div class="line"><span class="lineno"> 1709</span>                futures);</div>
<div class="line"><span class="lineno"> 1710</span> </div>
<div class="line"><span class="lineno"> 1711</span>            <span class="keyword">auto</span> add_faces = [&amp;](<span class="keyword">const</span> std::vector&lt;std::pair&lt;fd_t, std::vector&lt;vd_t&gt;&gt;&gt;&amp; remapped_faces) {</div>
<div class="line"><span class="lineno"> 1712</span>                <span class="keywordflow">for</span> (std::vector&lt;std::pair&lt;<a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a>, std::vector&lt;vd_t&gt;&gt;&gt;::const_iterator it = remapped_faces.cbegin(); it != remapped_faces.cend(); ++it) {</div>
<div class="line"><span class="lineno"> 1713</span>                    <span class="keyword">const</span> std::pair&lt;fd_t, std::vector&lt;vd_t&gt;&gt;&amp; p = *it;</div>
<div class="line"><span class="lineno"> 1714</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> f = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a2784844d96e3180300014869148d7577">add_face</a>(p.second);</div>
<div class="line"><span class="lineno"> 1715</span> </div>
<div class="line"><span class="lineno"> 1716</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(f != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>());</div>
<div class="line"><span class="lineno"> 1717</span> </div>
<div class="line"><span class="lineno"> 1718</span>                    ps_to_cm_face[f] = p.first;</div>
<div class="line"><span class="lineno"> 1719</span>                }</div>
<div class="line"><span class="lineno"> 1720</span>            };</div>
<div class="line"><span class="lineno"> 1721</span> </div>
<div class="line"><span class="lineno"> 1722</span>            <span class="keywordflow">for</span> (<a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> i = 0; i &lt; (<a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>)futures.size(); ++i) {</div>
<div class="line"><span class="lineno"> 1723</span>                <span class="keyword">const</span> std::vector&lt;std::pair&lt;fd_t, std::vector&lt;vd_t&gt;&gt;&gt; f_res = futures[i].get();</div>
<div class="line"><span class="lineno"> 1724</span>                add_faces(f_res);</div>
<div class="line"><span class="lineno"> 1725</span>            }</div>
<div class="line"><span class="lineno"> 1726</span> </div>
<div class="line"><span class="lineno"> 1727</span>            add_faces(master_thread_res);</div>
<div class="line"><span class="lineno"> 1728</span>        }</div>
<div class="line"><span class="lineno"> 1729</span><span class="preprocessor">#else </span><span class="comment">// #if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 1730</span> </div>
<div class="line"><span class="lineno"> 1731</span>        std::vector&lt;vd_t&gt; remapped_face_vertices_tmp;</div>
<div class="line"><span class="lineno"> 1732</span>        <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">face_array_iterator_t</a> i = cs.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a913e50afe2e1dc220a379b1dbf8050d2">faces_begin</a>(); i != cs.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a89e4f1f34dda0bdeced26bc71cb4a4fc">faces_end</a>(); ++i) {</div>
<div class="line"><span class="lineno"> 1733</span>            <span class="comment">// std::vector&lt;vd_t&gt; fv = get_vertices_on_face(cs, *i);</span></div>
<div class="line"><span class="lineno"> 1734</span> </div>
<div class="line"><span class="lineno"> 1735</span>            cs.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a765a6f3b7249eb47135d246f6d301102">get_vertices_around_face</a>(remapped_face_vertices_tmp, *i, sm_vtx_cnt);</div>
<div class="line"><span class="lineno"> 1736</span>            <span class="keyword">const</span> std::vector&lt;vd_t&gt;&amp; remapped_face_vertices = remapped_face_vertices_tmp;</div>
<div class="line"><span class="lineno"> 1737</span> </div>
<div class="line"><span class="lineno"> 1738</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> f = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a2784844d96e3180300014869148d7577">add_face</a>(remapped_face_vertices);</div>
<div class="line"><span class="lineno"> 1739</span> </div>
<div class="line"><span class="lineno"> 1740</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(f != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>());</div>
<div class="line"><span class="lineno"> 1741</span> </div>
<div class="line"><span class="lineno"> 1742</span>            ps_to_cm_face[f] = *i;</div>
<div class="line"><span class="lineno"> 1743</span>        }</div>
<div class="line"><span class="lineno"> 1744</span><span class="preprocessor">#endif </span><span class="comment">// #if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 1745</span>    }</div>
<div class="line"><span class="lineno"> 1746</span> </div>
<div class="line"><span class="lineno"> 1747</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 1748</span> </div>
<div class="line"><span class="lineno"> 1749</span>    <span class="comment">// cs_to_ps_vtx.clear();</span></div>
<div class="line"><span class="lineno"> 1750</span> </div>
<div class="line"><span class="lineno"> 1751</span>    <span class="keywordflow">if</span> (input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#acbacc55f2163529291e5a45671fed3d1">verbose</a>) {</div>
<div class="line"><span class="lineno"> 1752</span>        <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a9bb440c35b34b7ecd91a6ce4eca6941e">dump_mesh</a>(ps, <span class="stringliteral">&quot;polygon-soup&quot;</span>);</div>
<div class="line"><span class="lineno"> 1753</span>    }</div>
<div class="line"><span class="lineno"> 1754</span> </div>
<div class="line"><span class="lineno"> 1755</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> ps_vtx_cnt = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a35ce6de1cc36d41e9eb48edb3e23e795">number_of_vertices</a>();</div>
<div class="line"><span class="lineno"> 1756</span>    <span class="comment">// const int ps_face_cnt = ps.number_of_faces();</span></div>
<div class="line"><span class="lineno"> 1757</span> </div>
<div class="line"><span class="lineno"> 1758</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 1759</span> </div>
<div class="line"><span class="lineno"> 1761</span>    <span class="comment">// create the first auxilliary halfedge data structure (&quot;m0&quot;)</span></div>
<div class="line"><span class="lineno"> 1763</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 1764</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Create m0&quot;</span>);</div>
<div class="line"><span class="lineno"> 1765</span>    <span class="comment">// The auxilliary data structure stores:</span></div>
<div class="line"><span class="lineno"> 1766</span>    <span class="comment">// 1) vertices of the polygon-soup, including new intersection points</span></div>
<div class="line"><span class="lineno"> 1767</span>    <span class="comment">// 2) Non-intersecting edges of the polygon-soup</span></div>
<div class="line"><span class="lineno"> 1768</span>    <span class="comment">// 3) New edges created from intersection points</span></div>
<div class="line"><span class="lineno"> 1769</span>    <a class="code hl_class" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> m0;</div>
<div class="line"><span class="lineno"> 1770</span> </div>
<div class="line"><span class="lineno"> 1771</span>    <span class="comment">// copy ps vertices into the auxilliary mesh (map is used to maintain original vertex order)</span></div>
<div class="line"><span class="lineno"> 1772</span>    <span class="comment">// std::map&lt;vd_t, vd_t&gt; m0_to_ps_vtx;</span></div>
<div class="line"><span class="lineno"> 1773</span>    std::vector&lt;vd_t&gt; m0_to_ps_vtx; <span class="comment">// NOTE: only ps vertices are stored here</span></div>
<div class="line"><span class="lineno"> 1774</span>    <span class="comment">// std::map&lt;vd_t, vd_t&gt; ps_to_m0_vtx;</span></div>
<div class="line"><span class="lineno"> 1775</span>    std::vector&lt;vd_t&gt; ps_to_m0_vtx((std::size_t)sm_vtx_cnt + cs.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a35ce6de1cc36d41e9eb48edb3e23e795">number_of_vertices</a>());</div>
<div class="line"><span class="lineno"> 1776</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a0bf160ae73193f77064cc3d8f01e63a3">vertices_begin</a>(); i != ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a80ac49a03f1085744f5b121cc4acbf2c">vertices_end</a>(); ++i) {</div>
<div class="line"><span class="lineno"> 1777</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> v = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a0d2a1a79406b7352af07d4fc56707782">add_vertex</a>(ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(*i));</div>
<div class="line"><span class="lineno"> 1778</span> </div>
<div class="line"><span class="lineno"> 1779</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(v != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ab448d0b9684fd2f648195b2e5edb83f2">hmesh_t::null_vertex</a>());</div>
<div class="line"><span class="lineno"> 1780</span> </div>
<div class="line"><span class="lineno"> 1781</span>        <span class="comment">// m0_to_ps_vtx.emplace(v, *i);</span></div>
<div class="line"><span class="lineno"> 1782</span>        m0_to_ps_vtx.emplace_back(*i);</div>
<div class="line"><span class="lineno"> 1783</span>        <span class="comment">// ps_to_m0_vtx.emplace(*i, v);</span></div>
<div class="line"><span class="lineno"> 1784</span>        ps_to_m0_vtx[*i] = v;</div>
<div class="line"><span class="lineno"> 1785</span>    }</div>
<div class="line"><span class="lineno"> 1786</span> </div>
<div class="line"><span class="lineno"> 1787</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 1788</span>    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a35ce6de1cc36d41e9eb48edb3e23e795">number_of_vertices</a>() == ps_vtx_cnt); <span class="comment">// ... because we have only copied vertices</span></div>
<div class="line"><span class="lineno"> 1789</span> </div>
<div class="line"><span class="lineno"> 1791</span>    <span class="comment">// Calculate polygon intersection points</span></div>
<div class="line"><span class="lineno"> 1793</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 1794</span>    std::unordered_map&lt;ed_t, std::vector&lt;fd_t&gt;&gt; ps_edge_face_intersection_pairs;</div>
<div class="line"><span class="lineno"> 1795</span>    </div>
<div class="line"><span class="lineno"> 1796</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Prepare edge-to-face pairs&quot;</span>);</div>
<div class="line"><span class="lineno"> 1797</span> </div>
<div class="line"><span class="lineno"> 1798</span><span class="preprocessor">#if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 1799</span>    { <span class="comment">// NOTE: parallel implementation is different from sequential one</span></div>
<div class="line"><span class="lineno"> 1800</span>        <span class="keyword">typedef</span> std::unordered_map&lt;ed_t, std::vector&lt;fd_t&gt;&gt; OutputStorageType;</div>
<div class="line"><span class="lineno"> 1801</span>        <span class="keyword">typedef</span> std::map&lt;fd_t, std::vector&lt;fd_t&gt;&gt;::const_iterator InputStorageIteratorType;</div>
<div class="line"><span class="lineno"> 1802</span> </div>
<div class="line"><span class="lineno"> 1803</span>        std::vector&lt;std::future&lt;OutputStorageType&gt;&gt; futures;</div>
<div class="line"><span class="lineno"> 1804</span> </div>
<div class="line"><span class="lineno"> 1805</span>        <span class="keyword">auto</span> fn_compute_ps_edge_to_faces_map = [&amp;](InputStorageIteratorType block_start_, InputStorageIteratorType block_end_) {</div>
<div class="line"><span class="lineno"> 1806</span>            std::unordered_map&lt;ed_t, std::vector&lt;fd_t&gt;&gt; ps_edge_face_intersection_pairs_local;</div>
<div class="line"><span class="lineno"> 1807</span> </div>
<div class="line"><span class="lineno"> 1808</span>            <span class="keywordflow">for</span> (InputStorageIteratorType iter = block_start_; iter != block_end_; ++iter) {</div>
<div class="line"><span class="lineno"> 1809</span>                <span class="comment">// the face with the intersecting edges (i.e. the edges to be tested against the other face)</span></div>
<div class="line"><span class="lineno"> 1810</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a>&amp; intersecting_edge_face = iter-&gt;first; <span class="comment">// sm_face != hmesh_t::null_face() ? sm_face : cm_face;</span></div>
<div class="line"><span class="lineno"> 1811</span>                <span class="keyword">const</span> std::vector&lt;hd_t&gt;&amp; halfedges = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a86f122fb5db56b6f79b21b657d3326f9">get_halfedges_around_face</a>(intersecting_edge_face);</div>
<div class="line"><span class="lineno"> 1812</span> </div>
<div class="line"><span class="lineno"> 1813</span>                <span class="keywordflow">for</span> (std::vector&lt;hd_t&gt;::const_iterator hIter = halfedges.cbegin(); hIter != halfedges.cend(); ++hIter) {</div>
<div class="line"><span class="lineno"> 1814</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> edge = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a96e9db918396b86f0b61f5445ef46b18">edge</a>(*hIter);</div>
<div class="line"><span class="lineno"> 1815</span>                    std::vector&lt;fd_t&gt;&amp; edge_ifaces = ps_edge_face_intersection_pairs_local[edge];</div>
<div class="line"><span class="lineno"> 1816</span>                    <span class="keywordflow">if</span> (edge_ifaces.empty()) {</div>
<div class="line"><span class="lineno"> 1817</span>                        edge_ifaces = iter-&gt;second;</div>
<div class="line"><span class="lineno"> 1818</span>                        <span class="keywordflow">if</span> (edge_ifaces.size() &gt; 1) {</div>
<div class="line"><span class="lineno"> 1819</span>                            std::sort(edge_ifaces.begin(), edge_ifaces.end()); <span class="comment">// alows us to do binary search (std::lower_bound)</span></div>
<div class="line"><span class="lineno"> 1820</span>                        }</div>
<div class="line"><span class="lineno"> 1821</span>                    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 1822</span>                        <span class="keywordflow">for</span> (std::vector&lt;fd_t&gt;::const_iterator iface_iter = iter-&gt;second.cbegin();</div>
<div class="line"><span class="lineno"> 1823</span>                             iface_iter != iter-&gt;second.cend();</div>
<div class="line"><span class="lineno"> 1824</span>                             ++iface_iter) {</div>
<div class="line"><span class="lineno"> 1825</span>                            std::vector&lt;fd_t&gt;::iterator fiter = std::lower_bound(edge_ifaces.begin(), edge_ifaces.end(), *iface_iter);</div>
<div class="line"><span class="lineno"> 1826</span>                            <span class="keywordtype">bool</span> exists = fiter != edge_ifaces.end() &amp;&amp; (*fiter == *iface_iter);</div>
<div class="line"><span class="lineno"> 1827</span>                            <span class="keywordflow">if</span> (!exists) {</div>
<div class="line"><span class="lineno"> 1828</span>                                edge_ifaces.insert(fiter, *iface_iter); <span class="comment">// insert and maintain sorted order</span></div>
<div class="line"><span class="lineno"> 1829</span>                            }</div>
<div class="line"><span class="lineno"> 1830</span>                        }</div>
<div class="line"><span class="lineno"> 1831</span>                    }</div>
<div class="line"><span class="lineno"> 1832</span>                }</div>
<div class="line"><span class="lineno"> 1833</span>            }</div>
<div class="line"><span class="lineno"> 1834</span>            <span class="keywordflow">return</span> ps_edge_face_intersection_pairs_local;</div>
<div class="line"><span class="lineno"> 1835</span>        };</div>
<div class="line"><span class="lineno"> 1836</span> </div>
<div class="line"><span class="lineno"> 1837</span>        <a class="code hl_function" href="../../df/d05/tpool_8h.html#a48d2e68725f7691f1422697f4c359827">parallel_for</a>(</div>
<div class="line"><span class="lineno"> 1838</span>            *input.scheduler,</div>
<div class="line"><span class="lineno"> 1839</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8b2ff5d52c3860c53928326dddc24ff9">ps_face_to_potentially_intersecting_others</a>-&gt;cbegin(),</div>
<div class="line"><span class="lineno"> 1840</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8b2ff5d52c3860c53928326dddc24ff9">ps_face_to_potentially_intersecting_others</a>-&gt;cend(),</div>
<div class="line"><span class="lineno"> 1841</span>            fn_compute_ps_edge_to_faces_map,</div>
<div class="line"><span class="lineno"> 1842</span>            ps_edge_face_intersection_pairs, <span class="comment">// out</span></div>
<div class="line"><span class="lineno"> 1843</span>            futures);</div>
<div class="line"><span class="lineno"> 1844</span> </div>
<div class="line"><span class="lineno"> 1845</span>        <span class="comment">// merge results from other threads</span></div>
<div class="line"><span class="lineno"> 1846</span> </div>
<div class="line"><span class="lineno"> 1847</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> fi = 0; fi &lt; (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)futures.size(); ++fi) {</div>
<div class="line"><span class="lineno"> 1848</span>            std::future&lt;OutputStorageType&gt;&amp; f = futures[fi];</div>
<div class="line"><span class="lineno"> 1849</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(f.valid()); <span class="comment">// The behavior is undefined if valid()== false before the call to wait_for</span></div>
<div class="line"><span class="lineno"> 1850</span> </div>
<div class="line"><span class="lineno"> 1851</span>            OutputStorageType future_res = f.get();</div>
<div class="line"><span class="lineno"> 1852</span>            <span class="comment">// merge results for current block</span></div>
<div class="line"><span class="lineno"> 1853</span>            <span class="keywordflow">for</span> (OutputStorageType::const_iterator i = future_res.cbegin(); i != future_res.cend(); ++i) {</div>
<div class="line"><span class="lineno"> 1854</span>                OutputStorageType::iterator fiter = ps_edge_face_intersection_pairs.find(i-&gt;first);</div>
<div class="line"><span class="lineno"> 1855</span>                <span class="keywordflow">if</span> (fiter == ps_edge_face_intersection_pairs.cend()) {</div>
<div class="line"><span class="lineno"> 1856</span>                    ps_edge_face_intersection_pairs[i-&gt;first] = i-&gt;second;</div>
<div class="line"><span class="lineno"> 1857</span>                } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 1858</span>                    <span class="keywordflow">for</span> (std::vector&lt;fd_t&gt;::const_iterator j = i-&gt;second.cbegin(); j != i-&gt;second.cend(); ++j) {</div>
<div class="line"><span class="lineno"> 1859</span>                        std::vector&lt;fd_t&gt;::iterator lb_iter = std::lower_bound(fiter-&gt;second.begin(), fiter-&gt;second.end(), *j);</div>
<div class="line"><span class="lineno"> 1860</span>                        <span class="keywordtype">bool</span> exists = lb_iter != fiter-&gt;second.end() &amp;&amp; (*lb_iter == *j);</div>
<div class="line"><span class="lineno"> 1861</span>                        <span class="keywordflow">if</span> (!exists) {</div>
<div class="line"><span class="lineno"> 1862</span>                            fiter-&gt;second.insert(lb_iter, *j); <span class="comment">// insert and maintain sorted order</span></div>
<div class="line"><span class="lineno"> 1863</span>                        }</div>
<div class="line"><span class="lineno"> 1864</span>                    }</div>
<div class="line"><span class="lineno"> 1865</span>                }</div>
<div class="line"><span class="lineno"> 1866</span>            }</div>
<div class="line"><span class="lineno"> 1867</span>        }</div>
<div class="line"><span class="lineno"> 1868</span>    } <span class="comment">// end of parallel code</span></div>
<div class="line"><span class="lineno"> 1869</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno"> 1870</span>    {</div>
<div class="line"><span class="lineno"> 1871</span> </div>
<div class="line"><span class="lineno"> 1872</span>        std::vector&lt;fd_t&gt; unvisited_ps_ifaces; <span class="comment">//= *input.ps_face_to_potentially_intersecting_others;</span></div>
<div class="line"><span class="lineno"> 1873</span>        unvisited_ps_ifaces.reserve(input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8b2ff5d52c3860c53928326dddc24ff9">ps_face_to_potentially_intersecting_others</a>-&gt;size());</div>
<div class="line"><span class="lineno"> 1874</span>        <span class="comment">// NOTE: the elements of &quot;unvisited_ps_ifaces&quot; are already sorted because they come directly from</span></div>
<div class="line"><span class="lineno"> 1875</span>        <span class="comment">// &quot;input.ps_face_to_potentially_intersecting_others&quot;, which is an std::map (keys are always sorted)</span></div>
<div class="line"><span class="lineno"> 1876</span>        std::transform(</div>
<div class="line"><span class="lineno"> 1877</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8b2ff5d52c3860c53928326dddc24ff9">ps_face_to_potentially_intersecting_others</a>-&gt;cbegin(),</div>
<div class="line"><span class="lineno"> 1878</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8b2ff5d52c3860c53928326dddc24ff9">ps_face_to_potentially_intersecting_others</a>-&gt;cend(),</div>
<div class="line"><span class="lineno"> 1879</span>            std::back_inserter(unvisited_ps_ifaces),</div>
<div class="line"><span class="lineno"> 1880</span>            [](<span class="keyword">const</span> std::pair&lt;<a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a>, std::vector&lt;fd_t&gt;&gt;&amp; kv) { return kv.first; });</div>
<div class="line"><span class="lineno"> 1881</span> </div>
<div class="line"><span class="lineno"> 1882</span>        std::vector&lt;bool&gt; ps_iface_enqueued(ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a08178cf3f846017dbec208b96c970ac7">number_of_faces</a>(), <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno"> 1883</span> </div>
<div class="line"><span class="lineno"> 1884</span>        std::vector&lt;bool&gt; ps_edge_visited(ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ac759578dea5f6dd7eebcef3f1a5af705">number_of_edges</a>(), <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno"> 1885</span>        <span class="comment">// initially null</span></div>
<div class="line"><span class="lineno"> 1886</span>        std::map&lt;fd_t, std::vector&lt;fd_t&gt;&gt;::const_iterator cur_ps_cc_face = input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8b2ff5d52c3860c53928326dddc24ff9">ps_face_to_potentially_intersecting_others</a>-&gt;cend();</div>
<div class="line"><span class="lineno"> 1887</span>        <span class="comment">// start with any face, but we choose the first</span></div>
<div class="line"><span class="lineno"> 1888</span>        std::map&lt;fd_t, std::vector&lt;fd_t&gt;&gt;::const_iterator next_ps_cc_face = input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8b2ff5d52c3860c53928326dddc24ff9">ps_face_to_potentially_intersecting_others</a>-&gt;cbegin();</div>
<div class="line"><span class="lineno"> 1889</span>        ps_iface_enqueued[next_ps_cc_face-&gt;first] = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1890</span> </div>
<div class="line"><span class="lineno"> 1891</span>        <span class="comment">// an element of this queue is an iterator/ptr to an element of &quot;input.ps_face_to_potentially_intersecting_others&quot;</span></div>
<div class="line"><span class="lineno"> 1892</span>        std::queue&lt;std::map&lt;fd_t, std::vector&lt;fd_t&gt;&gt;::const_iterator&gt; adj_ps_face_queue;</div>
<div class="line"><span class="lineno"> 1893</span> </div>
<div class="line"><span class="lineno"> 1894</span>        <span class="keywordflow">do</span> { <span class="comment">// each iteration will find a set of edges that belong to a connected-component patch of intersectng faces (of sm or cm) in ps</span></div>
<div class="line"><span class="lineno"> 1895</span>            cur_ps_cc_face = next_ps_cc_face;</div>
<div class="line"><span class="lineno"> 1896</span>            next_ps_cc_face = input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8b2ff5d52c3860c53928326dddc24ff9">ps_face_to_potentially_intersecting_others</a>-&gt;cend(); <span class="comment">// set null</span></div>
<div class="line"><span class="lineno"> 1897</span> </div>
<div class="line"><span class="lineno"> 1898</span>            <span class="comment">// register unique edges of current face, and the add the neighbouring faces to queue</span></div>
<div class="line"><span class="lineno"> 1899</span> </div>
<div class="line"><span class="lineno"> 1900</span>            adj_ps_face_queue.push(cur_ps_cc_face);</div>
<div class="line"><span class="lineno"> 1901</span> </div>
<div class="line"><span class="lineno"> 1902</span>            <span class="keywordflow">do</span> { <span class="comment">// each interation will add unregistered edges of current face, and add unvisited faces to queue</span></div>
<div class="line"><span class="lineno"> 1903</span> </div>
<div class="line"><span class="lineno"> 1904</span>                <span class="keyword">const</span> std::map&lt;fd_t, std::vector&lt;fd_t&gt;&gt;::const_iterator cc_iface = adj_ps_face_queue.front(); <span class="comment">// current face of connected-component patch</span></div>
<div class="line"><span class="lineno"> 1905</span>                adj_ps_face_queue.pop();</div>
<div class="line"><span class="lineno"> 1906</span> </div>
<div class="line"><span class="lineno"> 1907</span>                { <span class="comment">// face is now visisted so we remove it</span></div>
<div class="line"><span class="lineno"> 1908</span>                    std::vector&lt;fd_t&gt;::iterator fiter = std::lower_bound(</div>
<div class="line"><span class="lineno"> 1909</span>                        unvisited_ps_ifaces.begin(),</div>
<div class="line"><span class="lineno"> 1910</span>                        unvisited_ps_ifaces.end(),</div>
<div class="line"><span class="lineno"> 1911</span>                        cc_iface-&gt;first);</div>
<div class="line"><span class="lineno"> 1912</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(fiter != unvisited_ps_ifaces.cend());</div>
<div class="line"><span class="lineno"> 1913</span>                    unvisited_ps_ifaces.erase(fiter); <span class="comment">// NOTE: list remains sorted</span></div>
<div class="line"><span class="lineno"> 1914</span>                }</div>
<div class="line"><span class="lineno"> 1915</span> </div>
<div class="line"><span class="lineno"> 1916</span>                std::vector&lt;fd_t&gt; cur_ps_face_ifaces_sorted = cc_iface-&gt;second; <span class="comment">// copy</span></div>
<div class="line"><span class="lineno"> 1917</span>                <span class="keywordflow">if</span> (cur_ps_face_ifaces_sorted.size() &gt; 1) {</div>
<div class="line"><span class="lineno"> 1918</span>                    std::sort(cur_ps_face_ifaces_sorted.begin(), cur_ps_face_ifaces_sorted.end()); <span class="comment">// allows quick binary search</span></div>
<div class="line"><span class="lineno"> 1919</span>                }</div>
<div class="line"><span class="lineno"> 1920</span>                <span class="comment">// bool is_sm_face = cc_iface-&gt;first &lt; sm_face_count;</span></div>
<div class="line"><span class="lineno"> 1921</span>                <span class="comment">//  const fd_t cc_iface_descr = is_sm_face ? cc_iface-&gt;first - sm_face_count : sm_face_count;</span></div>
<div class="line"><span class="lineno"> 1922</span> </div>
<div class="line"><span class="lineno"> 1923</span>                <span class="keyword">const</span> std::vector&lt;hd_t&gt;&amp; cur_ps_face_halfedges = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a86f122fb5db56b6f79b21b657d3326f9">get_halfedges_around_face</a>(cc_iface-&gt;first);</div>
<div class="line"><span class="lineno"> 1924</span>                <span class="comment">// all neighbours</span></div>
<div class="line"><span class="lineno"> 1925</span>                <span class="keyword">const</span> std::vector&lt;fd_t&gt; cur_ps_face_neigh_faces = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a197264c917b7fb5ddc007909ae89d372">get_faces_around_face</a>(cc_iface-&gt;first, &amp;cur_ps_face_halfedges);</div>
<div class="line"><span class="lineno"> 1926</span>                <span class="comment">// neighbours [which are intersecting faces]</span></div>
<div class="line"><span class="lineno"> 1927</span>                std::vector&lt;fd_t&gt; cur_ps_face_neigh_ifaces;</div>
<div class="line"><span class="lineno"> 1928</span>                cur_ps_face_neigh_ifaces.reserve(cur_ps_face_neigh_faces.size());</div>
<div class="line"><span class="lineno"> 1929</span> </div>
<div class="line"><span class="lineno"> 1930</span>                <span class="keywordflow">for</span> (std::vector&lt;fd_t&gt;::const_iterator face_iter = cur_ps_face_neigh_faces.cbegin();</div>
<div class="line"><span class="lineno"> 1931</span>                     face_iter != cur_ps_face_neigh_faces.cend();</div>
<div class="line"><span class="lineno"> 1932</span>                     ++face_iter) {</div>
<div class="line"><span class="lineno"> 1933</span>                    <span class="keywordtype">bool</span> is_iface = input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8b2ff5d52c3860c53928326dddc24ff9">ps_face_to_potentially_intersecting_others</a>-&gt;find(*face_iter) != input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8b2ff5d52c3860c53928326dddc24ff9">ps_face_to_potentially_intersecting_others</a>-&gt;cend();</div>
<div class="line"><span class="lineno"> 1934</span>                    <span class="keywordflow">if</span> (is_iface) {</div>
<div class="line"><span class="lineno"> 1935</span>                        cur_ps_face_neigh_ifaces.push_back(*face_iter);</div>
<div class="line"><span class="lineno"> 1936</span>                    }</div>
<div class="line"><span class="lineno"> 1937</span>                }</div>
<div class="line"><span class="lineno"> 1938</span> </div>
<div class="line"><span class="lineno"> 1939</span>                <span class="keywordflow">if</span> (cur_ps_face_neigh_ifaces.size() &gt; 1) {</div>
<div class="line"><span class="lineno"> 1940</span>                    std::sort(cur_ps_face_neigh_ifaces.begin(), cur_ps_face_neigh_ifaces.end());</div>
<div class="line"><span class="lineno"> 1941</span>                }</div>
<div class="line"><span class="lineno"> 1942</span> </div>
<div class="line"><span class="lineno"> 1943</span>                <span class="comment">// for each halfedge of current iface</span></div>
<div class="line"><span class="lineno"> 1944</span>                <span class="keywordflow">for</span> (std::vector&lt;hd_t&gt;::const_iterator hiter = cur_ps_face_halfedges.cbegin(); hiter != cur_ps_face_halfedges.cend(); ++hiter) {</div>
<div class="line"><span class="lineno"> 1945</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> halfedge_edge = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a96e9db918396b86f0b61f5445ef46b18">edge</a>(*hiter);</div>
<div class="line"><span class="lineno"> 1946</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> opp_he = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(*hiter);</div>
<div class="line"><span class="lineno"> 1947</span>                    <span class="comment">// Here we simply access corresponding element in &quot;cur_ps_face_neigh_faces&quot; based on</span></div>
<div class="line"><span class="lineno"> 1948</span>                    <span class="comment">// how &quot;ps.get_faces_around_face&quot; populates &quot;cur_ps_face_neigh_faces&quot;, given &quot;cur_ps_face_halfedges&quot;</span></div>
<div class="line"><span class="lineno"> 1949</span>                    <span class="comment">// as done above</span></div>
<div class="line"><span class="lineno"> 1950</span> </div>
<div class="line"><span class="lineno"> 1951</span>                    <span class="keywordflow">if</span> (ps_edge_visited[halfedge_edge] == <span class="keyword">false</span>) {</div>
<div class="line"><span class="lineno"> 1952</span>                        ps_edge_face_intersection_pairs.insert(std::make_pair(halfedge_edge, cur_ps_face_ifaces_sorted)); <span class="comment">// add edge</span></div>
<div class="line"><span class="lineno"> 1953</span>                        ps_edge_visited[halfedge_edge] = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1954</span> </div>
<div class="line"><span class="lineno"> 1955</span>                        <span class="keywordtype">bool</span> is_border_ps_face = cur_ps_face_neigh_faces.size() != cur_ps_face_halfedges.size();</div>
<div class="line"><span class="lineno"> 1956</span>                        <span class="keyword">const</span> <span class="keywordtype">size_t</span> idx = <a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(cur_ps_face_halfedges.cbegin(), hiter);</div>
<div class="line"><span class="lineno"> 1957</span>                        <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> opp_he_face = is_border_ps_face ? ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(opp_he) : <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(cur_ps_face_neigh_faces, idx);</div>
<div class="line"><span class="lineno"> 1958</span> </div>
<div class="line"><span class="lineno"> 1959</span>                        <span class="keywordflow">if</span> (!<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a0a7bbc0e3b52fd64237a4e3525cbc09e">is_virtual_face</a>(opp_he_face) &amp;&amp; ps_iface_enqueued[opp_he_face] == <span class="keyword">false</span>) { <span class="comment">// two neighbouring faces might share more that 1 edge (case of non-triangulated mesh)</span></div>
<div class="line"><span class="lineno"> 1960</span>                            <span class="keywordtype">bool</span> is_iface = std::binary_search(cur_ps_face_neigh_ifaces.cbegin(), cur_ps_face_neigh_ifaces.cend(), opp_he_face);</div>
<div class="line"><span class="lineno"> 1961</span>                            <span class="keywordflow">if</span> (is_iface) {</div>
<div class="line"><span class="lineno"> 1962</span>                                std::map&lt;fd_t, std::vector&lt;fd_t&gt;&gt;::const_iterator fiter = input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8b2ff5d52c3860c53928326dddc24ff9">ps_face_to_potentially_intersecting_others</a>-&gt;find(opp_he_face);</div>
<div class="line"><span class="lineno"> 1963</span>                                adj_ps_face_queue.push(fiter);</div>
<div class="line"><span class="lineno"> 1964</span>                                ps_iface_enqueued[opp_he_face] = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1965</span>                            }</div>
<div class="line"><span class="lineno"> 1966</span>                        }</div>
<div class="line"><span class="lineno"> 1967</span>                    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 1968</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ps_edge_face_intersection_pairs.find(halfedge_edge) != ps_edge_face_intersection_pairs.cend());</div>
<div class="line"><span class="lineno"> 1969</span>                        <span class="comment">// merge shared &quot;intersected&quot; faces.</span></div>
<div class="line"><span class="lineno"> 1970</span>                        <span class="comment">// Two intersecting faces that share an edge will share intersected faces. The shared faces</span></div>
<div class="line"><span class="lineno"> 1971</span>                        <span class="comment">// are those intersected by the shared edge.</span></div>
<div class="line"><span class="lineno"> 1972</span>                        std::vector&lt;fd_t&gt;&amp; existing_edge_ifaces = ps_edge_face_intersection_pairs[halfedge_edge]; <span class="comment">// sorted list</span></div>
<div class="line"><span class="lineno"> 1973</span> </div>
<div class="line"><span class="lineno"> 1974</span>                        <span class="keywordflow">for</span> (std::vector&lt;fd_t&gt;::const_iterator i = cur_ps_face_ifaces_sorted.cbegin(); i != cur_ps_face_ifaces_sorted.cend(); ++i) {</div>
<div class="line"><span class="lineno"> 1975</span>                            std::vector&lt;fd_t&gt;::iterator iter = std::lower_bound(existing_edge_ifaces.begin(), existing_edge_ifaces.end(), *i);</div>
<div class="line"><span class="lineno"> 1976</span> </div>
<div class="line"><span class="lineno"> 1977</span>                            <span class="keywordtype">bool</span> found = iter != existing_edge_ifaces.end() &amp;&amp; iter != existing_edge_ifaces.end() &amp;&amp; (*iter == *i);</div>
<div class="line"><span class="lineno"> 1978</span>                            <span class="keywordflow">if</span> (!found) {</div>
<div class="line"><span class="lineno"> 1979</span>                                existing_edge_ifaces.insert(iter, *i); <span class="comment">// insert into sorted list (i.e. possibly shifts some elements forward)</span></div>
<div class="line"><span class="lineno"> 1980</span>                            }</div>
<div class="line"><span class="lineno"> 1981</span>                        }</div>
<div class="line"><span class="lineno"> 1982</span>                    }</div>
<div class="line"><span class="lineno"> 1983</span>                } <span class="comment">// for each halfedge of current iface</span></div>
<div class="line"><span class="lineno"> 1984</span> </div>
<div class="line"><span class="lineno"> 1985</span>            } <span class="keywordflow">while</span> (adj_ps_face_queue.empty() == <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno"> 1986</span> </div>
<div class="line"><span class="lineno"> 1987</span>            <span class="comment">// find &quot;next_ps_cc_face&quot; as any face in &quot;input.ps_face_to_potentially_intersecting_others&quot; that is not visited</span></div>
<div class="line"><span class="lineno"> 1988</span>            <span class="keywordflow">if</span> (unvisited_ps_ifaces.size() &gt; 0) {</div>
<div class="line"><span class="lineno"> 1989</span>                <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> next_face = unvisited_ps_ifaces.back(); <span class="comment">// pick any unvisited iface (we choose the last for faster elemt removal from std::vector)</span></div>
<div class="line"><span class="lineno"> 1990</span>                next_ps_cc_face = input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8b2ff5d52c3860c53928326dddc24ff9">ps_face_to_potentially_intersecting_others</a>-&gt;find(next_face);</div>
<div class="line"><span class="lineno"> 1991</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(next_ps_cc_face != input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8b2ff5d52c3860c53928326dddc24ff9">ps_face_to_potentially_intersecting_others</a>-&gt;cend());</div>
<div class="line"><span class="lineno"> 1992</span>            }</div>
<div class="line"><span class="lineno"> 1993</span> </div>
<div class="line"><span class="lineno"> 1994</span>        } <span class="keywordflow">while</span> (next_ps_cc_face != input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8b2ff5d52c3860c53928326dddc24ff9">ps_face_to_potentially_intersecting_others</a>-&gt;cend());</div>
<div class="line"><span class="lineno"> 1995</span>    }</div>
<div class="line"><span class="lineno"> 1996</span>    <span class="comment">// std::unordered_map&lt;ed_t, std::vector&lt;fd_t&gt;&gt; ps_edge_face_intersection_pairs;</span></div>
<div class="line"><span class="lineno"> 1997</span><span class="preprocessor">#endif </span><span class="comment">// #if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 1998</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 1999</span> </div>
<div class="line"><span class="lineno"> 2000</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 2001</span>    <span class="comment">// build bounding boxes for each intersecting edge</span></div>
<div class="line"><span class="lineno"> 2002</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 2003</span><span class="preprocessor">#if 1</span></div>
<div class="line"><span class="lineno"> 2004</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Build edge bounding boxes&quot;</span>);</div>
<div class="line"><span class="lineno"> 2005</span> </div>
<div class="line"><span class="lineno"> 2006</span>    <span class="comment">// http://gamma.cs.unc.edu/RTRI/i3d08_RTRI.pdf</span></div>
<div class="line"><span class="lineno"> 2007</span>    std::unordered_map&lt;ed_t, bounding_box_t&lt;vec3&gt;&gt; ps_edge_to_bbox;</div>
<div class="line"><span class="lineno"> 2008</span> </div>
<div class="line"><span class="lineno"> 2009</span><span class="preprocessor">#if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 2010</span>    {</div>
<div class="line"><span class="lineno"> 2011</span>        <span class="keyword">typedef</span> std::unordered_map&lt;ed_t, bounding_box_t&lt;vec3&gt;&gt; OutputStorageType;</div>
<div class="line"><span class="lineno"> 2012</span>        <span class="keyword">typedef</span> std::unordered_map&lt;ed_t, std::vector&lt;fd_t&gt;&gt;::const_iterator InputStorageIteratorType;</div>
<div class="line"><span class="lineno"> 2013</span> </div>
<div class="line"><span class="lineno"> 2014</span>        <span class="keyword">auto</span> fn_compute_ps_edge_bbox = [&amp;](InputStorageIteratorType block_start_, InputStorageIteratorType block_end_) {</div>
<div class="line"><span class="lineno"> 2015</span>            OutputStorageType ps_edge_to_bbox_local;</div>
<div class="line"><span class="lineno"> 2016</span> </div>
<div class="line"><span class="lineno"> 2017</span>            <span class="keywordflow">for</span> (std::unordered_map&lt;<a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>, std::vector&lt;fd_t&gt;&gt;::const_iterator iedge_iter = block_start_; iedge_iter != block_end_; iedge_iter++) {</div>
<div class="line"><span class="lineno"> 2018</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> edge = iedge_iter-&gt;first;</div>
<div class="line"><span class="lineno"> 2019</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> v0 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(edge, 0);</div>
<div class="line"><span class="lineno"> 2020</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> v1 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(edge, 1);</div>
<div class="line"><span class="lineno"> 2021</span>                <a class="code hl_struct" href="../../df/d33/structbounding__box__t.html">bounding_box_t&lt;vec3&gt;</a>&amp; edge_bbox = ps_edge_to_bbox_local[edge];</div>
<div class="line"><span class="lineno"> 2022</span>                edge_bbox.<a class="code hl_function" href="../../df/d33/structbounding__box__t.html#a509cc2d8470f62eec4927f94e12ddb89">expand</a>(ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(v0));</div>
<div class="line"><span class="lineno"> 2023</span>                edge_bbox.<a class="code hl_function" href="../../df/d33/structbounding__box__t.html#a509cc2d8470f62eec4927f94e12ddb89">expand</a>(ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(v1));</div>
<div class="line"><span class="lineno"> 2024</span>            }</div>
<div class="line"><span class="lineno"> 2025</span> </div>
<div class="line"><span class="lineno"> 2026</span>            <span class="keywordflow">return</span> ps_edge_to_bbox_local;</div>
<div class="line"><span class="lineno"> 2027</span>        };</div>
<div class="line"><span class="lineno"> 2028</span> </div>
<div class="line"><span class="lineno"> 2029</span>        std::vector&lt;std::future&lt;OutputStorageType&gt;&gt; futures;</div>
<div class="line"><span class="lineno"> 2030</span> </div>
<div class="line"><span class="lineno"> 2031</span>        <a class="code hl_function" href="../../df/d05/tpool_8h.html#a48d2e68725f7691f1422697f4c359827">parallel_for</a>(</div>
<div class="line"><span class="lineno"> 2032</span>            *input.scheduler,</div>
<div class="line"><span class="lineno"> 2033</span>            ps_edge_face_intersection_pairs.cbegin(),</div>
<div class="line"><span class="lineno"> 2034</span>            ps_edge_face_intersection_pairs.cend(),</div>
<div class="line"><span class="lineno"> 2035</span>            fn_compute_ps_edge_bbox,</div>
<div class="line"><span class="lineno"> 2036</span>            ps_edge_to_bbox, <span class="comment">// out</span></div>
<div class="line"><span class="lineno"> 2037</span>            futures);</div>
<div class="line"><span class="lineno"> 2038</span> </div>
<div class="line"><span class="lineno"> 2039</span>        <span class="comment">// merge results from other threads</span></div>
<div class="line"><span class="lineno"> 2040</span> </div>
<div class="line"><span class="lineno"> 2041</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)futures.size(); ++i) {</div>
<div class="line"><span class="lineno"> 2042</span>            std::future&lt;OutputStorageType&gt;&amp; f = futures[i];</div>
<div class="line"><span class="lineno"> 2043</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(f.valid()); <span class="comment">// The behavior is undefined if valid()== false before the call to wait_for</span></div>
<div class="line"><span class="lineno"> 2044</span> </div>
<div class="line"><span class="lineno"> 2045</span>            OutputStorageType future_res = f.get();</div>
<div class="line"><span class="lineno"> 2046</span> </div>
<div class="line"><span class="lineno"> 2047</span>            ps_edge_to_bbox.insert(future_res.cbegin(), future_res.cend());</div>
<div class="line"><span class="lineno"> 2048</span>        }</div>
<div class="line"><span class="lineno"> 2049</span>    }</div>
<div class="line"><span class="lineno"> 2050</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno"> 2051</span>    <span class="keywordflow">for</span> (std::unordered_map&lt;<a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>, std::vector&lt;fd_t&gt;&gt;::const_iterator iedge_iter = ps_edge_face_intersection_pairs.cbegin();</div>
<div class="line"><span class="lineno"> 2052</span>         iedge_iter != ps_edge_face_intersection_pairs.cend();</div>
<div class="line"><span class="lineno"> 2053</span>         iedge_iter++) {</div>
<div class="line"><span class="lineno"> 2054</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(iedge_iter-&gt;second.size() &gt;= 1);</div>
<div class="line"><span class="lineno"> 2055</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> edge = iedge_iter-&gt;first;</div>
<div class="line"><span class="lineno"> 2056</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> v0 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(edge, 0);</div>
<div class="line"><span class="lineno"> 2057</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> v1 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(edge, 1);</div>
<div class="line"><span class="lineno"> 2058</span>        <a class="code hl_struct" href="../../df/d33/structbounding__box__t.html">bounding_box_t&lt;vec3&gt;</a>&amp; edge_bbox = ps_edge_to_bbox[edge];</div>
<div class="line"><span class="lineno"> 2059</span>        edge_bbox.<a class="code hl_function" href="../../df/d33/structbounding__box__t.html#a509cc2d8470f62eec4927f94e12ddb89">expand</a>(ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(v0));</div>
<div class="line"><span class="lineno"> 2060</span>        edge_bbox.<a class="code hl_function" href="../../df/d33/structbounding__box__t.html#a509cc2d8470f62eec4927f94e12ddb89">expand</a>(ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(v1));</div>
<div class="line"><span class="lineno"> 2061</span>    }</div>
<div class="line"><span class="lineno"> 2062</span><span class="preprocessor">#endif </span><span class="comment">// #if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 2063</span> </div>
<div class="line"><span class="lineno"> 2064</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 2065</span> </div>
<div class="line"><span class="lineno"> 2066</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 2067</span>    <span class="comment">// cull redundant edge to face pairs</span></div>
<div class="line"><span class="lineno"> 2068</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 2069</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Cull redundant edge-face pairs&quot;</span>);</div>
<div class="line"><span class="lineno"> 2070</span> </div>
<div class="line"><span class="lineno"> 2071</span><span class="preprocessor">#if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 2072</span>    {</div>
<div class="line"><span class="lineno"> 2073</span>        <span class="keyword">typedef</span> std::unordered_map&lt;ed_t, std::vector&lt;fd_t&gt;&gt;::iterator InputStorageIteratorType;</div>
<div class="line"><span class="lineno"> 2074</span> </div>
<div class="line"><span class="lineno"> 2075</span>        <span class="keyword">auto</span> fn_compute_edgefair_pair_culling = [&amp;](InputStorageIteratorType block_start_, InputStorageIteratorType block_end_) {</div>
<div class="line"><span class="lineno"> 2076</span>            <span class="keywordflow">for</span> (std::unordered_map&lt;<a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>, std::vector&lt;fd_t&gt;&gt;::iterator iedge_iter = block_start_; iedge_iter != block_end_; iedge_iter++) {</div>
<div class="line"><span class="lineno"> 2077</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> edge = iedge_iter-&gt;first;</div>
<div class="line"><span class="lineno"> 2078</span>                <span class="keyword">const</span> <a class="code hl_struct" href="../../df/d33/structbounding__box__t.html">bounding_box_t&lt;vec3&gt;</a>&amp; edge_bbox = ps_edge_to_bbox[edge];</div>
<div class="line"><span class="lineno"> 2079</span>                std::vector&lt;fd_t&gt;&amp; edge_ifaces = iedge_iter-&gt;second;</div>
<div class="line"><span class="lineno"> 2080</span> </div>
<div class="line"><span class="lineno"> 2081</span>                <span class="keywordflow">for</span> (std::vector&lt;fd_t&gt;::iterator iface_iter = edge_ifaces.begin(); iface_iter != edge_ifaces.end(); <span class="comment">/*increment inside loop*/</span>) {</div>
<div class="line"><span class="lineno"> 2082</span>                    <span class="keyword">const</span> <a class="code hl_struct" href="../../df/d33/structbounding__box__t.html">bounding_box_t&lt;vec3&gt;</a>* iface_bbox = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno"> 2083</span>                    <span class="keywordtype">bool</span> is_sm_face = (size_t)(*iface_iter) &lt; (size_t)sm_face_count;</div>
<div class="line"><span class="lineno"> 2084</span>                    <span class="keywordflow">if</span> (is_sm_face) {</div>
<div class="line"><span class="lineno"> 2085</span><span class="preprocessor">#if defined(USE_OIBVH)</span></div>
<div class="line"><span class="lineno"> 2086</span>                        iface_bbox = &amp;(<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>((*input.source_hmesh_face_aabb_array_ptr), *iface_iter));</div>
<div class="line"><span class="lineno"> 2087</span> </div>
<div class="line"><span class="lineno"> 2088</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno"> 2089</span>                        iface_bbox = &amp;input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a2978b29712123e54d4098c4e83679f83">source_hmesh_BVH</a>-&gt;GetPrimitiveBBox(*iface_iter); <span class="comment">// SAFE_ACCESS(((*input.source_hmesh_face_aabb_array_ptr), *iface_iter));</span></div>
<div class="line"><span class="lineno"> 2090</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 2091</span>                    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 2092</span><span class="preprocessor">#if defined(USE_OIBVH)</span></div>
<div class="line"><span class="lineno"> 2093</span>                        iface_bbox = &amp;(<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>((*input.cut_hmesh_face_aabb_array_ptr), (<span class="keywordtype">size_t</span>)(*iface_iter) - sm_face_count));</div>
<div class="line"><span class="lineno"> 2094</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno"> 2095</span>                        iface_bbox = &amp;input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a88f0d79acfc8973750f0c0ac49b661cb">cut_hmesh_BVH</a>-&gt;GetPrimitiveBBox((<span class="keywordtype">size_t</span>)(*iface_iter) - sm_face_count); <span class="comment">// SAFE_ACCESS(((*input.cut_hmesh_face_aabb_array_ptr), ((size_t)(*iface_iter) - sm_face_count)));</span></div>
<div class="line"><span class="lineno"> 2096</span> </div>
<div class="line"><span class="lineno"> 2097</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 2098</span>                    }</div>
<div class="line"><span class="lineno"> 2099</span> </div>
<div class="line"><span class="lineno"> 2100</span>                    <span class="keywordtype">bool</span> <a class="code hl_function" href="../../dc/d25/namespaceigl.html#a3b5976f2a4f7e21f45466b9151e59c94">intersect</a> = <a class="code hl_function" href="../../df/db1/math_8h.html#a428603c304be386b3a1ce9cbc31cc328">intersect_bounding_boxes</a>(edge_bbox, *iface_bbox);</div>
<div class="line"><span class="lineno"> 2101</span> </div>
<div class="line"><span class="lineno"> 2102</span>                    <span class="keywordflow">if</span> (!intersect) {</div>
<div class="line"><span class="lineno"> 2103</span>                        <span class="comment">// remove because &quot;iface_iter&quot; was paired with a coincident face (of &quot;edge&quot;) based on</span></div>
<div class="line"><span class="lineno"> 2104</span>                        <span class="comment">// the mere fact that the coincident face was found to be in close proximity with</span></div>
<div class="line"><span class="lineno"> 2105</span>                        <span class="comment">// &quot;iface_iter&quot; (from BVH tree proximity search)</span></div>
<div class="line"><span class="lineno"> 2106</span>                        iface_iter = edge_ifaces.erase(iface_iter); <span class="comment">// NOTE: &quot;erase&quot; return iterator to next after</span></div>
<div class="line"><span class="lineno"> 2107</span>                    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 2108</span>                        iface_iter++;</div>
<div class="line"><span class="lineno"> 2109</span>                    }</div>
<div class="line"><span class="lineno"> 2110</span>                }</div>
<div class="line"><span class="lineno"> 2111</span>            }</div>
<div class="line"><span class="lineno"> 2112</span>            <span class="keywordflow">return</span> 0;</div>
<div class="line"><span class="lineno"> 2113</span>        };</div>
<div class="line"><span class="lineno"> 2114</span> </div>
<div class="line"><span class="lineno"> 2115</span>        std::vector&lt;std::future&lt;int&gt;&gt; futures;</div>
<div class="line"><span class="lineno"> 2116</span>        <span class="keywordtype">int</span> _1;</div>
<div class="line"><span class="lineno"> 2117</span> </div>
<div class="line"><span class="lineno"> 2118</span>        <a class="code hl_function" href="../../df/d05/tpool_8h.html#a48d2e68725f7691f1422697f4c359827">parallel_for</a>(</div>
<div class="line"><span class="lineno"> 2119</span>            *input.scheduler,</div>
<div class="line"><span class="lineno"> 2120</span>            ps_edge_face_intersection_pairs.begin(),</div>
<div class="line"><span class="lineno"> 2121</span>            ps_edge_face_intersection_pairs.end(),</div>
<div class="line"><span class="lineno"> 2122</span>            fn_compute_edgefair_pair_culling,</div>
<div class="line"><span class="lineno"> 2123</span>            _1, <span class="comment">// out</span></div>
<div class="line"><span class="lineno"> 2124</span>            futures);</div>
<div class="line"><span class="lineno"> 2125</span> </div>
<div class="line"><span class="lineno"> 2126</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)futures.size(); ++i) {</div>
<div class="line"><span class="lineno"> 2127</span>            std::future&lt;int&gt;&amp; f = futures[i];</div>
<div class="line"><span class="lineno"> 2128</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(f.valid());</div>
<div class="line"><span class="lineno"> 2129</span>            f.wait(); <span class="comment">// simply wait for result to be done</span></div>
<div class="line"><span class="lineno"> 2130</span>        }</div>
<div class="line"><span class="lineno"> 2131</span>    }</div>
<div class="line"><span class="lineno"> 2132</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno"> 2133</span>    <span class="keywordflow">for</span> (std::unordered_map&lt;<a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>, std::vector&lt;fd_t&gt;&gt;::iterator iedge_iter = ps_edge_face_intersection_pairs.begin();</div>
<div class="line"><span class="lineno"> 2134</span>         iedge_iter != ps_edge_face_intersection_pairs.end();</div>
<div class="line"><span class="lineno"> 2135</span>         iedge_iter++) {</div>
<div class="line"><span class="lineno"> 2136</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> edge = iedge_iter-&gt;first;</div>
<div class="line"><span class="lineno"> 2137</span>        <span class="keyword">const</span> <a class="code hl_struct" href="../../df/d33/structbounding__box__t.html">bounding_box_t&lt;vec3&gt;</a>&amp; edge_bbox = ps_edge_to_bbox[edge];</div>
<div class="line"><span class="lineno"> 2138</span>        std::vector&lt;fd_t&gt;&amp; edge_ifaces = iedge_iter-&gt;second;</div>
<div class="line"><span class="lineno"> 2139</span> </div>
<div class="line"><span class="lineno"> 2140</span>        <span class="keywordflow">for</span> (std::vector&lt;fd_t&gt;::iterator iface_iter = edge_ifaces.begin(); iface_iter != edge_ifaces.end(); <span class="comment">/*increment inside loop*/</span>) {</div>
<div class="line"><span class="lineno"> 2141</span>            <span class="keyword">const</span> <a class="code hl_struct" href="../../df/d33/structbounding__box__t.html">bounding_box_t&lt;vec3&gt;</a>* iface_bbox = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno"> 2142</span>            <span class="keywordtype">bool</span> is_sm_face = (size_t)(*iface_iter) &lt; (size_t)sm_face_count;</div>
<div class="line"><span class="lineno"> 2143</span>            <span class="keywordflow">if</span> (is_sm_face) {</div>
<div class="line"><span class="lineno"> 2144</span><span class="preprocessor">#if defined(USE_OIBVH)</span></div>
<div class="line"><span class="lineno"> 2145</span>                iface_bbox = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(&amp;((*input.source_hmesh_face_aabb_array_ptr)), *iface_iter);</div>
<div class="line"><span class="lineno"> 2146</span> </div>
<div class="line"><span class="lineno"> 2147</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno"> 2148</span>                iface_bbox = &amp;input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a2978b29712123e54d4098c4e83679f83">source_hmesh_BVH</a>-&gt;GetPrimitiveBBox(*iface_iter); <span class="comment">// SAFE_ACCESS(((*input.source_hmesh_face_aabb_array_ptr), *iface_iter));</span></div>
<div class="line"><span class="lineno"> 2149</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 2150</span>            } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 2151</span><span class="preprocessor">#if defined(USE_OIBVH)</span></div>
<div class="line"><span class="lineno"> 2152</span>                iface_bbox = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(&amp;((*input.cut_hmesh_face_aabb_array_ptr)), ((<span class="keywordtype">size_t</span>)(*iface_iter) - sm_face_count));</div>
<div class="line"><span class="lineno"> 2153</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno"> 2154</span>                iface_bbox = &amp;input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a88f0d79acfc8973750f0c0ac49b661cb">cut_hmesh_BVH</a>-&gt;GetPrimitiveBBox((<span class="keywordtype">size_t</span>)(*iface_iter) - sm_face_count); <span class="comment">// SAFE_ACCESS(((*input.cut_hmesh_face_aabb_array_ptr), ((size_t)(*iface_iter) - sm_face_count)));</span></div>
<div class="line"><span class="lineno"> 2155</span> </div>
<div class="line"><span class="lineno"> 2156</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 2157</span>            }</div>
<div class="line"><span class="lineno"> 2158</span> </div>
<div class="line"><span class="lineno"> 2159</span>            <span class="keywordtype">bool</span> <a class="code hl_function" href="../../dc/d25/namespaceigl.html#a3b5976f2a4f7e21f45466b9151e59c94">intersect</a> = <a class="code hl_function" href="../../df/db1/math_8h.html#a428603c304be386b3a1ce9cbc31cc328">intersect_bounding_boxes</a>(edge_bbox, *iface_bbox);</div>
<div class="line"><span class="lineno"> 2160</span> </div>
<div class="line"><span class="lineno"> 2161</span>            <span class="keywordflow">if</span> (!intersect) {</div>
<div class="line"><span class="lineno"> 2162</span>                <span class="comment">// remove because &quot;iface_iter&quot; was paired with a coincident face (of &quot;edge&quot;) based on</span></div>
<div class="line"><span class="lineno"> 2163</span>                <span class="comment">// the mere fact that the coincident face was found to be in close proximity with</span></div>
<div class="line"><span class="lineno"> 2164</span>                <span class="comment">// &quot;iface_iter&quot; (from BVH tree proximity search)</span></div>
<div class="line"><span class="lineno"> 2165</span>                iface_iter = edge_ifaces.erase(iface_iter); <span class="comment">// NOTE: &quot;erase&quot; return iterator to next after</span></div>
<div class="line"><span class="lineno"> 2166</span>            } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 2167</span>                iface_iter++;</div>
<div class="line"><span class="lineno"> 2168</span>            }</div>
<div class="line"><span class="lineno"> 2169</span>        }</div>
<div class="line"><span class="lineno"> 2170</span>    }</div>
<div class="line"><span class="lineno"> 2171</span><span class="preprocessor">#endif </span><span class="comment">// #if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 2172</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 2173</span> </div>
<div class="line"><span class="lineno"> 2174</span>    ps_edge_to_bbox.clear();</div>
<div class="line"><span class="lineno"> 2175</span> </div>
<div class="line"><span class="lineno"> 2176</span>    <span class="comment">// assuming each edge will produce a new vertex</span></div>
<div class="line"><span class="lineno"> 2177</span>    m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a0c71c904363d4a3932bd674812f8478e">reserve_for_additional_elements</a>((std::uint32_t)ps_edge_face_intersection_pairs.size());</div>
<div class="line"><span class="lineno"> 2178</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 2179</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Compute intersecting face properties&quot;</span>);</div>
<div class="line"><span class="lineno"> 2180</span>    <span class="comment">// compute/extract geometry properties of each tested face</span></div>
<div class="line"><span class="lineno"> 2181</span>    <span class="comment">//--------------------------------------------------------</span></div>
<div class="line"><span class="lineno"> 2182</span> </div>
<div class="line"><span class="lineno"> 2183</span>    std::unordered_map&lt;fd_t, vec3&gt; ps_tested_face_to_plane_normal;</div>
<div class="line"><span class="lineno"> 2184</span>    std::unordered_map&lt;fd_t, double&gt; ps_tested_face_to_plane_normal_d_param;</div>
<div class="line"><span class="lineno"> 2185</span>    std::unordered_map&lt;fd_t, int&gt; ps_tested_face_to_plane_normal_max_comp;</div>
<div class="line"><span class="lineno"> 2186</span>    std::unordered_map&lt;fd_t, std::vector&lt;vec3&gt;&gt; ps_tested_face_to_vertices;</div>
<div class="line"><span class="lineno"> 2187</span> </div>
<div class="line"><span class="lineno"> 2188</span><span class="preprocessor">#if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 2189</span>    {</div>
<div class="line"><span class="lineno"> 2190</span>        <span class="keyword">typedef</span> std::tuple&lt;</div>
<div class="line"><span class="lineno"> 2191</span>            std::unordered_map&lt;fd_t, vec3&gt;, <span class="comment">// ps_tested_face_to_plane_normal;</span></div>
<div class="line"><span class="lineno"> 2192</span>            std::unordered_map&lt;fd_t, double&gt;, <span class="comment">// ps_tested_face_to_plane_normal_d_param;</span></div>
<div class="line"><span class="lineno"> 2193</span>            std::unordered_map&lt;fd_t, int&gt;, <span class="comment">// ps_tested_face_to_plane_normal_max_comp;</span></div>
<div class="line"><span class="lineno"> 2194</span>            std::unordered_map&lt;fd_t, std::vector&lt;vec3&gt;&gt; <span class="comment">// ps_tested_face_to_vertices;</span></div>
<div class="line"><span class="lineno"> 2195</span>            &gt;</div>
<div class="line"><span class="lineno"> 2196</span>            OutputStorageTypesTuple;</div>
<div class="line"><span class="lineno"> 2197</span>        <span class="keyword">typedef</span> std::map&lt;fd_t, std::vector&lt;fd_t&gt;&gt;::const_iterator InputStorageIteratorType;</div>
<div class="line"><span class="lineno"> 2198</span> </div>
<div class="line"><span class="lineno"> 2199</span>        std::atomic&lt;int&gt; potentially_intersecting_face_with_zero_area(-1); <span class="comment">// did any errors occur (e.g. found a face with zero area)</span></div>
<div class="line"><span class="lineno"> 2200</span> </div>
<div class="line"><span class="lineno"> 2201</span>        <span class="keyword">auto</span> fn_compute_intersecting_face_properties = [&amp;](InputStorageIteratorType block_start_, InputStorageIteratorType block_end_) -&gt; OutputStorageTypesTuple {</div>
<div class="line"><span class="lineno"> 2202</span>            OutputStorageTypesTuple output_res;</div>
<div class="line"><span class="lineno"> 2203</span>            std::unordered_map&lt;fd_t, vec3&gt;&amp; ps_tested_face_to_plane_normal_LOCAL = std::get&lt;0&gt;(output_res);</div>
<div class="line"><span class="lineno"> 2204</span>            std::unordered_map&lt;fd_t, double&gt;&amp; ps_tested_face_to_plane_normal_d_param_LOCAL = std::get&lt;1&gt;(output_res);</div>
<div class="line"><span class="lineno"> 2205</span>            std::unordered_map&lt;fd_t, int&gt;&amp; ps_tested_face_to_plane_normal_max_comp_LOCAL = std::get&lt;2&gt;(output_res);</div>
<div class="line"><span class="lineno"> 2206</span>            std::unordered_map&lt;fd_t, std::vector&lt;vec3&gt;&gt;&amp; ps_tested_face_to_vertices_LOCAL = std::get&lt;3&gt;(output_res);</div>
<div class="line"><span class="lineno"> 2207</span>            std::vector&lt;vd_t&gt; tested_face_descriptors_tmp;</div>
<div class="line"><span class="lineno"> 2208</span>            <span class="keywordflow">for</span> (std::map&lt;<a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a>, std::vector&lt;fd_t&gt;&gt;::const_iterator tested_faces_iter = block_start_;</div>
<div class="line"><span class="lineno"> 2209</span>                 tested_faces_iter != block_end_;</div>
<div class="line"><span class="lineno"> 2210</span>                 tested_faces_iter++) {</div>
<div class="line"><span class="lineno"> 2211</span>                <span class="comment">// get the vertices of tested_face (used to estimate its normal etc.)</span></div>
<div class="line"><span class="lineno"> 2212</span>                ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a765a6f3b7249eb47135d246f6d301102">get_vertices_around_face</a>(tested_face_descriptors_tmp, tested_faces_iter-&gt;first);</div>
<div class="line"><span class="lineno"> 2213</span>                std::vector&lt;vd_t&gt;&amp; tested_face_descriptors = tested_face_descriptors_tmp;</div>
<div class="line"><span class="lineno"> 2214</span>                std::vector&lt;vec3&gt;&amp; tested_face_vertices = ps_tested_face_to_vertices_LOCAL[tested_faces_iter-&gt;first]; <span class="comment">// insert and get reference</span></div>
<div class="line"><span class="lineno"> 2215</span> </div>
<div class="line"><span class="lineno"> 2216</span>                <span class="keywordflow">for</span> (std::vector&lt;vd_t&gt;::const_iterator it = tested_face_descriptors.cbegin(); it != tested_face_descriptors.cend(); ++it) {</div>
<div class="line"><span class="lineno"> 2217</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a>&amp; <a class="code hl_function" href="../../dd/d66/namespacelibnest2d_1_1shapelike.html#a2cf3480dc2a3b7f0c08c7e0028492210">vertex</a> = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(*it);</div>
<div class="line"><span class="lineno"> 2218</span>                    tested_face_vertices.push_back(vertex);</div>
<div class="line"><span class="lineno"> 2219</span>                }</div>
<div class="line"><span class="lineno"> 2220</span> </div>
<div class="line"><span class="lineno"> 2221</span>                <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a>&amp; tested_face_plane_normal = ps_tested_face_to_plane_normal_LOCAL[tested_faces_iter-&gt;first];</div>
<div class="line"><span class="lineno"> 2222</span>                <span class="keywordtype">double</span>&amp; tested_face_plane_param_d = ps_tested_face_to_plane_normal_d_param_LOCAL[tested_faces_iter-&gt;first];</div>
<div class="line"><span class="lineno"> 2223</span>                <span class="keywordtype">int</span>&amp; tested_face_plane_normal_max_comp = ps_tested_face_to_plane_normal_max_comp_LOCAL[tested_faces_iter-&gt;first];</div>
<div class="line"><span class="lineno"> 2224</span> </div>
<div class="line"><span class="lineno"> 2225</span>                tested_face_plane_normal_max_comp = <a class="code hl_function" href="../../df/db1/math_8h.html#aadd997d85262028302f802864dea9f6c">compute_polygon_plane_coefficients</a>(</div>
<div class="line"><span class="lineno"> 2226</span>                    tested_face_plane_normal,</div>
<div class="line"><span class="lineno"> 2227</span>                    tested_face_plane_param_d,</div>
<div class="line"><span class="lineno"> 2228</span>                    tested_face_vertices.data(),</div>
<div class="line"><span class="lineno"> 2229</span>                    (<span class="keywordtype">int</span>)tested_face_vertices.size());</div>
<div class="line"><span class="lineno"> 2230</span> </div>
<div class="line"><span class="lineno"> 2231</span>                <span class="keywordflow">if</span> (<a class="code hl_function" href="../../df/db1/math_8h.html#a5ac9a8399d477c88e7ab2e9e406015c6">squared_length</a>(tested_face_plane_normal) == 0) {</div>
<div class="line"><span class="lineno"> 2232</span>                    potentially_intersecting_face_with_zero_area.store((<span class="keywordtype">int</span>)tested_faces_iter-&gt;first, std::memory_order_release);</div>
<div class="line"><span class="lineno"> 2233</span>                }</div>
<div class="line"><span class="lineno"> 2234</span>            }</div>
<div class="line"><span class="lineno"> 2235</span>            <span class="keywordflow">return</span> output_res;</div>
<div class="line"><span class="lineno"> 2236</span>        };</div>
<div class="line"><span class="lineno"> 2237</span> </div>
<div class="line"><span class="lineno"> 2238</span>        std::vector&lt;std::future&lt;OutputStorageTypesTuple&gt;&gt; futures;</div>
<div class="line"><span class="lineno"> 2239</span>        OutputStorageTypesTuple partial_res;</div>
<div class="line"><span class="lineno"> 2240</span> </div>
<div class="line"><span class="lineno"> 2241</span>        <a class="code hl_function" href="../../df/d05/tpool_8h.html#a48d2e68725f7691f1422697f4c359827">parallel_for</a>(</div>
<div class="line"><span class="lineno"> 2242</span>            *input.scheduler,</div>
<div class="line"><span class="lineno"> 2243</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8b2ff5d52c3860c53928326dddc24ff9">ps_face_to_potentially_intersecting_others</a>-&gt;cbegin(),</div>
<div class="line"><span class="lineno"> 2244</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8b2ff5d52c3860c53928326dddc24ff9">ps_face_to_potentially_intersecting_others</a>-&gt;cend(),</div>
<div class="line"><span class="lineno"> 2245</span>            fn_compute_intersecting_face_properties,</div>
<div class="line"><span class="lineno"> 2246</span>            partial_res, <span class="comment">// out</span></div>
<div class="line"><span class="lineno"> 2247</span>            futures);</div>
<div class="line"><span class="lineno"> 2248</span> </div>
<div class="line"><span class="lineno"> 2249</span>        std::tie(</div>
<div class="line"><span class="lineno"> 2250</span>            ps_tested_face_to_plane_normal,</div>
<div class="line"><span class="lineno"> 2251</span>            ps_tested_face_to_plane_normal_d_param,</div>
<div class="line"><span class="lineno"> 2252</span>            ps_tested_face_to_plane_normal_max_comp,</div>
<div class="line"><span class="lineno"> 2253</span>            ps_tested_face_to_vertices)</div>
<div class="line"><span class="lineno"> 2254</span>            = partial_res;</div>
<div class="line"><span class="lineno"> 2255</span>        <span class="comment">// merge results from other threads</span></div>
<div class="line"><span class="lineno"> 2256</span> </div>
<div class="line"><span class="lineno"> 2257</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)futures.size(); ++i) {</div>
<div class="line"><span class="lineno"> 2258</span> </div>
<div class="line"><span class="lineno"> 2259</span>            std::future&lt;OutputStorageTypesTuple&gt;&amp; f = futures[i];</div>
<div class="line"><span class="lineno"> 2260</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(f.valid()); <span class="comment">// The behavior is undefined if valid()== false before the call to wait_for</span></div>
<div class="line"><span class="lineno"> 2261</span> </div>
<div class="line"><span class="lineno"> 2262</span>            OutputStorageTypesTuple future_res = f.get();</div>
<div class="line"><span class="lineno"> 2263</span> </div>
<div class="line"><span class="lineno"> 2264</span>            <span class="keywordflow">if</span> (potentially_intersecting_face_with_zero_area.load(std::memory_order_acquire) &gt;= 0) {</div>
<div class="line"><span class="lineno"> 2265</span>                <span class="keywordflow">break</span>; <span class="comment">// stop there was a runtime error</span></div>
<div class="line"><span class="lineno"> 2266</span>            }</div>
<div class="line"><span class="lineno"> 2267</span> </div>
<div class="line"><span class="lineno"> 2268</span>            std::unordered_map&lt;fd_t, vec3&gt;&amp; ps_tested_face_to_plane_normal_FUTURE = std::get&lt;0&gt;(future_res);</div>
<div class="line"><span class="lineno"> 2269</span>            std::unordered_map&lt;fd_t, double&gt;&amp; ps_tested_face_to_plane_normal_d_param_FUTURE = std::get&lt;1&gt;(future_res);</div>
<div class="line"><span class="lineno"> 2270</span>            std::unordered_map&lt;fd_t, int&gt;&amp; ps_tested_face_to_plane_normal_max_comp_FUTURE = std::get&lt;2&gt;(future_res);</div>
<div class="line"><span class="lineno"> 2271</span>            std::unordered_map&lt;fd_t, std::vector&lt;vec3&gt;&gt;&amp; ps_tested_face_to_vertices_FUTURE = std::get&lt;3&gt;(future_res);</div>
<div class="line"><span class="lineno"> 2272</span> </div>
<div class="line"><span class="lineno"> 2273</span>            ps_tested_face_to_plane_normal.insert(</div>
<div class="line"><span class="lineno"> 2274</span>                ps_tested_face_to_plane_normal_FUTURE.cbegin(),</div>
<div class="line"><span class="lineno"> 2275</span>                ps_tested_face_to_plane_normal_FUTURE.cend());</div>
<div class="line"><span class="lineno"> 2276</span> </div>
<div class="line"><span class="lineno"> 2277</span>            ps_tested_face_to_plane_normal_d_param.insert(</div>
<div class="line"><span class="lineno"> 2278</span>                ps_tested_face_to_plane_normal_d_param_FUTURE.cbegin(),</div>
<div class="line"><span class="lineno"> 2279</span>                ps_tested_face_to_plane_normal_d_param_FUTURE.cend());</div>
<div class="line"><span class="lineno"> 2280</span> </div>
<div class="line"><span class="lineno"> 2281</span>            ps_tested_face_to_plane_normal_max_comp.insert(</div>
<div class="line"><span class="lineno"> 2282</span>                ps_tested_face_to_plane_normal_max_comp_FUTURE.cbegin(),</div>
<div class="line"><span class="lineno"> 2283</span>                ps_tested_face_to_plane_normal_max_comp_FUTURE.cend());</div>
<div class="line"><span class="lineno"> 2284</span> </div>
<div class="line"><span class="lineno"> 2285</span>            ps_tested_face_to_vertices.insert(</div>
<div class="line"><span class="lineno"> 2286</span>                ps_tested_face_to_vertices_FUTURE.cbegin(),</div>
<div class="line"><span class="lineno"> 2287</span>                ps_tested_face_to_vertices_FUTURE.cend());</div>
<div class="line"><span class="lineno"> 2288</span>        }</div>
<div class="line"><span class="lineno"> 2289</span> </div>
<div class="line"><span class="lineno"> 2290</span>        <span class="keyword">const</span> <span class="keywordtype">int</span> tmp_local = potentially_intersecting_face_with_zero_area.load(std::memory_order_acquire);</div>
<div class="line"><span class="lineno"> 2291</span> </div>
<div class="line"><span class="lineno"> 2292</span>        <span class="keywordflow">if</span> (tmp_local &gt;= 0) {</div>
<div class="line"><span class="lineno"> 2293</span>            <span class="keyword">const</span> <span class="keywordtype">bool</span> is_cutmesh_face = (tmp_local &gt; sm_face_count);</div>
<div class="line"><span class="lineno"> 2294</span>            <span class="comment">// if &quot;tmp_local&quot; &gt; srcMeshFaceCount then &quot;tmp_local&quot; is a cut-mesh face with id=&quot;tmp_local-srcMeshFaceCount&quot;</span></div>
<div class="line"><span class="lineno"> 2295</span>            <span class="keyword">const</span> std::string msh_name = is_cutmesh_face ? <span class="stringliteral">&quot;cut-mesh&quot;</span> : <span class="stringliteral">&quot;source-mesh&quot;</span>;</div>
<div class="line"><span class="lineno"> 2296</span>            <span class="comment">// index/descriptor in the _kernel_ input mesh (note the stress on kernel since frontend might modify user-provided mesh)</span></div>
<div class="line"><span class="lineno"> 2297</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> bad_face_desr = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a>(is_cutmesh_face ? (tmp_local - sm_face_count) : tmp_local);</div>
<div class="line"><span class="lineno"> 2298</span>            lg.<a class="code hl_function" href="../../d8/d0d/classlogger__t.html#aecaed21510eca7fa095e7176d9e36850">set_reason_for_failure</a>(<span class="stringliteral">&quot;face f&quot;</span> + std::to_string(bad_face_desr) + <span class="stringliteral">&quot; of &quot;</span> + msh_name + <span class="stringliteral">&quot; is degenerate (has zero area)&quot;</span>);</div>
<div class="line"><span class="lineno"> 2299</span>            output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a7d4c902daa6f0439e388496967885dd9">status</a>.store(is_cutmesh_face ? <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a8737035059b46024b097c7e96031ee2e">status_t::INVALID_CUT_MESH</a> : <a class="code hl_enumeration" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>::<a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a4f41dc6e379aa2a8afaaee78c29c85ec">INVALID_SRC_MESH</a>, <a class="code hl_namespace" href="../../d8/dcc/namespacestd.html">std</a>::memory_order_release);</div>
<div class="line"><span class="lineno"> 2300</span>            <span class="keywordflow">return</span>; <span class="comment">// stop there was a runtime error</span></div>
<div class="line"><span class="lineno"> 2301</span>        }</div>
<div class="line"><span class="lineno"> 2302</span> </div>
<div class="line"><span class="lineno"> 2303</span>    } <span class="comment">// end of parallel scope</span></div>
<div class="line"><span class="lineno"> 2304</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno"> 2305</span>    <span class="comment">// for each face that is to be tested for intersection</span></div>
<div class="line"><span class="lineno"> 2306</span>    <span class="comment">// NOTE: the keys of input.ps_face_to_potentially_intersecting_others are the potentially colliding polygons</span></div>
<div class="line"><span class="lineno"> 2307</span>    <span class="comment">// that we get after BVH traversal</span></div>
<div class="line"><span class="lineno"> 2308</span>    {</div>
<div class="line"><span class="lineno"> 2309</span>        std::vector&lt;vd_t&gt; tested_face_descriptors_tmp;</div>
<div class="line"><span class="lineno"> 2310</span>        <span class="keywordflow">for</span> (std::map&lt;<a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a>, std::vector&lt;fd_t&gt;&gt;::const_iterator tested_faces_iter = input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8b2ff5d52c3860c53928326dddc24ff9">ps_face_to_potentially_intersecting_others</a>-&gt;cbegin();</div>
<div class="line"><span class="lineno"> 2311</span>             tested_faces_iter != input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8b2ff5d52c3860c53928326dddc24ff9">ps_face_to_potentially_intersecting_others</a>-&gt;cend();</div>
<div class="line"><span class="lineno"> 2312</span>             tested_faces_iter++) {</div>
<div class="line"><span class="lineno"> 2313</span>            <span class="comment">// get the vertices of tested_face (used to estimate its normal etc.)</span></div>
<div class="line"><span class="lineno"> 2314</span>            ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a765a6f3b7249eb47135d246f6d301102">get_vertices_around_face</a>(tested_face_descriptors_tmp, tested_faces_iter-&gt;first);</div>
<div class="line"><span class="lineno"> 2315</span>            <span class="keyword">const</span> std::vector&lt;vd_t&gt;&amp; tested_face_descriptors = tested_face_descriptors_tmp;</div>
<div class="line"><span class="lineno"> 2316</span>            std::vector&lt;vec3&gt;&amp; tested_face_vertices = ps_tested_face_to_vertices[tested_faces_iter-&gt;first]; <span class="comment">// insert and get reference</span></div>
<div class="line"><span class="lineno"> 2317</span> </div>
<div class="line"><span class="lineno"> 2318</span>            <span class="keywordflow">for</span> (std::vector&lt;vd_t&gt;::const_iterator it = tested_face_descriptors.cbegin(); it != tested_face_descriptors.cend(); ++it) {</div>
<div class="line"><span class="lineno"> 2319</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a>&amp; <a class="code hl_function" href="../../dd/d66/namespacelibnest2d_1_1shapelike.html#a2cf3480dc2a3b7f0c08c7e0028492210">vertex</a> = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(*it);</div>
<div class="line"><span class="lineno"> 2320</span>                tested_face_vertices.push_back(vertex);</div>
<div class="line"><span class="lineno"> 2321</span>            }</div>
<div class="line"><span class="lineno"> 2322</span> </div>
<div class="line"><span class="lineno"> 2323</span>            <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a>&amp; tested_face_plane_normal = ps_tested_face_to_plane_normal[tested_faces_iter-&gt;first];</div>
<div class="line"><span class="lineno"> 2324</span>            <span class="keywordtype">double</span>&amp; tested_face_plane_param_d = ps_tested_face_to_plane_normal_d_param[tested_faces_iter-&gt;first];</div>
<div class="line"><span class="lineno"> 2325</span>            <span class="keywordtype">int</span>&amp; tested_face_plane_normal_max_comp = ps_tested_face_to_plane_normal_max_comp[tested_faces_iter-&gt;first];</div>
<div class="line"><span class="lineno"> 2326</span> </div>
<div class="line"><span class="lineno"> 2327</span>            tested_face_plane_normal_max_comp = <a class="code hl_function" href="../../df/db1/math_8h.html#aadd997d85262028302f802864dea9f6c">compute_polygon_plane_coefficients</a>(</div>
<div class="line"><span class="lineno"> 2328</span>                tested_face_plane_normal,</div>
<div class="line"><span class="lineno"> 2329</span>                tested_face_plane_param_d,</div>
<div class="line"><span class="lineno"> 2330</span>                tested_face_vertices.data(),</div>
<div class="line"><span class="lineno"> 2331</span>                (<span class="keywordtype">int</span>)tested_face_vertices.size());</div>
<div class="line"><span class="lineno"> 2332</span> </div>
<div class="line"><span class="lineno"> 2333</span>            <span class="keywordflow">if</span> (<a class="code hl_function" href="../../df/db1/math_8h.html#a5ac9a8399d477c88e7ab2e9e406015c6">squared_length</a>(tested_face_plane_normal) == 0) {</div>
<div class="line"><span class="lineno"> 2334</span>                <span class="keyword">const</span> <span class="keywordtype">int</span> tmp_local = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)tested_faces_iter-&gt;first;</div>
<div class="line"><span class="lineno"> 2335</span>                <span class="keyword">const</span> <span class="keywordtype">bool</span> is_cutmesh_face = (tmp_local &gt; sm_face_count);</div>
<div class="line"><span class="lineno"> 2336</span>                <span class="keyword">const</span> std::string msh_name = is_cutmesh_face ? <span class="stringliteral">&quot;cut-mesh&quot;</span> : <span class="stringliteral">&quot;source-mesh&quot;</span>;</div>
<div class="line"><span class="lineno"> 2337</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> bad_face_desr = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a>(is_cutmesh_face ? (tmp_local - sm_face_count) : tmp_local);</div>
<div class="line"><span class="lineno"> 2338</span>                lg.<a class="code hl_function" href="../../d8/d0d/classlogger__t.html#aecaed21510eca7fa095e7176d9e36850">set_reason_for_failure</a>(<span class="stringliteral">&quot;face f&quot;</span> + std::to_string(bad_face_desr) + <span class="stringliteral">&quot; of &quot;</span> + msh_name + <span class="stringliteral">&quot; is degenerate (has zero area)&quot;</span>);</div>
<div class="line"><span class="lineno"> 2339</span>                output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a7d4c902daa6f0439e388496967885dd9">status</a> = (is_cutmesh_face ? <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a8737035059b46024b097c7e96031ee2e">status_t::INVALID_CUT_MESH</a> : <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a4f41dc6e379aa2a8afaaee78c29c85ec">status_t::INVALID_SRC_MESH</a>);</div>
<div class="line"><span class="lineno"> 2340</span>                <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno"> 2341</span>            }</div>
<div class="line"><span class="lineno"> 2342</span>        }</div>
<div class="line"><span class="lineno"> 2343</span>    }</div>
<div class="line"><span class="lineno"> 2344</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 2345</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 2346</span> </div>
<div class="line"><span class="lineno"> 2347</span>    <span class="comment">// edge-to-face intersection tests (narrow-phase)</span></div>
<div class="line"><span class="lineno"> 2348</span>    <span class="comment">// -----------------------------------------</span></div>
<div class="line"><span class="lineno"> 2349</span> </div>
<div class="line"><span class="lineno"> 2350</span>    <span class="comment">// ivertex to faces that meet at the this ivertex</span></div>
<div class="line"><span class="lineno"> 2351</span>    <span class="comment">// std::map&lt;</span></div>
<div class="line"><span class="lineno"> 2353</span><span class="comment"></span>    <span class="comment">//    std::vector&lt;fd_t&gt; // list of faces that intersect with another face at the intersection point</span></div>
<div class="line"><span class="lineno"> 2354</span>    <span class="comment">//    &gt;</span></div>
<div class="line"><span class="lineno"> 2355</span>    <span class="comment">//    m0_ivtx_to_ps_faces;</span></div>
<div class="line"><span class="lineno"> 2356</span> </div>
<div class="line"><span class="lineno"> 2357</span>    <span class="comment">// ivertex to halfedge that was tested again a face in order to produce this ivertex</span></div>
<div class="line"><span class="lineno"> 2358</span>    <span class="comment">// NOTE: the ordering of the intersections point is dependant on the order in which they where actually computed</span></div>
<div class="line"><span class="lineno"> 2359</span>    <span class="comment">// i.e. the data of the first intersection point is at index 0</span></div>
<div class="line"><span class="lineno"> 2360</span>    <span class="comment">// std::map&lt;</span></div>
<div class="line"><span class="lineno"> 2361</span>    <span class="comment">//    vd_t, // intersection point</span></div>
<div class="line"><span class="lineno"> 2362</span>    <span class="comment">//    ed_t // halfedge</span></div>
<div class="line"><span class="lineno"> 2363</span>    <span class="comment">//    &gt;</span></div>
<div class="line"><span class="lineno"> 2364</span>    <span class="comment">//    m0_ivtx_to_ps_edge;</span></div>
<div class="line"><span class="lineno"> 2365</span> </div>
<div class="line"><span class="lineno"> 2366</span>    std::vector&lt;</div>
<div class="line"><span class="lineno"> 2367</span>        std::pair&lt;ed_t, fd_t&gt; <span class="comment">// edge and face that where tested to produce our intersection point.</span></div>
<div class="line"><span class="lineno"> 2368</span>        &gt;</div>
<div class="line"><span class="lineno"> 2369</span>        m0_ivtx_to_intersection_registry_entry;</div>
<div class="line"><span class="lineno"> 2370</span> </div>
<div class="line"><span class="lineno"> 2371</span>    <span class="comment">// re-entrant vertices on the border of the cut-mesh</span></div>
<div class="line"><span class="lineno"> 2372</span>    std::vector&lt;vd_t&gt; cm_border_reentrant_ivtx_list;</div>
<div class="line"><span class="lineno"> 2373</span> </div>
<div class="line"><span class="lineno"> 2374</span>    <span class="comment">// std::map&lt;</span></div>
<div class="line"><span class="lineno"> 2377</span><span class="comment"></span>    <span class="comment">//    &gt;</span></div>
<div class="line"><span class="lineno"> 2378</span>    <span class="comment">//    m0_ivtx_to_tested_polygon_normal;</span></div>
<div class="line"><span class="lineno"> 2379</span> </div>
<div class="line"><span class="lineno"> 2380</span>    <span class="comment">// edges of the polygon soup mesh which intersect a face</span></div>
<div class="line"><span class="lineno"> 2381</span>    std::unordered_map&lt;ed_t, std::vector&lt;vd_t&gt;&gt; ps_intersecting_edges;</div>
<div class="line"><span class="lineno"> 2382</span> </div>
<div class="line"><span class="lineno"> 2383</span>    <span class="comment">// A map of used to create edges along the intersection path.</span></div>
<div class="line"><span class="lineno"> 2384</span>    <span class="comment">// Each element is the information such as intersection points that arise from testing two polygons.</span></div>
<div class="line"><span class="lineno"> 2385</span>    <span class="comment">// The size of thos vector is dependent on the number of polygon pairs (in &quot;input.intersecting_sm_cm_face_pairs&quot;)</span></div>
<div class="line"><span class="lineno"> 2386</span>    <span class="comment">// which intersect.</span></div>
<div class="line"><span class="lineno"> 2387</span> </div>
<div class="line"><span class="lineno"> 2388</span>    std::map&lt; <span class="comment">// information needed to build edges along the cut-path</span></div>
<div class="line"><span class="lineno"> 2389</span>        <a class="code hl_struct" href="../../df/de8/structpair.html">pair&lt;fd_t&gt;</a>, <span class="comment">// pair of intersecting polygons (source-mesh polygon, cut-mesh polygon)</span></div>
<div class="line"><span class="lineno"> 2390</span>        std::vector&lt;vd_t&gt; <span class="comment">// resulting intersection points</span></div>
<div class="line"><span class="lineno"> 2391</span>        &gt;</div>
<div class="line"><span class="lineno"> 2392</span>        cutpath_edge_creation_info;</div>
<div class="line"><span class="lineno"> 2393</span> </div>
<div class="line"><span class="lineno"> 2394</span>    std::unordered_map&lt;</div>
<div class="line"><span class="lineno"> 2395</span>        <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a>, <span class="comment">// intersectiong face</span></div>
<div class="line"><span class="lineno"> 2396</span>        std::vector&lt;vd_t&gt; <span class="comment">// intersection point which involve the intersecting face</span></div>
<div class="line"><span class="lineno"> 2397</span>        &gt;</div>
<div class="line"><span class="lineno"> 2398</span>        ps_iface_to_ivtx_list; <span class="comment">// faces which intersect with another</span></div>
<div class="line"><span class="lineno"> 2399</span> </div>
<div class="line"><span class="lineno"> 2400</span>    <span class="comment">// A partial cut intersection exists when there exists at-least one intersection point</span></div>
<div class="line"><span class="lineno"> 2401</span>    <span class="comment">// whose registry has a halfedge from the cut-surface, where this halfedge is a border halfedge.</span></div>
<div class="line"><span class="lineno"> 2402</span>    <span class="keywordtype">bool</span> partial_cut_detected = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 2403</span> </div>
<div class="line"><span class="lineno"> 2404</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Calculate intersection points (edge-to-face)&quot;</span>);</div>
<div class="line"><span class="lineno"> 2405</span> </div>
<div class="line"><span class="lineno"> 2406</span><span class="preprocessor">#if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 2407</span>    {</div>
<div class="line"><span class="lineno"> 2408</span>        <span class="comment">// typedef std::unordered_map&lt;ed_t, std::vector&lt;fd_t&gt;&gt;::const_iterator InputStorageIteratorType;</span></div>
<div class="line"><span class="lineno"> 2409</span>        <span class="keyword">typedef</span> std::tuple&lt;</div>
<div class="line"><span class="lineno"> 2410</span>            std::vector&lt;std::pair&lt;ed_t, fd_t&gt;&gt;, <span class="comment">// m0_ivtx_to_intersection_registry_entry</span></div>
<div class="line"><span class="lineno"> 2411</span>            std::vector&lt;vd_t&gt;, <span class="comment">// cm_border_reentrant_ivtx_list</span></div>
<div class="line"><span class="lineno"> 2412</span>            std::unordered_map&lt;ed_t, std::vector&lt;vd_t&gt;&gt;, <span class="comment">// ps_intersecting_edges</span></div>
<div class="line"><span class="lineno"> 2413</span>            std::map&lt;pair&lt;fd_t&gt;, std::vector&lt;vd_t&gt;&gt;, <span class="comment">// cutpath_edge_creation_info</span></div>
<div class="line"><span class="lineno"> 2414</span>            std::unordered_map&lt;fd_t, std::vector&lt;vd_t&gt;&gt;, <span class="comment">// ps_iface_to_ivtx_list</span></div>
<div class="line"><span class="lineno"> 2415</span>            bool, <span class="comment">// partial_cut_detected</span></div>
<div class="line"><span class="lineno"> 2416</span>            std::vector&lt;vec3&gt; <span class="comment">// list of intersection points computed in a future</span></div>
<div class="line"><span class="lineno"> 2417</span>            &gt;</div>
<div class="line"><span class="lineno"> 2418</span>            OutputStorageTypesTuple;</div>
<div class="line"><span class="lineno"> 2419</span> </div>
<div class="line"><span class="lineno"> 2420</span>        <span class="keyword">auto</span> fn_compute_intersection_points = [&amp;](</div>
<div class="line"><span class="lineno"> 2421</span>                                                  std::unordered_map&lt;ed_t, std::vector&lt;fd_t&gt;&gt;::const_iterator block_start_,</div>
<div class="line"><span class="lineno"> 2422</span>                                                  std::unordered_map&lt;ed_t, std::vector&lt;fd_t&gt;&gt;::const_iterator block_end_) -&gt; OutputStorageTypesTuple {</div>
<div class="line"><span class="lineno"> 2423</span>            OutputStorageTypesTuple local_output;</div>
<div class="line"><span class="lineno"> 2424</span> </div>
<div class="line"><span class="lineno"> 2425</span>            std::vector&lt;std::pair&lt;ed_t, fd_t&gt;&gt;&amp; m0_ivtx_to_intersection_registry_entry_LOCAL = std::get&lt;0&gt;(local_output);</div>
<div class="line"><span class="lineno"> 2426</span>            std::vector&lt;vd_t&gt;&amp; cm_border_reentrant_ivtx_list_LOCAL = std::get&lt;1&gt;(local_output);</div>
<div class="line"><span class="lineno"> 2427</span>            std::unordered_map&lt;ed_t, std::vector&lt;vd_t&gt;&gt;&amp; ps_intersecting_edges_LOCAL = std::get&lt;2&gt;(local_output);</div>
<div class="line"><span class="lineno"> 2428</span>            std::map&lt;pair&lt;fd_t&gt;, std::vector&lt;vd_t&gt;&gt;&amp; cutpath_edge_creation_info_LOCAL = std::get&lt;3&gt;(local_output);</div>
<div class="line"><span class="lineno"> 2429</span>            std::unordered_map&lt;fd_t, std::vector&lt;vd_t&gt;&gt;&amp; ps_iface_to_ivtx_list_LOCAL = std::get&lt;4&gt;(local_output);</div>
<div class="line"><span class="lineno"> 2430</span>            <span class="keywordtype">bool</span>&amp; partial_cut_detected_LOCAL = std::get&lt;5&gt;(local_output);</div>
<div class="line"><span class="lineno"> 2431</span>            std::vector&lt;vec3&gt;&amp; intersection_points_LOCAL = std::get&lt;6&gt;(local_output);</div>
<div class="line"><span class="lineno"> 2432</span> </div>
<div class="line"><span class="lineno"> 2433</span>            <span class="comment">// NOTE: threads do not add vertices into m0 to prevent contention on a shared resource.</span></div>
<div class="line"><span class="lineno"> 2434</span>            <span class="comment">// They instead store a placeholder value that is analogous to an local offset i.e.</span></div>
<div class="line"><span class="lineno"> 2435</span>            <span class="comment">// as if each thread was writing into its own mesh.</span></div>
<div class="line"><span class="lineno"> 2436</span> </div>
<div class="line"><span class="lineno"> 2437</span>            <span class="comment">// did another thread/job encountered a configuration in which we violated general position</span></div>
<div class="line"><span class="lineno"> 2438</span>            <span class="comment">// NOTE: we only check at the beginning to prevent contention on &quot;output.status&quot;</span></div>
<div class="line"><span class="lineno"> 2439</span>            <span class="keywordtype">bool</span> current_status_is_okay = (output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a7d4c902daa6f0439e388496967885dd9">status</a>.load() == <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586ad0749aaba8b833466dfcbb0428e4f89c">status_t::SUCCESS</a>);</div>
<div class="line"><span class="lineno"> 2440</span>            <span class="keywordflow">if</span> (!current_status_is_okay) {</div>
<div class="line"><span class="lineno"> 2441</span>                <span class="keywordflow">return</span> OutputStorageTypesTuple {}; <span class="comment">// immediately</span></div>
<div class="line"><span class="lineno"> 2442</span>            }</div>
<div class="line"><span class="lineno"> 2443</span> </div>
<div class="line"><span class="lineno"> 2444</span>            <span class="comment">// for each edge</span></div>
<div class="line"><span class="lineno"> 2445</span>            <span class="keywordflow">for</span> (std::unordered_map&lt;<a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>, std::vector&lt;fd_t&gt;&gt;::const_iterator ps_edge_face_intersection_pairs_iter = block_start_;</div>
<div class="line"><span class="lineno"> 2446</span>                 ps_edge_face_intersection_pairs_iter != block_end_;</div>
<div class="line"><span class="lineno"> 2447</span>                 ps_edge_face_intersection_pairs_iter++) {</div>
<div class="line"><span class="lineno"> 2448</span> </div>
<div class="line"><span class="lineno"> 2449</span>                <span class="comment">// our edge that we test for intersection with other faces</span></div>
<div class="line"><span class="lineno"> 2450</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> tested_edge = ps_edge_face_intersection_pairs_iter-&gt;first;</div>
<div class="line"><span class="lineno"> 2451</span>                <span class="comment">// the faces against which the edge is tested for intersection</span></div>
<div class="line"><span class="lineno"> 2452</span>                <span class="keyword">const</span> std::vector&lt;fd_t&gt;&amp; tested_faces = ps_edge_face_intersection_pairs_iter-&gt;second;</div>
<div class="line"><span class="lineno"> 2453</span> </div>
<div class="line"><span class="lineno"> 2454</span>                <span class="comment">// the halfedges of our edge</span></div>
<div class="line"><span class="lineno"> 2455</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> tested_edge_h0 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(tested_edge, 0);</div>
<div class="line"><span class="lineno"> 2456</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> tested_edge_h1 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(tested_edge, 1);</div>
<div class="line"><span class="lineno"> 2457</span> </div>
<div class="line"><span class="lineno"> 2458</span>                <span class="comment">// source vertex</span></div>
<div class="line"><span class="lineno"> 2459</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vertex_descriptor_t</a> tested_edge_h0_source_descr = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(tested_edge_h0);</div>
<div class="line"><span class="lineno"> 2460</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a>&amp; tested_edge_h0_source_vertex = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(tested_edge_h0_source_descr);</div>
<div class="line"><span class="lineno"> 2461</span>                <span class="comment">// target vertex</span></div>
<div class="line"><span class="lineno"> 2462</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vertex_descriptor_t</a> tested_edge_h0_target_descr = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(tested_edge_h0);</div>
<div class="line"><span class="lineno"> 2463</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a>&amp; tested_edge_h0_target_vertex = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(tested_edge_h0_target_descr);</div>
<div class="line"><span class="lineno"> 2464</span> </div>
<div class="line"><span class="lineno"> 2465</span>                <span class="comment">// This boolean var is evaluated based on the fact that sm faces come before cm faces inside the &quot;ps&quot; data structure</span></div>
<div class="line"><span class="lineno"> 2466</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> tested_edge_h0_face = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(tested_edge_h0);</div>
<div class="line"><span class="lineno"> 2467</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> tested_edge_h1_face = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(tested_edge_h1);</div>
<div class="line"><span class="lineno"> 2468</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> tested_edge_face = tested_edge_h0_face != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>() ? tested_edge_h0_face : tested_edge_h1_face;</div>
<div class="line"><span class="lineno"> 2469</span>                <span class="keyword">const</span> <span class="keywordtype">bool</span> tested_edge_belongs_to_cm = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aaf65fb11520f9cb197774e79efeddfbb">ps_is_cutmesh_face</a>(tested_edge_face, sm_face_count);</div>
<div class="line"><span class="lineno"> 2470</span> </div>
<div class="line"><span class="lineno"> 2471</span>                <span class="comment">// for each face that is to be intersected with the tested-edge</span></div>
<div class="line"><span class="lineno"> 2472</span>                <span class="keywordflow">for</span> (std::vector&lt;fd_t&gt;::const_iterator tested_faces_iter = tested_faces.cbegin();</div>
<div class="line"><span class="lineno"> 2473</span>                     tested_faces_iter != tested_faces.cend();</div>
<div class="line"><span class="lineno"> 2474</span>                     ++tested_faces_iter) {</div>
<div class="line"><span class="lineno"> 2475</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> tested_face = *tested_faces_iter;</div>
<div class="line"><span class="lineno"> 2476</span> </div>
<div class="line"><span class="lineno"> 2477</span>                    <span class="comment">// We are now finding the intersection points determined by calculating the location</span></div>
<div class="line"><span class="lineno"> 2478</span>                    <span class="comment">// where each halfedge of face A intersects the area defined by face B (if it exists).</span></div>
<div class="line"><span class="lineno"> 2479</span> </div>
<div class="line"><span class="lineno"> 2480</span>                    <span class="comment">// get the vertices of tested_face (used to estimate its normal etc.)</span></div>
<div class="line"><span class="lineno"> 2481</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ps_tested_face_to_vertices.find(tested_face) != ps_tested_face_to_vertices.end());</div>
<div class="line"><span class="lineno"> 2482</span>                    <span class="keyword">const</span> std::vector&lt;vec3&gt;&amp; tested_face_vertices = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_tested_face_to_vertices, tested_face);</div>
<div class="line"><span class="lineno"> 2483</span> </div>
<div class="line"><span class="lineno"> 2484</span>                    <span class="comment">// compute plane of tested_face</span></div>
<div class="line"><span class="lineno"> 2485</span>                    <span class="comment">// -----------------------</span></div>
<div class="line"><span class="lineno"> 2486</span> </div>
<div class="line"><span class="lineno"> 2487</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ps_tested_face_to_plane_normal.find(tested_face) != ps_tested_face_to_plane_normal.end());</div>
<div class="line"><span class="lineno"> 2488</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a>&amp; tested_face_plane_normal = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_tested_face_to_plane_normal, tested_face);</div>
<div class="line"><span class="lineno"> 2489</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ps_tested_face_to_plane_normal_d_param.find(tested_face) != ps_tested_face_to_plane_normal_d_param.end());</div>
<div class="line"><span class="lineno"> 2490</span>                    <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; tested_face_plane_param_d = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_tested_face_to_plane_normal_d_param, tested_face);</div>
<div class="line"><span class="lineno"> 2491</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ps_tested_face_to_plane_normal_max_comp.find(tested_face) != ps_tested_face_to_plane_normal_max_comp.end());</div>
<div class="line"><span class="lineno"> 2492</span>                    <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; tested_face_plane_normal_max_comp = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_tested_face_to_plane_normal_max_comp, tested_face); <span class="comment">// compute_polygon_plane_coefficients(</span></div>
<div class="line"><span class="lineno"> 2493</span> </div>
<div class="line"><span class="lineno"> 2494</span>                    <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a> intersection_point(0., 0., 0.); <span class="comment">// the intersection point to be computed</span></div>
<div class="line"><span class="lineno"> 2495</span> </div>
<div class="line"><span class="lineno"> 2496</span>                    <span class="keywordtype">char</span> segment_intersection_type = <a class="code hl_function" href="../../df/db1/math_8h.html#a2253a03334d0c9681225281db5a96928">compute_segment_plane_intersection_type</a>( <span class="comment">// exact**</span></div>
<div class="line"><span class="lineno"> 2497</span>                        tested_edge_h0_source_vertex,</div>
<div class="line"><span class="lineno"> 2498</span>                        tested_edge_h0_target_vertex,</div>
<div class="line"><span class="lineno"> 2499</span>                        tested_face_vertices,</div>
<div class="line"><span class="lineno"> 2500</span>                        tested_face_plane_normal,</div>
<div class="line"><span class="lineno"> 2501</span>                        tested_face_plane_normal_max_comp);</div>
<div class="line"><span class="lineno"> 2502</span> </div>
<div class="line"><span class="lineno"> 2503</span>                    <span class="keywordtype">bool</span> have_plane_intersection = (segment_intersection_type != <span class="charliteral">&#39;0&#39;</span>); <span class="comment">// any intersection !</span></div>
<div class="line"><span class="lineno"> 2504</span> </div>
<div class="line"><span class="lineno"> 2505</span>                    <span class="keywordflow">if</span> (have_plane_intersection) {</div>
<div class="line"><span class="lineno"> 2506</span>                        <span class="keywordflow">if</span> (segment_intersection_type != <span class="charliteral">&#39;1&#39;</span>) {</div>
<div class="line"><span class="lineno"> 2507</span>                            <span class="keywordtype">bool</span> violatedGP = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 2508</span>                            std::vector&lt;const vec3*&gt; points_touching_plane;</div>
<div class="line"><span class="lineno"> 2509</span> </div>
<div class="line"><span class="lineno"> 2510</span>                            <span class="keywordflow">if</span> (segment_intersection_type == <span class="charliteral">&#39;q&#39;</span> || segment_intersection_type == <span class="charliteral">&#39;r&#39;</span>) {</div>
<div class="line"><span class="lineno"> 2511</span>                                points_touching_plane.push_back((segment_intersection_type == <span class="charliteral">&#39;q&#39;</span>) ? &amp;tested_edge_h0_source_vertex : &amp;tested_edge_h0_target_vertex);</div>
<div class="line"><span class="lineno"> 2512</span>                            } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 2513</span>                                points_touching_plane.push_back(&amp;tested_edge_h0_source_vertex);</div>
<div class="line"><span class="lineno"> 2514</span>                                points_touching_plane.push_back(&amp;tested_edge_h0_target_vertex);</div>
<div class="line"><span class="lineno"> 2515</span>                            }</div>
<div class="line"><span class="lineno"> 2516</span> </div>
<div class="line"><span class="lineno"> 2517</span>                            <span class="keywordflow">for</span> (std::vector&lt;const vec3*&gt;::const_iterator i = points_touching_plane.cbegin(); i != points_touching_plane.cend(); ++i) {</div>
<div class="line"><span class="lineno"> 2518</span>                                <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a>&amp; point = (*(*i));</div>
<div class="line"><span class="lineno"> 2519</span>                                <span class="keywordtype">char</span> result = <a class="code hl_function" href="../../df/db1/math_8h.html#a82a9c1f090b54dc1416ca1c3673ef5d7">compute_point_in_polygon_test</a>(</div>
<div class="line"><span class="lineno"> 2520</span>                                    point,</div>
<div class="line"><span class="lineno"> 2521</span>                                    tested_face_vertices,</div>
<div class="line"><span class="lineno"> 2522</span>                                    tested_face_plane_normal,</div>
<div class="line"><span class="lineno"> 2523</span>                                    tested_face_plane_normal_max_comp);</div>
<div class="line"><span class="lineno"> 2524</span>                                <span class="keywordflow">if</span> (result == <span class="charliteral">&#39;i&#39;</span> || (result == <span class="charliteral">&#39;v&#39;</span> || result == <span class="charliteral">&#39;e&#39;</span>)) {</div>
<div class="line"><span class="lineno"> 2525</span>                                    violatedGP = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 2526</span>                                    <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 2527</span>                                }</div>
<div class="line"><span class="lineno"> 2528</span>                            }</div>
<div class="line"><span class="lineno"> 2529</span> </div>
<div class="line"><span class="lineno"> 2530</span>                            <span class="keywordflow">if</span> (violatedGP) {</div>
<div class="line"><span class="lineno"> 2531</span>                                <a class="code hl_enumeration" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> okay_status = <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586ad0749aaba8b833466dfcbb0428e4f89c">status_t::SUCCESS</a>;</div>
<div class="line"><span class="lineno"> 2532</span>                                <span class="keywordtype">bool</span> exchanged = output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a7d4c902daa6f0439e388496967885dd9">status</a>.compare_exchange_strong(okay_status, <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a91712b49b91fbf59087df24104715e29">status_t::GENERAL_POSITION_VIOLATION</a>);</div>
<div class="line"><span class="lineno"> 2533</span>                                <span class="keywordflow">if</span> (!input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a5793da463db7c7b18aab5817d243c875">enforce_general_position</a> &amp;&amp; exchanged) {</div>
<div class="line"><span class="lineno"> 2534</span>                                    <span class="comment">// only one thread can modify &quot;lg&quot;. Thus, &quot;lg&quot; does not need to be locked in order to set</span></div>
<div class="line"><span class="lineno"> 2535</span>                                    <span class="comment">// the reason for failure</span></div>
<div class="line"><span class="lineno"> 2536</span>                                    lg.<a class="code hl_function" href="../../d8/d0d/classlogger__t.html#aecaed21510eca7fa095e7176d9e36850">set_reason_for_failure</a>(<span class="stringliteral">&quot;invalid compute_segment_plane_intersection_type result (&#39;&quot;</span> + std::to_string(segment_intersection_type) + <span class="stringliteral">&quot;&#39;)&quot;</span>);</div>
<div class="line"><span class="lineno"> 2537</span>                                }</div>
<div class="line"><span class="lineno"> 2538</span>                                <span class="keywordflow">return</span> OutputStorageTypesTuple {};</div>
<div class="line"><span class="lineno"> 2539</span>                                ; <span class="comment">// stop immediately and do not complete the current job</span></div>
<div class="line"><span class="lineno"> 2540</span>                            } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 2541</span>                                <span class="comment">//  move onto the next edge-face test.</span></div>
<div class="line"><span class="lineno"> 2542</span>                                <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 2543</span>                            }</div>
<div class="line"><span class="lineno"> 2544</span>                        }</div>
<div class="line"><span class="lineno"> 2545</span> </div>
<div class="line"><span class="lineno"> 2546</span>                        <a class="code hl_function" href="../../df/db1/math_8h.html#a35c50f5df223f546dec9cd74983abc38">compute_segment_plane_intersection</a>(</div>
<div class="line"><span class="lineno"> 2547</span>                            intersection_point,</div>
<div class="line"><span class="lineno"> 2548</span>                            tested_face_plane_normal,</div>
<div class="line"><span class="lineno"> 2549</span>                            tested_face_plane_param_d,</div>
<div class="line"><span class="lineno"> 2550</span>                            tested_edge_h0_source_vertex,</div>
<div class="line"><span class="lineno"> 2551</span>                            tested_edge_h0_target_vertex);</div>
<div class="line"><span class="lineno"> 2552</span> </div>
<div class="line"><span class="lineno"> 2553</span>                        <span class="keywordtype">char</span> in_poly_test_intersection_type = <a class="code hl_function" href="../../df/db1/math_8h.html#a82a9c1f090b54dc1416ca1c3673ef5d7">compute_point_in_polygon_test</a>(</div>
<div class="line"><span class="lineno"> 2554</span>                            intersection_point,</div>
<div class="line"><span class="lineno"> 2555</span>                            tested_face_vertices,</div>
<div class="line"><span class="lineno"> 2556</span>                            <span class="comment">// #if 1</span></div>
<div class="line"><span class="lineno"> 2557</span>                            tested_face_plane_normal,</div>
<div class="line"><span class="lineno"> 2558</span>                            <span class="comment">// #else</span></div>
<div class="line"><span class="lineno"> 2559</span>                            tested_face_plane_normal_max_comp</div>
<div class="line"><span class="lineno"> 2560</span>                            <span class="comment">// #endif</span></div>
<div class="line"><span class="lineno"> 2561</span>                        );</div>
<div class="line"><span class="lineno"> 2562</span> </div>
<div class="line"><span class="lineno"> 2563</span>                        <span class="keywordflow">if</span> (in_poly_test_intersection_type == <span class="charliteral">&#39;v&#39;</span> || in_poly_test_intersection_type == <span class="charliteral">&#39;e&#39;</span>) {</div>
<div class="line"><span class="lineno"> 2564</span>                            <a class="code hl_enumeration" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> okay_status = <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586ad0749aaba8b833466dfcbb0428e4f89c">status_t::SUCCESS</a>;</div>
<div class="line"><span class="lineno"> 2565</span>                            <span class="keywordtype">bool</span> exchanged = output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a7d4c902daa6f0439e388496967885dd9">status</a>.compare_exchange_strong(okay_status, <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a91712b49b91fbf59087df24104715e29">status_t::GENERAL_POSITION_VIOLATION</a>);</div>
<div class="line"><span class="lineno"> 2566</span>                            <span class="comment">// output.status = status_t::GENERAL_POSITION_VIOLATION;</span></div>
<div class="line"><span class="lineno"> 2567</span>                            <span class="keywordflow">if</span> (!input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a5793da463db7c7b18aab5817d243c875">enforce_general_position</a> &amp;&amp; exchanged) {</div>
<div class="line"><span class="lineno"> 2568</span>                                lg.<a class="code hl_function" href="../../d8/d0d/classlogger__t.html#aecaed21510eca7fa095e7176d9e36850">set_reason_for_failure</a>(<span class="stringliteral">&quot;invalid point-in-polygon test result (&#39;&quot;</span> + std::to_string(in_poly_test_intersection_type) + <span class="stringliteral">&quot;&#39;)&quot;</span>);</div>
<div class="line"><span class="lineno"> 2569</span>                            }</div>
<div class="line"><span class="lineno"> 2570</span>                            <span class="keywordflow">return</span> OutputStorageTypesTuple {};</div>
<div class="line"><span class="lineno"> 2571</span>                            ; <span class="comment">// stop immediately and do not complete the current job</span></div>
<div class="line"><span class="lineno"> 2572</span>                        }</div>
<div class="line"><span class="lineno"> 2573</span> </div>
<div class="line"><span class="lineno"> 2574</span>                        <span class="keywordtype">bool</span> have_point_in_polygon = in_poly_test_intersection_type == <span class="charliteral">&#39;i&#39;</span>;</div>
<div class="line"><span class="lineno"> 2575</span> </div>
<div class="line"><span class="lineno"> 2576</span>                        <span class="keywordflow">if</span> (have_point_in_polygon) {</div>
<div class="line"><span class="lineno"> 2577</span> </div>
<div class="line"><span class="lineno"> 2578</span>                            <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> face_pqr = tested_edge_face;</div>
<div class="line"><span class="lineno"> 2579</span>                            <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> face_xyz = tested_face;</div>
<div class="line"><span class="lineno"> 2580</span>                            <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> face_pqs = tested_edge_face == tested_edge_h0_face ? tested_edge_h1_face : <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>();</div>
<div class="line"><span class="lineno"> 2581</span> </div>
<div class="line"><span class="lineno"> 2582</span>                            <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> new_vertex_descr((<a class="code hl_typedef" href="../../dd/dad/classdescriptor__t__.html#a80e181aa419b05d8c73a579815159df9">vd_t::index_type</a>)intersection_points_LOCAL.size());</div>
<div class="line"><span class="lineno"> 2583</span>                            intersection_points_LOCAL.push_back(intersection_point); <span class="comment">/*m0.add_vertex(intersection_point)*/</span></div>
<div class="line"><span class="lineno"> 2584</span>                            ;</div>
<div class="line"><span class="lineno"> 2585</span> </div>
<div class="line"><span class="lineno"> 2586</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)new_vertex_descr == m0_ivtx_to_intersection_registry_entry_LOCAL.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(new_vertex_descr) == m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 2587</span>                            m0_ivtx_to_intersection_registry_entry_LOCAL.push_back(std::make_pair(tested_edge, tested_face));</div>
<div class="line"><span class="lineno"> 2588</span> </div>
<div class="line"><span class="lineno"> 2589</span>                            ps_intersecting_edges_LOCAL[tested_edge].push_back(new_vertex_descr);</div>
<div class="line"><span class="lineno"> 2590</span> </div>
<div class="line"><span class="lineno"> 2591</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> cm_face = tested_edge_belongs_to_cm ? tested_edge_face : tested_face;</div>
<div class="line"><span class="lineno"> 2592</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> sm_face = tested_edge_belongs_to_cm ? tested_face : tested_edge_face;</div>
<div class="line"><span class="lineno"> 2593</span> </div>
<div class="line"><span class="lineno"> 2594</span>                            <span class="keywordflow">if</span> (tested_edge_belongs_to_cm) {</div>
<div class="line"><span class="lineno"> 2595</span>                                <span class="comment">// NOTE: std::pair format/order is {source-mesh-face, cut-mesh-face}</span></div>
<div class="line"><span class="lineno"> 2596</span>                                cutpath_edge_creation_info_LOCAL[<a class="code hl_function" href="../../d5/d60/utils_8h.html#ad365c8c3344c9156ff85f9122be357ac">make_pair</a>(tested_face, face_pqr)].push_back(new_vertex_descr);</div>
<div class="line"><span class="lineno"> 2597</span>                                <span class="keywordflow">if</span> (face_pqs != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>()) {</div>
<div class="line"><span class="lineno"> 2598</span>                                    cutpath_edge_creation_info_LOCAL[<a class="code hl_function" href="../../d5/d60/utils_8h.html#ad365c8c3344c9156ff85f9122be357ac">make_pair</a>(tested_face, face_pqs)].push_back(new_vertex_descr);</div>
<div class="line"><span class="lineno"> 2599</span>                                }</div>
<div class="line"><span class="lineno"> 2600</span>                            } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 2601</span>                                cutpath_edge_creation_info_LOCAL[<a class="code hl_function" href="../../d5/d60/utils_8h.html#ad365c8c3344c9156ff85f9122be357ac">make_pair</a>(tested_edge_face, tested_face)].push_back(new_vertex_descr);</div>
<div class="line"><span class="lineno"> 2602</span>                                <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> tested_edge_face_other = (tested_edge_face == tested_edge_h0_face) ? tested_edge_h1_face : tested_edge_h0_face;</div>
<div class="line"><span class="lineno"> 2603</span> </div>
<div class="line"><span class="lineno"> 2604</span>                                <span class="keywordflow">if</span> (tested_edge_face_other != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>()) {</div>
<div class="line"><span class="lineno"> 2605</span>                                    cutpath_edge_creation_info_LOCAL[<a class="code hl_function" href="../../d5/d60/utils_8h.html#ad365c8c3344c9156ff85f9122be357ac">make_pair</a>(tested_edge_face_other, tested_face)].push_back(new_vertex_descr);</div>
<div class="line"><span class="lineno"> 2606</span>                                }</div>
<div class="line"><span class="lineno"> 2607</span>                            }</div>
<div class="line"><span class="lineno"> 2608</span> </div>
<div class="line"><span class="lineno"> 2609</span>                            <span class="keywordflow">if</span> (tested_edge_belongs_to_cm) {</div>
<div class="line"><span class="lineno"> 2610</span>                                <span class="keyword">const</span> <span class="keywordtype">bool</span> is_border_reentrant_ivertex = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a56a93aa8ba1f69b11d91c8fb2a9b3913">is_border</a>(tested_edge); <span class="comment">// ps.is_border(ps.edge(halfedge_pq));</span></div>
<div class="line"><span class="lineno"> 2611</span> </div>
<div class="line"><span class="lineno"> 2612</span>                                <span class="keywordflow">if</span> (is_border_reentrant_ivertex) {</div>
<div class="line"><span class="lineno"> 2613</span>                                    cm_border_reentrant_ivtx_list_LOCAL.push_back(new_vertex_descr);</div>
<div class="line"><span class="lineno"> 2614</span>                                }</div>
<div class="line"><span class="lineno"> 2615</span>                            }</div>
<div class="line"><span class="lineno"> 2616</span> </div>
<div class="line"><span class="lineno"> 2617</span>                            ps_iface_to_ivtx_list_LOCAL[tested_face].push_back(new_vertex_descr);</div>
<div class="line"><span class="lineno"> 2618</span>                            <span class="keywordflow">if</span> (tested_edge_h0_face != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>()) {</div>
<div class="line"><span class="lineno"> 2619</span>                                ps_iface_to_ivtx_list_LOCAL[tested_edge_h0_face].push_back(new_vertex_descr);</div>
<div class="line"><span class="lineno"> 2620</span>                            }</div>
<div class="line"><span class="lineno"> 2621</span>                            <span class="keywordflow">if</span> (tested_edge_h1_face != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>()) {</div>
<div class="line"><span class="lineno"> 2622</span>                                ps_iface_to_ivtx_list_LOCAL[tested_edge_h1_face].push_back(new_vertex_descr);</div>
<div class="line"><span class="lineno"> 2623</span>                            }</div>
<div class="line"><span class="lineno"> 2624</span> </div>
<div class="line"><span class="lineno"> 2625</span>                            <span class="keywordflow">if</span> (partial_cut_detected_LOCAL == <span class="keyword">false</span>) { <span class="comment">// keep checking until (locally) true</span></div>
<div class="line"><span class="lineno"> 2626</span>                                <span class="keyword">const</span> <span class="keywordtype">bool</span> is_cs_edge = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a426849b7f7105963c5e2767bdd31b155">ps_is_cutmesh_vertex</a>(tested_edge_h0_source_descr, sm_vtx_cnt);</div>
<div class="line"><span class="lineno"> 2627</span>                                <span class="keywordtype">bool</span> is_border = (tested_edge_h0_face == <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>() || tested_edge_h1_face == <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>());</div>
<div class="line"><span class="lineno"> 2628</span>                                partial_cut_detected_LOCAL = (is_cs_edge &amp;&amp; is_border);</div>
<div class="line"><span class="lineno"> 2629</span>                            }</div>
<div class="line"><span class="lineno"> 2630</span>                        } <span class="comment">// if (have_point_in_polygon)</span></div>
<div class="line"><span class="lineno"> 2631</span>                    } <span class="comment">// if (have_plane_intersection) {</span></div>
<div class="line"><span class="lineno"> 2632</span>                } <span class="comment">// for (std::vector&lt;fd_t&gt;::const_iterator intersected_faces_iter = intersected_faces.cbegin(); intersected_faces_iter != intersected_faces.cend(); ++intersected_faces_iter) {</span></div>
<div class="line"><span class="lineno"> 2633</span>            } <span class="comment">// for (std::map&lt;ed_t, std::vector&lt;fd_t&gt;&gt;::const_iterator ps_edge_face_intersection_pairs_iter = ps_edge_face_intersection_pairs.cbegin(); ps_edge_face_intersection_pairs_iter != ps_edge_face_intersection_pairs.cend(); ps_edge_face_intersection_pairs_iter++) {</span></div>
<div class="line"><span class="lineno"> 2634</span> </div>
<div class="line"><span class="lineno"> 2635</span>            <span class="keywordflow">return</span> local_output;</div>
<div class="line"><span class="lineno"> 2636</span>        };</div>
<div class="line"><span class="lineno"> 2637</span> </div>
<div class="line"><span class="lineno"> 2638</span>        std::vector&lt;std::future&lt;OutputStorageTypesTuple&gt;&gt; futures;</div>
<div class="line"><span class="lineno"> 2639</span>        OutputStorageTypesTuple partial_res;</div>
<div class="line"><span class="lineno"> 2640</span>        <a class="code hl_function" href="../../df/d05/tpool_8h.html#a48d2e68725f7691f1422697f4c359827">parallel_for</a>(</div>
<div class="line"><span class="lineno"> 2641</span>            *input.scheduler,</div>
<div class="line"><span class="lineno"> 2642</span>            ps_edge_face_intersection_pairs.cbegin(),</div>
<div class="line"><span class="lineno"> 2643</span>            ps_edge_face_intersection_pairs.cend(),</div>
<div class="line"><span class="lineno"> 2644</span>            fn_compute_intersection_points,</div>
<div class="line"><span class="lineno"> 2645</span>            partial_res, <span class="comment">// output computed by master thread</span></div>
<div class="line"><span class="lineno"> 2646</span>            futures);</div>
<div class="line"><span class="lineno"> 2647</span> </div>
<div class="line"><span class="lineno"> 2648</span>        std::vector&lt;vec3&gt; intersection_points;</div>
<div class="line"><span class="lineno"> 2649</span>        std::tie(</div>
<div class="line"><span class="lineno"> 2650</span>            m0_ivtx_to_intersection_registry_entry,</div>
<div class="line"><span class="lineno"> 2651</span>            cm_border_reentrant_ivtx_list,</div>
<div class="line"><span class="lineno"> 2652</span>            ps_intersecting_edges,</div>
<div class="line"><span class="lineno"> 2653</span>            cutpath_edge_creation_info,</div>
<div class="line"><span class="lineno"> 2654</span>            ps_iface_to_ivtx_list,</div>
<div class="line"><span class="lineno"> 2655</span>            partial_cut_detected,</div>
<div class="line"><span class="lineno"> 2656</span>            intersection_points)</div>
<div class="line"><span class="lineno"> 2657</span>            = partial_res;</div>
<div class="line"><span class="lineno"> 2658</span> </div>
<div class="line"><span class="lineno"> 2659</span>        <span class="comment">// Add intersection points computed by master thread in to &quot;m0&quot; and</span></div>
<div class="line"><span class="lineno"> 2660</span>        <span class="comment">// account for intersection point offsets</span></div>
<div class="line"><span class="lineno"> 2661</span>        <span class="keywordflow">for</span> (std::vector&lt;vec3&gt;::const_iterator i = intersection_points.cbegin(); i != intersection_points.cend(); ++i) {</div>
<div class="line"><span class="lineno"> 2662</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> stored_descr = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a0d2a1a79406b7352af07d4fc56707782">add_vertex</a>(*i);</div>
<div class="line"><span class="lineno"> 2663</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(stored_descr != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ab448d0b9684fd2f648195b2e5edb83f2">hmesh_t::null_vertex</a>());</div>
<div class="line"><span class="lineno"> 2664</span>        }</div>
<div class="line"><span class="lineno"> 2665</span> </div>
<div class="line"><span class="lineno"> 2666</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)cm_border_reentrant_ivtx_list.size(); ++i) {</div>
<div class="line"><span class="lineno"> 2667</span>            cm_border_reentrant_ivtx_list[i] += ps_vtx_cnt;</div>
<div class="line"><span class="lineno"> 2668</span>        }</div>
<div class="line"><span class="lineno"> 2669</span> </div>
<div class="line"><span class="lineno"> 2670</span>        <span class="keywordflow">for</span> (std::unordered_map&lt;<a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>, std::vector&lt;vd_t&gt;&gt;::iterator i = ps_intersecting_edges.begin();</div>
<div class="line"><span class="lineno"> 2671</span>             i != ps_intersecting_edges.end(); ++i) {</div>
<div class="line"><span class="lineno"> 2672</span>            <span class="keywordflow">for</span> (std::vector&lt;vd_t&gt;::iterator j = i-&gt;second.begin(); j != i-&gt;second.end(); j++) {</div>
<div class="line"><span class="lineno"> 2673</span>                *j += ps_vtx_cnt;</div>
<div class="line"><span class="lineno"> 2674</span>            }</div>
<div class="line"><span class="lineno"> 2675</span>        }</div>
<div class="line"><span class="lineno"> 2676</span> </div>
<div class="line"><span class="lineno"> 2677</span>        <span class="keywordflow">for</span> (std::unordered_map&lt;<a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a>, std::vector&lt;vd_t&gt;&gt;::iterator i = ps_iface_to_ivtx_list.begin();</div>
<div class="line"><span class="lineno"> 2678</span>             i != ps_iface_to_ivtx_list.end(); ++i) {</div>
<div class="line"><span class="lineno"> 2679</span>            <span class="keywordflow">for</span> (std::vector&lt;vd_t&gt;::iterator j = i-&gt;second.begin(); j != i-&gt;second.end(); j++) {</div>
<div class="line"><span class="lineno"> 2680</span>                *j += ps_vtx_cnt;</div>
<div class="line"><span class="lineno"> 2681</span>            }</div>
<div class="line"><span class="lineno"> 2682</span>        }</div>
<div class="line"><span class="lineno"> 2683</span> </div>
<div class="line"><span class="lineno"> 2684</span>        <span class="keywordflow">for</span> (std::map&lt;<a class="code hl_struct" href="../../df/de8/structpair.html">pair&lt;fd_t&gt;</a>, std::vector&lt;vd_t&gt;&gt;::iterator i = cutpath_edge_creation_info.begin();</div>
<div class="line"><span class="lineno"> 2685</span>             i != cutpath_edge_creation_info.end(); ++i) {</div>
<div class="line"><span class="lineno"> 2686</span>            <span class="keywordflow">for</span> (std::vector&lt;vd_t&gt;::iterator j = i-&gt;second.begin(); j != i-&gt;second.end(); j++) {</div>
<div class="line"><span class="lineno"> 2687</span>                *j += ps_vtx_cnt;</div>
<div class="line"><span class="lineno"> 2688</span>            }</div>
<div class="line"><span class="lineno"> 2689</span>        }</div>
<div class="line"><span class="lineno"> 2690</span> </div>
<div class="line"><span class="lineno"> 2691</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 2692</span>        <span class="comment">// Now we merge the results from futures</span></div>
<div class="line"><span class="lineno"> 2693</span> </div>
<div class="line"><span class="lineno"> 2694</span>        <span class="keywordtype">bool</span> status_is_okay = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 2695</span> </div>
<div class="line"><span class="lineno"> 2696</span>        <span class="keywordflow">if</span> (futures.empty()) { <span class="comment">// only master thred</span></div>
<div class="line"><span class="lineno"> 2697</span>            status_is_okay = (output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a7d4c902daa6f0439e388496967885dd9">status</a>.load() == <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586ad0749aaba8b833466dfcbb0428e4f89c">status_t::SUCCESS</a>);</div>
<div class="line"><span class="lineno"> 2698</span>            <span class="keywordflow">if</span> (!status_is_okay) {</div>
<div class="line"><span class="lineno"> 2699</span>                <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno"> 2700</span>            }</div>
<div class="line"><span class="lineno"> 2701</span>        } <span class="keywordflow">else</span> { <span class="comment">// one or more worker threads</span></div>
<div class="line"><span class="lineno"> 2702</span> </div>
<div class="line"><span class="lineno"> 2703</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 2704</span>            <span class="comment">// This scope is executed by the master thread, which will merge results from other threads via std::futures</span></div>
<div class="line"><span class="lineno"> 2705</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 2706</span>            <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> intersection_point_descr_baseoffset(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a35ce6de1cc36d41e9eb48edb3e23e795">number_of_vertices</a>());</div>
<div class="line"><span class="lineno"> 2707</span> </div>
<div class="line"><span class="lineno"> 2708</span>            <span class="comment">// iterate through all available future so that we can 1) get their results</span></div>
<div class="line"><span class="lineno"> 2709</span>            <span class="comment">// and 2) ensure that all scheduled jobs are completed before exiting (or returning from)</span></div>
<div class="line"><span class="lineno"> 2710</span>            <span class="comment">// the kernel</span></div>
<div class="line"><span class="lineno"> 2711</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i_ = 0; i_ &lt; (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)futures.size(); ++i_) {</div>
<div class="line"><span class="lineno"> 2712</span> </div>
<div class="line"><span class="lineno"> 2713</span>                std::future&lt;OutputStorageTypesTuple&gt;&amp; f = futures[i_];</div>
<div class="line"><span class="lineno"> 2714</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(f.valid()); <span class="comment">// The behavior is undefined if valid()== false before the call to wait_for</span></div>
<div class="line"><span class="lineno"> 2715</span> </div>
<div class="line"><span class="lineno"> 2716</span>                OutputStorageTypesTuple future_result = f.get(); <span class="comment">// &quot;get()&quot; is a blocking function</span></div>
<div class="line"><span class="lineno"> 2717</span> </div>
<div class="line"><span class="lineno"> 2718</span>                <span class="comment">// As the master thread works to merge the partial results, it is possible that one of the</span></div>
<div class="line"><span class="lineno"> 2719</span>                <span class="comment">// worker threads detected a violation of general position. In this case, the current dispatch call</span></div>
<div class="line"><span class="lineno"> 2720</span>                <span class="comment">// needs to be stopped so that the front-end will be able to perturb the cut-mesh.</span></div>
<div class="line"><span class="lineno"> 2721</span>                <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 2722</span>                <span class="comment">// Thus, we ask &quot;did any worker-thread encounter a GP violation?&quot; If so, we must stop all merging</span></div>
<div class="line"><span class="lineno"> 2723</span>                <span class="comment">// of partial results [and] wait for the currently running jobs (futures) to finish. Waiting is</span></div>
<div class="line"><span class="lineno"> 2724</span>                <span class="comment">// done automatically by calling f.get()</span></div>
<div class="line"><span class="lineno"> 2725</span>                status_is_okay = (output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a7d4c902daa6f0439e388496967885dd9">status</a>.load() == <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586ad0749aaba8b833466dfcbb0428e4f89c">status_t::SUCCESS</a>);</div>
<div class="line"><span class="lineno"> 2726</span> </div>
<div class="line"><span class="lineno"> 2727</span>                <span class="keywordflow">if</span> (!status_is_okay) {</div>
<div class="line"><span class="lineno"> 2728</span>                    <span class="keywordflow">continue</span>; <span class="comment">// skip future result</span></div>
<div class="line"><span class="lineno"> 2729</span>                }</div>
<div class="line"><span class="lineno"> 2730</span> </div>
<div class="line"><span class="lineno"> 2731</span>                <span class="keyword">const</span> std::vector&lt;std::pair&lt;ed_t, fd_t&gt;&gt;&amp; m0_ivtx_to_intersection_registry_entry_FUTURE = std::get&lt;0&gt;(future_result);</div>
<div class="line"><span class="lineno"> 2732</span>                <span class="keyword">const</span> std::vector&lt;vd_t&gt;&amp; cm_border_reentrant_ivtx_list_FUTURE = std::get&lt;1&gt;(future_result);</div>
<div class="line"><span class="lineno"> 2733</span>                <span class="keyword">const</span> std::unordered_map&lt;ed_t, std::vector&lt;vd_t&gt;&gt;&amp; ps_intersecting_edges_FUTURE = std::get&lt;2&gt;(future_result);</div>
<div class="line"><span class="lineno"> 2734</span>                <span class="keyword">const</span> std::map&lt;pair&lt;fd_t&gt;, std::vector&lt;vd_t&gt;&gt;&amp; cutpath_edge_creation_info_FUTURE = std::get&lt;3&gt;(future_result);</div>
<div class="line"><span class="lineno"> 2735</span>                <span class="keyword">const</span> std::unordered_map&lt;fd_t, std::vector&lt;vd_t&gt;&gt;&amp; ps_iface_to_ivtx_list_FUTURE = std::get&lt;4&gt;(future_result);</div>
<div class="line"><span class="lineno"> 2736</span>                <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; partial_cut_detected_FUTURE = std::get&lt;5&gt;(future_result);</div>
<div class="line"><span class="lineno"> 2737</span>                <span class="keyword">const</span> std::vector&lt;vec3&gt;&amp; intersection_points_FUTURE = std::get&lt;6&gt;(future_result);</div>
<div class="line"><span class="lineno"> 2738</span>                <span class="keyword">const</span> <a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> intersection_points_in_future = (<a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>)intersection_points_FUTURE.size();</div>
<div class="line"><span class="lineno"> 2739</span> </div>
<div class="line"><span class="lineno"> 2740</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(intersection_points_FUTURE.size() == m0_ivtx_to_intersection_registry_entry_FUTURE.size());</div>
<div class="line"><span class="lineno"> 2741</span> </div>
<div class="line"><span class="lineno"> 2742</span>                <span class="comment">// add intersection point corresponding to the current future</span></div>
<div class="line"><span class="lineno"> 2743</span>                <span class="keywordflow">for</span> (std::vector&lt;vec3&gt;::const_iterator it = intersection_points_FUTURE.cbegin();</div>
<div class="line"><span class="lineno"> 2744</span>                     it != intersection_points_FUTURE.cend();</div>
<div class="line"><span class="lineno"> 2745</span>                     ++it) {</div>
<div class="line"><span class="lineno"> 2746</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> stored_descr = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a0d2a1a79406b7352af07d4fc56707782">add_vertex</a>(*it);</div>
<div class="line"><span class="lineno"> 2747</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(stored_descr != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ab448d0b9684fd2f648195b2e5edb83f2">hmesh_t::null_vertex</a>());</div>
<div class="line"><span class="lineno"> 2748</span>                }</div>
<div class="line"><span class="lineno"> 2749</span> </div>
<div class="line"><span class="lineno"> 2750</span>                <span class="comment">// merge m0_ivtx_to_intersection_registry_entry_FUTURE</span></div>
<div class="line"><span class="lineno"> 2751</span>                m0_ivtx_to_intersection_registry_entry.insert(</div>
<div class="line"><span class="lineno"> 2752</span>                    m0_ivtx_to_intersection_registry_entry.end(),</div>
<div class="line"><span class="lineno"> 2753</span>                    m0_ivtx_to_intersection_registry_entry_FUTURE.cbegin(),</div>
<div class="line"><span class="lineno"> 2754</span>                    m0_ivtx_to_intersection_registry_entry_FUTURE.cend());</div>
<div class="line"><span class="lineno"> 2755</span> </div>
<div class="line"><span class="lineno"> 2756</span>                <span class="comment">// merge cm_border_reentrant_ivtx_list_FUTURE</span></div>
<div class="line"><span class="lineno"> 2757</span>                <span class="keywordflow">for</span> (std::vector&lt;vd_t&gt;::const_iterator it = cm_border_reentrant_ivtx_list_FUTURE.cbegin();</div>
<div class="line"><span class="lineno"> 2758</span>                     it != cm_border_reentrant_ivtx_list_FUTURE.cend();</div>
<div class="line"><span class="lineno"> 2759</span>                     ++it) {</div>
<div class="line"><span class="lineno"> 2760</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> rel_descr = (*it);</div>
<div class="line"><span class="lineno"> 2761</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> actual_descr = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a>(intersection_point_descr_baseoffset + rel_descr);</div>
<div class="line"><span class="lineno"> 2762</span>                    cm_border_reentrant_ivtx_list.push_back(actual_descr);</div>
<div class="line"><span class="lineno"> 2763</span>                }</div>
<div class="line"><span class="lineno"> 2764</span> </div>
<div class="line"><span class="lineno"> 2765</span>                <span class="comment">// merge ps_intersecting_edges_FUTURE</span></div>
<div class="line"><span class="lineno"> 2766</span>                <span class="keywordflow">for</span> (std::unordered_map&lt;<a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>, std::vector&lt;vd_t&gt;&gt;::const_iterator i = ps_intersecting_edges_FUTURE.cbegin();</div>
<div class="line"><span class="lineno"> 2767</span>                     i != ps_intersecting_edges_FUTURE.cend();</div>
<div class="line"><span class="lineno"> 2768</span>                     ++i) {</div>
<div class="line"><span class="lineno"> 2769</span>                    std::unordered_map&lt;ed_t, std::vector&lt;vd_t&gt;&gt;::iterator fiter = ps_intersecting_edges.find(i-&gt;first);</div>
<div class="line"><span class="lineno"> 2770</span>                    <span class="keywordtype">bool</span> collision = (fiter != ps_intersecting_edges.end());</div>
<div class="line"><span class="lineno"> 2771</span>                    <span class="keywordflow">if</span> (collision) { <span class="comment">// another thread also encounter the same edge</span></div>
<div class="line"><span class="lineno"> 2772</span>                        <span class="keywordflow">for</span> (std::vector&lt;vd_t&gt;::const_iterator j = i-&gt;second.cbegin(); j != i-&gt;second.cend(); ++j) {</div>
<div class="line"><span class="lineno"> 2773</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> rel_descr = (*j);</div>
<div class="line"><span class="lineno"> 2774</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> actual_descr = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a>(intersection_point_descr_baseoffset + rel_descr);</div>
<div class="line"><span class="lineno"> 2775</span>                            <span class="keywordflow">if</span> (std::find(fiter-&gt;second.cbegin(), fiter-&gt;second.cend(), *j) == fiter-&gt;second.cend()) {</div>
<div class="line"><span class="lineno"> 2776</span>                                fiter-&gt;second.push_back(actual_descr);</div>
<div class="line"><span class="lineno"> 2777</span>                            }</div>
<div class="line"><span class="lineno"> 2778</span>                        }</div>
<div class="line"><span class="lineno"> 2779</span>                    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 2780</span>                        <span class="comment">// just insert and account for offset</span></div>
<div class="line"><span class="lineno"> 2781</span>                        <span class="keywordflow">for</span> (std::vector&lt;vd_t&gt;::const_iterator j = i-&gt;second.cbegin(); j != i-&gt;second.cend(); ++j) {</div>
<div class="line"><span class="lineno"> 2782</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> rel_descr = (*j);</div>
<div class="line"><span class="lineno"> 2783</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> actual_descr = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a>(intersection_point_descr_baseoffset + rel_descr);</div>
<div class="line"><span class="lineno"> 2784</span>                            ps_intersecting_edges[i-&gt;first].push_back(actual_descr);</div>
<div class="line"><span class="lineno"> 2785</span>                        }</div>
<div class="line"><span class="lineno"> 2786</span>                    }</div>
<div class="line"><span class="lineno"> 2787</span>                }</div>
<div class="line"><span class="lineno"> 2788</span> </div>
<div class="line"><span class="lineno"> 2789</span>                <span class="comment">// merge cutpath_edge_creation_info_FUTURE</span></div>
<div class="line"><span class="lineno"> 2790</span>                <span class="keywordflow">for</span> (std::map&lt;<a class="code hl_struct" href="../../df/de8/structpair.html">pair&lt;fd_t&gt;</a>, std::vector&lt;vd_t&gt;&gt;::const_iterator i = cutpath_edge_creation_info_FUTURE.cbegin();</div>
<div class="line"><span class="lineno"> 2791</span>                     i != cutpath_edge_creation_info_FUTURE.cend();</div>
<div class="line"><span class="lineno"> 2792</span>                     ++i) {</div>
<div class="line"><span class="lineno"> 2793</span>                    std::map&lt;pair&lt;fd_t&gt;, std::vector&lt;vd_t&gt;&gt;::iterator fiter = cutpath_edge_creation_info.find(i-&gt;first);</div>
<div class="line"><span class="lineno"> 2794</span>                    <span class="keywordtype">bool</span> collision = (fiter != cutpath_edge_creation_info.end());</div>
<div class="line"><span class="lineno"> 2795</span>                    <span class="keywordflow">if</span> (collision) { <span class="comment">// another thread also encounter the same key</span></div>
<div class="line"><span class="lineno"> 2796</span>                        <span class="keywordflow">for</span> (std::vector&lt;vd_t&gt;::const_iterator j = i-&gt;second.cbegin(); j != i-&gt;second.cend(); ++j) {</div>
<div class="line"><span class="lineno"> 2797</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> rel_descr = (*j);</div>
<div class="line"><span class="lineno"> 2798</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> actual_descr = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a>(intersection_point_descr_baseoffset + rel_descr);</div>
<div class="line"><span class="lineno"> 2799</span>                            <span class="keywordflow">if</span> (std::find(fiter-&gt;second.cbegin(), fiter-&gt;second.cend(), actual_descr) == fiter-&gt;second.cend()) {</div>
<div class="line"><span class="lineno"> 2800</span>                                fiter-&gt;second.push_back(actual_descr);</div>
<div class="line"><span class="lineno"> 2801</span>                            }</div>
<div class="line"><span class="lineno"> 2802</span>                        }</div>
<div class="line"><span class="lineno"> 2803</span>                    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 2804</span>                        <span class="comment">// just insert and account for offset</span></div>
<div class="line"><span class="lineno"> 2805</span>                        <span class="keywordflow">for</span> (std::vector&lt;vd_t&gt;::const_iterator j = i-&gt;second.cbegin(); j != i-&gt;second.cend(); ++j) {</div>
<div class="line"><span class="lineno"> 2806</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> rel_descr = (*j);</div>
<div class="line"><span class="lineno"> 2807</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> actual_descr = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a>(intersection_point_descr_baseoffset + rel_descr);</div>
<div class="line"><span class="lineno"> 2808</span>                            cutpath_edge_creation_info[i-&gt;first].push_back(actual_descr);</div>
<div class="line"><span class="lineno"> 2809</span>                        }</div>
<div class="line"><span class="lineno"> 2810</span>                    }</div>
<div class="line"><span class="lineno"> 2811</span>                }</div>
<div class="line"><span class="lineno"> 2812</span> </div>
<div class="line"><span class="lineno"> 2813</span>                <span class="comment">// merge ps_iface_to_ivtx_list_FUTURE</span></div>
<div class="line"><span class="lineno"> 2814</span>                <span class="keywordflow">for</span> (std::unordered_map&lt;<a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a>, std::vector&lt;vd_t&gt;&gt;::const_iterator i = ps_iface_to_ivtx_list_FUTURE.cbegin();</div>
<div class="line"><span class="lineno"> 2815</span>                     i != ps_iface_to_ivtx_list_FUTURE.cend();</div>
<div class="line"><span class="lineno"> 2816</span>                     ++i) {</div>
<div class="line"><span class="lineno"> 2817</span>                    std::unordered_map&lt;fd_t, std::vector&lt;vd_t&gt;&gt;::iterator fiter = ps_iface_to_ivtx_list.find(i-&gt;first);</div>
<div class="line"><span class="lineno"> 2818</span>                    <span class="keywordtype">bool</span> collision = (fiter != ps_iface_to_ivtx_list.end());</div>
<div class="line"><span class="lineno"> 2819</span>                    <span class="keywordflow">if</span> (collision) { <span class="comment">// another thread also encounter the same face</span></div>
<div class="line"><span class="lineno"> 2820</span>                        <span class="keywordflow">for</span> (std::vector&lt;vd_t&gt;::const_iterator j = i-&gt;second.cbegin(); j != i-&gt;second.cend(); ++j) {</div>
<div class="line"><span class="lineno"> 2821</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> rel_descr = (*j);</div>
<div class="line"><span class="lineno"> 2822</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> actual_descr = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a>(intersection_point_descr_baseoffset + rel_descr);</div>
<div class="line"><span class="lineno"> 2823</span>                            <span class="keywordflow">if</span> (std::find(fiter-&gt;second.cbegin(), fiter-&gt;second.cend(), actual_descr) == fiter-&gt;second.cend()) {</div>
<div class="line"><span class="lineno"> 2824</span>                                fiter-&gt;second.push_back(actual_descr);</div>
<div class="line"><span class="lineno"> 2825</span>                            }</div>
<div class="line"><span class="lineno"> 2826</span>                        }</div>
<div class="line"><span class="lineno"> 2827</span>                    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 2828</span>                        <span class="comment">// just insert and account for offset</span></div>
<div class="line"><span class="lineno"> 2829</span>                        <span class="keywordflow">for</span> (std::vector&lt;vd_t&gt;::const_iterator j = i-&gt;second.cbegin(); j != i-&gt;second.cend(); ++j) {</div>
<div class="line"><span class="lineno"> 2830</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> rel_descr = (*j);</div>
<div class="line"><span class="lineno"> 2831</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> actual_descr = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a>(intersection_point_descr_baseoffset + rel_descr);</div>
<div class="line"><span class="lineno"> 2832</span>                            ps_iface_to_ivtx_list[i-&gt;first].push_back(actual_descr);</div>
<div class="line"><span class="lineno"> 2833</span>                        }</div>
<div class="line"><span class="lineno"> 2834</span>                    }</div>
<div class="line"><span class="lineno"> 2835</span>                }</div>
<div class="line"><span class="lineno"> 2836</span> </div>
<div class="line"><span class="lineno"> 2837</span>                <span class="comment">// merge (i.e. boolean-wise OR) partial_cut_detected_FUTURE</span></div>
<div class="line"><span class="lineno"> 2838</span>                partial_cut_detected = (partial_cut_detected || partial_cut_detected_FUTURE) ? <span class="keyword">true</span> : false;</div>
<div class="line"><span class="lineno"> 2839</span> </div>
<div class="line"><span class="lineno"> 2840</span>                <span class="comment">// shift to account for the (number of) intersection points computed in the current future</span></div>
<div class="line"><span class="lineno"> 2841</span>                intersection_point_descr_baseoffset += intersection_points_in_future;</div>
<div class="line"><span class="lineno"> 2842</span>            } <span class="comment">// while(!futures.empty()) {</span></div>
<div class="line"><span class="lineno"> 2843</span>        } <span class="comment">// if(num_blocks &gt; 1)</span></div>
<div class="line"><span class="lineno"> 2844</span> </div>
<div class="line"><span class="lineno"> 2845</span>        <span class="keywordflow">if</span> (!status_is_okay) {</div>
<div class="line"><span class="lineno"> 2846</span>            <span class="comment">// Safely return to the front-end since all jobs are now successively finished/cancelled.</span></div>
<div class="line"><span class="lineno"> 2847</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 2848</span>            <span class="comment">// CAUTION: if the master thread returns before all current jobs are done (e.g.</span></div>
<div class="line"><span class="lineno"> 2849</span>            <span class="comment">// successively cancelled) the worker threads would end up accessing dangling</span></div>
<div class="line"><span class="lineno"> 2850</span>            <span class="comment">// references to e.g. variables like &quot;ps&quot;, &quot;m0&quot;, etc.</span></div>
<div class="line"><span class="lineno"> 2851</span>            <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno"> 2852</span>        }</div>
<div class="line"><span class="lineno"> 2853</span>    } <span class="comment">// end of parallel execution scope</span></div>
<div class="line"><span class="lineno"> 2854</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno"> 2855</span>    <span class="keywordflow">for</span> (std::unordered_map&lt;<a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>, std::vector&lt;fd_t&gt;&gt;::const_iterator ps_edge_face_intersection_pairs_iter = ps_edge_face_intersection_pairs.cbegin();</div>
<div class="line"><span class="lineno"> 2856</span>         ps_edge_face_intersection_pairs_iter != ps_edge_face_intersection_pairs.cend();</div>
<div class="line"><span class="lineno"> 2857</span>         ps_edge_face_intersection_pairs_iter++) {</div>
<div class="line"><span class="lineno"> 2858</span> </div>
<div class="line"><span class="lineno"> 2859</span>        <span class="comment">// our edge that we test for intersection with other faces</span></div>
<div class="line"><span class="lineno"> 2860</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> tested_edge = ps_edge_face_intersection_pairs_iter-&gt;first;</div>
<div class="line"><span class="lineno"> 2861</span>        <span class="comment">// the faces against which the edge is tested for intersection</span></div>
<div class="line"><span class="lineno"> 2862</span>        <span class="keyword">const</span> std::vector&lt;fd_t&gt;&amp; tested_faces = ps_edge_face_intersection_pairs_iter-&gt;second;</div>
<div class="line"><span class="lineno"> 2863</span> </div>
<div class="line"><span class="lineno"> 2864</span>        <span class="comment">// the halfedges of our edge</span></div>
<div class="line"><span class="lineno"> 2865</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> tested_edge_h0 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(tested_edge, 0);</div>
<div class="line"><span class="lineno"> 2866</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> tested_edge_h1 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(tested_edge, 1);</div>
<div class="line"><span class="lineno"> 2867</span> </div>
<div class="line"><span class="lineno"> 2868</span>        <span class="comment">// source vertex</span></div>
<div class="line"><span class="lineno"> 2869</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vertex_descriptor_t</a> tested_edge_h0_source_descr = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(tested_edge_h0);</div>
<div class="line"><span class="lineno"> 2870</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a>&amp; tested_edge_h0_source_vertex = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(tested_edge_h0_source_descr);</div>
<div class="line"><span class="lineno"> 2871</span>        <span class="comment">// target vertex</span></div>
<div class="line"><span class="lineno"> 2872</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vertex_descriptor_t</a> tested_edge_h0_target_descr = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(tested_edge_h0);</div>
<div class="line"><span class="lineno"> 2873</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a>&amp; tested_edge_h0_target_vertex = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(tested_edge_h0_target_descr);</div>
<div class="line"><span class="lineno"> 2874</span> </div>
<div class="line"><span class="lineno"> 2875</span>        <span class="comment">// This boolean var is evaluated based on the fact that sm faces come before cm faces inside the &quot;ps&quot; data structure</span></div>
<div class="line"><span class="lineno"> 2876</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> tested_edge_h0_face = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(tested_edge_h0);</div>
<div class="line"><span class="lineno"> 2877</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> tested_edge_h1_face = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(tested_edge_h1);</div>
<div class="line"><span class="lineno"> 2878</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> tested_edge_face = tested_edge_h0_face != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>() ? tested_edge_h0_face : tested_edge_h1_face;</div>
<div class="line"><span class="lineno"> 2879</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> tested_edge_belongs_to_cm = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aaf65fb11520f9cb197774e79efeddfbb">ps_is_cutmesh_face</a>(tested_edge_face, sm_face_count);</div>
<div class="line"><span class="lineno"> 2880</span> </div>
<div class="line"><span class="lineno"> 2881</span>        <span class="comment">// for each face that is to be intersected with the tested-edge</span></div>
<div class="line"><span class="lineno"> 2882</span>        <span class="keywordflow">for</span> (std::vector&lt;fd_t&gt;::const_iterator tested_faces_iter = tested_faces.cbegin();</div>
<div class="line"><span class="lineno"> 2883</span>             tested_faces_iter != tested_faces.cend();</div>
<div class="line"><span class="lineno"> 2884</span>             ++tested_faces_iter) {</div>
<div class="line"><span class="lineno"> 2885</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> tested_face = *tested_faces_iter;</div>
<div class="line"><span class="lineno"> 2886</span> </div>
<div class="line"><span class="lineno"> 2887</span>            <span class="comment">// We are now finding the intersection points determined by calculating the location</span></div>
<div class="line"><span class="lineno"> 2888</span>            <span class="comment">// where each halfedge of face A intersects the area defined by face B (if it exists).</span></div>
<div class="line"><span class="lineno"> 2889</span> </div>
<div class="line"><span class="lineno"> 2890</span>            <span class="comment">// get the vertices of tested_face (used to estimate its normal etc.)</span></div>
<div class="line"><span class="lineno"> 2891</span>            <span class="comment">// std::vector&lt;vd_t&gt; tested_face_descriptors = ps.get_vertices_around_face(tested_face);</span></div>
<div class="line"><span class="lineno"> 2892</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ps_tested_face_to_vertices.find(tested_face) != ps_tested_face_to_vertices.end());</div>
<div class="line"><span class="lineno"> 2893</span>            <span class="keyword">const</span> std::vector&lt;vec3&gt;&amp; tested_face_vertices = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_tested_face_to_vertices, tested_face);</div>
<div class="line"><span class="lineno"> 2894</span> </div>
<div class="line"><span class="lineno"> 2895</span>            <span class="comment">// compute plane of tested_face</span></div>
<div class="line"><span class="lineno"> 2896</span>            <span class="comment">// -----------------------</span></div>
<div class="line"><span class="lineno"> 2897</span> </div>
<div class="line"><span class="lineno"> 2898</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ps_tested_face_to_plane_normal.find(tested_face) != ps_tested_face_to_plane_normal.end());</div>
<div class="line"><span class="lineno"> 2899</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a>&amp; tested_face_plane_normal = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_tested_face_to_plane_normal, tested_face);</div>
<div class="line"><span class="lineno"> 2900</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ps_tested_face_to_plane_normal_d_param.find(tested_face) != ps_tested_face_to_plane_normal_d_param.end());</div>
<div class="line"><span class="lineno"> 2901</span>            <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; tested_face_plane_param_d = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_tested_face_to_plane_normal_d_param, tested_face);</div>
<div class="line"><span class="lineno"> 2902</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ps_tested_face_to_plane_normal_max_comp.find(tested_face) != ps_tested_face_to_plane_normal_max_comp.end());</div>
<div class="line"><span class="lineno"> 2903</span>            <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; tested_face_plane_normal_max_comp = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_tested_face_to_plane_normal_max_comp, tested_face);</div>
<div class="line"><span class="lineno"> 2904</span> </div>
<div class="line"><span class="lineno"> 2905</span>            <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a> intersection_point(0., 0., 0.); <span class="comment">// the intersection po int to be computed</span></div>
<div class="line"><span class="lineno"> 2906</span> </div>
<div class="line"><span class="lineno"> 2907</span>            <span class="comment">// TODO: replace this with shewchuck predicate (nasty failure on test 42)</span></div>
<div class="line"><span class="lineno"> 2908</span>            <span class="comment">// at least orient3d will be able to give use the corrent result!</span></div>
<div class="line"><span class="lineno"> 2909</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 2910</span>            <span class="keywordtype">char</span> lp_intersection_result = <a class="code hl_function" href="../../df/db1/math_8h.html#a54f69876b05b83a7096e4bac9d0c3b13">compute_line_plane_intersection</a>(</div>
<div class="line"><span class="lineno"> 2911</span>                intersection_point,</div>
<div class="line"><span class="lineno"> 2912</span>                tested_edge_h0_source_vertex,</div>
<div class="line"><span class="lineno"> 2913</span>                tested_edge_h0_target_vertex,</div>
<div class="line"><span class="lineno"> 2914</span>                tested_face_vertices.data(),</div>
<div class="line"><span class="lineno"> 2915</span>                tested_face_vertices.size(),</div>
<div class="line"><span class="lineno"> 2916</span>                tested_face_plane_normal_max_comp,</div>
<div class="line"><span class="lineno"> 2917</span>                tested_face_plane_normal,</div>
<div class="line"><span class="lineno"> 2918</span>                tested_face_plane_param_d);</div>
<div class="line"><span class="lineno"> 2919</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno"> 2920</span>            <span class="keywordtype">char</span> segment_intersection_type = <a class="code hl_function" href="../../df/db1/math_8h.html#a2253a03334d0c9681225281db5a96928">compute_segment_plane_intersection_type</a>( <span class="comment">// exact**</span></div>
<div class="line"><span class="lineno"> 2921</span>                tested_edge_h0_source_vertex,</div>
<div class="line"><span class="lineno"> 2922</span>                tested_edge_h0_target_vertex,</div>
<div class="line"><span class="lineno"> 2923</span>                tested_face_vertices,</div>
<div class="line"><span class="lineno"> 2924</span>                tested_face_plane_normal,</div>
<div class="line"><span class="lineno"> 2925</span>                tested_face_plane_normal_max_comp);</div>
<div class="line"><span class="lineno"> 2926</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 2927</span>            <span class="keywordtype">bool</span> have_plane_intersection = (segment_intersection_type != <span class="charliteral">&#39;0&#39;</span>); <span class="comment">// any intersection !</span></div>
<div class="line"><span class="lineno"> 2928</span> </div>
<div class="line"><span class="lineno"> 2929</span>            <span class="keywordflow">if</span> (have_plane_intersection) { <span class="comment">// does the segment intersect the plane?</span></div>
<div class="line"><span class="lineno"> 2930</span> </div>
<div class="line"><span class="lineno"> 2931</span>                <span class="keywordflow">if</span> (segment_intersection_type != <span class="charliteral">&#39;1&#39;</span>) { <span class="comment">// the segment only touches the the plane (the line reprsented by segment still intersects the plane)</span></div>
<div class="line"><span class="lineno"> 2932</span> </div>
<div class="line"><span class="lineno"> 2933</span>                    <span class="comment">// before jumping-the-gun and assuming that we have indeed violated GP,</span></div>
<div class="line"><span class="lineno"> 2934</span>                    <span class="comment">// we should check whether the point found to be on the plane (touching point) is</span></div>
<div class="line"><span class="lineno"> 2935</span>                    <span class="comment">// actually [inside] the tested_face. That would imply cutting through a vertex or edge (which is undefined).</span></div>
<div class="line"><span class="lineno"> 2936</span>                    <span class="comment">// If this is true then we have indeed violated GP. Otherwise, we just treat this as a non-intersection because</span></div>
<div class="line"><span class="lineno"> 2937</span>                    <span class="comment">// the what-would-have-been intersection point actually lies outside the tested_face.</span></div>
<div class="line"><span class="lineno"> 2938</span>                    <span class="keywordtype">bool</span> violatedGP = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 2939</span>                    std::vector&lt;const vec3*&gt; points_touching_plane;</div>
<div class="line"><span class="lineno"> 2940</span> </div>
<div class="line"><span class="lineno"> 2941</span>                    <span class="keywordflow">if</span> (segment_intersection_type == <span class="charliteral">&#39;q&#39;</span> <span class="comment">/*segment start*/</span> || segment_intersection_type == <span class="charliteral">&#39;r&#39;</span> <span class="comment">/*segment end*/</span>) { <span class="comment">// only one segment end is touching plane</span></div>
<div class="line"><span class="lineno"> 2942</span>                        points_touching_plane.push_back((segment_intersection_type == <span class="charliteral">&#39;q&#39;</span>) ? &amp;tested_edge_h0_source_vertex : &amp;tested_edge_h0_target_vertex);</div>
<div class="line"><span class="lineno"> 2943</span>                    } <span class="keywordflow">else</span> { <span class="comment">// both point are in the plane, so we will need to confirm whether BOTH are outside our tested face.</span></div>
<div class="line"><span class="lineno"> 2944</span>                        points_touching_plane.push_back(&amp;tested_edge_h0_source_vertex);</div>
<div class="line"><span class="lineno"> 2945</span>                        points_touching_plane.push_back(&amp;tested_edge_h0_target_vertex);</div>
<div class="line"><span class="lineno"> 2946</span>                    }</div>
<div class="line"><span class="lineno"> 2947</span> </div>
<div class="line"><span class="lineno"> 2948</span>                    <span class="comment">// if any point in &quot;points_touching_plane&quot; is inside the tested_face then we have violated GP</span></div>
<div class="line"><span class="lineno"> 2949</span>                    <span class="keywordflow">for</span> (std::vector&lt;const vec3*&gt;::const_iterator i = points_touching_plane.cbegin(); i != points_touching_plane.cend(); ++i) {</div>
<div class="line"><span class="lineno"> 2950</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a>&amp; point = (*(*i));</div>
<div class="line"><span class="lineno"> 2951</span>                        <span class="keywordtype">char</span> result = <a class="code hl_function" href="../../df/db1/math_8h.html#a82a9c1f090b54dc1416ca1c3673ef5d7">compute_point_in_polygon_test</a>(</div>
<div class="line"><span class="lineno"> 2952</span>                            point,</div>
<div class="line"><span class="lineno"> 2953</span>                            tested_face_vertices,</div>
<div class="line"><span class="lineno"> 2954</span>                            tested_face_plane_normal,</div>
<div class="line"><span class="lineno"> 2955</span>                            tested_face_plane_normal_max_comp);</div>
<div class="line"><span class="lineno"> 2956</span>                        <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 2957</span>                            <span class="comment">// the touching point is inside, which implies cutting through a vertex (of &quot;tested_edge&quot;)</span></div>
<div class="line"><span class="lineno"> 2958</span>                            result == <span class="charliteral">&#39;i&#39;</span> ||</div>
<div class="line"><span class="lineno"> 2959</span>                            <span class="comment">// The following condition means that we will have an edge-edge intersection anyway!</span></div>
<div class="line"><span class="lineno"> 2960</span>                            <span class="comment">// i.e. &#39;v&#39; means that two edges (from sm and cm) touch at their tips/points since point is an end point of &quot;tested_edge&quot;</span></div>
<div class="line"><span class="lineno"> 2961</span>                            <span class="comment">// ... and &#39;e&#39; means that an end point of &quot;tested_edge&quot; touches an edge of &quot;tested_face&quot;</span></div>
<div class="line"><span class="lineno"> 2962</span>                            (result == <span class="charliteral">&#39;v&#39;</span> || result == <span class="charliteral">&#39;e&#39;</span>)) {</div>
<div class="line"><span class="lineno"> 2963</span>                            violatedGP = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 2964</span>                            <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 2965</span>                        }</div>
<div class="line"><span class="lineno"> 2966</span>                    }</div>
<div class="line"><span class="lineno"> 2967</span> </div>
<div class="line"><span class="lineno"> 2968</span>                    <span class="keywordflow">if</span> (violatedGP) {</div>
<div class="line"><span class="lineno"> 2969</span>                        output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a7d4c902daa6f0439e388496967885dd9">status</a> = <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a91712b49b91fbf59087df24104715e29">status_t::GENERAL_POSITION_VIOLATION</a>;</div>
<div class="line"><span class="lineno"> 2970</span>                        <span class="keywordflow">if</span> (!input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a5793da463db7c7b18aab5817d243c875">enforce_general_position</a>) {</div>
<div class="line"><span class="lineno"> 2971</span>                            <span class="comment">// Our assumption of having inputs in general position has been violated, we need to terminate</span></div>
<div class="line"><span class="lineno"> 2972</span>                            <span class="comment">// with an error since perturbation (enforcement of general positions) is disabled by the user.</span></div>
<div class="line"><span class="lineno"> 2973</span>                            <span class="comment">// Note: our intersection registry formulation requires that edges completely penetrate/intersect through polygon&#39;s area.</span></div>
<div class="line"><span class="lineno"> 2974</span>                            lg.<a class="code hl_function" href="../../d8/d0d/classlogger__t.html#aecaed21510eca7fa095e7176d9e36850">set_reason_for_failure</a>(<span class="stringliteral">&quot;invalid compute_segment_plane_intersection_type result (&#39;&quot;</span> + std::to_string(segment_intersection_type) + <span class="stringliteral">&quot;&#39;)&quot;</span>);</div>
<div class="line"><span class="lineno"> 2975</span>                        }</div>
<div class="line"><span class="lineno"> 2976</span>                        <span class="keywordflow">return</span>; <span class="comment">// bail and return to the front-end</span></div>
<div class="line"><span class="lineno"> 2977</span>                    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 2978</span>                        <span class="comment">// same as the case where &quot;have_plane_intersection&quot; is false.</span></div>
<div class="line"><span class="lineno"> 2979</span>                        <span class="comment">// so we just move onto the next edge-face test.</span></div>
<div class="line"><span class="lineno"> 2980</span>                        <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 2981</span>                    }</div>
<div class="line"><span class="lineno"> 2982</span>                }</div>
<div class="line"><span class="lineno"> 2983</span> </div>
<div class="line"><span class="lineno"> 2984</span>                <span class="comment">// at this point, we have established that the segment actually intersects the plane [properly]</span></div>
<div class="line"><span class="lineno"> 2985</span> </div>
<div class="line"><span class="lineno"> 2986</span>                <span class="comment">// ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</span></div>
<div class="line"><span class="lineno"> 2987</span>                <span class="comment">// Now we compute the [actual] intersection point (coordinates)</span></div>
<div class="line"><span class="lineno"> 2988</span>                <span class="comment">// and check whether it lies inside our polygon, or that GP has been violated,</span></div>
<div class="line"><span class="lineno"> 2989</span>                <span class="comment">// which happens if e.g. the intersection point lies on an edge/vertex of &quot;tested_face&quot;)</span></div>
<div class="line"><span class="lineno"> 2990</span> </div>
<div class="line"><span class="lineno"> 2991</span>                <span class="comment">// NOTE: if using fixed precision floats (i.e. double), then here we just care about getting the intersection point</span></div>
<div class="line"><span class="lineno"> 2992</span>                <span class="comment">// irrespective of whether &quot;segment_intersection_result&quot; is consistent with &quot;segment_intersection_type&quot; from above.</span></div>
<div class="line"><span class="lineno"> 2993</span>                <span class="comment">// The inconsistency can happen during edge cases. see e.g. test 42.</span></div>
<div class="line"><span class="lineno"> 2994</span>                <a class="code hl_function" href="../../df/db1/math_8h.html#a35c50f5df223f546dec9cd74983abc38">compute_segment_plane_intersection</a>(</div>
<div class="line"><span class="lineno"> 2995</span>                    intersection_point,</div>
<div class="line"><span class="lineno"> 2996</span>                    tested_face_plane_normal,</div>
<div class="line"><span class="lineno"> 2997</span>                    tested_face_plane_param_d,</div>
<div class="line"><span class="lineno"> 2998</span>                    tested_edge_h0_source_vertex,</div>
<div class="line"><span class="lineno"> 2999</span>                    tested_edge_h0_target_vertex);</div>
<div class="line"><span class="lineno"> 3000</span> </div>
<div class="line"><span class="lineno"> 3001</span>                <span class="comment">// is our intersection point in the polygon?</span></div>
<div class="line"><span class="lineno"> 3002</span>                <span class="keywordtype">char</span> in_poly_test_intersection_type = <a class="code hl_function" href="../../df/db1/math_8h.html#a82a9c1f090b54dc1416ca1c3673ef5d7">compute_point_in_polygon_test</a>(</div>
<div class="line"><span class="lineno"> 3003</span>                    intersection_point,</div>
<div class="line"><span class="lineno"> 3004</span>                    tested_face_vertices,</div>
<div class="line"><span class="lineno"> 3005</span>                    tested_face_plane_normal,</div>
<div class="line"><span class="lineno"> 3006</span>                    tested_face_plane_normal_max_comp);</div>
<div class="line"><span class="lineno"> 3007</span> </div>
<div class="line"><span class="lineno"> 3008</span>                <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 3009</span>                    <span class="comment">// illegal on-edge and on-vertex intersections</span></div>
<div class="line"><span class="lineno"> 3010</span>                    (in_poly_test_intersection_type == <span class="charliteral">&#39;v&#39;</span> || in_poly_test_intersection_type == <span class="charliteral">&#39;e&#39;</span>)) {</div>
<div class="line"><span class="lineno"> 3011</span>                    output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a7d4c902daa6f0439e388496967885dd9">status</a> = <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a91712b49b91fbf59087df24104715e29">status_t::GENERAL_POSITION_VIOLATION</a>;</div>
<div class="line"><span class="lineno"> 3012</span>                    <span class="keywordflow">if</span> (!input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a5793da463db7c7b18aab5817d243c875">enforce_general_position</a>) {</div>
<div class="line"><span class="lineno"> 3013</span>                        <span class="comment">// Our assuption of having inputs in general position has been violated, we need to terminate</span></div>
<div class="line"><span class="lineno"> 3014</span>                        <span class="comment">// with an error since perturbation (enforment of general positions) is disabled.</span></div>
<div class="line"><span class="lineno"> 3015</span>                        lg.<a class="code hl_function" href="../../d8/d0d/classlogger__t.html#aecaed21510eca7fa095e7176d9e36850">set_reason_for_failure</a>(<span class="stringliteral">&quot;invalid point-in-polygon test result (&#39;&quot;</span> + std::to_string(in_poly_test_intersection_type) + <span class="stringliteral">&quot;&#39;)&quot;</span>);</div>
<div class="line"><span class="lineno"> 3016</span>                    }</div>
<div class="line"><span class="lineno"> 3017</span>                    <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno"> 3018</span>                }</div>
<div class="line"><span class="lineno"> 3019</span> </div>
<div class="line"><span class="lineno"> 3020</span>                <span class="keywordtype">bool</span> have_point_in_polygon = in_poly_test_intersection_type == <span class="charliteral">&#39;i&#39;</span>;</div>
<div class="line"><span class="lineno"> 3021</span> </div>
<div class="line"><span class="lineno"> 3022</span>                <span class="keywordflow">if</span> (have_point_in_polygon) { <span class="comment">// NOTE: point must be [inside] the polygon for us to consider it further</span></div>
<div class="line"><span class="lineno"> 3023</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 3024</span>                    <span class="comment">// Intersection point is now determined to be in side face-B (our polygon), now we must use the information</span></div>
<div class="line"><span class="lineno"> 3025</span>                    <span class="comment">// we computed from the segment-plane intersection test Check source-mesh for defectsto find out if general position has been violated (i.e.</span></div>
<div class="line"><span class="lineno"> 3026</span>                    <span class="comment">// invalid case of cutting through a vertex)</span></div>
<div class="line"><span class="lineno"> 3027</span>                    <span class="keywordflow">if</span> (segment_intersection_type == <span class="charliteral">&#39;p&#39;</span> || segment_intersection_type == <span class="charliteral">&#39;q&#39;</span> || segment_intersection_type == <span class="charliteral">&#39;r&#39;</span>) {</div>
<div class="line"><span class="lineno"> 3028</span> </div>
<div class="line"><span class="lineno"> 3029</span>                        output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a7d4c902daa6f0439e388496967885dd9">status</a> = <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a91712b49b91fbf59087df24104715e29">status_t::GENERAL_POSITION_VIOLATION</a>;</div>
<div class="line"><span class="lineno"> 3030</span> </div>
<div class="line"><span class="lineno"> 3031</span>                        <span class="keywordflow">if</span> (!input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a5793da463db7c7b18aab5817d243c875">enforce_general_position</a>) {</div>
<div class="line"><span class="lineno"> 3032</span>                            <span class="comment">// Our assumption of having inputs in general position has been violated, we need to terminate</span></div>
<div class="line"><span class="lineno"> 3033</span>                            <span class="comment">// with an error since perturbation (i.e. enforcement of general positions) is disabled.</span></div>
<div class="line"><span class="lineno"> 3034</span>                            <span class="comment">// If any one of a segment&#39;s vertices only touch (i.e. lie on) the plane</span></div>
<div class="line"><span class="lineno"> 3035</span>                            <span class="comment">// then that implies a situation of cutting through a vertex which is undefined.</span></div>
<div class="line"><span class="lineno"> 3036</span>                            lg.<a class="code hl_function" href="../../d8/d0d/classlogger__t.html#aecaed21510eca7fa095e7176d9e36850">set_reason_for_failure</a>(<span class="stringliteral">&quot;segment-plane intersection (&#39;&quot;</span> + std::to_string(segment_intersection_type) + <span class="stringliteral">&quot;&#39;)&quot;</span>);</div>
<div class="line"><span class="lineno"> 3037</span>                        }</div>
<div class="line"><span class="lineno"> 3038</span>                        <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno"> 3039</span>                    }</div>
<div class="line"><span class="lineno"> 3040</span>                    <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> pre_existing_copy = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ab448d0b9684fd2f648195b2e5edb83f2">hmesh_t::null_vertex</a>(); <span class="comment">// set to correct value if intersection has already been computed</span></div>
<div class="line"><span class="lineno"> 3041</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 3042</span>                                             <span class="comment">// The naming convention of these variables is based on Sifakis et al. 2007</span></div>
<div class="line"><span class="lineno"> 3043</span>                    <span class="comment">// hd_t halfedge_pq = tested_edge_h0; // the halfedge which is intersected with polygon</span></div>
<div class="line"><span class="lineno"> 3044</span>                    <span class="comment">// hd_t halfedge_pq_opp = tested_edge_h1; // ps.opposite(halfedge_pq);</span></div>
<div class="line"><span class="lineno"> 3045</span>                    <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> face_pqr = tested_edge_face; <span class="comment">// the face which is incident to halfedge-pq</span></div>
<div class="line"><span class="lineno"> 3046</span>                    <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> face_xyz = tested_face; <span class="comment">// the face which is intersected with halfedge-pq</span></div>
<div class="line"><span class="lineno"> 3047</span>                    <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> face_pqs = tested_edge_face == tested_edge_h0_face ? tested_edge_h1_face : <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>(); <span class="comment">// ps.face(halfedge_pq_opp); // the face which is incident to the halfedge opposite to halfedge-pq</span></div>
<div class="line"><span class="lineno"> 3048</span>                                                                                                                          <span class="comment">// fd_t face_pqX = hmesh_t::null_face(); // a virtual face pqX (where X denotes an unspecified auxiliary point)</span></div>
<div class="line"><span class="lineno"> 3049</span> </div>
<div class="line"><span class="lineno"> 3050</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 3051</span>                    <span class="comment">// add vertex if it does not exist.</span></div>
<div class="line"><span class="lineno"> 3052</span>                    <span class="comment">// --------------------------------</span></div>
<div class="line"><span class="lineno"> 3053</span> </div>
<div class="line"><span class="lineno"> 3054</span>                   </div>
<div class="line"><span class="lineno"> 3055</span>                    <span class="keyword">const</span> <span class="keywordtype">bool</span> pq_is_indicent_on_pqr_and_pqs = (face_pqs != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>()); <span class="comment">// pq is common to faces pqr and pqs</span></div>
<div class="line"><span class="lineno"> 3056</span>                    std::vector&lt;fd_t&gt; new_vertex_incident_ps_faces; <span class="comment">// the list of faces which are incident to our intersection point</span></div>
<div class="line"><span class="lineno"> 3057</span>                    <span class="comment">// NOTE: Two intersection vertices are same if they are incident on the same faces AND their registry halfedges are opposites</span></div>
<div class="line"><span class="lineno"> 3058</span>                    <span class="comment">//bool computed_intersection_point_exists = false;</span></div>
<div class="line"><span class="lineno"> 3059</span> </div>
<div class="line"><span class="lineno"> 3060</span>                    <span class="keywordflow">if</span> (pq_is_indicent_on_pqr_and_pqs) {</div>
<div class="line"><span class="lineno"> 3061</span> </div>
<div class="line"><span class="lineno"> 3062</span>                        <span class="comment">// all three faces are defined and meet at the intersection point</span></div>
<div class="line"><span class="lineno"> 3063</span>                        new_vertex_incident_ps_faces.push_back(face_pqr);</div>
<div class="line"><span class="lineno"> 3064</span>                        new_vertex_incident_ps_faces.push_back(face_pqs);</div>
<div class="line"><span class="lineno"> 3065</span>                        new_vertex_incident_ps_faces.push_back(face_xyz);</div>
<div class="line"><span class="lineno"> 3066</span> </div>
<div class="line"><span class="lineno"> 3067</span>                    } <span class="comment">// if (pq_is_indicent_on_pqr_and_pqs) {</span></div>
<div class="line"><span class="lineno"> 3068</span>                    <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3069</span>                        <span class="comment">// pqr is the only face incident to pq</span></div>
<div class="line"><span class="lineno"> 3070</span>                        <span class="comment">// -----------------------------------</span></div>
<div class="line"><span class="lineno"> 3071</span>                        new_vertex_incident_ps_faces.push_back(face_pqr);</div>
<div class="line"><span class="lineno"> 3072</span>                        new_vertex_incident_ps_faces.push_back(face_pqX); <span class="comment">// virtual face</span></div>
<div class="line"><span class="lineno"> 3073</span>                        new_vertex_incident_ps_faces.push_back(face_xyz);</div>
<div class="line"><span class="lineno"> 3074</span>                    }</div>
<div class="line"><span class="lineno"> 3075</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 3076</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 3077</span>                    <span class="keywordtype">int</span> fv_count = 0;</div>
<div class="line"><span class="lineno"> 3078</span>                    <span class="keyword">const</span> <span class="keywordtype">bool</span> on_face  = <a class="code hl_function" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#ae375f46b52762e0a296490cf704c47eb">point_on_face_plane</a>(ps, tested_face, intersection_point, fv_count);</div>
<div class="line"><span class="lineno"> 3079</span>                    </div>
<div class="line"><span class="lineno"> 3080</span>                    <span class="keywordflow">if</span> (!on_face)</div>
<div class="line"><span class="lineno"> 3081</span>                    { </div>
<div class="line"><span class="lineno"> 3082</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a> <a class="code hl_function" href="../../dd/d3d/namespace_slic3r_1_1sla_1_1anonymous__namespace_02_rotfinder_8cpp_03.html#a9702d7dc6b0a37966d1157909ff81294">normal</a> = <a class="code hl_function" href="../../df/db1/math_8h.html#a1d24f16459340cb796ff7bf6b7094108">normalize</a>(tested_face_plane_normal);</div>
<div class="line"><span class="lineno"> 3083</span>                        <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code hl_function" href="../../df/db1/math_8h.html#a3a54064875b1b215da4904e90278a089">length</a> = <a class="code hl_function" href="../../df/db1/math_8h.html#a3a54064875b1b215da4904e90278a089">length</a>(normal) ;</div>
<div class="line"><span class="lineno"> 3084</span> </div>
<div class="line"><span class="lineno"> 3085</span>                        <span class="comment">//MCUT_ASSERT(length == double(1.0));</span></div>
<div class="line"><span class="lineno"> 3086</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a>&amp; point_on_plane = tested_face_vertices.back(); <span class="comment">// any vertex will do (assuming all vertices of face are coplanar)</span></div>
<div class="line"><span class="lineno"> 3087</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a> vec = (intersection_point - point_on_plane);</div>
<div class="line"><span class="lineno"> 3088</span>                        <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code hl_function" href="../../dc/d25/namespaceigl.html#abd8cd3f9a4ecc153494f4aab80ad881e">dot</a> = <a class="code hl_function" href="../../df/db1/math_8h.html#a0b6cff67f1f57a1096b42782cf5397da">dot_product</a>(normal, vec);</div>
<div class="line"><span class="lineno"> 3089</span>                        intersection_point = intersection_point - (<a class="code hl_function" href="../../dd/d3d/namespace_slic3r_1_1sla_1_1anonymous__namespace_02_rotfinder_8cpp_03.html#a9702d7dc6b0a37966d1157909ff81294">normal</a> * <a class="code hl_function" href="../../dc/d25/namespaceigl.html#abd8cd3f9a4ecc153494f4aab80ad881e">dot</a>);</div>
<div class="line"><span class="lineno"> 3090</span>                        <a class="code hl_function" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#ae375f46b52762e0a296490cf704c47eb">point_on_face_plane</a>(ps, tested_face, intersection_point, fv_count);</div>
<div class="line"><span class="lineno"> 3091</span>                    }</div>
<div class="line"><span class="lineno"> 3092</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 3093</span>                    <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> new_vertex_descr = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a0d2a1a79406b7352af07d4fc56707782">add_vertex</a>(intersection_point);</div>
<div class="line"><span class="lineno"> 3094</span> </div>
<div class="line"><span class="lineno"> 3095</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 3096</span> </div>
<div class="line"><span class="lineno"> 3097</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 3098</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 3099</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 3100</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 3101</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 3102</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 3103</span>                    </div>
<div class="line"><span class="lineno"> 3104</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 3105</span> </div>
<div class="line"><span class="lineno"> 3106</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 3107</span>                    <span class="comment">// m0_ivtx_to_ps_faces.insert(std::make_pair(new_vertex_descr, new_vertex_incident_ps_faces));</span></div>
<div class="line"><span class="lineno"> 3108</span>                    <span class="comment">// m0_ivtx_to_ps_edge.insert(std::make_pair(new_vertex_descr, tested_edge));</span></div>
<div class="line"><span class="lineno"> 3109</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)new_vertex_descr - ps_vtx_cnt == m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(new_vertex_descr) == m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 3110</span>                    m0_ivtx_to_intersection_registry_entry.push_back(std::make_pair(tested_edge, tested_face));</div>
<div class="line"><span class="lineno"> 3111</span> </div>
<div class="line"><span class="lineno"> 3112</span>                    <span class="comment">// ed_t e = ps.edge(halfedge_pq);</span></div>
<div class="line"><span class="lineno"> 3113</span>                    <span class="comment">// bool edge_registered_as_intersecting = ps_intersecting_edges.find(tested_edge) != ps_intersecting_edges.cend();</span></div>
<div class="line"><span class="lineno"> 3114</span> </div>
<div class="line"><span class="lineno"> 3115</span>                    ps_intersecting_edges[tested_edge].push_back(new_vertex_descr);</div>
<div class="line"><span class="lineno"> 3116</span> </div>
<div class="line"><span class="lineno"> 3117</span>                    <span class="comment">// intersection_test_ivtx_list.push_back(new_vertex_descr);</span></div>
<div class="line"><span class="lineno"> 3118</span> </div>
<div class="line"><span class="lineno"> 3119</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> cm_face = tested_edge_belongs_to_cm ? tested_edge_face : tested_face;</div>
<div class="line"><span class="lineno"> 3120</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> sm_face = tested_edge_belongs_to_cm ? tested_face : tested_edge_face;</div>
<div class="line"><span class="lineno"> 3121</span> </div>
<div class="line"><span class="lineno"> 3122</span>                    <span class="keywordflow">if</span> (tested_edge_belongs_to_cm) {</div>
<div class="line"><span class="lineno"> 3123</span>                        <span class="comment">// &quot;tested_face&quot; is from the source mesh</span></div>
<div class="line"><span class="lineno"> 3124</span> </div>
<div class="line"><span class="lineno"> 3125</span>                        <span class="comment">// NOTE: std::pair format/order is {source-mesh-face, cut-mesh-face}</span></div>
<div class="line"><span class="lineno"> 3126</span>                        cutpath_edge_creation_info[<a class="code hl_function" href="../../d5/d60/utils_8h.html#ad365c8c3344c9156ff85f9122be357ac">make_pair</a>(tested_face, face_pqr)].push_back(new_vertex_descr);</div>
<div class="line"><span class="lineno"> 3127</span> </div>
<div class="line"><span class="lineno"> 3128</span>                        <span class="keywordflow">if</span> (face_pqs != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>()) {</div>
<div class="line"><span class="lineno"> 3129</span> </div>
<div class="line"><span class="lineno"> 3130</span>                            cutpath_edge_creation_info[<a class="code hl_function" href="../../d5/d60/utils_8h.html#ad365c8c3344c9156ff85f9122be357ac">make_pair</a>(tested_face, face_pqs)].push_back(new_vertex_descr);</div>
<div class="line"><span class="lineno"> 3131</span>                        }</div>
<div class="line"><span class="lineno"> 3132</span>                    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3133</span> </div>
<div class="line"><span class="lineno"> 3134</span>                        cutpath_edge_creation_info[<a class="code hl_function" href="../../d5/d60/utils_8h.html#ad365c8c3344c9156ff85f9122be357ac">make_pair</a>(tested_edge_face, tested_face)].push_back(new_vertex_descr);</div>
<div class="line"><span class="lineno"> 3135</span> </div>
<div class="line"><span class="lineno"> 3136</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> tested_edge_face_other = (tested_edge_face == tested_edge_h0_face) ? tested_edge_h1_face : tested_edge_h0_face;</div>
<div class="line"><span class="lineno"> 3137</span> </div>
<div class="line"><span class="lineno"> 3138</span>                        <span class="keywordflow">if</span> (tested_edge_face_other != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>()) {</div>
<div class="line"><span class="lineno"> 3139</span> </div>
<div class="line"><span class="lineno"> 3140</span>                            cutpath_edge_creation_info[<a class="code hl_function" href="../../d5/d60/utils_8h.html#ad365c8c3344c9156ff85f9122be357ac">make_pair</a>(tested_edge_face_other, tested_face)].push_back(new_vertex_descr);</div>
<div class="line"><span class="lineno"> 3141</span>                        }</div>
<div class="line"><span class="lineno"> 3142</span>                    }</div>
<div class="line"><span class="lineno"> 3143</span> </div>
<div class="line"><span class="lineno"> 3144</span>                    <span class="comment">// MCUT_ASSERT(m0_ivtx_to_tested_polygon_normal.count(new_vertex_descr) == 0);</span></div>
<div class="line"><span class="lineno"> 3145</span>                    <span class="comment">// m0_ivtx_to_tested_polygon_normal[new_vertex_descr] = tested_face_plane_normal;</span></div>
<div class="line"><span class="lineno"> 3146</span>                    <span class="comment">// MCUT_ASSERT(m0_ivtx_to_tested_polygon_normal.count(new_vertex_descr) == 1);</span></div>
<div class="line"><span class="lineno"> 3147</span> </div>
<div class="line"><span class="lineno"> 3148</span>                    <span class="keywordflow">if</span> (tested_edge_belongs_to_cm) { <span class="comment">// halfedge_pq belongs to cut mesh</span></div>
<div class="line"><span class="lineno"> 3149</span> </div>
<div class="line"><span class="lineno"> 3150</span>                        <span class="keyword">const</span> <span class="keywordtype">bool</span> is_border_reentrant_ivertex = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a56a93aa8ba1f69b11d91c8fb2a9b3913">is_border</a>(tested_edge); <span class="comment">// ps.is_border(ps.edge(halfedge_pq));</span></div>
<div class="line"><span class="lineno"> 3151</span> </div>
<div class="line"><span class="lineno"> 3152</span>                        <span class="keywordflow">if</span> (is_border_reentrant_ivertex) {</div>
<div class="line"><span class="lineno"> 3153</span> </div>
<div class="line"><span class="lineno"> 3154</span>                            cm_border_reentrant_ivtx_list.push_back(new_vertex_descr);</div>
<div class="line"><span class="lineno"> 3155</span>                        } <span class="comment">// else // is regular</span></div>
<div class="line"><span class="lineno"> 3156</span>                    }</div>
<div class="line"><span class="lineno"> 3157</span> </div>
<div class="line"><span class="lineno"> 3158</span>                    <span class="comment">// map face to intersections points (reverse mapping of the intPoint-to-registryEntry)</span></div>
<div class="line"><span class="lineno"> 3159</span>                    ps_iface_to_ivtx_list[tested_face].push_back(new_vertex_descr);</div>
<div class="line"><span class="lineno"> 3160</span>                    <span class="keywordflow">if</span> (tested_edge_h0_face != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>()) {</div>
<div class="line"><span class="lineno"> 3161</span>                        ps_iface_to_ivtx_list[tested_edge_h0_face].push_back(new_vertex_descr);</div>
<div class="line"><span class="lineno"> 3162</span>                    }</div>
<div class="line"><span class="lineno"> 3163</span>                    <span class="keywordflow">if</span> (tested_edge_h1_face != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>()) {</div>
<div class="line"><span class="lineno"> 3164</span>                        ps_iface_to_ivtx_list[tested_edge_h1_face].push_back(new_vertex_descr);</div>
<div class="line"><span class="lineno"> 3165</span>                    }</div>
<div class="line"><span class="lineno"> 3166</span> </div>
<div class="line"><span class="lineno"> 3167</span>                    <span class="keywordflow">if</span> (partial_cut_detected == <span class="keyword">false</span>) { <span class="comment">// keep checking until true</span></div>
<div class="line"><span class="lineno"> 3168</span>                        <span class="comment">// const vd_t v0 = ps.vertex(tested_edge, 0);</span></div>
<div class="line"><span class="lineno"> 3169</span>                        <span class="keyword">const</span> <span class="keywordtype">bool</span> is_cs_edge = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a426849b7f7105963c5e2767bdd31b155">ps_is_cutmesh_vertex</a>(tested_edge_h0_source_descr, sm_vtx_cnt);</div>
<div class="line"><span class="lineno"> 3170</span>                        <span class="comment">// partial_cut_detected = (is_cs_edge &amp;&amp; ps.is_border(tested_edge));</span></div>
<div class="line"><span class="lineno"> 3171</span>                        <span class="keywordtype">bool</span> is_border = (tested_edge_h0_face == <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>() || tested_edge_h1_face == <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>());</div>
<div class="line"><span class="lineno"> 3172</span>                        partial_cut_detected = (is_cs_edge &amp;&amp; is_border);</div>
<div class="line"><span class="lineno"> 3173</span>                    }</div>
<div class="line"><span class="lineno"> 3174</span> </div>
<div class="line"><span class="lineno"> 3175</span>                } <span class="comment">// if (have_point_in_polygon)</span></div>
<div class="line"><span class="lineno"> 3176</span> </div>
<div class="line"><span class="lineno"> 3177</span>            } <span class="comment">// if (have_plane_intersection) {</span></div>
<div class="line"><span class="lineno"> 3178</span>        } <span class="comment">// for (std::vector&lt;fd_t&gt;::const_iterator intersected_faces_iter = intersected_faces.cbegin(); intersected_faces_iter != intersected_faces.cend(); ++intersected_faces_iter) {</span></div>
<div class="line"><span class="lineno"> 3179</span> </div>
<div class="line"><span class="lineno"> 3180</span>    } <span class="comment">// for (std::map&lt;ed_t, std::vector&lt;fd_t&gt;&gt;::const_iterator ps_edge_face_intersection_pairs_iter = ps_edge_face_intersection_pairs.cbegin(); ps_edge_face_intersection_pairs_iter != ps_edge_face_intersection_pairs.cend(); ps_edge_face_intersection_pairs_iter++) {</span></div>
<div class="line"><span class="lineno"> 3181</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 3182</span> </div>
<div class="line"><span class="lineno"> 3183</span>    <span class="comment">// Create edges from the new intersection points</span></div>
<div class="line"><span class="lineno"> 3184</span>    <span class="comment">// ---------------------------------------------</span></div>
<div class="line"><span class="lineno"> 3185</span> </div>
<div class="line"><span class="lineno"> 3186</span>    <span class="keywordflow">if</span> (m0_ivtx_to_intersection_registry_entry.empty()) {</div>
<div class="line"><span class="lineno"> 3187</span>        lg.<a class="code hl_function" href="../../d8/d0d/classlogger__t.html#aecaed21510eca7fa095e7176d9e36850">set_reason_for_failure</a>(<span class="stringliteral">&quot;no face intersection found&quot;</span>);</div>
<div class="line"><span class="lineno"> 3188</span>        <span class="keywordflow">if</span> (input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a5793da463db7c7b18aab5817d243c875">enforce_general_position</a> &amp;&amp; input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af1d9592385500dcceb4384ed823bb850">general_position_enforcement_count</a> &gt; 0) {</div>
<div class="line"><span class="lineno"> 3189</span>            <span class="comment">// This is not the first time we have invoked the kernel, which means that</span></div>
<div class="line"><span class="lineno"> 3190</span>            <span class="comment">// perturbation pushed the cut-mesh into a state/position/configuration that</span></div>
<div class="line"><span class="lineno"> 3191</span>            <span class="comment">// that does not actually intersect with the src-mesh. Thus, we will need to</span></div>
<div class="line"><span class="lineno"> 3192</span>            <span class="comment">// perturb again!</span></div>
<div class="line"><span class="lineno"> 3193</span>            <span class="comment">// By contruction, general position can only have been violated on inputs that</span></div>
<div class="line"><span class="lineno"> 3194</span>            <span class="comment">// where intersecting (in some way) to begin with i.e. with the input meshes</span></div>
<div class="line"><span class="lineno"> 3195</span>            <span class="comment">// as provided by the user. Thus, it would be incorrect to perturb the cut-mesh</span></div>
<div class="line"><span class="lineno"> 3196</span>            <span class="comment">// into an intersection-free configuration and then claim that we have</span></div>
<div class="line"><span class="lineno"> 3197</span>            <span class="comment">// successfully enforced general position. We want to make sure that after we</span></div>
<div class="line"><span class="lineno"> 3198</span>            <span class="comment">// perturb we can at least produce *some* cut.</span></div>
<div class="line"><span class="lineno"> 3199</span>            output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a7d4c902daa6f0439e388496967885dd9">status</a> = <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a91712b49b91fbf59087df24104715e29">status_t::GENERAL_POSITION_VIOLATION</a>;</div>
<div class="line"><span class="lineno"> 3200</span>        } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3201</span>            output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a7d4c902daa6f0439e388496967885dd9">status</a> = <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586ad0749aaba8b833466dfcbb0428e4f89c">status_t::SUCCESS</a>;</div>
<div class="line"><span class="lineno"> 3202</span>        }</div>
<div class="line"><span class="lineno"> 3203</span>        <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno"> 3204</span>    }</div>
<div class="line"><span class="lineno"> 3205</span> </div>
<div class="line"><span class="lineno"> 3206</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 3207</span> </div>
<div class="line"><span class="lineno"> 3208</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 3209</span>        <span class="keywordflow">for</span> (std::map&lt;<a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a>, std::pair&lt;ed_t, fd_t&gt;&gt;::const_iterator entry_it = m0_ivtx_to_intersection_registry_entry.cbegin(); entry_it != m0_ivtx_to_intersection_registry_entry.cend(); ++entry_it)</div>
<div class="line"><span class="lineno"> 3210</span>        {</div>
<div class="line"><span class="lineno"> 3211</span>            <span class="comment">//const vd_t&amp; ipoint_descr = entry_it-&gt;first;</span></div>
<div class="line"><span class="lineno"> 3212</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> &amp;ipoint_iedge = entry_it-&gt;second.first;</div>
<div class="line"><span class="lineno"> 3213</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> v0 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(ipoint_iedge, 0);</div>
<div class="line"><span class="lineno"> 3214</span>            <span class="keyword">const</span> <span class="keywordtype">bool</span> is_cs_edge = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a426849b7f7105963c5e2767bdd31b155">ps_is_cutmesh_vertex</a>(v0, sm_vtx_cnt);</div>
<div class="line"><span class="lineno"> 3215</span> </div>
<div class="line"><span class="lineno"> 3216</span>            <span class="comment">//if () {</span></div>
<div class="line"><span class="lineno"> 3217</span> </div>
<div class="line"><span class="lineno"> 3218</span>            partial_cut_detected = (is_cs_edge &amp;&amp; ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a56a93aa8ba1f69b11d91c8fb2a9b3913">is_border</a>(ipoint_iedge));</div>
<div class="line"><span class="lineno"> 3219</span>            <span class="keywordflow">if</span> (partial_cut_detected)</div>
<div class="line"><span class="lineno"> 3220</span>            {</div>
<div class="line"><span class="lineno"> 3221</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 3222</span>            }</div>
<div class="line"><span class="lineno"> 3223</span> </div>
<div class="line"><span class="lineno"> 3224</span>            <span class="comment">// if (is_border) {</span></div>
<div class="line"><span class="lineno"> 3225</span>            <span class="comment">//     partial_cut_detected = true;</span></div>
<div class="line"><span class="lineno"> 3226</span>            <span class="comment">// }</span></div>
<div class="line"><span class="lineno"> 3227</span>            <span class="comment">//}</span></div>
<div class="line"><span class="lineno"> 3228</span>        }</div>
<div class="line"><span class="lineno"> 3229</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 3230</span> </div>
<div class="line"><span class="lineno"> 3231</span>    <span class="keywordflow">if</span> (partial_cut_detected &amp;&amp; cm_border_reentrant_ivtx_list.size() == 0) {</div>
<div class="line"><span class="lineno"> 3232</span>        <span class="comment">// can happen with case when both the input mesh and cut surface are not watertight</span></div>
<div class="line"><span class="lineno"> 3233</span>    }</div>
<div class="line"><span class="lineno"> 3234</span> </div>
<div class="line"><span class="lineno"> 3235</span>    <span class="keywordflow">if</span> (input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#acbacc55f2163529291e5a45671fed3d1">verbose</a>) {</div>
<div class="line"><span class="lineno"> 3236</span>        <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a9bb440c35b34b7ecd91a6ce4eca6941e">dump_mesh</a>(m0, <span class="stringliteral">&quot;m0.v&quot;</span>); <span class="comment">// containing only vertices (polygon soup vertices and newly computed intersection points)</span></div>
<div class="line"><span class="lineno"> 3237</span>    }</div>
<div class="line"><span class="lineno"> 3238</span> </div>
<div class="line"><span class="lineno"> 3239</span>    <span class="keywordflow">if</span> (partial_cut_detected) {</div>
<div class="line"><span class="lineno"> 3240</span> </div>
<div class="line"><span class="lineno"> 3241</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(!cm_is_watertight);</div>
<div class="line"><span class="lineno"> 3242</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(!m0_ivtx_to_intersection_registry_entry.empty());</div>
<div class="line"><span class="lineno"> 3243</span>        <span class="comment">// MCUT_ASSERT(!m0_ivtx_to_ps_edge.empty());</span></div>
<div class="line"><span class="lineno"> 3244</span> </div>
<div class="line"><span class="lineno"> 3245</span>        <span class="keywordflow">if</span> (input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af6a1bc1df77e026c551054fb7c3752bc">require_looped_cutpaths</a>) {</div>
<div class="line"><span class="lineno"> 3246</span>            output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a7d4c902daa6f0439e388496967885dd9">status</a> = <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586ad0749aaba8b833466dfcbb0428e4f89c">status_t::SUCCESS</a>;</div>
<div class="line"><span class="lineno"> 3247</span>            <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno"> 3248</span>        }</div>
<div class="line"><span class="lineno"> 3249</span>    }</div>
<div class="line"><span class="lineno"> 3250</span> </div>
<div class="line"><span class="lineno"> 3252</span>    <span class="comment">// Check for degenerate mesh intersections</span></div>
<div class="line"><span class="lineno"> 3254</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 3255</span>    <span class="comment">// TODO: this is redundnat (remove)</span></div>
<div class="line"><span class="lineno"> 3256</span>    <a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">vertex_array_iterator_t</a> m0_ivtx_iter_begin = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a0bf160ae73193f77064cc3d8f01e63a3">vertices_begin</a>();</div>
<div class="line"><span class="lineno"> 3257</span>    std::advance(m0_ivtx_iter_begin, ps_vtx_cnt); <span class="comment">// offset to start of intersection vertices in hmesh_t (note: internal mesh data stored consecutively)</span></div>
<div class="line"><span class="lineno"> 3258</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 3259</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 3260</span>        <span class="comment">// check if at-least one source mesh edge intersects any face of the cut mesh.</span></div>
<div class="line"><span class="lineno"> 3261</span>        <span class="comment">// ---------------------------------------------------------------------------</span></div>
<div class="line"><span class="lineno"> 3262</span> </div>
<div class="line"><span class="lineno"> 3263</span>        <span class="comment">/*for each intersection cs face</span></div>
<div class="line"><span class="lineno"> 3264</span><span class="comment">        for each halfedge of face        </span></div>
<div class="line"><span class="lineno"> 3265</span><span class="comment">            if halfedge intersects an im face and halfedge is a border halfedge</span></div>
<div class="line"><span class="lineno"> 3266</span><span class="comment">                1) find all other border halfedges of faces which also intersect im face</span></div>
<div class="line"><span class="lineno"> 3267</span><span class="comment">                if (1) &gt; 0</span></div>
<div class="line"><span class="lineno"> 3268</span><span class="comment">                    check to ensure that at least one halfedge of the im face intersects the cs face </span></div>
<div class="line"><span class="lineno"> 3269</span><span class="comment">    */</span></div>
<div class="line"><span class="lineno"> 3270</span> </div>
<div class="line"><span class="lineno"> 3271</span>        <span class="comment">// This check prevents malformed configurations where a cut-mesh face might stab/pierce</span></div>
<div class="line"><span class="lineno"> 3272</span>        <span class="comment">// a face of the source-mesh face while correctly intersecting another source-mesh face</span></div>
<div class="line"><span class="lineno"> 3273</span>        <span class="comment">// on the &quot;other side&quot;. (Think of a wedge-like triangle stabbing a tet face while</span></div>
<div class="line"><span class="lineno"> 3274</span>        <span class="comment">// intersecting [two] other faces by cutting an edge in the tet).</span></div>
<div class="line"><span class="lineno"> 3275</span>        <span class="keywordtype">bool</span> atleast_one_sm_edge_intersects_an_cs_face = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 3276</span> </div>
<div class="line"><span class="lineno"> 3277</span>        <span class="comment">// TODO: just loop over m0_ivtx_to_intersection_registry_entry</span></div>
<div class="line"><span class="lineno"> 3278</span>        <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">vertex_array_iterator_t</a> i = m0_ivtx_iter_begin; i != m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a80ac49a03f1085744f5b121cc4acbf2c">vertices_end</a>(); ++i)</div>
<div class="line"><span class="lineno"> 3279</span>        {</div>
<div class="line"><span class="lineno"> 3280</span> </div>
<div class="line"><span class="lineno"> 3281</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> &amp;ps_edge = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, (*i) - ps_vtx_cnt).first;</div>
<div class="line"><span class="lineno"> 3282</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> ps_edge_v0 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(ps_edge, 0);</div>
<div class="line"><span class="lineno"> 3283</span>            <span class="keyword">const</span> <span class="keywordtype">bool</span> is_sm_edge = !<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a426849b7f7105963c5e2767bdd31b155">ps_is_cutmesh_vertex</a>(ps_edge_v0, sm_vtx_cnt);</div>
<div class="line"><span class="lineno"> 3284</span> </div>
<div class="line"><span class="lineno"> 3285</span>            <span class="keywordflow">if</span> (is_sm_edge)</div>
<div class="line"><span class="lineno"> 3286</span>            {</div>
<div class="line"><span class="lineno"> 3287</span>                atleast_one_sm_edge_intersects_an_cs_face = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 3288</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 3289</span>            }</div>
<div class="line"><span class="lineno"> 3290</span>        }</div>
<div class="line"><span class="lineno"> 3291</span> </div>
<div class="line"><span class="lineno"> 3292</span>    <span class="keywordflow">if</span> (!atleast_one_sm_edge_intersects_an_cs_face) {</div>
<div class="line"><span class="lineno"> 3293</span>        <span class="comment">// NOTE: the sm must intersect at least one face of the cs to allow for an opening on the sm boundary.</span></div>
<div class="line"><span class="lineno"> 3294</span>        lg.<a class="code hl_function" href="../../d8/d0d/classlogger__t.html#aecaed21510eca7fa095e7176d9e36850">set_reason_for_failure</a>(<span class="stringliteral">&quot;found no edge in source mesh which intersects a cut mesh face.&quot;</span>);</div>
<div class="line"><span class="lineno"> 3295</span>        output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a7d4c902daa6f0439e388496967885dd9">status</a> = <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a1919962cb3db319ec5b0563a93a68d8a">status_t::INVALID_MESH_INTERSECTION</a>;</div>
<div class="line"><span class="lineno"> 3296</span>        <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno"> 3297</span>    }</div>
<div class="line"><span class="lineno"> 3298</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 3300</span>    <span class="comment">// Create new edges along the intersection</span></div>
<div class="line"><span class="lineno"> 3302</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 3303</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Create edges with intersection points &quot;</span>); <span class="comment">// &amp;&amp;&amp;&amp;&amp;</span></div>
<div class="line"><span class="lineno"> 3304</span> </div>
<div class="line"><span class="lineno"> 3305</span>    <span class="comment">// A mapping from an intersecting ps-face to the new edges. These edges are those whose</span></div>
<div class="line"><span class="lineno"> 3306</span>    <span class="comment">// src and tgt vertices contain the respective face in their registry entry</span></div>
<div class="line"><span class="lineno"> 3307</span>    <span class="comment">// (note: all or some may be used for used to clip the face).</span></div>
<div class="line"><span class="lineno"> 3308</span>    std::unordered_map&lt;</div>
<div class="line"><span class="lineno"> 3309</span>        <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a>, <span class="comment">// A face intersecting another</span></div>
<div class="line"><span class="lineno"> 3310</span>        std::vector&lt;ed_t&gt; <span class="comment">// edges touching/incident on the intersecting face</span></div>
<div class="line"><span class="lineno"> 3311</span>        &gt;</div>
<div class="line"><span class="lineno"> 3312</span>        ps_iface_to_m0_edge_list;</div>
<div class="line"><span class="lineno"> 3313</span> </div>
<div class="line"><span class="lineno"> 3314</span>    <span class="comment">// Edges defining the cut path/line of intersecton/intersection contour</span></div>
<div class="line"><span class="lineno"> 3315</span>    std::vector&lt;ed_t&gt; m0_cutpath_edges;</div>
<div class="line"><span class="lineno"> 3316</span> </div>
<div class="line"><span class="lineno"> 3317</span>    <span class="comment">// A mapping from and ivertex to the incoming halfedges</span></div>
<div class="line"><span class="lineno"> 3318</span>    std::unordered_map&lt;</div>
<div class="line"><span class="lineno"> 3319</span>        <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a>, <span class="comment">// intersection point</span></div>
<div class="line"><span class="lineno"> 3320</span>        std::vector&lt;hd_t&gt; <span class="comment">// list of halfedges whose target is the intersection point</span></div>
<div class="line"><span class="lineno"> 3321</span>        &gt;</div>
<div class="line"><span class="lineno"> 3322</span>        ivtx_to_incoming_hlist;</div>
<div class="line"><span class="lineno"> 3323</span><span class="preprocessor">#if 0 </span><span class="comment">// used for debugging colinearity bug, which occur when we have poly with eg. &gt; 3</span></div>
<div class="line"><span class="lineno"> 3324</span>    <span class="comment">// vertices where at least 3 more-or-less are colinear but exact predicate says no.</span></div>
<div class="line"><span class="lineno"> 3325</span>    <span class="keywordflow">for</span> (std::map&lt;<a class="code hl_struct" href="../../df/de8/structpair.html">pair&lt;fd_t&gt;</a>, std::vector&lt;vd_t&gt;&gt;::const_iterator cutpath_edge_creation_info_iter = cutpath_edge_creation_info.cbegin();</div>
<div class="line"><span class="lineno"> 3326</span>         cutpath_edge_creation_info_iter != cutpath_edge_creation_info.cend();</div>
<div class="line"><span class="lineno"> 3327</span>         ++cutpath_edge_creation_info_iter) {</div>
<div class="line"><span class="lineno"> 3328</span> </div>
<div class="line"><span class="lineno"> 3329</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> sm_face = cutpath_edge_creation_info_iter-&gt;first.first;</div>
<div class="line"><span class="lineno"> 3330</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> cm_face = cutpath_edge_creation_info_iter-&gt;first.second;</div>
<div class="line"><span class="lineno"> 3331</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(!<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aaf65fb11520f9cb197774e79efeddfbb">ps_is_cutmesh_face</a>(sm_face, sm_face_count));</div>
<div class="line"><span class="lineno"> 3332</span>        <span class="keyword">const</span> std::vector&lt;vd_t&gt;&amp; intersection_test_ivtx_list = cutpath_edge_creation_info_iter-&gt;second;</div>
<div class="line"><span class="lineno"> 3333</span>        <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>)intersection_test_ivtx_list.size() &lt; 2) {</div>
<div class="line"><span class="lineno"> 3334</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> ivtx = intersection_test_ivtx_list.back();</div>
<div class="line"><span class="lineno"> 3335</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; ps_edge = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, ivtx - ps_vtx_cnt).first;</div>
<div class="line"><span class="lineno"> 3336</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> ps_edge_f0 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(ps_edge, 0));</div>
<div class="line"><span class="lineno"> 3337</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> ps_edge_f1 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(ps_edge, 1));</div>
<div class="line"><span class="lineno"> 3338</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> ps_f = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, ivtx - ps_vtx_cnt).second;</div>
<div class="line"><span class="lineno"> 3339</span> </div>
<div class="line"><span class="lineno"> 3340</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 3341</span>                <span class="keyword">auto</span> dump_faces = [&amp;](std::vector&lt;fd_t&gt; fv, std::string fpath)</div>
<div class="line"><span class="lineno"> 3342</span>                {</div>
<div class="line"><span class="lineno"> 3343</span>                    std::ofstream file(fpath);</div>
<div class="line"><span class="lineno"> 3344</span>                    <span class="keywordflow">for</span>(<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">vertex_array_iterator_t</a> v = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a0bf160ae73193f77064cc3d8f01e63a3">vertices_begin</a>(); v != ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a80ac49a03f1085744f5b121cc4acbf2c">vertices_end</a>(); ++v)</div>
<div class="line"><span class="lineno"> 3345</span>                    {</div>
<div class="line"><span class="lineno"> 3346</span>                        file &lt;&lt; <span class="stringliteral">&quot;v &quot;</span> &lt;&lt; ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(*v).x() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(*v).y() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(*v).z() &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 3347</span>                    }</div>
<div class="line"><span class="lineno"> 3348</span> </div>
<div class="line"><span class="lineno"> 3349</span>                    <span class="keywordflow">for</span>(<span class="keyword">auto</span> f : fv)</div>
<div class="line"><span class="lineno"> 3350</span>                    {</div>
<div class="line"><span class="lineno"> 3351</span>                        file &lt;&lt; <span class="stringliteral">&quot;f &quot;</span>;</div>
<div class="line"><span class="lineno"> 3352</span>                        std::vector&lt;vd_t&gt; verts = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a765a6f3b7249eb47135d246f6d301102">get_vertices_around_face</a>(f); </div>
<div class="line"><span class="lineno"> 3353</span>                        <span class="keywordflow">for</span>(<span class="keyword">auto</span> v : verts)</div>
<div class="line"><span class="lineno"> 3354</span>                        {</div>
<div class="line"><span class="lineno"> 3355</span>                            file &lt;&lt; v+1 &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><span class="lineno"> 3356</span>                        }</div>
<div class="line"><span class="lineno"> 3357</span>                        file &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno"> 3358</span>                    }</div>
<div class="line"><span class="lineno"> 3359</span>                };</div>
<div class="line"><span class="lineno"> 3360</span> </div>
<div class="line"><span class="lineno"> 3361</span>                dump_faces({ ps_edge_f0, ps_edge_f1 }, <span class="stringliteral">&quot;ps_edge.obj&quot;</span>);</div>
<div class="line"><span class="lineno"> 3362</span>                dump_faces({ ps_f }, <span class="stringliteral">&quot;ps_f.obj&quot;</span>);</div>
<div class="line"><span class="lineno"> 3363</span> </div>
<div class="line"><span class="lineno"> 3364</span>                <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a9bb440c35b34b7ecd91a6ce4eca6941e">dump_mesh</a>(sm, <span class="stringliteral">&quot;sm-.off&quot;</span>);</div>
<div class="line"><span class="lineno"> 3365</span>                <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a9bb440c35b34b7ecd91a6ce4eca6941e">dump_mesh</a>(cs, <span class="stringliteral">&quot;cm-.off&quot;</span>);</div>
<div class="line"><span class="lineno"> 3366</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 3367</span> </div>
<div class="line"><span class="lineno"> 3368</span>            output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a7d4c902daa6f0439e388496967885dd9">status</a> = <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a91712b49b91fbf59087df24104715e29">status_t::GENERAL_POSITION_VIOLATION</a>;</div>
<div class="line"><span class="lineno"> 3369</span> </div>
<div class="line"><span class="lineno"> 3370</span>            <span class="keywordflow">if</span> (!input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a5793da463db7c7b18aab5817d243c875">enforce_general_position</a>) {</div>
<div class="line"><span class="lineno"> 3371</span> </div>
<div class="line"><span class="lineno"> 3372</span>                <span class="comment">// Our assumption of having inputs in general position has been violated, we need to terminate</span></div>
<div class="line"><span class="lineno"> 3373</span>                <span class="comment">// with an error since perturbation (i.e. enforcement of general positions) is disabled.</span></div>
<div class="line"><span class="lineno"> 3374</span>                <span class="comment">// If any one of a segment&#39;s vertices only touch (i.e. lie on) the plane</span></div>
<div class="line"><span class="lineno"> 3375</span>                <span class="comment">// then that implies a situation of cutting through a vertex which is undefined.</span></div>
<div class="line"><span class="lineno"> 3376</span> </div>
<div class="line"><span class="lineno"> 3377</span>                <span class="keyword">auto</span> sm_or_cm = [&amp;](<a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> f) {</div>
<div class="line"><span class="lineno"> 3378</span>                    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aaf65fb11520f9cb197774e79efeddfbb">ps_is_cutmesh_face</a>(f, sm_face_count) ? <span class="stringliteral">&quot;cm&quot;</span> : <span class="stringliteral">&quot;sm&quot;</span>;</div>
<div class="line"><span class="lineno"> 3379</span>                };</div>
<div class="line"><span class="lineno"> 3380</span> </div>
<div class="line"><span class="lineno"> 3381</span>                <span class="keyword">auto</span> descr_v = [&amp;](<a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> f) {</div>
<div class="line"><span class="lineno"> 3382</span>                    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aaf65fb11520f9cb197774e79efeddfbb">ps_is_cutmesh_face</a>(f, sm_face_count) ? f - sm_face_count : f;</div>
<div class="line"><span class="lineno"> 3383</span>                };</div>
<div class="line"><span class="lineno"> 3384</span> </div>
<div class="line"><span class="lineno"> 3385</span>                <span class="keywordtype">char</span> buff[128];</div>
<div class="line"><span class="lineno"> 3386</span>                sprintf(buff, <span class="stringliteral">&quot;edge(%s.f%d, %s.f%d) lies exactly on face %s.f%d\n&quot;</span>,</div>
<div class="line"><span class="lineno"> 3387</span>                    sm_or_cm(ps_edge_f0), (<span class="keywordtype">int</span>)descr_v(ps_edge_f0),</div>
<div class="line"><span class="lineno"> 3388</span>                    sm_or_cm(ps_edge_f1), (<span class="keywordtype">int</span>)descr_v(ps_edge_f1),</div>
<div class="line"><span class="lineno"> 3389</span>                    sm_or_cm(ps_f), (<span class="keywordtype">int</span>)descr_v(ps_f));</div>
<div class="line"><span class="lineno"> 3390</span> </div>
<div class="line"><span class="lineno"> 3391</span>                lg.<a class="code hl_function" href="../../d8/d0d/classlogger__t.html#aecaed21510eca7fa095e7176d9e36850">set_reason_for_failure</a>(buff);</div>
<div class="line"><span class="lineno"> 3392</span>            }</div>
<div class="line"><span class="lineno"> 3393</span> </div>
<div class="line"><span class="lineno"> 3394</span>            <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno"> 3395</span>        }</div>
<div class="line"><span class="lineno"> 3396</span>    }</div>
<div class="line"><span class="lineno"> 3397</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 3398</span>    <span class="keywordflow">for</span> (std::map&lt;<a class="code hl_struct" href="../../df/de8/structpair.html">pair&lt;fd_t&gt;</a>, std::vector&lt;vd_t&gt;&gt;::const_iterator cutpath_edge_creation_info_iter = cutpath_edge_creation_info.cbegin();</div>
<div class="line"><span class="lineno"> 3399</span>         cutpath_edge_creation_info_iter != cutpath_edge_creation_info.cend();</div>
<div class="line"><span class="lineno"> 3400</span>         ++cutpath_edge_creation_info_iter) {</div>
<div class="line"><span class="lineno"> 3401</span> </div>
<div class="line"><span class="lineno"> 3402</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> sm_face = cutpath_edge_creation_info_iter-&gt;first.first;</div>
<div class="line"><span class="lineno"> 3403</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> cm_face = cutpath_edge_creation_info_iter-&gt;first.second;</div>
<div class="line"><span class="lineno"> 3404</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(!<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aaf65fb11520f9cb197774e79efeddfbb">ps_is_cutmesh_face</a>(sm_face, sm_face_count));</div>
<div class="line"><span class="lineno"> 3405</span>        <span class="keyword">const</span> std::vector&lt;vd_t&gt;&amp; intersection_test_ivtx_list = cutpath_edge_creation_info_iter-&gt;second;</div>
<div class="line"><span class="lineno"> 3406</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">int</span>)intersection_test_ivtx_list.size() &gt;= 2); <span class="comment">// edge-case scenario: an edge intersects with another edge exactly</span></div>
<div class="line"><span class="lineno"> 3407</span>        <span class="keyword">const</span> <a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> new_ivertices_count = (<a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>)intersection_test_ivtx_list.size();</div>
<div class="line"><span class="lineno"> 3408</span> </div>
<div class="line"><span class="lineno"> 3409</span>        <span class="keywordflow">if</span> (new_ivertices_count == 2) { <span class="comment">// one edge</span></div>
<div class="line"><span class="lineno"> 3410</span>            <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> first_new_ivertex = intersection_test_ivtx_list.front();</div>
<div class="line"><span class="lineno"> 3411</span>            <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> second_new_ivertex = intersection_test_ivtx_list.back();</div>
<div class="line"><span class="lineno"> 3412</span> </div>
<div class="line"><span class="lineno"> 3413</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(first_new_ivertex, ps_vtx_cnt));</div>
<div class="line"><span class="lineno"> 3414</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(second_new_ivertex, ps_vtx_cnt));</div>
<div class="line"><span class="lineno"> 3415</span> </div>
<div class="line"><span class="lineno"> 3416</span>            <span class="keywordtype">bool</span> cutpath_edge_exists = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(first_new_ivertex, second_new_ivertex, <span class="keyword">true</span>) != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno"> 3417</span>            <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 3418</span>                cutpath_edge_exists == <span class="keyword">false</span></div>
<div class="line"><span class="lineno"> 3420</span>            ) {</div>
<div class="line"><span class="lineno"> 3421</span> </div>
<div class="line"><span class="lineno"> 3422</span>                <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ae64649dd61e0c188c547c686abc8a19e">add_edge</a>(first_new_ivertex, second_new_ivertex);</div>
<div class="line"><span class="lineno"> 3423</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(h != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>());</div>
<div class="line"><span class="lineno"> 3424</span> </div>
<div class="line"><span class="lineno"> 3425</span>                m0_cutpath_edges.emplace_back(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a96e9db918396b86f0b61f5445ef46b18">edge</a>(h));</div>
<div class="line"><span class="lineno"> 3426</span> </div>
<div class="line"><span class="lineno"> 3427</span>                <span class="comment">// all newly created edges will lie on both face A and face B since intersection</span></div>
<div class="line"><span class="lineno"> 3428</span>                <span class="comment">// points lie on a line which is the intersection of the two planes of face A and B</span></div>
<div class="line"><span class="lineno"> 3429</span>                ps_iface_to_m0_edge_list[sm_face].emplace_back(m0_cutpath_edges.back());</div>
<div class="line"><span class="lineno"> 3430</span>                ps_iface_to_m0_edge_list[cm_face].emplace_back(m0_cutpath_edges.back());</div>
<div class="line"><span class="lineno"> 3431</span> </div>
<div class="line"><span class="lineno"> 3432</span>                <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a263f562fbe3843b93d07f1b41eb4362e">update_neighouring_ps_iface_m0_edge_list</a>(</div>
<div class="line"><span class="lineno"> 3433</span>                    first_new_ivertex,</div>
<div class="line"><span class="lineno"> 3434</span>                    second_new_ivertex,</div>
<div class="line"><span class="lineno"> 3435</span>                    ps,</div>
<div class="line"><span class="lineno"> 3436</span>                    sm_face,</div>
<div class="line"><span class="lineno"> 3437</span>                    cm_face,</div>
<div class="line"><span class="lineno"> 3438</span>                    m0_ivtx_to_intersection_registry_entry,</div>
<div class="line"><span class="lineno"> 3439</span>                    ps_iface_to_m0_edge_list,</div>
<div class="line"><span class="lineno"> 3440</span>                    m0_cutpath_edges);</div>
<div class="line"><span class="lineno"> 3441</span> </div>
<div class="line"><span class="lineno"> 3442</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(h) == second_new_ivertex);</div>
<div class="line"><span class="lineno"> 3443</span>                ivtx_to_incoming_hlist[second_new_ivertex].push_back(h);</div>
<div class="line"><span class="lineno"> 3444</span> </div>
<div class="line"><span class="lineno"> 3445</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(h)) == first_new_ivertex);</div>
<div class="line"><span class="lineno"> 3446</span>                ivtx_to_incoming_hlist[first_new_ivertex].push_back(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(h));</div>
<div class="line"><span class="lineno"> 3447</span>            }</div>
<div class="line"><span class="lineno"> 3448</span>        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (new_ivertices_count &gt; 2) { <span class="comment">// create N edges (N &gt;= 1)</span></div>
<div class="line"><span class="lineno"> 3449</span> </div>
<div class="line"><span class="lineno"> 3450</span>            <span class="comment">// our produced intersection points</span></div>
<div class="line"><span class="lineno"> 3451</span>            std::vector&lt;</div>
<div class="line"><span class="lineno"> 3452</span>                std::pair&lt;</div>
<div class="line"><span class="lineno"> 3453</span>                    <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a>, <span class="comment">// descriptor</span></div>
<div class="line"><span class="lineno"> 3454</span>                    <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a> <span class="comment">// coordinates</span></div>
<div class="line"><span class="lineno"> 3455</span>                    &gt;&gt;</div>
<div class="line"><span class="lineno"> 3456</span>                ivertex_coords;</div>
<div class="line"><span class="lineno"> 3457</span> </div>
<div class="line"><span class="lineno"> 3458</span>            <span class="keywordflow">for</span> (<a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> v = 0; v &lt; new_ivertices_count; ++v) {</div>
<div class="line"><span class="lineno"> 3459</span>                <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> new_ivertex_descr = intersection_test_ivtx_list[v];</div>
<div class="line"><span class="lineno"> 3460</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(new_ivertex_descr, ps_vtx_cnt));</div>
<div class="line"><span class="lineno"> 3461</span>                ivertex_coords.emplace_back(new_ivertex_descr, m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(new_ivertex_descr));</div>
<div class="line"><span class="lineno"> 3462</span>            }</div>
<div class="line"><span class="lineno"> 3463</span> </div>
<div class="line"><span class="lineno"> 3464</span>            std::vector&lt;vd_t&gt; sorted_descriptors = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a1b55223f27099f06cf4ef4442552eb3e">linear_projection_sort</a>(ivertex_coords);</div>
<div class="line"><span class="lineno"> 3465</span> </div>
<div class="line"><span class="lineno"> 3466</span>            <span class="comment">// for (std::vector&lt;std::pair&lt;vd_t, vec3&gt;&gt;::const_iterator iter = ivertex_coords.cbegin() + 1; iter != ivertex_coords.cend(); ++iter) {</span></div>
<div class="line"><span class="lineno"> 3467</span>            <span class="keywordflow">for</span> (std::vector&lt;vd_t&gt;::const_iterator iter = sorted_descriptors.cbegin() + 1; iter != sorted_descriptors.cend(); ++iter) {</div>
<div class="line"><span class="lineno"> 3468</span>                <span class="comment">// const vd_t src_vertex = (iter - 1)-&gt;first;</span></div>
<div class="line"><span class="lineno"> 3469</span>                <span class="comment">// const vd_t tgt_vertex = (iter)-&gt;first;</span></div>
<div class="line"><span class="lineno"> 3470</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> src_vertex = *(iter - 1);</div>
<div class="line"><span class="lineno"> 3471</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> tgt_vertex = *(iter);</div>
<div class="line"><span class="lineno"> 3472</span> </div>
<div class="line"><span class="lineno"> 3473</span>                <span class="keywordtype">bool</span> cutpath_edge_exists = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(src_vertex, tgt_vertex, <span class="keyword">true</span>) != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno"> 3474</span> </div>
<div class="line"><span class="lineno"> 3475</span>                <span class="keywordflow">if</span> (cutpath_edge_exists == <span class="keyword">false</span>) {</div>
<div class="line"><span class="lineno"> 3476</span> </div>
<div class="line"><span class="lineno"> 3477</span>                    <span class="comment">// Here we also check whether the edge actually lies on the area of two [shared polygons]</span></div>
<div class="line"><span class="lineno"> 3478</span>                    <span class="comment">// in the registry entries of its vertices. This operation is fundamentally geometric</span></div>
<div class="line"><span class="lineno"> 3479</span>                    <span class="comment">// and cannot be resolved using topology (we have insufficient information to identify</span></div>
<div class="line"><span class="lineno"> 3480</span>                    <span class="comment">// intersection edges). See benchmark test 34</span></div>
<div class="line"><span class="lineno"> 3481</span>                    <span class="comment">// Thus, we will not add the edge if its mid-point does not lie in the area of [two]</span></div>
<div class="line"><span class="lineno"> 3482</span>                    <span class="comment">// of the shared faces in the resgistry entries of its vertices (intersection points)..</span></div>
<div class="line"><span class="lineno"> 3483</span>                    <span class="comment">// std::vector&lt;std::pair&lt;ed_t, fd_t&gt;&gt;::const_iterator find_iter = m0_ivtx_to_intersection_registry_entry.cend();</span></div>
<div class="line"><span class="lineno"> 3484</span> </div>
<div class="line"><span class="lineno"> 3485</span>                    <span class="comment">// get intersection-registry faces of src vertex</span></div>
<div class="line"><span class="lineno"> 3486</span>                    <span class="comment">// find_iter = m0_ivtx_to_intersection_registry_entry.find(src_vertex);</span></div>
<div class="line"><span class="lineno"> 3487</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)src_vertex - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*find_iter != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 3488</span>                    <span class="keyword">const</span> std::vector&lt;fd_t&gt; src_vertex_faces = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#abcaa230eb10486e26a5167bae360d451">ps_get_ivtx_registry_entry_faces</a>(ps, <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, (std::size_t)src_vertex - ps_vtx_cnt) <span class="comment">/*find_iter-&gt;second*/</span>);</div>
<div class="line"><span class="lineno"> 3489</span> </div>
<div class="line"><span class="lineno"> 3490</span>                    <span class="comment">// get intersection-registry faces of tgt vertex</span></div>
<div class="line"><span class="lineno"> 3491</span>                    <span class="comment">// find_iter = m0_ivtx_to_intersection_registry_entry.find(tgt_vertex);</span></div>
<div class="line"><span class="lineno"> 3492</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)tgt_vertex - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*find_iter != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 3493</span>                    <span class="keyword">const</span> std::vector&lt;fd_t&gt; tgt_vertex_faces = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#abcaa230eb10486e26a5167bae360d451">ps_get_ivtx_registry_entry_faces</a>(ps, <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, (std::size_t)tgt_vertex - ps_vtx_cnt) <span class="comment">/*find_iter-&gt;second*/</span>);</div>
<div class="line"><span class="lineno"> 3494</span> </div>
<div class="line"><span class="lineno"> 3495</span>                    std::vector&lt;fd_t&gt; shared_faces;</div>
<div class="line"><span class="lineno"> 3496</span>                    std::copy_if(src_vertex_faces.begin(), src_vertex_faces.end(), std::back_inserter(shared_faces),</div>
<div class="line"><span class="lineno"> 3497</span>                        [&amp;](<a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> f) {</div>
<div class="line"><span class="lineno"> 3498</span>                            return !is_virtual_face(f) &amp;&amp; std::find(tgt_vertex_faces.cbegin(), tgt_vertex_faces.cend(), f) != tgt_vertex_faces.cend();</div>
<div class="line"><span class="lineno"> 3499</span>                        });</div>
<div class="line"><span class="lineno"> 3500</span> </div>
<div class="line"><span class="lineno"> 3501</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(shared_faces.size() &gt;= 2); <span class="comment">// connectable intersection points must match by 2 or more faces</span></div>
<div class="line"><span class="lineno"> 3502</span> </div>
<div class="line"><span class="lineno"> 3503</span>                    <span class="comment">// compute edge mid-point (could be any point along the edge that is not one of the vertices)</span></div>
<div class="line"><span class="lineno"> 3504</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a>&amp; src_vertex_coords = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(src_vertex);</div>
<div class="line"><span class="lineno"> 3505</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a>&amp; tgt_vertex_coords = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(tgt_vertex);</div>
<div class="line"><span class="lineno"> 3506</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a> midpoint = (tgt_vertex_coords + src_vertex_coords) * <span class="keywordtype">double</span>(0.5);</div>
<div class="line"><span class="lineno"> 3507</span> </div>
<div class="line"><span class="lineno"> 3508</span>                    std::vector&lt;int&gt; shared_faces_containing_edge;</div>
<div class="line"><span class="lineno"> 3509</span>                    <span class="comment">// for each shared face</span></div>
<div class="line"><span class="lineno"> 3510</span>                    <span class="keywordflow">for</span> (std::vector&lt;fd_t&gt;::const_iterator sf_iter = shared_faces.cbegin(); sf_iter != shared_faces.cend(); ++sf_iter) {</div>
<div class="line"><span class="lineno"> 3511</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> shared_face = *sf_iter;</div>
<div class="line"><span class="lineno"> 3512</span> </div>
<div class="line"><span class="lineno"> 3513</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ps_tested_face_to_plane_normal.find(shared_face) != ps_tested_face_to_plane_normal.cend());</div>
<div class="line"><span class="lineno"> 3514</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a>&amp; shared_face_plane_normal = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_tested_face_to_plane_normal, shared_face);</div>
<div class="line"><span class="lineno"> 3515</span> </div>
<div class="line"><span class="lineno"> 3516</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ps_tested_face_to_plane_normal_max_comp.find(shared_face) != ps_tested_face_to_plane_normal_max_comp.cend());</div>
<div class="line"><span class="lineno"> 3517</span>                        <span class="keywordtype">int</span> shared_face_normal_max_comp = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_tested_face_to_plane_normal_max_comp, shared_face);</div>
<div class="line"><span class="lineno"> 3518</span> </div>
<div class="line"><span class="lineno"> 3519</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ps_tested_face_to_vertices.find(shared_face) != ps_tested_face_to_vertices.cend());</div>
<div class="line"><span class="lineno"> 3520</span>                        <span class="keyword">const</span> std::vector&lt;vec3&gt;&amp; shared_face_vertices = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_tested_face_to_vertices, shared_face);</div>
<div class="line"><span class="lineno"> 3521</span> </div>
<div class="line"><span class="lineno"> 3522</span>                        <span class="keywordtype">char</span> in_poly_test_intersection_type = <a class="code hl_function" href="../../df/db1/math_8h.html#a82a9c1f090b54dc1416ca1c3673ef5d7">compute_point_in_polygon_test</a>(</div>
<div class="line"><span class="lineno"> 3523</span>                            midpoint,</div>
<div class="line"><span class="lineno"> 3524</span>                            shared_face_vertices,</div>
<div class="line"><span class="lineno"> 3525</span>                            shared_face_plane_normal,</div>
<div class="line"><span class="lineno"> 3526</span>                            shared_face_normal_max_comp);</div>
<div class="line"><span class="lineno"> 3527</span> </div>
<div class="line"><span class="lineno"> 3528</span>                        <span class="keywordflow">if</span> (in_poly_test_intersection_type == <span class="charliteral">&#39;i&#39;</span>) {</div>
<div class="line"><span class="lineno"> 3529</span>                            <span class="keyword">const</span> <span class="keywordtype">int</span> idx = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)<a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(shared_faces.cbegin(), sf_iter);</div>
<div class="line"><span class="lineno"> 3530</span>                            shared_faces_containing_edge.push_back(idx);</div>
<div class="line"><span class="lineno"> 3531</span>                        }</div>
<div class="line"><span class="lineno"> 3532</span>                    }</div>
<div class="line"><span class="lineno"> 3533</span> </div>
<div class="line"><span class="lineno"> 3534</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">int</span>)shared_faces_containing_edge.size() &lt;= 2);</div>
<div class="line"><span class="lineno"> 3535</span> </div>
<div class="line"><span class="lineno"> 3536</span>                    <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>)shared_faces_containing_edge.size() == 2) {</div>
<div class="line"><span class="lineno"> 3537</span> </div>
<div class="line"><span class="lineno"> 3538</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ae64649dd61e0c188c547c686abc8a19e">add_edge</a>(src_vertex, tgt_vertex); <span class="comment">// insert segment!</span></div>
<div class="line"><span class="lineno"> 3539</span> </div>
<div class="line"><span class="lineno"> 3540</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(h != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>());</div>
<div class="line"><span class="lineno"> 3541</span>                        m0_cutpath_edges.emplace_back(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a96e9db918396b86f0b61f5445ef46b18">edge</a>(h));</div>
<div class="line"><span class="lineno"> 3542</span> </div>
<div class="line"><span class="lineno"> 3543</span>                        <span class="comment">// NOTE: here we add all edge without assuming anything about which of the will be used to clip either polygon</span></div>
<div class="line"><span class="lineno"> 3544</span>                        <span class="comment">// ps_iface_to_m0_edge_list[sm_face].emplace_back(m0_cutpath_edges.back());</span></div>
<div class="line"><span class="lineno"> 3545</span>                        <span class="comment">// ps_iface_to_m0_edge_list[cm_face].emplace_back(m0_cutpath_edges.back());</span></div>
<div class="line"><span class="lineno"> 3546</span>                        <span class="keywordflow">for</span> (std::vector&lt;int&gt;::const_iterator i = shared_faces_containing_edge.cbegin(); i != shared_faces_containing_edge.cend(); ++i) {</div>
<div class="line"><span class="lineno"> 3547</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> shared_face = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(shared_faces, *i);</div>
<div class="line"><span class="lineno"> 3548</span>                            ps_iface_to_m0_edge_list[shared_face].emplace_back(m0_cutpath_edges.back());</div>
<div class="line"><span class="lineno"> 3549</span>                        }</div>
<div class="line"><span class="lineno"> 3550</span> </div>
<div class="line"><span class="lineno"> 3551</span>                        <span class="comment">// update_neighouring_ps_iface_m0_edge_list(src_vertex, tgt_vertex, ps,</span></div>
<div class="line"><span class="lineno"> 3552</span>                        <span class="comment">//     sm_face,</span></div>
<div class="line"><span class="lineno"> 3553</span>                        <span class="comment">//     cm_face,</span></div>
<div class="line"><span class="lineno"> 3554</span>                        <span class="comment">//     m0_ivtx_to_intersection_registry_entry,</span></div>
<div class="line"><span class="lineno"> 3555</span>                        <span class="comment">//     ps_iface_to_m0_edge_list,</span></div>
<div class="line"><span class="lineno"> 3556</span>                        <span class="comment">//     m0_cutpath_edges);</span></div>
<div class="line"><span class="lineno"> 3557</span> </div>
<div class="line"><span class="lineno"> 3558</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(h) == tgt_vertex);</div>
<div class="line"><span class="lineno"> 3559</span>                        ivtx_to_incoming_hlist[tgt_vertex].push_back(h);</div>
<div class="line"><span class="lineno"> 3560</span> </div>
<div class="line"><span class="lineno"> 3561</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(h)) == src_vertex);</div>
<div class="line"><span class="lineno"> 3562</span>                        ivtx_to_incoming_hlist[src_vertex].push_back(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(h));</div>
<div class="line"><span class="lineno"> 3563</span>                    }</div>
<div class="line"><span class="lineno"> 3564</span>                }</div>
<div class="line"><span class="lineno"> 3565</span>            }</div>
<div class="line"><span class="lineno"> 3566</span>        } <span class="comment">// else if (new_ivertices_count &gt; 2) {</span></div>
<div class="line"><span class="lineno"> 3567</span>    }</div>
<div class="line"><span class="lineno"> 3568</span> </div>
<div class="line"><span class="lineno"> 3569</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 3570</span> </div>
<div class="line"><span class="lineno"> 3571</span>    <span class="comment">// NOTE: at this stage we have all vertices and edges which are needed to clip</span></div>
<div class="line"><span class="lineno"> 3572</span>    <span class="comment">// intersecting faces in the polygon-soup (&quot;ps&quot;).</span></div>
<div class="line"><span class="lineno"> 3573</span> </div>
<div class="line"><span class="lineno"> 3574</span>    <span class="keywordflow">if</span> (input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#acbacc55f2163529291e5a45671fed3d1">verbose</a>) {</div>
<div class="line"><span class="lineno"> 3575</span>        <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a9bb440c35b34b7ecd91a6ce4eca6941e">dump_mesh</a>(m0, <span class="stringliteral">&quot;m0.v.e&quot;</span>); <span class="comment">// containing only vertices &amp; edges</span></div>
<div class="line"><span class="lineno"> 3576</span>    }</div>
<div class="line"><span class="lineno"> 3577</span> </div>
<div class="line"><span class="lineno"> 3578</span>    <span class="keyword">const</span> <a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> m0_num_cutpath_edges = (<a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>)m0_cutpath_edges.size();</div>
<div class="line"><span class="lineno"> 3579</span>    <span class="keyword">const</span> <a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> m0_num_cutpath_halfedges = m0_num_cutpath_edges * 2;</div>
<div class="line"><span class="lineno"> 3580</span> </div>
<div class="line"><span class="lineno"> 3582</span>    <span class="comment">// Find cut-paths (the boundaries of the openings/holes in the source mesh)</span></div>
<div class="line"><span class="lineno"> 3584</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 3585</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Find cut-paths &quot;</span>);</div>
<div class="line"><span class="lineno"> 3586</span> </div>
<div class="line"><span class="lineno"> 3587</span>    <span class="comment">// We are now going to search for all the cut-paths created from the intersection</span></div>
<div class="line"><span class="lineno"> 3588</span>    <span class="comment">// between source- and cut-mesh faces. Some of these cut-paths identify holes to be</span></div>
<div class="line"><span class="lineno"> 3589</span>    <span class="comment">// filled while others indentify separation/slitting of the src-mesh.</span></div>
<div class="line"><span class="lineno"> 3590</span> </div>
<div class="line"><span class="lineno"> 3591</span>    <span class="comment">// We start off by creating &quot;bins&quot; : each bin corresonds to an intersection point</span></div>
<div class="line"><span class="lineno"> 3592</span>    <span class="comment">// and the values/elements in that bin are the [cut-path edges] connected to it.</span></div>
<div class="line"><span class="lineno"> 3593</span> </div>
<div class="line"><span class="lineno"> 3594</span>    std::unordered_map&lt;vd_t, std::vector&lt;ed_t&gt;&gt; m0_ivtx_to_cutpath_edges;</div>
<div class="line"><span class="lineno"> 3595</span> </div>
<div class="line"><span class="lineno"> 3596</span>    <span class="keywordflow">for</span> (std::vector&lt;ed_t&gt;::const_iterator cutpath_edge_iter = m0_cutpath_edges.cbegin();</div>
<div class="line"><span class="lineno"> 3597</span>         cutpath_edge_iter != m0_cutpath_edges.cend();</div>
<div class="line"><span class="lineno"> 3598</span>         ++cutpath_edge_iter) {</div>
<div class="line"><span class="lineno"> 3599</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; edge = *cutpath_edge_iter;</div>
<div class="line"><span class="lineno"> 3600</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> vertex0 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(edge, 0);</div>
<div class="line"><span class="lineno"> 3601</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> vertex1 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(edge, 1);</div>
<div class="line"><span class="lineno"> 3602</span>        m0_ivtx_to_cutpath_edges[vertex0].push_back(edge);</div>
<div class="line"><span class="lineno"> 3603</span>        m0_ivtx_to_cutpath_edges[vertex1].push_back(edge);</div>
<div class="line"><span class="lineno"> 3604</span>    }</div>
<div class="line"><span class="lineno"> 3605</span> </div>
<div class="line"><span class="lineno"> 3606</span>    <span class="comment">//... every intersection point is connected to at least onecut-path edge</span></div>
<div class="line"><span class="lineno"> 3607</span>    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_ivtx_to_cutpath_edges.empty() == <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno"> 3608</span> </div>
<div class="line"><span class="lineno"> 3609</span>    <span class="comment">// build implicit cut-path sequences (a sorted set of connected edges)</span></div>
<div class="line"><span class="lineno"> 3610</span>    <span class="comment">// -----------------------------------------------------------------------</span></div>
<div class="line"><span class="lineno"> 3611</span> </div>
<div class="line"><span class="lineno"> 3612</span>    <span class="comment">// An &quot;implicit&quot; cut-path sequence is a list of cut-path edges that are sorted (i.e.</span></div>
<div class="line"><span class="lineno"> 3613</span>    <span class="comment">// this means that in memory, edges are placed next to others they connect to).</span></div>
<div class="line"><span class="lineno"> 3614</span> </div>
<div class="line"><span class="lineno"> 3615</span>    std::vector&lt;std::vector&lt;ed_t&gt;&gt; m0_cutpath_sequences;</div>
<div class="line"><span class="lineno"> 3616</span>    std::unordered_map&lt;vd_t, int&gt; m0_ivtx_to_cutpath_sequence;</div>
<div class="line"><span class="lineno"> 3617</span>    std::unordered_map&lt;ed_t, int&gt; m0_edge_to_cutpath_sequence;</div>
<div class="line"><span class="lineno"> 3618</span> </div>
<div class="line"><span class="lineno"> 3619</span>    <span class="keywordflow">do</span> { <span class="comment">// an iteration will build a cut-path sequence</span></div>
<div class="line"><span class="lineno"> 3620</span> </div>
<div class="line"><span class="lineno"> 3621</span>        <span class="comment">// const int diff = (int)m0_ivtx_to_cutpath_edges.size() - (int)m0_ivtx_to_cutpath_sequence.size();</span></div>
<div class="line"><span class="lineno"> 3622</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">int</span>)m0_ivtx_to_cutpath_edges.size() - (<span class="keywordtype">int</span>)m0_ivtx_to_cutpath_sequence.size() &gt;= 2); <span class="comment">// need a minimum of 2 intersection points (one edge) to form a sequence</span></div>
<div class="line"><span class="lineno"> 3623</span> </div>
<div class="line"><span class="lineno"> 3624</span>        <span class="keywordtype">int</span> cur_cutpath_sequence_index = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)m0_cutpath_sequences.size();</div>
<div class="line"><span class="lineno"> 3625</span> </div>
<div class="line"><span class="lineno"> 3626</span>        <span class="comment">// start from an intersection point that is not yet mapped-to/associated-with a</span></div>
<div class="line"><span class="lineno"> 3627</span>        <span class="comment">//  sequence in &quot;cur_cutpath_sequence&quot;</span></div>
<div class="line"><span class="lineno"> 3628</span>        <span class="comment">// pick the vertex which is a terminal vertex (to start search from beginning of sequence)</span></div>
<div class="line"><span class="lineno"> 3629</span>        <span class="comment">// or any vertex (if there are not terminal vertices)</span></div>
<div class="line"><span class="lineno"> 3630</span> </div>
<div class="line"><span class="lineno"> 3631</span>        <span class="comment">// find any intersection point which is not associated with a cut-path and is connected to one edge (terminal vertex)</span></div>
<div class="line"><span class="lineno"> 3632</span>        std::unordered_map&lt;vd_t, std::vector&lt;ed_t&gt;&gt;::const_iterator m0_ivtx_to_cutpath_edges_iter = std::find_if(</div>
<div class="line"><span class="lineno"> 3633</span>            m0_ivtx_to_cutpath_edges.cbegin(), m0_ivtx_to_cutpath_edges.cend(),</div>
<div class="line"><span class="lineno"> 3634</span>            [&amp;](<span class="keyword">const</span> std::pair&lt;<a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a>, std::vector&lt;ed_t&gt;&gt;&amp; elem) {</div>
<div class="line"><span class="lineno"> 3635</span>                bool is_mapped = m0_ivtx_to_cutpath_sequence.find(elem.first) != m0_ivtx_to_cutpath_sequence.cend();</div>
<div class="line"><span class="lineno"> 3636</span>                bool is_connected_to_one_edge = elem.second.size() == 1;</div>
<div class="line"><span class="lineno"> 3637</span>                return (!is_mapped &amp;&amp; is_connected_to_one_edge);</div>
<div class="line"><span class="lineno"> 3638</span>            });</div>
<div class="line"><span class="lineno"> 3639</span> </div>
<div class="line"><span class="lineno"> 3640</span>        <span class="keywordflow">if</span> (m0_ivtx_to_cutpath_edges_iter == m0_ivtx_to_cutpath_edges.cend()) { <span class="comment">// we could not find any intersection point from above</span></div>
<div class="line"><span class="lineno"> 3641</span>            <span class="comment">// find any intersection point which is not mapped to a cut-path (less strict condition that above)</span></div>
<div class="line"><span class="lineno"> 3642</span>            m0_ivtx_to_cutpath_edges_iter = std::find_if(</div>
<div class="line"><span class="lineno"> 3643</span>                m0_ivtx_to_cutpath_edges.cbegin(), m0_ivtx_to_cutpath_edges.cend(),</div>
<div class="line"><span class="lineno"> 3644</span>                [&amp;](<span class="keyword">const</span> std::pair&lt;<a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a>, std::vector&lt;ed_t&gt;&gt;&amp; elem) {</div>
<div class="line"><span class="lineno"> 3645</span>                    bool is_mapped = m0_ivtx_to_cutpath_sequence.find(elem.first) != m0_ivtx_to_cutpath_sequence.cend();</div>
<div class="line"><span class="lineno"> 3646</span>                    return !is_mapped;</div>
<div class="line"><span class="lineno"> 3647</span>                });</div>
<div class="line"><span class="lineno"> 3648</span>        }</div>
<div class="line"><span class="lineno"> 3649</span> </div>
<div class="line"><span class="lineno"> 3650</span>        <span class="keywordflow">if</span> (m0_ivtx_to_cutpath_edges_iter == m0_ivtx_to_cutpath_edges.cend()) { <span class="comment">// still could not find any unmapped intersection point</span></div>
<div class="line"><span class="lineno"> 3651</span>            <span class="keywordflow">break</span>; <span class="comment">// done (found all implicit cut paths)</span></div>
<div class="line"><span class="lineno"> 3652</span>        }</div>
<div class="line"><span class="lineno"> 3653</span> </div>
<div class="line"><span class="lineno"> 3654</span>        <span class="comment">// start new sequence of edges</span></div>
<div class="line"><span class="lineno"> 3655</span>        <span class="comment">// ---------------------------</span></div>
<div class="line"><span class="lineno"> 3656</span> </div>
<div class="line"><span class="lineno"> 3657</span>        m0_cutpath_sequences.emplace_back(std::vector&lt;ed_t&gt;());</div>
<div class="line"><span class="lineno"> 3658</span>        std::vector&lt;ed_t&gt;&amp; cur_cutpath_sequence = m0_cutpath_sequences.back();</div>
<div class="line"><span class="lineno"> 3659</span> </div>
<div class="line"><span class="lineno"> 3660</span>        <span class="comment">// vertex at the beginning of the sequence</span></div>
<div class="line"><span class="lineno"> 3661</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a>&amp; first_vertex_of_sequence = m0_ivtx_to_cutpath_edges_iter-&gt;first;</div>
<div class="line"><span class="lineno"> 3662</span> </div>
<div class="line"><span class="lineno"> 3663</span>        <span class="comment">// the edges connected to our first intersection point</span></div>
<div class="line"><span class="lineno"> 3664</span>        <span class="keyword">const</span> std::vector&lt;ed_t&gt;&amp; cutpath_edges_connected_to_first_vertex = m0_ivtx_to_cutpath_edges_iter-&gt;second;</div>
<div class="line"><span class="lineno"> 3665</span> </div>
<div class="line"><span class="lineno"> 3666</span>        <span class="comment">// pick the edge that is not yet mapped-to/associated-with a  cut-path</span></div>
<div class="line"><span class="lineno"> 3667</span>        <span class="comment">// sequence in &quot;cur_cutpath_sequence&quot;. Note: if the current sequence</span></div>
<div class="line"><span class="lineno"> 3668</span>        <span class="comment">// is linear, then there is no possibility that one of the edges</span></div>
<div class="line"><span class="lineno"> 3669</span>        <span class="comment">// in &quot;cutpath_edges_connected_to_first_vertex&quot; has already been mapped-to/associated-with</span></div>
<div class="line"><span class="lineno"> 3670</span>        <span class="comment">// a disjoint cut-path sequence in &quot;cur_cutpath_sequence&quot;.</span></div>
<div class="line"><span class="lineno"> 3671</span>        <span class="comment">// This is because sequence discovery starts by first searching from terminal vertices/edges</span></div>
<div class="line"><span class="lineno"> 3672</span>        <span class="comment">// (see above conditions).</span></div>
<div class="line"><span class="lineno"> 3673</span>        std::vector&lt;ed_t&gt;::const_iterator incident_edge_find_iter = std::find_if(</div>
<div class="line"><span class="lineno"> 3674</span>            cutpath_edges_connected_to_first_vertex.cbegin(),</div>
<div class="line"><span class="lineno"> 3675</span>            cutpath_edges_connected_to_first_vertex.cend(),</div>
<div class="line"><span class="lineno"> 3676</span>            [&amp;](<span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; incident_edge) {</div>
<div class="line"><span class="lineno"> 3677</span>                return m0_edge_to_cutpath_sequence.find(incident_edge) == m0_edge_to_cutpath_sequence.cend();</div>
<div class="line"><span class="lineno"> 3678</span>            });</div>
<div class="line"><span class="lineno"> 3679</span> </div>
<div class="line"><span class="lineno"> 3680</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(incident_edge_find_iter != cutpath_edges_connected_to_first_vertex.cend());</div>
<div class="line"><span class="lineno"> 3681</span> </div>
<div class="line"><span class="lineno"> 3682</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; first_edge = *incident_edge_find_iter;</div>
<div class="line"><span class="lineno"> 3683</span> </div>
<div class="line"><span class="lineno"> 3684</span>        <span class="comment">// now we will iteratively add edges into the current sequence, starting from &quot;first_edge&quot;.</span></div>
<div class="line"><span class="lineno"> 3685</span>        <span class="comment">// the next added edge is alway one which share&#39;s the &quot;next_vertex&quot; with the current.</span></div>
<div class="line"><span class="lineno"> 3686</span>        <span class="comment">// ----------------------------------------------------------------------------------------</span></div>
<div class="line"><span class="lineno"> 3687</span> </div>
<div class="line"><span class="lineno"> 3688</span>        <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> current_vertex = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ab448d0b9684fd2f648195b2e5edb83f2">hmesh_t::null_vertex</a>();</div>
<div class="line"><span class="lineno"> 3689</span>        <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> current_edge = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aabb2a87d3b736883d381532fb871389e">hmesh_t::null_edge</a>();</div>
<div class="line"><span class="lineno"> 3690</span>        <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> next_vertex = first_vertex_of_sequence; <span class="comment">// ... initial intersection point</span></div>
<div class="line"><span class="lineno"> 3691</span>        <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> next_edge = first_edge;</div>
<div class="line"><span class="lineno"> 3692</span> </div>
<div class="line"><span class="lineno"> 3693</span>        <span class="keywordflow">do</span> { <span class="comment">// an iteration will add an edge to the current cut-path sequence</span></div>
<div class="line"><span class="lineno"> 3694</span> </div>
<div class="line"><span class="lineno"> 3695</span>            <span class="comment">// update state</span></div>
<div class="line"><span class="lineno"> 3696</span>            current_vertex = next_vertex;</div>
<div class="line"><span class="lineno"> 3697</span>            current_edge = next_edge;</div>
<div class="line"><span class="lineno"> 3698</span> </div>
<div class="line"><span class="lineno"> 3699</span>            <span class="comment">// add edge</span></div>
<div class="line"><span class="lineno"> 3700</span>            cur_cutpath_sequence.emplace_back(current_edge);</div>
<div class="line"><span class="lineno"> 3701</span> </div>
<div class="line"><span class="lineno"> 3702</span>            <span class="comment">// map vertex to current disjoint implicit cut-path sequence</span></div>
<div class="line"><span class="lineno"> 3703</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_ivtx_to_cutpath_sequence.count(current_vertex) == 0);</div>
<div class="line"><span class="lineno"> 3704</span>            m0_ivtx_to_cutpath_sequence[current_vertex] = cur_cutpath_sequence_index;</div>
<div class="line"><span class="lineno"> 3705</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_ivtx_to_cutpath_sequence.count(current_vertex) == 1);</div>
<div class="line"><span class="lineno"> 3706</span> </div>
<div class="line"><span class="lineno"> 3707</span>            <span class="comment">// map edge to current disjoint implicit cut-path sequence</span></div>
<div class="line"><span class="lineno"> 3708</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_edge_to_cutpath_sequence.count(current_edge) == 0);</div>
<div class="line"><span class="lineno"> 3709</span>            m0_edge_to_cutpath_sequence[current_edge] = cur_cutpath_sequence_index;</div>
<div class="line"><span class="lineno"> 3710</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_edge_to_cutpath_sequence.count(current_edge) == 1);</div>
<div class="line"><span class="lineno"> 3711</span> </div>
<div class="line"><span class="lineno"> 3712</span>            <span class="comment">// reset state</span></div>
<div class="line"><span class="lineno"> 3713</span>            next_vertex = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ab448d0b9684fd2f648195b2e5edb83f2">hmesh_t::null_vertex</a>();</div>
<div class="line"><span class="lineno"> 3714</span>            next_edge = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aabb2a87d3b736883d381532fb871389e">hmesh_t::null_edge</a>();</div>
<div class="line"><span class="lineno"> 3715</span> </div>
<div class="line"><span class="lineno"> 3716</span>            <span class="comment">// resolve next vertex (..since we don&#39;t know whether vertex0 or vertex1 is &quot;current_vertex&quot;)</span></div>
<div class="line"><span class="lineno"> 3717</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> current_edge_vertex0 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(current_edge, 0);</div>
<div class="line"><span class="lineno"> 3718</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> current_edge_vertex1 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(current_edge, 1);</div>
<div class="line"><span class="lineno"> 3719</span> </div>
<div class="line"><span class="lineno"> 3720</span>            <span class="comment">// &quot;next_vertex&quot; is whichever vertex of the current edge that is not</span></div>
<div class="line"><span class="lineno"> 3721</span>            <span class="comment">// equal to the &quot;current_vertex&quot;</span></div>
<div class="line"><span class="lineno"> 3722</span>            <span class="keywordflow">if</span> (current_vertex == current_edge_vertex0) {</div>
<div class="line"><span class="lineno"> 3723</span>                next_vertex = current_edge_vertex1;</div>
<div class="line"><span class="lineno"> 3724</span>            } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3725</span>                next_vertex = current_edge_vertex0;</div>
<div class="line"><span class="lineno"> 3726</span>            }</div>
<div class="line"><span class="lineno"> 3727</span> </div>
<div class="line"><span class="lineno"> 3728</span>            <span class="comment">// now that we have the next vertex, we can determine the next edge</span></div>
<div class="line"><span class="lineno"> 3729</span>            <span class="comment">// ----------------------------------------------------------------</span></div>
<div class="line"><span class="lineno"> 3730</span> </div>
<div class="line"><span class="lineno"> 3731</span>            <span class="comment">// check if next vertex has already been associated with the cut-path sequence.</span></div>
<div class="line"><span class="lineno"> 3732</span>            <span class="keywordtype">bool</span> reached_end_of_sequence = m0_ivtx_to_cutpath_sequence.find(next_vertex) != m0_ivtx_to_cutpath_sequence.cend();</div>
<div class="line"><span class="lineno"> 3733</span> </div>
<div class="line"><span class="lineno"> 3734</span>            <span class="keywordflow">if</span> (!reached_end_of_sequence) {</div>
<div class="line"><span class="lineno"> 3735</span>                <span class="comment">// get the other edge connected to &quot;next_vertex&quot; i.e. the edge which is not the &quot;current_edge&quot;</span></div>
<div class="line"><span class="lineno"> 3736</span>                m0_ivtx_to_cutpath_edges_iter = m0_ivtx_to_cutpath_edges.find(next_vertex);</div>
<div class="line"><span class="lineno"> 3737</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_ivtx_to_cutpath_edges_iter != m0_ivtx_to_cutpath_edges.cend());</div>
<div class="line"><span class="lineno"> 3738</span> </div>
<div class="line"><span class="lineno"> 3739</span>                <span class="keyword">const</span> std::vector&lt;ed_t&gt;&amp; cutpath_edges_connected_to_next_vertex = m0_ivtx_to_cutpath_edges_iter-&gt;second;</div>
<div class="line"><span class="lineno"> 3740</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(cutpath_edges_connected_to_next_vertex.size() &lt;= 2);</div>
<div class="line"><span class="lineno"> 3741</span> </div>
<div class="line"><span class="lineno"> 3742</span>                <span class="keywordtype">bool</span> current_edge_is_terminal = (cutpath_edges_connected_to_next_vertex.size() == 1);</div>
<div class="line"><span class="lineno"> 3743</span> </div>
<div class="line"><span class="lineno"> 3744</span>                <span class="keywordflow">if</span> (current_edge_is_terminal == <span class="keyword">false</span>) {</div>
<div class="line"><span class="lineno"> 3745</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; edge0 = cutpath_edges_connected_to_next_vertex.front();</div>
<div class="line"><span class="lineno"> 3746</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; edge1 = cutpath_edges_connected_to_next_vertex.back();</div>
<div class="line"><span class="lineno"> 3747</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; other_edge = (current_edge == edge0) ? edge1 : edge0;</div>
<div class="line"><span class="lineno"> 3748</span> </div>
<div class="line"><span class="lineno"> 3749</span>                    <span class="comment">// check that &quot;other_edge&quot; has not already been mapped to a disjoint implicit cutpath sequence</span></div>
<div class="line"><span class="lineno"> 3750</span>                    std::unordered_map&lt;ed_t, int&gt;::const_iterator find_iter = m0_edge_to_cutpath_sequence.find(other_edge);</div>
<div class="line"><span class="lineno"> 3751</span>                    <span class="keywordtype">bool</span> other_edge_is_already_mapped = (find_iter != m0_edge_to_cutpath_sequence.cend());</div>
<div class="line"><span class="lineno"> 3752</span> </div>
<div class="line"><span class="lineno"> 3753</span>                    <span class="keywordflow">if</span> (other_edge_is_already_mapped == <span class="keyword">false</span>) {</div>
<div class="line"><span class="lineno"> 3754</span>                        next_edge = other_edge; <span class="comment">// set sext edge</span></div>
<div class="line"><span class="lineno"> 3755</span>                    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3756</span>                        <span class="comment">// reached end of sequence</span></div>
<div class="line"><span class="lineno"> 3757</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_ivtx_to_cutpath_sequence.count(next_vertex) == 0);</div>
<div class="line"><span class="lineno"> 3758</span>                        <span class="comment">// need to update this state here because we wont jump back up to the top of the loop as in the normal case.</span></div>
<div class="line"><span class="lineno"> 3759</span>                        <span class="comment">// This is because &quot;next_edge&quot; is null, and the do-while loop continues iff &quot;next_edge != hmesh_t::null_edge()&quot;</span></div>
<div class="line"><span class="lineno"> 3760</span>                        m0_ivtx_to_cutpath_sequence[next_vertex] = cur_cutpath_sequence_index;</div>
<div class="line"><span class="lineno"> 3761</span> </div>
<div class="line"><span class="lineno"> 3762</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_ivtx_to_cutpath_sequence.count(next_vertex) == 1);</div>
<div class="line"><span class="lineno"> 3763</span>                    }</div>
<div class="line"><span class="lineno"> 3764</span>                } <span class="comment">// if (current_edge_is_terminal == false) {</span></div>
<div class="line"><span class="lineno"> 3765</span>                <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3766</span>                    m0_ivtx_to_cutpath_sequence[next_vertex] = cur_cutpath_sequence_index;</div>
<div class="line"><span class="lineno"> 3767</span>                }</div>
<div class="line"><span class="lineno"> 3768</span>            } <span class="comment">// if (!reached_end_of_sequence) {</span></div>
<div class="line"><span class="lineno"> 3769</span> </div>
<div class="line"><span class="lineno"> 3770</span>            <span class="comment">// while there is another edge to added to the current disjoint implicit cutpath sequence</span></div>
<div class="line"><span class="lineno"> 3771</span>        } <span class="keywordflow">while</span> (next_edge != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aabb2a87d3b736883d381532fb871389e">hmesh_t::null_edge</a>());</div>
<div class="line"><span class="lineno"> 3772</span> </div>
<div class="line"><span class="lineno"> 3773</span>        <span class="comment">// while not all intersection-points have been mapped to a disjoint implicit cutpath sequence</span></div>
<div class="line"><span class="lineno"> 3774</span>    } <span class="keywordflow">while</span> (m0_edge_to_cutpath_sequence.size() != m0_cutpath_edges.size());</div>
<div class="line"><span class="lineno"> 3775</span> </div>
<div class="line"><span class="lineno"> 3776</span>    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_cutpath_sequences.empty() == <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno"> 3777</span> </div>
<div class="line"><span class="lineno"> 3778</span>    <span class="comment">// delink the implicit cut-path sequences to create the final explicit cut-path sequences</span></div>
<div class="line"><span class="lineno"> 3779</span>    <span class="comment">// --------------------------------------------------------------------------------------</span></div>
<div class="line"><span class="lineno"> 3780</span> </div>
<div class="line"><span class="lineno"> 3781</span>    m0_cutpath_edges.clear(); <span class="comment">// free</span></div>
<div class="line"><span class="lineno"> 3782</span> </div>
<div class="line"><span class="lineno"> 3783</span>    m0_edge_to_cutpath_sequence.clear(); <span class="comment">// free</span></div>
<div class="line"><span class="lineno"> 3784</span>    <span class="comment">// m0_ivtx_to_cutpath_edges.clear();      // free</span></div>
<div class="line"><span class="lineno"> 3785</span>    <span class="comment">// m0_cutpath_sequences.clear(); // free</span></div>
<div class="line"><span class="lineno"> 3786</span> </div>
<div class="line"><span class="lineno"> 3787</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 3788</span> </div>
<div class="line"><span class="lineno"> 3789</span>    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_cutpath_sequences.empty() == <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno"> 3790</span> </div>
<div class="line"><span class="lineno"> 3791</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> num_explicit_cutpath_sequences = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)m0_cutpath_sequences.size();</div>
<div class="line"><span class="lineno"> 3792</span> </div>
<div class="line"><span class="lineno"> 3793</span>    <span class="comment">// save cut-path sequence properties (linear/circular;is_hole)</span></div>
<div class="line"><span class="lineno"> 3794</span>    <span class="comment">// -----------------------------------------------------------------------</span></div>
<div class="line"><span class="lineno"> 3795</span> </div>
<div class="line"><span class="lineno"> 3796</span>    <span class="comment">// first we need to find all intersection points which have a border source-mesh</span></div>
<div class="line"><span class="lineno"> 3797</span>    <span class="comment">// halfedge in their intersection registry. We need this data structure to allow</span></div>
<div class="line"><span class="lineno"> 3798</span>    <span class="comment">// us to determine the properties of the cut-paths</span></div>
<div class="line"><span class="lineno"> 3799</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 3800</span> </div>
<div class="line"><span class="lineno"> 3801</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Infer cutpath info&quot;</span>);</div>
<div class="line"><span class="lineno"> 3802</span> </div>
<div class="line"><span class="lineno"> 3803</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 3804</span>    <span class="comment">// MapKey=intersection point on a border halfedge of either the source-mesh or cut-mesh</span></div>
<div class="line"><span class="lineno"> 3805</span>    <span class="comment">// MapValue=pointer entry in &quot;m0_ivtx_to_ps_edge&quot;</span></div>
<div class="line"><span class="lineno"> 3806</span>    std::map&lt;vd_t, std::vector&lt;std::pair&lt;ed_t, fd_t&gt;&gt;::const_iterator&gt; m0_cutpath_terminal_vertices;</div>
<div class="line"><span class="lineno"> 3807</span> </div>
<div class="line"><span class="lineno"> 3808</span>    <span class="keywordflow">for</span> (std::vector&lt;std::pair&lt;ed_t, fd_t&gt;&gt;::const_iterator iter = m0_ivtx_to_intersection_registry_entry.cbegin();</div>
<div class="line"><span class="lineno"> 3809</span>         iter != m0_ivtx_to_intersection_registry_entry.cend();</div>
<div class="line"><span class="lineno"> 3810</span>         ++iter) {</div>
<div class="line"><span class="lineno"> 3811</span> </div>
<div class="line"><span class="lineno"> 3812</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a>&amp; ivtx = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a>((std::uint32_t)<a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(m0_ivtx_to_intersection_registry_entry.cbegin(), iter) + ps_vtx_cnt); <span class="comment">// iter-&gt;first;</span></div>
<div class="line"><span class="lineno"> 3813</span> </div>
<div class="line"><span class="lineno"> 3814</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> edge_of_ivtx_ps_he = iter-&gt;first; <span class="comment">// iter-&gt;second.first; // ps.edge(ivtx_ps_he);</span></div>
<div class="line"><span class="lineno"> 3815</span>        <span class="comment">// check that &quot;ivtx_ps_he&quot; is a border halfedge</span></div>
<div class="line"><span class="lineno"> 3816</span>        <span class="keywordflow">if</span> (ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a56a93aa8ba1f69b11d91c8fb2a9b3913">is_border</a>(edge_of_ivtx_ps_he)) {</div>
<div class="line"><span class="lineno"> 3817</span>            <span class="comment">// we have found a terminal vertex</span></div>
<div class="line"><span class="lineno"> 3818</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_cutpath_terminal_vertices.count(ivtx) == 0);</div>
<div class="line"><span class="lineno"> 3819</span>            m0_cutpath_terminal_vertices[ivtx] = iter;</div>
<div class="line"><span class="lineno"> 3820</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_cutpath_terminal_vertices.count(ivtx) == 1);</div>
<div class="line"><span class="lineno"> 3821</span>        }</div>
<div class="line"><span class="lineno"> 3822</span>    }</div>
<div class="line"><span class="lineno"> 3823</span> </div>
<div class="line"><span class="lineno"> 3824</span>    <span class="comment">// MapKey=index of an explicit cutpath in  m0_cutpath_sequences</span></div>
<div class="line"><span class="lineno"> 3825</span>    <span class="comment">// MapValue=a tuple of boolean properties (is_linear, is_hole, is_srcmesh_severing).</span></div>
<div class="line"><span class="lineno"> 3826</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 3827</span>    <span class="comment">// if is_linear is false, then the cut path is &quot;circular&quot; and &quot;is_hole&quot; will</span></div>
<div class="line"><span class="lineno"> 3828</span>    <span class="comment">// always be true in this specific case.</span></div>
<div class="line"><span class="lineno"> 3829</span>    <span class="comment">// if is_linear is true, then the cutpath may or may not be a source-mesh severing cutpath (depends on</span></div>
<div class="line"><span class="lineno"> 3830</span>    <span class="comment">// whether we have a partial cut or not)</span></div>
<div class="line"><span class="lineno"> 3831</span>    <span class="comment">// if is_circular is true, then the cutpath is always severing.</span></div>
<div class="line"><span class="lineno"> 3832</span>    std::map&lt;int, std::tuple&lt;bool, bool, bool&gt;&gt; m0_cutpath_sequence_to_properties;</div>
<div class="line"><span class="lineno"> 3833</span> </div>
<div class="line"><span class="lineno"> 3834</span>    <span class="keywordflow">for</span> (std::vector&lt;std::vector&lt;ed_t&gt;&gt;::const_iterator iter = m0_cutpath_sequences.cbegin();</div>
<div class="line"><span class="lineno"> 3835</span>         iter != m0_cutpath_sequences.cend();</div>
<div class="line"><span class="lineno"> 3836</span>         ++iter) {</div>
<div class="line"><span class="lineno"> 3837</span> </div>
<div class="line"><span class="lineno"> 3838</span>        <span class="keyword">const</span> <span class="keywordtype">int</span> cutpath_index = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)<a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(m0_cutpath_sequences.cbegin(), iter);</div>
<div class="line"><span class="lineno"> 3839</span> </div>
<div class="line"><span class="lineno"> 3840</span>        <span class="keyword">const</span> std::vector&lt;ed_t&gt;&amp; cutpath = *iter;</div>
<div class="line"><span class="lineno"> 3841</span> </div>
<div class="line"><span class="lineno"> 3842</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_cutpath_sequence_to_properties.count(cutpath_index) == 0);</div>
<div class="line"><span class="lineno"> 3843</span>        m0_cutpath_sequence_to_properties[cutpath_index] = std::tuple&lt;bool, bool, bool&gt;();</div>
<div class="line"><span class="lineno"> 3844</span> </div>
<div class="line"><span class="lineno"> 3845</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_cutpath_sequence_to_properties.count(cutpath_index) == 1);</div>
<div class="line"><span class="lineno"> 3846</span> </div>
<div class="line"><span class="lineno"> 3847</span>        std::tuple&lt;bool, bool, bool&gt;&amp; properties = m0_cutpath_sequence_to_properties[cutpath_index];</div>
<div class="line"><span class="lineno"> 3848</span>        <span class="keywordtype">bool</span>&amp; cutpath_is_linear = std::get&lt;0&gt;(properties);</div>
<div class="line"><span class="lineno"> 3849</span>        <span class="keywordtype">bool</span>&amp; cutpath_is_hole = std::get&lt;1&gt;(properties);</div>
<div class="line"><span class="lineno"> 3850</span>        <span class="keywordtype">bool</span>&amp; cutpath_is_srcmesh_severing = std::get&lt;2&gt;(properties); <span class="comment">// i.e. the cutpath severs/partitions the src-mesh into two parts</span></div>
<div class="line"><span class="lineno"> 3851</span> </div>
<div class="line"><span class="lineno"> 3852</span>        cutpath_is_linear = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 3853</span>        cutpath_is_hole = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 3854</span>        cutpath_is_srcmesh_severing = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 3855</span> </div>
<div class="line"><span class="lineno"> 3856</span>        <span class="comment">// check if it is a linear cut path</span></div>
<div class="line"><span class="lineno"> 3857</span> </div>
<div class="line"><span class="lineno"> 3858</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; first_edge = cutpath.front();</div>
<div class="line"><span class="lineno"> 3859</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> first_edge_vertex0 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(first_edge, 0);</div>
<div class="line"><span class="lineno"> 3860</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> first_edge_vertex1 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(first_edge, 1);</div>
<div class="line"><span class="lineno"> 3861</span>        <span class="keywordtype">bool</span> first_edge_vertex0_is_terminal = m0_cutpath_terminal_vertices.find(first_edge_vertex0) != m0_cutpath_terminal_vertices.cend();</div>
<div class="line"><span class="lineno"> 3862</span> </div>
<div class="line"><span class="lineno"> 3863</span>        <span class="keywordtype">bool</span> first_edge_is_terminal = first_edge_vertex0_is_terminal;</div>
<div class="line"><span class="lineno"> 3864</span> </div>
<div class="line"><span class="lineno"> 3865</span>        <span class="keywordflow">if</span> (first_edge_vertex0_is_terminal == <span class="keyword">false</span>) {</div>
<div class="line"><span class="lineno"> 3866</span>            <span class="comment">// check if vertex1 is terminal</span></div>
<div class="line"><span class="lineno"> 3867</span>            <span class="keywordtype">bool</span> first_edge_vertex1_is_terminal = m0_cutpath_terminal_vertices.find(first_edge_vertex1) != m0_cutpath_terminal_vertices.cend();</div>
<div class="line"><span class="lineno"> 3868</span>            first_edge_is_terminal = first_edge_vertex1_is_terminal;</div>
<div class="line"><span class="lineno"> 3869</span>        }</div>
<div class="line"><span class="lineno"> 3870</span> </div>
<div class="line"><span class="lineno"> 3871</span>        <span class="comment">// note: by construction, if the first edge is terminal then the</span></div>
<div class="line"><span class="lineno"> 3872</span>        <span class="comment">// last edge will also be terminal (thus we could have used the</span></div>
<div class="line"><span class="lineno"> 3873</span>        <span class="comment">// last edge for the above tests too!)</span></div>
<div class="line"><span class="lineno"> 3874</span>        cutpath_is_linear = first_edge_is_terminal;</div>
<div class="line"><span class="lineno"> 3875</span> </div>
<div class="line"><span class="lineno"> 3876</span>        <span class="keywordtype">bool</span> cutpath_is_circular = !cutpath_is_linear;</div>
<div class="line"><span class="lineno"> 3877</span>        <span class="comment">// check if a hole is created by the cutpath (which will need sealing later)</span></div>
<div class="line"><span class="lineno"> 3878</span>        <span class="keywordflow">if</span> (cutpath_is_circular) {</div>
<div class="line"><span class="lineno"> 3879</span>            cutpath_is_hole = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 3880</span>        } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3881</span>            <span class="comment">// current cut path is [linear]. it creates a hole (in the source mesh) if both terminal vertices</span></div>
<div class="line"><span class="lineno"> 3882</span>            <span class="comment">// have a cut-mesh halfedge in their registry</span></div>
<div class="line"><span class="lineno"> 3883</span> </div>
<div class="line"><span class="lineno"> 3884</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a>&amp; first_edge_terminal_vertex = (first_edge_vertex0_is_terminal ? first_edge_vertex0 : first_edge_vertex1);</div>
<div class="line"><span class="lineno"> 3885</span> </div>
<div class="line"><span class="lineno"> 3886</span>            <span class="comment">// get the halfedge and check where is comes from (cut-mesh/source-mesh)</span></div>
<div class="line"><span class="lineno"> 3887</span> </div>
<div class="line"><span class="lineno"> 3888</span>            std::map&lt;vd_t, std::vector&lt;std::pair&lt;ed_t, fd_t&gt;&gt;::const_iterator&gt;::const_iterator find_iter = m0_cutpath_terminal_vertices.cend();</div>
<div class="line"><span class="lineno"> 3889</span>            find_iter = m0_cutpath_terminal_vertices.find(first_edge_terminal_vertex);</div>
<div class="line"><span class="lineno"> 3890</span> </div>
<div class="line"><span class="lineno"> 3891</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(find_iter != m0_cutpath_terminal_vertices.cend());</div>
<div class="line"><span class="lineno"> 3892</span> </div>
<div class="line"><span class="lineno"> 3893</span>            <span class="comment">// TODO: These variable names are outdated</span></div>
<div class="line"><span class="lineno"> 3894</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; first_edge_terminal_vertex_edge = find_iter-&gt;second-&gt;first;</div>
<div class="line"><span class="lineno"> 3895</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> first_edge_terminal_vertex_edge_h0 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(first_edge_terminal_vertex_edge, 0);</div>
<div class="line"><span class="lineno"> 3896</span>            <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> ps_face_of_first_edge_terminal_vertex_he = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(first_edge_terminal_vertex_edge_h0);</div>
<div class="line"><span class="lineno"> 3897</span>            <span class="keywordflow">if</span> (ps_face_of_first_edge_terminal_vertex_he == <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>()) {</div>
<div class="line"><span class="lineno"> 3898</span>                <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> first_edge_terminal_vertex_edge_h1 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(first_edge_terminal_vertex_edge_h0);</div>
<div class="line"><span class="lineno"> 3899</span>                ps_face_of_first_edge_terminal_vertex_he = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(first_edge_terminal_vertex_edge_h1);</div>
<div class="line"><span class="lineno"> 3900</span>            }</div>
<div class="line"><span class="lineno"> 3901</span> </div>
<div class="line"><span class="lineno"> 3902</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ps_face_of_first_edge_terminal_vertex_he != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>());</div>
<div class="line"><span class="lineno"> 3903</span> </div>
<div class="line"><span class="lineno"> 3904</span>            <span class="keywordtype">bool</span> is_from_cut_mesh = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aaf65fb11520f9cb197774e79efeddfbb">ps_is_cutmesh_face</a>(ps_face_of_first_edge_terminal_vertex_he, sm_face_count);</div>
<div class="line"><span class="lineno"> 3905</span>            <span class="keywordtype">bool</span> is_from_src_mesh = !is_from_cut_mesh;</div>
<div class="line"><span class="lineno"> 3906</span> </div>
<div class="line"><span class="lineno"> 3907</span>            <span class="keyword">const</span> <span class="keywordtype">bool</span> first_vtx_is_from_src_mesh = is_from_src_mesh;</div>
<div class="line"><span class="lineno"> 3908</span>            <span class="comment">/*</span></div>
<div class="line"><span class="lineno"> 3909</span><span class="comment">        if (is_from_src_mesh) {</span></div>
<div class="line"><span class="lineno"> 3910</span><span class="comment">            cutpath_is_hole = false;</span></div>
<div class="line"><span class="lineno"> 3911</span><span class="comment">        }</span></div>
<div class="line"><span class="lineno"> 3912</span><span class="comment">        else</span></div>
<div class="line"><span class="lineno"> 3913</span><span class="comment">        {*/</span></div>
<div class="line"><span class="lineno"> 3914</span>            <span class="comment">// ... so the halfedge in the registry of &quot;first_edge_terminal_vertex&quot;</span></div>
<div class="line"><span class="lineno"> 3915</span>            <span class="comment">// belongs to the cut-mesh. Now let us repeat the same test but this</span></div>
<div class="line"><span class="lineno"> 3916</span>            <span class="comment">// time for the &quot;last_edge_terminal_vertex&quot;</span></div>
<div class="line"><span class="lineno"> 3917</span> </div>
<div class="line"><span class="lineno"> 3918</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; last_edge = cutpath.back();</div>
<div class="line"><span class="lineno"> 3919</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> last_edge_vertex0 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(last_edge, 0);</div>
<div class="line"><span class="lineno"> 3920</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> last_edge_vertex1 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(last_edge, 1);</div>
<div class="line"><span class="lineno"> 3921</span>            <span class="keywordtype">bool</span> last_edge_vertex0_is_terminal = m0_cutpath_terminal_vertices.find(last_edge_vertex0) != m0_cutpath_terminal_vertices.cend();</div>
<div class="line"><span class="lineno"> 3922</span> </div>
<div class="line"><span class="lineno"> 3923</span>            <span class="comment">// bool last_edge_is_terminal = last_edge_vertex0_is_terminal;</span></div>
<div class="line"><span class="lineno"> 3924</span> </div>
<div class="line"><span class="lineno"> 3925</span>            <span class="comment">// if (last_edge_vertex0_is_terminal == false)</span></div>
<div class="line"><span class="lineno"> 3926</span>            <span class="comment">//{</span></div>
<div class="line"><span class="lineno"> 3927</span>            <span class="comment">//  check if vertex1 is terminal</span></div>
<div class="line"><span class="lineno"> 3928</span>            <span class="comment">// bool last_edge_vertex1_is_terminal = m0_cutpath_terminal_vertices.find(last_edge_vertex1) != m0_cutpath_terminal_vertices.cend();</span></div>
<div class="line"><span class="lineno"> 3929</span>            <span class="comment">// last_edge_is_terminal = last_edge_vertex1_is_terminal;</span></div>
<div class="line"><span class="lineno"> 3930</span>            <span class="comment">//}</span></div>
<div class="line"><span class="lineno"> 3931</span> </div>
<div class="line"><span class="lineno"> 3932</span>            <span class="keywordtype">bool</span> last_vtx_is_from_src_mesh = first_vtx_is_from_src_mesh; <span class="comment">// ... we will use this to determine whether we have a severing cutpath or not (the current one)</span></div>
<div class="line"><span class="lineno"> 3933</span> </div>
<div class="line"><span class="lineno"> 3934</span>            <span class="comment">// MCUT_ASSERT(last_edge_is_terminal); // i.e. we have a linear cut path</span></div>
<div class="line"><span class="lineno"> 3935</span>            <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> last_edge_terminal_vertex = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ab448d0b9684fd2f648195b2e5edb83f2">hmesh_t::null_vertex</a>();</div>
<div class="line"><span class="lineno"> 3936</span> </div>
<div class="line"><span class="lineno"> 3937</span>            <span class="keywordflow">if</span> (last_edge == first_edge) <span class="comment">// sequence has one edge</span></div>
<div class="line"><span class="lineno"> 3938</span>            {</div>
<div class="line"><span class="lineno"> 3939</span>                last_edge_terminal_vertex = (first_edge_terminal_vertex == last_edge_vertex0) ? last_edge_vertex1 : last_edge_vertex0;</div>
<div class="line"><span class="lineno"> 3940</span>            } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3941</span>                last_edge_terminal_vertex = (last_edge_vertex0_is_terminal ? last_edge_vertex0 : last_edge_vertex1);</div>
<div class="line"><span class="lineno"> 3942</span>            }</div>
<div class="line"><span class="lineno"> 3943</span> </div>
<div class="line"><span class="lineno"> 3944</span>            <span class="comment">// get the halfedge and check where is comes from (cut-mesh/src-mesh)</span></div>
<div class="line"><span class="lineno"> 3945</span> </div>
<div class="line"><span class="lineno"> 3946</span>            <span class="comment">// std::map&lt;vd_t, std::map&lt;vd_t, hd_t&gt;::const_iterator&gt;::const_iterator find_iter = m0_cutpath_terminal_vertices.cend();</span></div>
<div class="line"><span class="lineno"> 3947</span>            find_iter = m0_cutpath_terminal_vertices.find(last_edge_terminal_vertex);</div>
<div class="line"><span class="lineno"> 3948</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(find_iter != m0_cutpath_terminal_vertices.cend());</div>
<div class="line"><span class="lineno"> 3949</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; last_edge_terminal_vertex_e = find_iter-&gt;second-&gt;first;</div>
<div class="line"><span class="lineno"> 3950</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> last_edge_terminal_vertex_e_h0 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(last_edge_terminal_vertex_e, 0);</div>
<div class="line"><span class="lineno"> 3951</span>            <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> ps_face_of_last_edge_terminal_vertex_he = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(last_edge_terminal_vertex_e_h0);</div>
<div class="line"><span class="lineno"> 3952</span> </div>
<div class="line"><span class="lineno"> 3953</span>            <span class="keywordflow">if</span> (ps_face_of_last_edge_terminal_vertex_he == <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>()) {</div>
<div class="line"><span class="lineno"> 3954</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> last_edge_terminal_vertex_e_h1 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(last_edge_terminal_vertex_e_h0);</div>
<div class="line"><span class="lineno"> 3955</span>                ps_face_of_last_edge_terminal_vertex_he = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(last_edge_terminal_vertex_e_h1);</div>
<div class="line"><span class="lineno"> 3956</span>            }</div>
<div class="line"><span class="lineno"> 3957</span> </div>
<div class="line"><span class="lineno"> 3958</span>            <span class="comment">// must exist because &quot;ivtx_ps_he&quot; came from an intersecting face in the</span></div>
<div class="line"><span class="lineno"> 3959</span>            <span class="comment">// polygon soup</span></div>
<div class="line"><span class="lineno"> 3960</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ps_face_of_last_edge_terminal_vertex_he != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>());</div>
<div class="line"><span class="lineno"> 3961</span> </div>
<div class="line"><span class="lineno"> 3962</span>            is_from_cut_mesh = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aaf65fb11520f9cb197774e79efeddfbb">ps_is_cutmesh_face</a>(ps_face_of_last_edge_terminal_vertex_he, sm_face_count);</div>
<div class="line"><span class="lineno"> 3963</span>            is_from_src_mesh = !is_from_cut_mesh;</div>
<div class="line"><span class="lineno"> 3964</span> </div>
<div class="line"><span class="lineno"> 3965</span>            last_vtx_is_from_src_mesh = is_from_src_mesh;</div>
<div class="line"><span class="lineno"> 3966</span> </div>
<div class="line"><span class="lineno"> 3967</span>            <span class="comment">// if (is_from_cut_mesh) {</span></div>
<div class="line"><span class="lineno"> 3968</span>            <span class="comment">//     cutpath_is_hole = true;</span></div>
<div class="line"><span class="lineno"> 3969</span>            <span class="comment">// }</span></div>
<div class="line"><span class="lineno"> 3970</span>            <span class="comment">//  }</span></div>
<div class="line"><span class="lineno"> 3971</span>            cutpath_is_hole = (!last_vtx_is_from_src_mesh &amp;&amp; !first_vtx_is_from_src_mesh);</div>
<div class="line"><span class="lineno"> 3972</span>            cutpath_is_srcmesh_severing = (first_vtx_is_from_src_mesh &amp;&amp; (last_vtx_is_from_src_mesh <span class="comment">/* == first_vtx_is_from_src_mesh*/</span>));</div>
<div class="line"><span class="lineno"> 3973</span>            <span class="comment">//}</span></div>
<div class="line"><span class="lineno"> 3974</span>        }</div>
<div class="line"><span class="lineno"> 3975</span>    }</div>
<div class="line"><span class="lineno"> 3976</span> </div>
<div class="line"><span class="lineno"> 3977</span>    m0_cutpath_terminal_vertices.clear(); <span class="comment">// free</span></div>
<div class="line"><span class="lineno"> 3978</span> </div>
<div class="line"><span class="lineno"> 3979</span>    <span class="keywordtype">int</span> num_explicit_linear_cutpaths = 0;</div>
<div class="line"><span class="lineno"> 3980</span>    <span class="keywordtype">int</span> num_explicit_circular_cutpaths = 0;</div>
<div class="line"><span class="lineno"> 3981</span>    std::vector&lt;int&gt; explicit_cutpaths_making_holes;</div>
<div class="line"><span class="lineno"> 3982</span>    std::vector&lt;int&gt; explicit_cutpaths_severing_srcmesh;</div>
<div class="line"><span class="lineno"> 3983</span> </div>
<div class="line"><span class="lineno"> 3984</span>    <span class="keywordflow">for</span> (std::map&lt;<span class="keywordtype">int</span>, std::tuple&lt;bool, bool, bool&gt;&gt;::const_iterator iter = m0_cutpath_sequence_to_properties.cbegin();</div>
<div class="line"><span class="lineno"> 3985</span>         iter != m0_cutpath_sequence_to_properties.cend(); ++iter) {</div>
<div class="line"><span class="lineno"> 3986</span>        <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; explicit_cutpath_index = iter-&gt;first;</div>
<div class="line"><span class="lineno"> 3987</span>        <span class="keyword">const</span> std::tuple&lt;bool, bool, bool&gt;&amp; properties = iter-&gt;second;</div>
<div class="line"><span class="lineno"> 3988</span> </div>
<div class="line"><span class="lineno"> 3989</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; is_linear = std::get&lt;0&gt;(properties);</div>
<div class="line"><span class="lineno"> 3990</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; is_hole = std::get&lt;1&gt;(properties);</div>
<div class="line"><span class="lineno"> 3991</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; is_srcmesh_severing = std::get&lt;2&gt;(properties);</div>
<div class="line"><span class="lineno"> 3992</span> </div>
<div class="line"><span class="lineno"> 3993</span>        <span class="keywordflow">if</span> (is_linear) {</div>
<div class="line"><span class="lineno"> 3994</span>            num_explicit_linear_cutpaths += 1;</div>
<div class="line"><span class="lineno"> 3995</span>        } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 3996</span>            num_explicit_circular_cutpaths += 1;</div>
<div class="line"><span class="lineno"> 3997</span>        }</div>
<div class="line"><span class="lineno"> 3998</span> </div>
<div class="line"><span class="lineno"> 3999</span>        <span class="keywordflow">if</span> (is_hole) {</div>
<div class="line"><span class="lineno"> 4000</span>            explicit_cutpaths_making_holes.push_back(explicit_cutpath_index);</div>
<div class="line"><span class="lineno"> 4001</span>        }</div>
<div class="line"><span class="lineno"> 4002</span> </div>
<div class="line"><span class="lineno"> 4003</span>        <span class="keywordflow">if</span> (is_srcmesh_severing) {</div>
<div class="line"><span class="lineno"> 4004</span>            explicit_cutpaths_severing_srcmesh.push_back(explicit_cutpath_index);</div>
<div class="line"><span class="lineno"> 4005</span>        }</div>
<div class="line"><span class="lineno"> 4006</span>    }</div>
<div class="line"><span class="lineno"> 4007</span> </div>
<div class="line"><span class="lineno"> 4008</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 4009</span> </div>
<div class="line"><span class="lineno"> 4010</span>    <span class="comment">// NOTE:    at this point we have all vertices, edges, and the lists of</span></div>
<div class="line"><span class="lineno"> 4011</span>    <span class="comment">//          edge sequences identifying the cutpaths</span></div>
<div class="line"><span class="lineno"> 4012</span>    <span class="comment">// =====================================================================</span></div>
<div class="line"><span class="lineno"> 4013</span> </div>
<div class="line"><span class="lineno"> 4014</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 4015</span>        <span class="comment">// Detect degeneracy (see note &quot;limitations&quot;)</span></div>
<div class="line"><span class="lineno"> 4016</span>        <span class="comment">//--------------------------------------------</span></div>
<div class="line"><span class="lineno"> 4017</span> </div>
<div class="line"><span class="lineno"> 4018</span>        <span class="keywordtype">bool</span> have_more_than_one_cutpath = (m0_cutpath_sequences.size() &gt; 0);</div>
<div class="line"><span class="lineno"> 4019</span>        <span class="keywordflow">if</span> (have_more_than_one_cutpath)</div>
<div class="line"><span class="lineno"> 4020</span>        {</div>
<div class="line"><span class="lineno"> 4021</span>            <span class="keywordtype">bool</span> atleast_one_cutpath_makes_a_hole = !explicit_cutpaths_making_holes.empty();</div>
<div class="line"><span class="lineno"> 4022</span>            <span class="comment">//bool atleast_one_explicit_cutpath_is_linear = num_explicit_linear_cutpaths;</span></div>
<div class="line"><span class="lineno"> 4023</span>            <span class="keywordflow">if</span> (atleast_one_cutpath_makes_a_hole)</div>
<div class="line"><span class="lineno"> 4024</span>            {</div>
<div class="line"><span class="lineno"> 4025</span>                <span class="comment">// TODO</span></div>
<div class="line"><span class="lineno"> 4026</span>            }</div>
<div class="line"><span class="lineno"> 4027</span>        }</div>
<div class="line"><span class="lineno"> 4028</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 4029</span> </div>
<div class="line"><span class="lineno"> 4030</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Detect floating polygons&quot;</span>);</div>
<div class="line"><span class="lineno"> 4031</span> </div>
<div class="line"><span class="lineno"> 4032</span>    <span class="comment">// Detect floating polygons</span></div>
<div class="line"><span class="lineno"> 4033</span>    <span class="comment">// ::::::::::::::::::::::::</span></div>
<div class="line"><span class="lineno"> 4034</span>    <span class="comment">// NOTE: The following code is what we used to determine when to do polygon partitioning in the front end</span></div>
<div class="line"><span class="lineno"> 4035</span> </div>
<div class="line"><span class="lineno"> 4036</span>    <span class="comment">// for each circular cut-path (i.e. those making a hole)</span></div>
<div class="line"><span class="lineno"> 4037</span>    <span class="keywordflow">for</span> (std::vector&lt;int&gt;::const_iterator it = explicit_cutpaths_making_holes.cbegin(); it != explicit_cutpaths_making_holes.cend(); ++it) {</div>
<div class="line"><span class="lineno"> 4038</span>        <span class="keyword">const</span> <span class="keywordtype">int</span> cutpath_idx = *it;</div>
<div class="line"><span class="lineno"> 4039</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_cutpath_sequence_to_properties.find(cutpath_idx) != m0_cutpath_sequence_to_properties.cend());</div>
<div class="line"><span class="lineno"> 4040</span>        <span class="keyword">const</span> std::tuple&lt;bool, bool, bool&gt;&amp; properties = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_cutpath_sequence_to_properties, cutpath_idx);</div>
<div class="line"><span class="lineno"> 4041</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; is_linear = std::get&lt;0&gt;(properties);</div>
<div class="line"><span class="lineno"> 4042</span>        <span class="keywordtype">bool</span> is_circular = !is_linear;</div>
<div class="line"><span class="lineno"> 4043</span> </div>
<div class="line"><span class="lineno"> 4044</span>        <span class="keywordflow">if</span> (!is_circular) {</div>
<div class="line"><span class="lineno"> 4045</span>            <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 4046</span>        }</div>
<div class="line"><span class="lineno"> 4047</span> </div>
<div class="line"><span class="lineno"> 4048</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(cutpath_idx &lt; (<span class="keywordtype">int</span>)m0_cutpath_sequences.size());</div>
<div class="line"><span class="lineno"> 4049</span>        <span class="keyword">const</span> std::vector&lt;ed_t&gt;&amp; cutpath_sequence = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_cutpath_sequences, cutpath_idx);</div>
<div class="line"><span class="lineno"> 4050</span> </div>
<div class="line"><span class="lineno"> 4051</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(cutpath_sequence.size() &gt;= 3); <span class="comment">// triangle</span></div>
<div class="line"><span class="lineno"> 4052</span> </div>
<div class="line"><span class="lineno"> 4053</span>        <span class="comment">// :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</span></div>
<div class="line"><span class="lineno"> 4054</span>        <span class="comment">// Detect a floating polygon as &quot;one which is not connectable to other</span></div>
<div class="line"><span class="lineno"> 4055</span>        <span class="comment">// [traced] polygons by an edge&quot;. In practice, these polygons are represented</span></div>
<div class="line"><span class="lineno"> 4056</span>        <span class="comment">// by circular cutpaths whose vertices are intersection points that have a</span></div>
<div class="line"><span class="lineno"> 4057</span>        <span class="comment">// tested/intersected face in their registry entry from the same input mesh</span></div>
<div class="line"><span class="lineno"> 4058</span>        <span class="keywordtype">bool</span> is_floating_polygon = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 4059</span>        <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> shared_registry_entry_intersected_face = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>();</div>
<div class="line"><span class="lineno"> 4060</span>        <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> vertex_prev = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ab448d0b9684fd2f648195b2e5edb83f2">hmesh_t::null_vertex</a>();</div>
<div class="line"><span class="lineno"> 4061</span>        <span class="keywordflow">for</span> (std::vector&lt;ed_t&gt;::const_iterator cp_edge_iter = cutpath_sequence.cbegin(); cp_edge_iter != cutpath_sequence.cend(); cp_edge_iter++) {</div>
<div class="line"><span class="lineno"> 4062</span>            <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> v = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(*cp_edge_iter, 0);</div>
<div class="line"><span class="lineno"> 4063</span>            <span class="keywordflow">if</span> (vertex_prev != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ab448d0b9684fd2f648195b2e5edb83f2">hmesh_t::null_vertex</a>() &amp;&amp; v == vertex_prev) {</div>
<div class="line"><span class="lineno"> 4064</span>                v = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(*cp_edge_iter, 1);</div>
<div class="line"><span class="lineno"> 4065</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(v != vertex_prev);</div>
<div class="line"><span class="lineno"> 4066</span>            }</div>
<div class="line"><span class="lineno"> 4067</span> </div>
<div class="line"><span class="lineno"> 4068</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(v, ps_vtx_cnt));</div>
<div class="line"><span class="lineno"> 4069</span> </div>
<div class="line"><span class="lineno"> 4070</span>            <span class="comment">// std::map&lt;vd_t, std::pair&lt;ed_t, fd_t&gt;&gt;::const_iterator v_to_intersection_registry_entry = m0_ivtx_to_intersection_registry_entry.find(v);</span></div>
<div class="line"><span class="lineno"> 4071</span>            <span class="keywordflow">if</span> (shared_registry_entry_intersected_face == <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>()) {</div>
<div class="line"><span class="lineno"> 4072</span>                shared_registry_entry_intersected_face = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, (std::size_t)v - ps_vtx_cnt).second; <span class="comment">// v_to_intersection_registry_entry-&gt;second.second; // set to initial value</span></div>
<div class="line"><span class="lineno"> 4073</span>            } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 4074</span>                <span class="comment">// i.e. &quot;is same face&quot; which is being pierced by multiple edges [of the same input mesh]</span></div>
<div class="line"><span class="lineno"> 4075</span>                is_floating_polygon = (shared_registry_entry_intersected_face == <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, (std::size_t)v - ps_vtx_cnt).second <span class="comment">/*v_to_intersection_registry_entry-&gt;second.second*/</span>);</div>
<div class="line"><span class="lineno"> 4076</span>            }</div>
<div class="line"><span class="lineno"> 4077</span> </div>
<div class="line"><span class="lineno"> 4078</span>            <span class="keywordflow">if</span> (!is_floating_polygon) {</div>
<div class="line"><span class="lineno"> 4079</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 4080</span>            }</div>
<div class="line"><span class="lineno"> 4081</span> </div>
<div class="line"><span class="lineno"> 4082</span>            vertex_prev = v;</div>
<div class="line"><span class="lineno"> 4083</span>        }</div>
<div class="line"><span class="lineno"> 4084</span> </div>
<div class="line"><span class="lineno"> 4085</span>        vertex_prev = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ab448d0b9684fd2f648195b2e5edb83f2">hmesh_t::null_vertex</a>();</div>
<div class="line"><span class="lineno"> 4086</span>        <span class="keywordflow">if</span> (is_floating_polygon) {</div>
<div class="line"><span class="lineno"> 4087</span> </div>
<div class="line"><span class="lineno"> 4088</span>            <span class="comment">// bool ps_face_is_from_cutmesh = ps_is_cutmesh_face(shared_registry_entry_intersected_face, sm_face_count);</span></div>
<div class="line"><span class="lineno"> 4089</span> </div>
<div class="line"><span class="lineno"> 4090</span>            output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8ad08f78bc8be7a6cbd0494282ebf00d">detected_floating_polygons</a>[shared_registry_entry_intersected_face].emplace_back(<a class="code hl_struct" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#dd/d1d/structfloating__polygon__info__t">floating_polygon_info_t</a>());</div>
<div class="line"><span class="lineno"> 4091</span>            <a class="code hl_struct" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#dd/d1d/structfloating__polygon__info__t">floating_polygon_info_t</a>&amp; fpi = output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8ad08f78bc8be7a6cbd0494282ebf00d">detected_floating_polygons</a>[shared_registry_entry_intersected_face].back();</div>
<div class="line"><span class="lineno"> 4092</span> </div>
<div class="line"><span class="lineno"> 4093</span>            <span class="comment">// fpi.origin_mesh = ps_face_is_from_cutmesh ? input.cut_mesh : input.src_mesh;</span></div>
<div class="line"><span class="lineno"> 4094</span>            <span class="comment">// const uint32_t cm_faces_start_offset = sm_face_count; // i.e. start offset in &quot;ps&quot;</span></div>
<div class="line"><span class="lineno"> 4095</span>            <span class="comment">// fpi.origin_face = (ps_face_is_from_cutmesh ? fd_t(shared_registry_entry_intersected_face - cm_faces_start_offset) : shared_registry_entry_intersected_face);</span></div>
<div class="line"><span class="lineno"> 4096</span>            fpi.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#acddb106c53c82046d8f6c4f85268c497">polygon_vertices</a>.clear();</div>
<div class="line"><span class="lineno"> 4097</span> </div>
<div class="line"><span class="lineno"> 4098</span>            std::unordered_map&lt;vd_t, std::vector&lt;ed_t&gt;&gt; ivtx_to_cp_edges;</div>
<div class="line"><span class="lineno"> 4099</span> </div>
<div class="line"><span class="lineno"> 4100</span>            <span class="keywordflow">for</span> (std::vector&lt;ed_t&gt;::const_iterator cp_edge_iter = cutpath_sequence.cbegin(); cp_edge_iter != cutpath_sequence.cend(); cp_edge_iter++) {</div>
<div class="line"><span class="lineno"> 4101</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> v0 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(*cp_edge_iter, 0);</div>
<div class="line"><span class="lineno"> 4102</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> v1 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(*cp_edge_iter, 1);</div>
<div class="line"><span class="lineno"> 4103</span>                ivtx_to_cp_edges[v0].push_back(*cp_edge_iter);</div>
<div class="line"><span class="lineno"> 4104</span>                ivtx_to_cp_edges[v1].push_back(*cp_edge_iter);</div>
<div class="line"><span class="lineno"> 4105</span>            }</div>
<div class="line"><span class="lineno"> 4106</span> </div>
<div class="line"><span class="lineno"> 4107</span>            std::unordered_map&lt;vd_t, std::vector&lt;ed_t&gt;&gt;::const_iterator cur = ivtx_to_cp_edges.cend();</div>
<div class="line"><span class="lineno"> 4108</span>            std::unordered_map&lt;vd_t, std::vector&lt;ed_t&gt;&gt;::const_iterator next = ivtx_to_cp_edges.cbegin();</div>
<div class="line"><span class="lineno"> 4109</span> </div>
<div class="line"><span class="lineno"> 4110</span>            <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> prev_edge = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aabb2a87d3b736883d381532fb871389e">hmesh_t::null_edge</a>();</div>
<div class="line"><span class="lineno"> 4111</span>            <span class="keywordflow">do</span> {</div>
<div class="line"><span class="lineno"> 4112</span>                cur = next;</div>
<div class="line"><span class="lineno"> 4113</span>                next = ivtx_to_cp_edges.cend();</div>
<div class="line"><span class="lineno"> 4114</span> </div>
<div class="line"><span class="lineno"> 4115</span>                <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> cur_vertex = cur-&gt;first;</div>
<div class="line"><span class="lineno"> 4116</span> </div>
<div class="line"><span class="lineno"> 4117</span>                fpi.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#acddb106c53c82046d8f6c4f85268c497">polygon_vertices</a>.emplace_back(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(cur_vertex)); <span class="comment">// save coords</span></div>
<div class="line"><span class="lineno"> 4118</span> </div>
<div class="line"><span class="lineno"> 4119</span>                <span class="keywordflow">if</span> (prev_edge == <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aabb2a87d3b736883d381532fb871389e">hmesh_t::null_edge</a>() || fpi.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#acddb106c53c82046d8f6c4f85268c497">polygon_vertices</a>.size() &lt; cutpath_sequence.size()) {</div>
<div class="line"><span class="lineno"> 4120</span>                    <span class="keyword">const</span> std::vector&lt;ed_t&gt;&amp; evec = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ivtx_to_cp_edges, cur-&gt;first);</div>
<div class="line"><span class="lineno"> 4121</span>                    std::vector&lt;ed_t&gt;::const_iterator fiter = std::find_if(evec.cbegin(), evec.cend(), [&amp;](<span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; e) { return e != prev_edge; });</div>
<div class="line"><span class="lineno"> 4122</span> </div>
<div class="line"><span class="lineno"> 4123</span>                    <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> edge = *fiter;</div>
<div class="line"><span class="lineno"> 4124</span>                    <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> next_vertex = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(edge, 0);</div>
<div class="line"><span class="lineno"> 4125</span> </div>
<div class="line"><span class="lineno"> 4126</span>                    <span class="keywordflow">if</span> (next_vertex == cur-&gt;first) {</div>
<div class="line"><span class="lineno"> 4127</span>                        next_vertex = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(edge, 1);</div>
<div class="line"><span class="lineno"> 4128</span>                    }</div>
<div class="line"><span class="lineno"> 4129</span> </div>
<div class="line"><span class="lineno"> 4130</span>                    prev_edge = edge;</div>
<div class="line"><span class="lineno"> 4131</span> </div>
<div class="line"><span class="lineno"> 4132</span>                    next = ivtx_to_cp_edges.find(next_vertex);</div>
<div class="line"><span class="lineno"> 4133</span> </div>
<div class="line"><span class="lineno"> 4134</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(next != ivtx_to_cp_edges.cend()); <span class="comment">// because we have a loop (floating polygon)</span></div>
<div class="line"><span class="lineno"> 4135</span>                }</div>
<div class="line"><span class="lineno"> 4136</span> </div>
<div class="line"><span class="lineno"> 4137</span>            } <span class="keywordflow">while</span> (next != ivtx_to_cp_edges.cend());</div>
<div class="line"><span class="lineno"> 4138</span> </div>
<div class="line"><span class="lineno"> 4139</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ps_tested_face_to_plane_normal.find(shared_registry_entry_intersected_face) != ps_tested_face_to_plane_normal.end());</div>
<div class="line"><span class="lineno"> 4140</span>            fpi.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a537b5e59975d86fe000126788c87b4eb">polygon_normal</a> = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_tested_face_to_plane_normal, shared_registry_entry_intersected_face); <span class="comment">// used for 2d project</span></div>
<div class="line"><span class="lineno"> 4141</span> </div>
<div class="line"><span class="lineno"> 4142</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ps_tested_face_to_plane_normal_max_comp.find(shared_registry_entry_intersected_face) != ps_tested_face_to_plane_normal_max_comp.end());</div>
<div class="line"><span class="lineno"> 4143</span>            fpi.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a7bb3038442d8cb6a12416126e3b62d14">polygon_normal_largest_component</a> = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_tested_face_to_plane_normal_max_comp, shared_registry_entry_intersected_face);</div>
<div class="line"><span class="lineno"> 4144</span>        }</div>
<div class="line"><span class="lineno"> 4145</span>    }</div>
<div class="line"><span class="lineno"> 4146</span> </div>
<div class="line"><span class="lineno"> 4147</span>    <span class="keywordflow">if</span> (!output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8ad08f78bc8be7a6cbd0494282ebf00d">detected_floating_polygons</a>.empty()) {</div>
<div class="line"><span class="lineno"> 4148</span>        output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a7d4c902daa6f0439e388496967885dd9">status</a> = <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a86987e2e179fda428149b6ccce3fb9ab">status_t::DETECTED_FLOATING_POLYGON</a>;</div>
<div class="line"><span class="lineno"> 4149</span>        <span class="keywordflow">return</span>; <span class="comment">// abort, so that the front-end can partition ps-faces containing floating polygon</span></div>
<div class="line"><span class="lineno"> 4150</span>    }</div>
<div class="line"><span class="lineno"> 4151</span> </div>
<div class="line"><span class="lineno"> 4152</span>    m0_cutpath_sequence_to_properties.clear();</div>
<div class="line"><span class="lineno"> 4153</span>    m0_ivtx_to_cutpath_edges.clear(); <span class="comment">// free</span></div>
<div class="line"><span class="lineno"> 4154</span> </div>
<div class="line"><span class="lineno"> 4155</span>    <span class="comment">// The following sections of code are about clipping intersecting polygons,</span></div>
<div class="line"><span class="lineno"> 4156</span>    <span class="comment">// and the information we need in order to do that.</span></div>
<div class="line"><span class="lineno"> 4157</span>    <span class="comment">// -----------------------------------------------------------------------</span></div>
<div class="line"><span class="lineno"> 4158</span> </div>
<div class="line"><span class="lineno"> 4159</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 4161</span>        <span class="comment">// Gather/map intersection points on each intersecting faces</span></div>
<div class="line"><span class="lineno"> 4163</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 4164</span>        </div>
<div class="line"><span class="lineno"> 4165</span> </div>
<div class="line"><span class="lineno"> 4166</span>        <span class="comment">// TODO: build this data structure during polygon intersection tests!</span></div>
<div class="line"><span class="lineno"> 4167</span>        std::map&lt;</div>
<div class="line"><span class="lineno"> 4168</span>            <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a>,             <span class="comment">// intersectiong face</span></div>
<div class="line"><span class="lineno"> 4169</span>            std::vector&lt;vd_t&gt; <span class="comment">// intersection point which involve the intersecting face</span></div>
<div class="line"><span class="lineno"> 4170</span>            &gt;</div>
<div class="line"><span class="lineno"> 4171</span>            ps_iface_to_ivtx_list; <span class="comment">// faces which intersect with another</span></div>
<div class="line"><span class="lineno"> 4172</span> </div>
<div class="line"><span class="lineno"> 4173</span>        <span class="keywordflow">for</span> (std::map&lt;<a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a>, std::pair&lt;ed_t, fd_t&gt;&gt;::const_iterator ireg_entry_iter = m0_ivtx_to_intersection_registry_entry.cbegin();</div>
<div class="line"><span class="lineno"> 4174</span>             ireg_entry_iter != m0_ivtx_to_intersection_registry_entry.cend();</div>
<div class="line"><span class="lineno"> 4175</span>             ++ireg_entry_iter)</div>
<div class="line"><span class="lineno"> 4176</span>        { <span class="comment">// for each intersection point ...</span></div>
<div class="line"><span class="lineno"> 4177</span> </div>
<div class="line"><span class="lineno"> 4178</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> &amp;intersection_point = ireg_entry_iter-&gt;first;</div>
<div class="line"><span class="lineno"> 4179</span>            <span class="keyword">const</span> std::vector&lt;fd_t&gt; entry_faces = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#abcaa230eb10486e26a5167bae360d451">ps_get_ivtx_registry_entry_faces</a>(ps, ireg_entry_iter-&gt;second); <span class="comment">// faces in registry entry</span></div>
<div class="line"><span class="lineno"> 4180</span> </div>
<div class="line"><span class="lineno"> 4181</span>            <span class="comment">// update face vertex-registry</span></div>
<div class="line"><span class="lineno"> 4182</span> </div>
<div class="line"><span class="lineno"> 4183</span>            <span class="keywordflow">for</span> (std::vector&lt;fd_t&gt;::const_iterator entry_face_iter = entry_faces.cbegin();</div>
<div class="line"><span class="lineno"> 4184</span>                 entry_face_iter != entry_faces.cend();</div>
<div class="line"><span class="lineno"> 4185</span>                 ++entry_face_iter)</div>
<div class="line"><span class="lineno"> 4186</span>            { <span class="comment">// for each face in the intersection point&#39;s registry entry</span></div>
<div class="line"><span class="lineno"> 4187</span> </div>
<div class="line"><span class="lineno"> 4188</span>                <span class="keywordflow">if</span> (<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a0a7bbc0e3b52fd64237a4e3525cbc09e">is_virtual_face</a>(*entry_face_iter))</div>
<div class="line"><span class="lineno"> 4189</span>                {</div>
<div class="line"><span class="lineno"> 4190</span>                    <span class="keywordflow">continue</span>; <span class="comment">// virtual faces are simply placeholders - not useful</span></div>
<div class="line"><span class="lineno"> 4191</span>                }</div>
<div class="line"><span class="lineno"> 4192</span> </div>
<div class="line"><span class="lineno"> 4193</span>                <span class="comment">// get entry of current face</span></div>
<div class="line"><span class="lineno"> 4194</span>                std::map&lt;fd_t, std::vector&lt;vd_t&gt;&gt;::iterator find_iter = ps_iface_to_ivtx_list.find(*entry_face_iter);</div>
<div class="line"><span class="lineno"> 4195</span>                <span class="keyword">const</span> <span class="keywordtype">bool</span> face_vertex_registery_exists = find_iter != ps_iface_to_ivtx_list.cend();</div>
<div class="line"><span class="lineno"> 4196</span> </div>
<div class="line"><span class="lineno"> 4197</span>                <span class="keywordflow">if</span> (face_vertex_registery_exists)</div>
<div class="line"><span class="lineno"> 4198</span>                { <span class="comment">// do we have a map entry already...?</span></div>
<div class="line"><span class="lineno"> 4199</span>                    <span class="comment">// get the intersection points incident to the face</span></div>
<div class="line"><span class="lineno"> 4200</span>                    std::vector&lt;vd_t&gt; &amp;face_vertex_registry = find_iter-&gt;second;</div>
<div class="line"><span class="lineno"> 4201</span>                    <span class="comment">// has the current intersection point been associated with the current intersecting face</span></div>
<div class="line"><span class="lineno"> 4202</span>                    <span class="keyword">const</span> <span class="keywordtype">bool</span> vertex_registered = std::find(face_vertex_registry.cbegin(), face_vertex_registry.cend(), intersection_point) != face_vertex_registry.cend();</div>
<div class="line"><span class="lineno"> 4203</span> </div>
<div class="line"><span class="lineno"> 4204</span>                    <span class="keywordflow">if</span> (!vertex_registered)</div>
<div class="line"><span class="lineno"> 4205</span>                    {</div>
<div class="line"><span class="lineno"> 4206</span>                        face_vertex_registry.push_back(intersection_point); <span class="comment">// associate intersection point with intersecting face</span></div>
<div class="line"><span class="lineno"> 4207</span>                    }</div>
<div class="line"><span class="lineno"> 4208</span>                }</div>
<div class="line"><span class="lineno"> 4209</span>                <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno"> 4210</span>                {</div>
<div class="line"><span class="lineno"> 4211</span>                    <span class="comment">// add face-registry and register vertex</span></div>
<div class="line"><span class="lineno"> 4212</span>                    std::pair&lt;std::map&lt;fd_t, std::vector&lt;vd_t&gt;&gt;::iterator, <span class="keywordtype">bool</span>&gt; <a class="code hl_struct" href="../../df/de8/structpair.html">pair</a> = ps_iface_to_ivtx_list.insert(std::make_pair(*entry_face_iter, std::vector&lt;vd_t&gt;()));</div>
<div class="line"><span class="lineno"> 4213</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(<a class="code hl_struct" href="../../df/de8/structpair.html">pair</a>.second == <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 4214</span> </div>
<div class="line"><span class="lineno"> 4215</span>                    find_iter = <a class="code hl_struct" href="../../df/de8/structpair.html">pair</a>.first;</div>
<div class="line"><span class="lineno"> 4216</span>                    std::vector&lt;vd_t&gt; &amp;face_vertex_registry = find_iter-&gt;second;</div>
<div class="line"><span class="lineno"> 4217</span>                    face_vertex_registry.push_back(intersection_point); <span class="comment">// associate intersection point with intersecting face</span></div>
<div class="line"><span class="lineno"> 4218</span>                }</div>
<div class="line"><span class="lineno"> 4219</span>            }</div>
<div class="line"><span class="lineno"> 4220</span>        }</div>
<div class="line"><span class="lineno"> 4221</span> </div>
<div class="line"><span class="lineno"> 4222</span>        <span class="keywordflow">for</span> (std::map&lt;<a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a>, std::vector&lt;vd_t&gt;&gt;::const_iterator i = ps_iface_to_ivtx_list.cbegin(); i != ps_iface_to_ivtx_list.cend(); ++i)</div>
<div class="line"><span class="lineno"> 4223</span>        {</div>
<div class="line"><span class="lineno"> 4224</span>            </div>
<div class="line"><span class="lineno"> 4225</span>            </div>
<div class="line"><span class="lineno"> 4226</span> </div>
<div class="line"><span class="lineno"> 4227</span>            <span class="comment">// log</span></div>
<div class="line"><span class="lineno"> 4228</span>            </div>
<div class="line"><span class="lineno"> 4229</span>            <span class="keywordflow">for</span> (std::vector&lt;vd_t&gt;::const_iterator j = i-&gt;second.cbegin(); j != i-&gt;second.cend(); ++j)</div>
<div class="line"><span class="lineno"> 4230</span>            {</div>
<div class="line"><span class="lineno"> 4231</span>                </div>
<div class="line"><span class="lineno"> 4232</span>            }</div>
<div class="line"><span class="lineno"> 4233</span>            </div>
<div class="line"><span class="lineno"> 4234</span>            </div>
<div class="line"><span class="lineno"> 4235</span> </div>
<div class="line"><span class="lineno"> 4236</span>            </div>
<div class="line"><span class="lineno"> 4237</span>        }</div>
<div class="line"><span class="lineno"> 4238</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 4239</span> </div>
<div class="line"><span class="lineno"> 4240</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 4241</span> </div>
<div class="line"><span class="lineno"> 4243</span>    <span class="comment">// Create new edges partitioning the intersecting ps edges (2-part process)</span></div>
<div class="line"><span class="lineno"> 4245</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 4246</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Create polygon-exterior edges (w/ &gt; 3 vertices)&quot;</span>);</div>
<div class="line"><span class="lineno"> 4247</span> </div>
<div class="line"><span class="lineno"> 4248</span>    <span class="comment">// Part 1</span></div>
<div class="line"><span class="lineno"> 4249</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 4250</span>    <span class="comment">// Here, we identify ps-edges with more than 3 coincident m0-vertices (ps-</span></div>
<div class="line"><span class="lineno"> 4251</span>    <span class="comment">// and intersection points)</span></div>
<div class="line"><span class="lineno"> 4252</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 4253</span>    <span class="comment">// Task: 1) find ps-edges with more than 3 coincident m0-vertices, 2)</span></div>
<div class="line"><span class="lineno"> 4254</span>    <span class="comment">// sort these vertices along the ps-edge 3) connect sorted point by</span></div>
<div class="line"><span class="lineno"> 4255</span>    <span class="comment">// creating edges in &quot;m0&quot;</span></div>
<div class="line"><span class="lineno"> 4256</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 4257</span>    <span class="comment">// Brief: ps-edges with more than 3 coincident vertices arise during a</span></div>
<div class="line"><span class="lineno"> 4258</span>    <span class="comment">// partial-cut (3d polyhedron) and/or concave cut-mesh-to-source-mesh</span></div>
<div class="line"><span class="lineno"> 4259</span>    <span class="comment">// face intersection.</span></div>
<div class="line"><span class="lineno"> 4260</span>    <span class="comment">// For every such edge, there will be 2 ps-vertices and the rest are</span></div>
<div class="line"><span class="lineno"> 4261</span>    <span class="comment">// intersection points. (Sorting requires numerical calculation).</span></div>
<div class="line"><span class="lineno"> 4262</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 4263</span>    <span class="comment">// We also create a mapping between each polygon-boundary interior-edge</span></div>
<div class="line"><span class="lineno"> 4264</span>    <span class="comment">// vertex and its multiple copies which will be used for connected component</span></div>
<div class="line"><span class="lineno"> 4265</span>    <span class="comment">// separation and sealing (hole filling).</span></div>
<div class="line"><span class="lineno"> 4266</span>    <span class="comment">// NOTE: a polygon-boundary edge is one which is lies on the boundary of a</span></div>
<div class="line"><span class="lineno"> 4267</span>    <span class="comment">// ps-polygon. Conversely, an interior edge lies within the polygon (path</span></div>
<div class="line"><span class="lineno"> 4268</span>    <span class="comment">// along which polygon is clipped - the cut path).</span></div>
<div class="line"><span class="lineno"> 4269</span> </div>
<div class="line"><span class="lineno"> 4270</span>    <span class="comment">// std::map&lt;vd_t, std::vector&lt;vd_t&gt;&gt; m0_to_m1_poly_ext_int_edge_vertex;</span></div>
<div class="line"><span class="lineno"> 4271</span> </div>
<div class="line"><span class="lineno"> 4272</span>    std::unordered_map&lt;ed_t, std::vector&lt;std::pair&lt;vd_t, vec3&gt;&gt;&gt; ps_edge_to_vertices; <span class="comment">// stores ps-edges with more-than 3 coincident vertices</span></div>
<div class="line"><span class="lineno"> 4273</span> </div>
<div class="line"><span class="lineno"> 4274</span>    <span class="keywordflow">for</span> (std::unordered_map&lt;<a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>, std::vector&lt;vd_t&gt;&gt;::const_iterator iter_ps_edge = ps_intersecting_edges.cbegin(); iter_ps_edge != ps_intersecting_edges.cend(); ++iter_ps_edge) {</div>
<div class="line"><span class="lineno"> 4275</span> </div>
<div class="line"><span class="lineno"> 4276</span>        <span class="comment">// TODO: get_vertices_on_ps_edge() is not needed we can probably infer this information using previously/pre-computed std::maps</span></div>
<div class="line"><span class="lineno"> 4277</span>        <span class="comment">// vertices that lie on current ps edge</span></div>
<div class="line"><span class="lineno"> 4278</span> </div>
<div class="line"><span class="lineno"> 4279</span>        <span class="comment">// get_vertices_on_ps_edge(iter_ps_edge, m0_ivtx_to_intersection_registry_entry, ps, m0_to_ps_vtx);</span></div>
<div class="line"><span class="lineno"> 4280</span> </div>
<div class="line"><span class="lineno"> 4281</span>        <span class="keywordflow">if</span> (iter_ps_edge-&gt;second.size() &gt; 1) { <span class="comment">// intersection points on edge is more than 1 i.e. edge has more than three vertices</span></div>
<div class="line"><span class="lineno"> 4282</span> </div>
<div class="line"><span class="lineno"> 4283</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> ps_v0 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(iter_ps_edge-&gt;first, 0);</div>
<div class="line"><span class="lineno"> 4284</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> ps_v1 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(iter_ps_edge-&gt;first, 1);</div>
<div class="line"><span class="lineno"> 4285</span> </div>
<div class="line"><span class="lineno"> 4286</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">int</span>)(ps_v0) &lt; (<span class="keywordtype">int</span>)ps_to_m0_vtx.size() <span class="comment">/*ps_to_m0_vtx.find(ps_v0) != ps_to_m0_vtx.cend())*/</span>);</div>
<div class="line"><span class="lineno"> 4287</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_v0 = ps_to_m0_vtx[ps_v0];</div>
<div class="line"><span class="lineno"> 4288</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">int</span>)(ps_v1) &lt; (<span class="keywordtype">int</span>)ps_to_m0_vtx.size() <span class="comment">/*ps_to_m0_vtx.find(ps_v1) != ps_to_m0_vtx.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 4289</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_v1 = ps_to_m0_vtx[ps_v1];</div>
<div class="line"><span class="lineno"> 4290</span>            std::vector&lt;vd_t&gt; vertices_on_ps_edge = { m0_v0, m0_v1 };</div>
<div class="line"><span class="lineno"> 4291</span> </div>
<div class="line"><span class="lineno"> 4292</span>            <span class="comment">// and rest of points (intersection points)</span></div>
<div class="line"><span class="lineno"> 4293</span>            vertices_on_ps_edge.insert(vertices_on_ps_edge.end(), iter_ps_edge-&gt;second.cbegin(), iter_ps_edge-&gt;second.cend());</div>
<div class="line"><span class="lineno"> 4294</span> </div>
<div class="line"><span class="lineno"> 4295</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ps_edge_to_vertices.find(iter_ps_edge-&gt;first) == ps_edge_to_vertices.end()); <span class="comment">// edge cannot have been traversed before!</span></div>
<div class="line"><span class="lineno"> 4296</span> </div>
<div class="line"><span class="lineno"> 4297</span>            ps_edge_to_vertices.insert(std::make_pair(iter_ps_edge-&gt;first, std::vector&lt;std::pair&lt;vd_t, vec3&gt;&gt;()));</div>
<div class="line"><span class="lineno"> 4298</span> </div>
<div class="line"><span class="lineno"> 4299</span>            <span class="keywordflow">for</span> (std::vector&lt;vd_t&gt;::const_iterator it = vertices_on_ps_edge.cbegin(); it != vertices_on_ps_edge.cend(); ++it) {</div>
<div class="line"><span class="lineno"> 4300</span> </div>
<div class="line"><span class="lineno"> 4301</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a>&amp; vertex_coordinates = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(*it); <span class="comment">// get the coordinates (for sorting)</span></div>
<div class="line"><span class="lineno"> 4302</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_edge_to_vertices, iter_ps_edge-&gt;first).push_back(std::make_pair(*it, vertex_coordinates));</div>
<div class="line"><span class="lineno"> 4303</span> </div>
<div class="line"><span class="lineno"> 4304</span>                <span class="comment">// if (m0_is_intersection_point(*it, ps_vtx_cnt)) { // is intersection point</span></div>
<div class="line"><span class="lineno"> 4305</span>                <span class="comment">// m0_to_m1_poly_ext_int_edge_vertex.insert(std::make_pair(*it, std::vector&lt;vd_t&gt;()));</span></div>
<div class="line"><span class="lineno"> 4306</span>                <span class="comment">// }</span></div>
<div class="line"><span class="lineno"> 4307</span>            }</div>
<div class="line"><span class="lineno"> 4308</span>        }</div>
<div class="line"><span class="lineno"> 4309</span>    }</div>
<div class="line"><span class="lineno"> 4310</span> </div>
<div class="line"><span class="lineno"> 4311</span>    <span class="comment">// In the next for-loop, we sort each list of vertices on each ps-edge</span></div>
<div class="line"><span class="lineno"> 4312</span>    <span class="comment">// which more than 3 coincident vertices</span></div>
<div class="line"><span class="lineno"> 4313</span> </div>
<div class="line"><span class="lineno"> 4314</span>    std::unordered_map&lt;ed_t, std::vector&lt;vd_t&gt;&gt; ps_edge_to_sorted_descriptors; <span class="comment">// sorted vertex that lie on each edge with &gt; 3 vertices</span></div>
<div class="line"><span class="lineno"> 4315</span> </div>
<div class="line"><span class="lineno"> 4316</span>    <span class="keywordflow">for</span> (std::unordered_map&lt;<a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>, std::vector&lt;std::pair&lt;vd_t, vec3&gt;&gt;&gt;::iterator edge_vertices_iter = ps_edge_to_vertices.begin(); edge_vertices_iter != ps_edge_to_vertices.end(); ++edge_vertices_iter) {</div>
<div class="line"><span class="lineno"> 4317</span>        std::vector&lt;std::pair&lt;vd_t, vec3&gt;&gt;&amp; incident_vertices = edge_vertices_iter-&gt;second;</div>
<div class="line"><span class="lineno"> 4318</span> </div>
<div class="line"><span class="lineno"> 4319</span>        ps_edge_to_sorted_descriptors[edge_vertices_iter-&gt;first] = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a1b55223f27099f06cf4ef4442552eb3e">linear_projection_sort</a>(incident_vertices);</div>
<div class="line"><span class="lineno"> 4320</span> </div>
<div class="line"><span class="lineno"> 4321</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 4322</span>      <span class="comment">// since all points are on straight line, we sort them by x-coord and by y-coord if x-coord is the same for all vertices</span></div>
<div class="line"><span class="lineno"> 4323</span>      std::sort(incident_vertices.begin(), incident_vertices.end(),</div>
<div class="line"><span class="lineno"> 4324</span>        [&amp;](<span class="keyword">const</span> std::pair&lt;vd_t, vec3&gt;&amp; a, <span class="keyword">const</span> std::pair&lt;vd_t, vec3&gt;&amp; b) {</div>
<div class="line"><span class="lineno"> 4325</span>          return (a.second.x() &lt; b.second.x());</div>
<div class="line"><span class="lineno"> 4326</span>        });</div>
<div class="line"><span class="lineno"> 4327</span> </div>
<div class="line"><span class="lineno"> 4328</span>      <span class="keyword">const</span> <span class="keywordtype">bool</span> x_coordinate_is_same = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a9c800ed2d7c13bb98e4f4fb2be59b53e">have_same_coordinate</a>(incident_vertices, 0);</div>
<div class="line"><span class="lineno"> 4329</span> </div>
<div class="line"><span class="lineno"> 4330</span>      <span class="keywordflow">if</span> (x_coordinate_is_same) {</div>
<div class="line"><span class="lineno"> 4331</span>        <span class="comment">// ... then  sort on y-coord</span></div>
<div class="line"><span class="lineno"> 4332</span>        std::sort(incident_vertices.begin(), incident_vertices.end(),</div>
<div class="line"><span class="lineno"> 4333</span>          [&amp;](<span class="keyword">const</span> std::pair&lt;vd_t, vec3&gt;&amp; a, <span class="keyword">const</span> std::pair&lt;vd_t, vec3&gt;&amp; b) {</div>
<div class="line"><span class="lineno"> 4334</span>            return (a.second.y() &lt; b.second.y());</div>
<div class="line"><span class="lineno"> 4335</span>          });</div>
<div class="line"><span class="lineno"> 4336</span> </div>
<div class="line"><span class="lineno"> 4337</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> y_coordinate_is_same = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a9c800ed2d7c13bb98e4f4fb2be59b53e">have_same_coordinate</a>(incident_vertices, 1);</div>
<div class="line"><span class="lineno"> 4338</span> </div>
<div class="line"><span class="lineno"> 4339</span>        <span class="keywordflow">if</span> (y_coordinate_is_same) {</div>
<div class="line"><span class="lineno"> 4340</span>          <span class="comment">// ... then  sort on z-coord</span></div>
<div class="line"><span class="lineno"> 4341</span>          std::sort(incident_vertices.begin(), incident_vertices.end(),</div>
<div class="line"><span class="lineno"> 4342</span>            [&amp;](<span class="keyword">const</span> std::pair&lt;vd_t, vec3&gt;&amp; a, <span class="keyword">const</span> std::pair&lt;vd_t, vec3&gt;&amp; b) {</div>
<div class="line"><span class="lineno"> 4343</span>              return (a.second.z() &lt; b.second.z());</div>
<div class="line"><span class="lineno"> 4344</span>            });</div>
<div class="line"><span class="lineno"> 4345</span>        }</div>
<div class="line"><span class="lineno"> 4346</span>      }</div>
<div class="line"><span class="lineno"> 4347</span> </div>
<div class="line"><span class="lineno"> 4348</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 4349</span>    }</div>
<div class="line"><span class="lineno"> 4350</span> </div>
<div class="line"><span class="lineno"> 4351</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 4352</span>    <span class="comment">// Now we, create edges between the sorted vertices that are coincident</span></div>
<div class="line"><span class="lineno"> 4353</span>    <span class="comment">// on the same ps-edge that has more-than 3 incident vertices.</span></div>
<div class="line"><span class="lineno"> 4354</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 4355</span>    <span class="comment">// This step will create class-1 (o==&gt;x), class-2 (o==&gt;x),</span></div>
<div class="line"><span class="lineno"> 4356</span>    <span class="comment">// and class-3 (x==&gt;x) which are the so called &quot;polygon-boundary</span></div>
<div class="line"><span class="lineno"> 4357</span>    <span class="comment">// interior-iedges&quot;.</span></div>
<div class="line"><span class="lineno"> 4358</span> </div>
<div class="line"><span class="lineno"> 4359</span>    std::map&lt;</div>
<div class="line"><span class="lineno"> 4360</span>        <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a92abe1b30dc402b94e53318479d8b242">ed_t</a>, <span class="comment">// polygon-soup edge</span></div>
<div class="line"><span class="lineno"> 4361</span>        std::vector&lt;ed_t&gt; <span class="comment">// list of m0-edges which lay on polygon-soup edge</span></div>
<div class="line"><span class="lineno"> 4362</span>        &gt;</div>
<div class="line"><span class="lineno"> 4363</span>        ps_to_m0_edges;</div>
<div class="line"><span class="lineno"> 4364</span> </div>
<div class="line"><span class="lineno"> 4365</span>    <span class="comment">// for each ps-edge with more than 3 coincindent vertices</span></div>
<div class="line"><span class="lineno"> 4366</span>    <span class="keywordflow">for</span> (std::unordered_map&lt;<a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>, std::vector&lt;vd_t&gt;&gt;::const_iterator ps_edge_coincident_vertices_iter = ps_edge_to_sorted_descriptors.begin();</div>
<div class="line"><span class="lineno"> 4367</span>         ps_edge_coincident_vertices_iter != ps_edge_to_sorted_descriptors.end();</div>
<div class="line"><span class="lineno"> 4368</span>         ++ps_edge_coincident_vertices_iter) {</div>
<div class="line"><span class="lineno"> 4369</span> </div>
<div class="line"><span class="lineno"> 4370</span>        <span class="comment">// get sorted list of vertices on edge</span></div>
<div class="line"><span class="lineno"> 4371</span>        <span class="keyword">const</span> std::vector&lt;vd_t&gt;&amp; coincident_sorted_vertices = ps_edge_coincident_vertices_iter-&gt;second;</div>
<div class="line"><span class="lineno"> 4372</span> </div>
<div class="line"><span class="lineno"> 4373</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(coincident_sorted_vertices.size() &gt; 3); <span class="comment">// we are only dealing with ps-edges with more than 3 coicindent vertices</span></div>
<div class="line"><span class="lineno"> 4374</span> </div>
<div class="line"><span class="lineno"> 4375</span>        <span class="comment">// first vertex must not be an intersection point, because all vertices lie on a</span></div>
<div class="line"><span class="lineno"> 4376</span>        <span class="comment">// ps-edge to be partitioned into new edges, thus the first vertex must not</span></div>
<div class="line"><span class="lineno"> 4377</span>        <span class="comment">// be an intersection point: [*]===========[*] --&gt; [*]===*==*======[*]</span></div>
<div class="line"><span class="lineno"> 4378</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(!<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(coincident_sorted_vertices.front(), ps_vtx_cnt));</div>
<div class="line"><span class="lineno"> 4379</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>((*(coincident_sorted_vertices.cbegin() + 1)), ps_vtx_cnt));</div>
<div class="line"><span class="lineno"> 4380</span> </div>
<div class="line"><span class="lineno"> 4381</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>((*(coincident_sorted_vertices.cend() - 2)), ps_vtx_cnt));</div>
<div class="line"><span class="lineno"> 4382</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(!<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(coincident_sorted_vertices.back(), ps_vtx_cnt)); <span class="comment">// likewise, last vertex must not be an intersection point</span></div>
<div class="line"><span class="lineno"> 4383</span> </div>
<div class="line"><span class="lineno"> 4384</span>        <span class="comment">// for each sorted vertex on ps-edge (starting from the second in the list)</span></div>
<div class="line"><span class="lineno"> 4385</span>        <span class="keywordflow">for</span> (std::vector&lt;vd_t&gt;::const_iterator iter = coincident_sorted_vertices.cbegin() + 1; iter != coincident_sorted_vertices.cend(); ++iter) {</div>
<div class="line"><span class="lineno"> 4386</span> </div>
<div class="line"><span class="lineno"> 4387</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> src_vertex = *(iter - 1);</div>
<div class="line"><span class="lineno"> 4388</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> tgt_vertex = *(iter);</div>
<div class="line"><span class="lineno"> 4389</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ae64649dd61e0c188c547c686abc8a19e">add_edge</a>(src_vertex, tgt_vertex); <span class="comment">// create edge!</span></div>
<div class="line"><span class="lineno"> 4390</span> </div>
<div class="line"><span class="lineno"> 4391</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(h != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>());</div>
<div class="line"><span class="lineno"> 4392</span> </div>
<div class="line"><span class="lineno"> 4393</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> new_edge = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a96e9db918396b86f0b61f5445ef46b18">edge</a>(h);</div>
<div class="line"><span class="lineno"> 4394</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(new_edge != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aabb2a87d3b736883d381532fb871389e">hmesh_t::null_edge</a>());</div>
<div class="line"><span class="lineno"> 4395</span> </div>
<div class="line"><span class="lineno"> 4396</span>            <span class="comment">// map original ps-edge to list of &quot;child&quot; edges which lie on it</span></div>
<div class="line"><span class="lineno"> 4397</span>            ps_to_m0_edges[ps_edge_coincident_vertices_iter-&gt;first].push_back(new_edge);</div>
<div class="line"><span class="lineno"> 4398</span> </div>
<div class="line"><span class="lineno"> 4399</span>            <span class="comment">// Here we save the &quot;incoming&quot; halfedge for each vertex of the created edge,</span></div>
<div class="line"><span class="lineno"> 4400</span>            <span class="comment">// if the vertex is an intersection point. An incoming halfedge is a one</span></div>
<div class="line"><span class="lineno"> 4401</span>            <span class="comment">// whose target is the vertex.</span></div>
<div class="line"><span class="lineno"> 4402</span>            <span class="comment">// We will using this information when splitting the source mesh along the</span></div>
<div class="line"><span class="lineno"> 4403</span>            <span class="comment">// cut path (when duplicating intersection points to create holes).</span></div>
<div class="line"><span class="lineno"> 4404</span> </div>
<div class="line"><span class="lineno"> 4405</span>            <span class="keywordflow">if</span> ((iter - 1) == coincident_sorted_vertices.cbegin()) <span class="comment">// first iteration</span></div>
<div class="line"><span class="lineno"> 4406</span>            {</div>
<div class="line"><span class="lineno"> 4407</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(h) == tgt_vertex);</div>
<div class="line"><span class="lineno"> 4408</span>                ivtx_to_incoming_hlist[tgt_vertex].push_back(h);</div>
<div class="line"><span class="lineno"> 4409</span>            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((std::size_t)<a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(coincident_sorted_vertices.cbegin(), iter) == coincident_sorted_vertices.size() - 1) <span class="comment">// last iterator</span></div>
<div class="line"><span class="lineno"> 4410</span>            {</div>
<div class="line"><span class="lineno"> 4411</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(h)) == src_vertex);</div>
<div class="line"><span class="lineno"> 4412</span>                ivtx_to_incoming_hlist[src_vertex].push_back(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(h));</div>
<div class="line"><span class="lineno"> 4413</span>            } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 4414</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(h) == tgt_vertex);</div>
<div class="line"><span class="lineno"> 4415</span>                ivtx_to_incoming_hlist[tgt_vertex].push_back(h);</div>
<div class="line"><span class="lineno"> 4416</span> </div>
<div class="line"><span class="lineno"> 4417</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(h)) == src_vertex);</div>
<div class="line"><span class="lineno"> 4418</span>                ivtx_to_incoming_hlist[src_vertex].push_back(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(h));</div>
<div class="line"><span class="lineno"> 4419</span>            }</div>
<div class="line"><span class="lineno"> 4420</span> </div>
<div class="line"><span class="lineno"> 4421</span>            <span class="comment">// Here, we also associate the new edge with an intersecting ps-face.</span></div>
<div class="line"><span class="lineno"> 4422</span>            <span class="comment">// Note: since the new edge here will lie on the face boundary, its associated intersecting ps-face(s) will</span></div>
<div class="line"><span class="lineno"> 4423</span>            <span class="comment">// be those which are incident to the parent ps-edge</span></div>
<div class="line"><span class="lineno"> 4424</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> ps_edge = ps_edge_coincident_vertices_iter-&gt;first;</div>
<div class="line"><span class="lineno"> 4425</span> </div>
<div class="line"><span class="lineno"> 4426</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 2; ++i) { <span class="comment">// for each halfedge of edge</span></div>
<div class="line"><span class="lineno"> 4427</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> ps_edge_h = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(ps_edge, i);</div>
<div class="line"><span class="lineno"> 4428</span> </div>
<div class="line"><span class="lineno"> 4429</span>                <span class="keywordflow">if</span> (ps_edge_h != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>()) {</div>
<div class="line"><span class="lineno"> 4430</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> f = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(ps_edge_h);</div>
<div class="line"><span class="lineno"> 4431</span>                    <span class="keywordflow">if</span> (f != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>()) <span class="comment">// ps_edge could be on the border!</span></div>
<div class="line"><span class="lineno"> 4432</span>                    {</div>
<div class="line"><span class="lineno"> 4433</span>                        ps_iface_to_m0_edge_list[f].emplace_back(new_edge);</div>
<div class="line"><span class="lineno"> 4434</span>                    }</div>
<div class="line"><span class="lineno"> 4435</span>                }</div>
<div class="line"><span class="lineno"> 4436</span>            }</div>
<div class="line"><span class="lineno"> 4437</span>        }</div>
<div class="line"><span class="lineno"> 4438</span>    }</div>
<div class="line"><span class="lineno"> 4439</span> </div>
<div class="line"><span class="lineno"> 4440</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 4441</span> </div>
<div class="line"><span class="lineno"> 4442</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Create polygon-exterior edges (2 or 3 vertices)&quot;</span>);</div>
<div class="line"><span class="lineno"> 4443</span> </div>
<div class="line"><span class="lineno"> 4444</span>    <span class="comment">// Part 2</span></div>
<div class="line"><span class="lineno"> 4445</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 4446</span>    <span class="comment">// We will now create edges between vertices that lie on the same ps-edge</span></div>
<div class="line"><span class="lineno"> 4447</span>    <span class="comment">// which has 2 or 3 coincident vertices. Note that in the case of 2 coincident</span></div>
<div class="line"><span class="lineno"> 4448</span>    <span class="comment">// vertices, the created edge is the same as the original ps-edge.</span></div>
<div class="line"><span class="lineno"> 4449</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 4450</span>    <span class="comment">// Brief: the order of m0-vertices along the ps-edge is deduced since the number</span></div>
<div class="line"><span class="lineno"> 4451</span>    <span class="comment">// of vertices is small enough (unlike Part 1).</span></div>
<div class="line"><span class="lineno"> 4452</span>    <span class="comment">// So we have two simple cases:</span></div>
<div class="line"><span class="lineno"> 4453</span>    <span class="comment">// a) ps-edge is coincident on two m0-vertices which are not intersection points</span></div>
<div class="line"><span class="lineno"> 4454</span>    <span class="comment">// b) ps-edge is coincident on three m0-vertices such that one is an intersection point</span></div>
<div class="line"><span class="lineno"> 4455</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 4456</span> </div>
<div class="line"><span class="lineno"> 4457</span>    <span class="comment">// a map between edge ids in &quot;ps&quot; and in &quot;m0&quot;, which is the data structure we are progressively</span></div>
<div class="line"><span class="lineno"> 4458</span>    <span class="comment">// defining to hold data for the new mesh containing clipped polygons</span></div>
<div class="line"><span class="lineno"> 4459</span>    std::unordered_map&lt;ed_t, ed_t&gt; ps_to_m0_non_intersecting_edge;</div>
<div class="line"><span class="lineno"> 4460</span> </div>
<div class="line"><span class="lineno"> 4461</span><span class="preprocessor">#if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 4462</span>    {</div>
<div class="line"><span class="lineno"> 4463</span>        <span class="keyword">typedef</span> <a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">edge_array_iterator_t</a> InputStorageIteratorType;</div>
<div class="line"><span class="lineno"> 4464</span>        <span class="keyword">typedef</span> std::tuple&lt;</div>
<div class="line"><span class="lineno"> 4465</span>            std::unordered_map&lt;ed_t, ed_t&gt;, <span class="comment">// ps_to_m0_non_intersecting_edge</span></div>
<div class="line"><span class="lineno"> 4466</span>            std::unordered_map&lt;fd_t, std::vector&lt;ed_t&gt;&gt;, <span class="comment">// ps_iface_to_m0_edge_list</span></div>
<div class="line"><span class="lineno"> 4467</span>            std::unordered_map&lt;vd_t, std::vector&lt;hd_t&gt;&gt;, <span class="comment">// ivtx_to_incoming_hlist</span></div>
<div class="line"><span class="lineno"> 4468</span>            <span class="comment">// locally computed edge</span></div>
<div class="line"><span class="lineno"> 4469</span>            <span class="comment">// local-edge-id to the m0-vertex-descriptors that are used to create edge</span></div>
<div class="line"><span class="lineno"> 4470</span>            std::vector&lt;std::pair&lt;vd_t, vd_t&gt;&gt;&gt;</div>
<div class="line"><span class="lineno"> 4471</span>            OutputStorageTypesTuple;</div>
<div class="line"><span class="lineno"> 4472</span> </div>
<div class="line"><span class="lineno"> 4473</span>        <span class="keyword">auto</span> fn_compute_polygon_boundary_edges = [&amp;](</div>
<div class="line"><span class="lineno"> 4474</span>                                                     InputStorageIteratorType block_start_,</div>
<div class="line"><span class="lineno"> 4475</span>                                                     InputStorageIteratorType block_end_) -&gt; OutputStorageTypesTuple {</div>
<div class="line"><span class="lineno"> 4476</span>            OutputStorageTypesTuple local_output;</div>
<div class="line"><span class="lineno"> 4477</span> </div>
<div class="line"><span class="lineno"> 4478</span>            std::unordered_map&lt;ed_t, ed_t&gt;&amp; ps_to_m0_non_intersecting_edge_LOCAL = std::get&lt;0&gt;(local_output);</div>
<div class="line"><span class="lineno"> 4479</span>            std::unordered_map&lt;fd_t, std::vector&lt;ed_t&gt;&gt;&amp; ps_iface_to_m0_edge_list_LOCAL = std::get&lt;1&gt;(local_output);</div>
<div class="line"><span class="lineno"> 4480</span>            std::unordered_map&lt;vd_t, std::vector&lt;hd_t&gt;&gt;&amp; ivtx_to_incoming_hlist_LOCAL = std::get&lt;2&gt;(local_output);</div>
<div class="line"><span class="lineno"> 4481</span>            std::vector&lt;std::pair&lt;vd_t, vd_t&gt;&gt;&amp; edges_LOCAL = std::get&lt;3&gt;(local_output);</div>
<div class="line"><span class="lineno"> 4482</span> </div>
<div class="line"><span class="lineno"> 4483</span>            <span class="keyword">const</span> <a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> rough_number_of_edges = (<a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>)<a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(block_start_, block_end_);</div>
<div class="line"><span class="lineno"> 4484</span>            edges_LOCAL.reserve((<a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>)(rough_number_of_edges * 1.2)); <span class="comment">// most edges are original</span></div>
<div class="line"><span class="lineno"> 4485</span> </div>
<div class="line"><span class="lineno"> 4486</span>            <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">edge_array_iterator_t</a> iter_ps_edge = block_start_; iter_ps_edge != block_end_; ++iter_ps_edge) {</div>
<div class="line"><span class="lineno"> 4487</span>                <span class="comment">// std::cout &lt;&lt; (uint32_t)(*iter_ps_edge) &lt;&lt; std::endl;</span></div>
<div class="line"><span class="lineno"> 4488</span>                <span class="keywordflow">if</span> (ps_edge_to_vertices.find(*iter_ps_edge) != ps_edge_to_vertices.end()) {</div>
<div class="line"><span class="lineno"> 4489</span>                    <span class="keywordflow">continue</span>; <span class="comment">// the case of more than 3 vertices (handled above)</span></div>
<div class="line"><span class="lineno"> 4490</span>                }</div>
<div class="line"><span class="lineno"> 4491</span> </div>
<div class="line"><span class="lineno"> 4492</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> ps_edge = *iter_ps_edge; <span class="comment">// edge handle</span></div>
<div class="line"><span class="lineno"> 4493</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> ps_v0 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(ps_edge, 0);</div>
<div class="line"><span class="lineno"> 4494</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> ps_v1 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(ps_edge, 1);</div>
<div class="line"><span class="lineno"> 4495</span> </div>
<div class="line"><span class="lineno"> 4496</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">int</span>)(ps_v0) &lt; (<span class="keywordtype">int</span>)ps_to_m0_vtx.size());</div>
<div class="line"><span class="lineno"> 4497</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_v0 = ps_to_m0_vtx[ps_v0];</div>
<div class="line"><span class="lineno"> 4498</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">int</span>)(ps_v1) &lt; (<span class="keywordtype">int</span>)ps_to_m0_vtx.size());</div>
<div class="line"><span class="lineno"> 4499</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_v1 = ps_to_m0_vtx[ps_v1];</div>
<div class="line"><span class="lineno"> 4500</span> </div>
<div class="line"><span class="lineno"> 4501</span>                std::vector&lt;vd_t&gt; vertices_on_ps_edge = { ps_v0, ps_v1 };</div>
<div class="line"><span class="lineno"> 4502</span>                std::unordered_map&lt;ed_t, std::vector&lt;vd_t&gt;&gt;::const_iterator ps_intersecting_edges_iter = ps_intersecting_edges.find(ps_edge);</div>
<div class="line"><span class="lineno"> 4503</span>                <span class="keywordflow">if</span> (ps_intersecting_edges_iter != ps_intersecting_edges.cend()) {</div>
<div class="line"><span class="lineno"> 4504</span>                    vertices_on_ps_edge.insert(</div>
<div class="line"><span class="lineno"> 4505</span>                        vertices_on_ps_edge.end(),</div>
<div class="line"><span class="lineno"> 4506</span>                        ps_intersecting_edges_iter-&gt;second.cbegin(),</div>
<div class="line"><span class="lineno"> 4507</span>                        ps_intersecting_edges_iter-&gt;second.cend());</div>
<div class="line"><span class="lineno"> 4508</span>                }</div>
<div class="line"><span class="lineno"> 4509</span> </div>
<div class="line"><span class="lineno"> 4510</span>                <span class="keywordflow">if</span> (vertices_on_ps_edge.size() == 2) {</div>
<div class="line"><span class="lineno"> 4511</span>                    <span class="comment">// const hd_t h = m0.add_edge(vertices_on_ps_edge.back(), vertices_on_ps_edge.front());</span></div>
<div class="line"><span class="lineno"> 4512</span>                    <span class="comment">// MCUT_ASSERT(h != hmesh_t::null_halfedge());</span></div>
<div class="line"><span class="lineno"> 4513</span>                    edges_LOCAL.push_back(std::make_pair(vertices_on_ps_edge.back(), vertices_on_ps_edge.front()));</div>
<div class="line"><span class="lineno"> 4514</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> edge = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a92abe1b30dc402b94e53318479d8b242">ed_t</a>((<a class="code hl_typedef" href="../../dd/dad/classdescriptor__t__.html#a80e181aa419b05d8c73a579815159df9">ed_t::index_type</a>)(edges_LOCAL.size() - 1));</div>
<div class="line"><span class="lineno"> 4515</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h(edge * 2);</div>
<div class="line"><span class="lineno"> 4516</span> </div>
<div class="line"><span class="lineno"> 4517</span>                    ps_to_m0_non_intersecting_edge_LOCAL[ps_edge] = edge;</div>
<div class="line"><span class="lineno"> 4518</span> </div>
<div class="line"><span class="lineno"> 4519</span>                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 2; ++i) {</div>
<div class="line"><span class="lineno"> 4520</span>                        <span class="comment">// const hd_t ps_edge_h = ps.halfedge(ps_edge, i);</span></div>
<div class="line"><span class="lineno"> 4521</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> ps_edge_h = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(ps_edge, i);</div>
<div class="line"><span class="lineno"> 4522</span>                        <span class="keywordflow">if</span> (ps_edge_h != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>()) {</div>
<div class="line"><span class="lineno"> 4523</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> f = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(ps_edge_h);</div>
<div class="line"><span class="lineno"> 4524</span>                            <span class="comment">// NOTE: ps_iface_to_m0_edge_list already contains [all] intersecting ps faces,</span></div>
<div class="line"><span class="lineno"> 4525</span>                            <span class="comment">// which where added when we compute edge between intersection points.</span></div>
<div class="line"><span class="lineno"> 4526</span>                            <span class="comment">// We associate &quot;f&quot; with &quot;edge&quot; using the local variable &quot;ps_iface_to_m0_edge_list_LOCAL&quot;</span></div>
<div class="line"><span class="lineno"> 4527</span>                            <span class="comment">// because &quot;ps_iface_to_m0_edge_list&quot; is shared by all threads. Thus, each thread computes</span></div>
<div class="line"><span class="lineno"> 4528</span>                            <span class="comment">// its local output first, and then we&#39;ll merge it into &quot;ps_iface_to_m0_edge_list&quot; later</span></div>
<div class="line"><span class="lineno"> 4529</span>                            <span class="keywordtype">bool</span> is_intersecting_ps_face = f != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>() &amp;&amp; ps_iface_to_m0_edge_list.find(f) != ps_iface_to_m0_edge_list.cend();</div>
<div class="line"><span class="lineno"> 4530</span>                            <span class="keywordflow">if</span> (is_intersecting_ps_face) {</div>
<div class="line"><span class="lineno"> 4531</span>                                ps_iface_to_m0_edge_list_LOCAL[f].emplace_back(edge);</div>
<div class="line"><span class="lineno"> 4532</span>                            }</div>
<div class="line"><span class="lineno"> 4533</span>                        }</div>
<div class="line"><span class="lineno"> 4534</span>                    }</div>
<div class="line"><span class="lineno"> 4535</span>                } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 4536</span> </div>
<div class="line"><span class="lineno"> 4537</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(vertices_on_ps_edge.size() == 3);</div>
<div class="line"><span class="lineno"> 4538</span> </div>
<div class="line"><span class="lineno"> 4539</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> first = vertices_on_ps_edge[0];</div>
<div class="line"><span class="lineno"> 4540</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> second = vertices_on_ps_edge[1];</div>
<div class="line"><span class="lineno"> 4541</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> third = vertices_on_ps_edge[2];</div>
<div class="line"><span class="lineno"> 4542</span> </div>
<div class="line"><span class="lineno"> 4543</span>                    <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h0;</div>
<div class="line"><span class="lineno"> 4544</span>                    <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h1;</div>
<div class="line"><span class="lineno"> 4545</span> </div>
<div class="line"><span class="lineno"> 4546</span>                    <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> m0_h0_edge_local;</div>
<div class="line"><span class="lineno"> 4547</span>                    <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> m0_h1_edge_local;</div>
<div class="line"><span class="lineno"> 4548</span> </div>
<div class="line"><span class="lineno"> 4549</span>                    <span class="keywordflow">if</span> (!<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(first, ps_vtx_cnt)) { <span class="comment">// o--&gt;...</span></div>
<div class="line"><span class="lineno"> 4550</span>                        <span class="keywordflow">if</span> (<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(second, ps_vtx_cnt)) {</div>
<div class="line"><span class="lineno"> 4551</span> </div>
<div class="line"><span class="lineno"> 4552</span>                            <span class="comment">// h0 = m0.add_edge(first, second);</span></div>
<div class="line"><span class="lineno"> 4553</span>                            <span class="comment">// MCUT_ASSERT(h0 != hmesh_t::null_halfedge());</span></div>
<div class="line"><span class="lineno"> 4554</span>                            edges_LOCAL.push_back(std::make_pair(first, second));</div>
<div class="line"><span class="lineno"> 4555</span>                            m0_h0_edge_local = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a92abe1b30dc402b94e53318479d8b242">ed_t</a>((<a class="code hl_typedef" href="../../dd/dad/classdescriptor__t__.html#a80e181aa419b05d8c73a579815159df9">ed_t::index_type</a>)(edges_LOCAL.size() - 1));</div>
<div class="line"><span class="lineno"> 4556</span>                            h0 = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a>(m0_h0_edge_local * 2); <span class="comment">// mimmick halfedge descriptor</span></div>
<div class="line"><span class="lineno"> 4557</span> </div>
<div class="line"><span class="lineno"> 4558</span>                            <span class="comment">// MCUT_ASSERT(m0.target(h0) == second);</span></div>
<div class="line"><span class="lineno"> 4559</span>                            ivtx_to_incoming_hlist_LOCAL[second].push_back(h0);</div>
<div class="line"><span class="lineno"> 4560</span> </div>
<div class="line"><span class="lineno"> 4561</span>                            <span class="comment">// h1 = m0.add_edge(second, third);</span></div>
<div class="line"><span class="lineno"> 4562</span>                            <span class="comment">// MCUT_ASSERT(h1 != hmesh_t::null_halfedge());</span></div>
<div class="line"><span class="lineno"> 4563</span> </div>
<div class="line"><span class="lineno"> 4564</span>                            edges_LOCAL.push_back(std::make_pair(second, third));</div>
<div class="line"><span class="lineno"> 4565</span>                            m0_h1_edge_local = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a92abe1b30dc402b94e53318479d8b242">ed_t</a>((<a class="code hl_typedef" href="../../dd/dad/classdescriptor__t__.html#a80e181aa419b05d8c73a579815159df9">ed_t::index_type</a>)(edges_LOCAL.size() - 1));</div>
<div class="line"><span class="lineno"> 4566</span>                            h1 = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a>(m0_h1_edge_local * 2);</div>
<div class="line"><span class="lineno"> 4567</span> </div>
<div class="line"><span class="lineno"> 4568</span>                            <span class="comment">// MCUT_ASSERT(m0.target(m0.opposite(h1)) == second);</span></div>
<div class="line"><span class="lineno"> 4569</span>                            <span class="comment">// ivtx_to_incoming_hlist_LOCAL[second].push_back(m0.opposite(h1));</span></div>
<div class="line"><span class="lineno"> 4570</span>                            <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h1_opp_local = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a>((<a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>)h1 + 1);</div>
<div class="line"><span class="lineno"> 4571</span>                            ivtx_to_incoming_hlist_LOCAL[second].push_back(h1_opp_local);</div>
<div class="line"><span class="lineno"> 4572</span>                        } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 4573</span>                            <span class="comment">// h0 = m0.add_edge(first, third);</span></div>
<div class="line"><span class="lineno"> 4574</span>                            <span class="comment">// MCUT_ASSERT(h0 != hmesh_t::null_halfedge());</span></div>
<div class="line"><span class="lineno"> 4575</span>                            edges_LOCAL.push_back(std::make_pair(first, third));</div>
<div class="line"><span class="lineno"> 4576</span>                            m0_h0_edge_local = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a92abe1b30dc402b94e53318479d8b242">ed_t</a>((<a class="code hl_typedef" href="../../dd/dad/classdescriptor__t__.html#a80e181aa419b05d8c73a579815159df9">ed_t::index_type</a>)(edges_LOCAL.size() - 1));</div>
<div class="line"><span class="lineno"> 4577</span>                            h0 = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a>(m0_h0_edge_local * 2);</div>
<div class="line"><span class="lineno"> 4578</span> </div>
<div class="line"><span class="lineno"> 4579</span>                            ivtx_to_incoming_hlist_LOCAL[third].push_back(h0);</div>
<div class="line"><span class="lineno"> 4580</span> </div>
<div class="line"><span class="lineno"> 4581</span>                            <span class="comment">// h1 = m0.add_edge(third, second);</span></div>
<div class="line"><span class="lineno"> 4582</span>                            <span class="comment">// MCUT_ASSERT(h1 != hmesh_t::null_halfedge());</span></div>
<div class="line"><span class="lineno"> 4583</span>                            edges_LOCAL.push_back(std::make_pair(third, second));</div>
<div class="line"><span class="lineno"> 4584</span>                            m0_h1_edge_local = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a92abe1b30dc402b94e53318479d8b242">ed_t</a>((<a class="code hl_typedef" href="../../dd/dad/classdescriptor__t__.html#a80e181aa419b05d8c73a579815159df9">ed_t::index_type</a>)(edges_LOCAL.size() - 1));</div>
<div class="line"><span class="lineno"> 4585</span>                            h1 = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a>(m0_h1_edge_local * 2);</div>
<div class="line"><span class="lineno"> 4586</span> </div>
<div class="line"><span class="lineno"> 4587</span>                            <span class="comment">// ivtx_to_incoming_hlist_LOCAL[third].push_back(m0.opposite(h1));</span></div>
<div class="line"><span class="lineno"> 4588</span>                            <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h1_opp_local = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a>((<a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>)h1 + 1);</div>
<div class="line"><span class="lineno"> 4589</span>                            ivtx_to_incoming_hlist_LOCAL[third].push_back(h1_opp_local);</div>
<div class="line"><span class="lineno"> 4590</span>                        }</div>
<div class="line"><span class="lineno"> 4591</span>                    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 4592</span>                        <span class="comment">// h0 = m0.add_edge(second, first); // o--&gt;x</span></div>
<div class="line"><span class="lineno"> 4593</span>                        <span class="comment">// MCUT_ASSERT(h0 != hmesh_t::null_halfedge());</span></div>
<div class="line"><span class="lineno"> 4594</span>                        edges_LOCAL.push_back(std::make_pair(second, first));</div>
<div class="line"><span class="lineno"> 4595</span>                        m0_h0_edge_local = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a92abe1b30dc402b94e53318479d8b242">ed_t</a>((<a class="code hl_typedef" href="../../dd/dad/classdescriptor__t__.html#a80e181aa419b05d8c73a579815159df9">ed_t::index_type</a>)(edges_LOCAL.size() - 1));</div>
<div class="line"><span class="lineno"> 4596</span>                        h0 = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a>(m0_h0_edge_local * 2);</div>
<div class="line"><span class="lineno"> 4597</span> </div>
<div class="line"><span class="lineno"> 4598</span>                        ivtx_to_incoming_hlist_LOCAL[first].push_back(h0);</div>
<div class="line"><span class="lineno"> 4599</span> </div>
<div class="line"><span class="lineno"> 4600</span>                        <span class="comment">// MCUT_ASSERT(m0.target(m0.opposite(h0)) == second);</span></div>
<div class="line"><span class="lineno"> 4601</span>                        <span class="comment">// h1 = m0.add_edge(first, third);</span></div>
<div class="line"><span class="lineno"> 4602</span>                        <span class="comment">// MCUT_ASSERT(h1 != hmesh_t::null_halfedge());</span></div>
<div class="line"><span class="lineno"> 4603</span>                        edges_LOCAL.push_back(std::make_pair(first, third));</div>
<div class="line"><span class="lineno"> 4604</span>                        m0_h1_edge_local = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a92abe1b30dc402b94e53318479d8b242">ed_t</a>((<a class="code hl_typedef" href="../../dd/dad/classdescriptor__t__.html#a80e181aa419b05d8c73a579815159df9">ed_t::index_type</a>)(edges_LOCAL.size() - 1));</div>
<div class="line"><span class="lineno"> 4605</span>                        h1 = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a>(m0_h1_edge_local * 2);</div>
<div class="line"><span class="lineno"> 4606</span> </div>
<div class="line"><span class="lineno"> 4607</span>                        <span class="comment">// MCUT_ASSERT(m0.target(m0.opposite(h1)) == first);</span></div>
<div class="line"><span class="lineno"> 4608</span>                        <span class="comment">// ivtx_to_incoming_hlist_LOCAL[first].push_back(m0.opposite(h1));</span></div>
<div class="line"><span class="lineno"> 4609</span>                        <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h1_opp_local = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a>((<a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>)h1 + 1);</div>
<div class="line"><span class="lineno"> 4610</span>                        ivtx_to_incoming_hlist_LOCAL[first].push_back(h1_opp_local);</div>
<div class="line"><span class="lineno"> 4611</span>                    }</div>
<div class="line"><span class="lineno"> 4612</span> </div>
<div class="line"><span class="lineno"> 4613</span>                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 2; ++i) {</div>
<div class="line"><span class="lineno"> 4614</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> ps_edge_h = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(ps_edge, i);</div>
<div class="line"><span class="lineno"> 4615</span>                        <span class="keywordflow">if</span> (ps_edge_h != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>()) {</div>
<div class="line"><span class="lineno"> 4616</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> f = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(ps_edge_h);</div>
<div class="line"><span class="lineno"> 4617</span>                            <span class="keywordflow">if</span> (f != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>()) {</div>
<div class="line"><span class="lineno"> 4618</span>                                <span class="comment">// ps_iface_to_m0_edge_list_LOCAL[f].emplace_back(m0.edge(h0));</span></div>
<div class="line"><span class="lineno"> 4619</span>                                ps_iface_to_m0_edge_list_LOCAL[f].emplace_back(m0_h0_edge_local);</div>
<div class="line"><span class="lineno"> 4620</span>                                <span class="comment">// ps_iface_to_m0_edge_list_LOCAL[f].emplace_back(m0.edge(h1));</span></div>
<div class="line"><span class="lineno"> 4621</span>                                ps_iface_to_m0_edge_list_LOCAL[f].emplace_back(m0_h1_edge_local);</div>
<div class="line"><span class="lineno"> 4622</span>                            }</div>
<div class="line"><span class="lineno"> 4623</span>                        }</div>
<div class="line"><span class="lineno"> 4624</span>                    }</div>
<div class="line"><span class="lineno"> 4625</span>                }</div>
<div class="line"><span class="lineno"> 4626</span>            }</div>
<div class="line"><span class="lineno"> 4627</span> </div>
<div class="line"><span class="lineno"> 4628</span>            <span class="keywordflow">return</span> local_output;</div>
<div class="line"><span class="lineno"> 4629</span>        };</div>
<div class="line"><span class="lineno"> 4630</span> </div>
<div class="line"><span class="lineno"> 4631</span>        std::vector&lt;std::future&lt;OutputStorageTypesTuple&gt;&gt; futures;</div>
<div class="line"><span class="lineno"> 4632</span>        OutputStorageTypesTuple partial_res;</div>
<div class="line"><span class="lineno"> 4633</span> </div>
<div class="line"><span class="lineno"> 4634</span>        <a class="code hl_function" href="../../df/d05/tpool_8h.html#a48d2e68725f7691f1422697f4c359827">parallel_for</a>(</div>
<div class="line"><span class="lineno"> 4635</span>            *input.scheduler,</div>
<div class="line"><span class="lineno"> 4636</span>            ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a8d7c997988ef348807997c1b35d1ba62">edges_begin</a>(),</div>
<div class="line"><span class="lineno"> 4637</span>            ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a3d290168d74d3af8636faa881a9e3708">edges_end</a>(),</div>
<div class="line"><span class="lineno"> 4638</span>            fn_compute_polygon_boundary_edges,</div>
<div class="line"><span class="lineno"> 4639</span>            partial_res, <span class="comment">// output computed by master thread</span></div>
<div class="line"><span class="lineno"> 4640</span>            futures);</div>
<div class="line"><span class="lineno"> 4641</span> </div>
<div class="line"><span class="lineno"> 4642</span>        <span class="keyword">const</span> std::unordered_map&lt;ed_t, ed_t&gt; ps_to_m0_non_intersecting_edge_MASTER_THREAD_LOCAL = std::get&lt;0&gt;(partial_res);</div>
<div class="line"><span class="lineno"> 4643</span>        <span class="keyword">const</span> std::unordered_map&lt;fd_t, std::vector&lt;ed_t&gt;&gt;&amp; ps_iface_to_m0_edge_list_MASTER_THREAD_LOCAL = std::get&lt;1&gt;(partial_res);</div>
<div class="line"><span class="lineno"> 4644</span>        <span class="keyword">const</span> std::unordered_map&lt;vd_t, std::vector&lt;hd_t&gt;&gt;&amp; ivtx_to_incoming_hlist_MASTER_THREAD_LOCAL = std::get&lt;2&gt;(partial_res);</div>
<div class="line"><span class="lineno"> 4645</span>        <span class="comment">// local-edge-id to the m0-vertex-descriptors that are used to create edge</span></div>
<div class="line"><span class="lineno"> 4646</span>        <span class="comment">// the sequence of elements signifies the order in which they were computed</span></div>
<div class="line"><span class="lineno"> 4647</span>        <span class="keyword">const</span> std::vector&lt;std::pair&lt;vd_t, vd_t&gt;&gt;&amp; edge_create_info_MASTER_THREAD_LOCAL = std::get&lt;3&gt;(partial_res);</div>
<div class="line"><span class="lineno"> 4648</span> </div>
<div class="line"><span class="lineno"> 4649</span>        <span class="comment">// NOTE: this lambda adds the edges stored in &quot;edge_create_info_&quot; into m0</span></div>
<div class="line"><span class="lineno"> 4650</span>        <span class="comment">// the other iterable parameters are simply updated (i.e. ed_t of &quot;m0&quot; variables are given their proper offset)</span></div>
<div class="line"><span class="lineno"> 4651</span>        <span class="keyword">auto</span> merge_local_m0_edges = [](</div>
<div class="line"><span class="lineno"> 4652</span>                                        <a class="code hl_class" href="../../d7/d63/classhmesh__t.html">hmesh_t</a>&amp; m0_,</div>
<div class="line"><span class="lineno"> 4653</span>                                        <span class="keyword">const</span> std::unordered_map&lt;ed_t, ed_t&gt;&amp; ps_to_m0_non_intersecting_edge_FUTURE,</div>
<div class="line"><span class="lineno"> 4654</span>                                        <span class="keyword">const</span> std::unordered_map&lt;fd_t, std::vector&lt;ed_t&gt;&gt;&amp; ps_iface_to_m0_edge_list_FUTURE,</div>
<div class="line"><span class="lineno"> 4655</span>                                        <span class="keyword">const</span> std::unordered_map&lt;vd_t, std::vector&lt;hd_t&gt;&gt;&amp; ivtx_to_incoming_hlist_FUTURE,</div>
<div class="line"><span class="lineno"> 4656</span>                                        <span class="keyword">const</span> std::vector&lt;std::pair&lt;vd_t, vd_t&gt;&gt;&amp; edge_create_info_FUTURE,</div>
<div class="line"><span class="lineno"> 4657</span>                                        std::unordered_map&lt;ed_t, ed_t&gt;&amp; ps_to_m0_non_intersecting_edge,</div>
<div class="line"><span class="lineno"> 4658</span>                                        std::unordered_map&lt;fd_t, std::vector&lt;ed_t&gt;&gt;&amp; ps_iface_to_m0_edge_list,</div>
<div class="line"><span class="lineno"> 4659</span>                                        std::unordered_map&lt;vd_t, std::vector&lt;hd_t&gt;&gt;&amp; ivtx_to_incoming_hlist) {</div>
<div class="line"><span class="lineno"> 4660</span>            std::vector&lt;ed_t&gt; emap(edge_create_info_FUTURE.size());</div>
<div class="line"><span class="lineno"> 4661</span>            <span class="comment">// add edges using edge_create_info</span></div>
<div class="line"><span class="lineno"> 4662</span>            <span class="keywordflow">for</span> (std::vector&lt;std::pair&lt;vd_t, vd_t&gt;&gt;::const_iterator it = edge_create_info_FUTURE.begin();</div>
<div class="line"><span class="lineno"> 4663</span>                 it != edge_create_info_FUTURE.end();</div>
<div class="line"><span class="lineno"> 4664</span>                 ++it) {</div>
<div class="line"><span class="lineno"> 4665</span>                <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h = m0_.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ae64649dd61e0c188c547c686abc8a19e">add_edge</a>(it-&gt;first, it-&gt;second);</div>
<div class="line"><span class="lineno"> 4666</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(h % 2 == 0); <span class="comment">// this is what allows indexing trick</span></div>
<div class="line"><span class="lineno"> 4667</span>                <span class="comment">// MCUT_ASSERT(ed_t((uint32_t)h/2) == ed_t(m0_edge_descr_baseoffset_ + it-&gt;first));</span></div>
<div class="line"><span class="lineno"> 4668</span>                <span class="keywordtype">size_t</span> local_edge_idx = <a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(edge_create_info_FUTURE.cbegin(), it);</div>
<div class="line"><span class="lineno"> 4669</span>                emap[local_edge_idx] = m0_.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a96e9db918396b86f0b61f5445ef46b18">edge</a>(h);</div>
<div class="line"><span class="lineno"> 4670</span>            }</div>
<div class="line"><span class="lineno"> 4671</span> </div>
<div class="line"><span class="lineno"> 4672</span>            <span class="comment">// merge ps_to_m0_non_intersecting_edge</span></div>
<div class="line"><span class="lineno"> 4673</span> </div>
<div class="line"><span class="lineno"> 4674</span>            <span class="keywordflow">for</span> (std::unordered_map&lt;ed_t, ed_t&gt;::const_iterator it = ps_to_m0_non_intersecting_edge_FUTURE.cbegin();</div>
<div class="line"><span class="lineno"> 4675</span>                 it != ps_to_m0_non_intersecting_edge_FUTURE.cend();</div>
<div class="line"><span class="lineno"> 4676</span>                 ++it) {</div>
<div class="line"><span class="lineno"> 4677</span>                ps_to_m0_non_intersecting_edge[it-&gt;first] = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(emap, it-&gt;second);</div>
<div class="line"><span class="lineno"> 4678</span>            }</div>
<div class="line"><span class="lineno"> 4679</span> </div>
<div class="line"><span class="lineno"> 4680</span>            <span class="comment">// merge ps_iface_to_m0_edge_list</span></div>
<div class="line"><span class="lineno"> 4681</span>            <span class="keywordflow">for</span> (std::unordered_map&lt;<a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a>, std::vector&lt;ed_t&gt;&gt;::const_iterator it = ps_iface_to_m0_edge_list_FUTURE.cbegin();</div>
<div class="line"><span class="lineno"> 4682</span>                 it != ps_iface_to_m0_edge_list_FUTURE.cend();</div>
<div class="line"><span class="lineno"> 4683</span>                 ++it) {</div>
<div class="line"><span class="lineno"> 4684</span>                <span class="keywordflow">for</span> (std::vector&lt;ed_t&gt;::const_iterator i = it-&gt;second.cbegin(); i != it-&gt;second.cend(); ++i) {</div>
<div class="line"><span class="lineno"> 4685</span>                    ps_iface_to_m0_edge_list[it-&gt;first].push_back(<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(emap, *i));</div>
<div class="line"><span class="lineno"> 4686</span>                }</div>
<div class="line"><span class="lineno"> 4687</span>            }</div>
<div class="line"><span class="lineno"> 4688</span> </div>
<div class="line"><span class="lineno"> 4689</span>            <span class="comment">// merge ivtx_to_incoming_hlist</span></div>
<div class="line"><span class="lineno"> 4690</span>            <span class="keywordflow">for</span> (std::unordered_map&lt;<a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a>, std::vector&lt;hd_t&gt;&gt;::const_iterator it = ivtx_to_incoming_hlist_FUTURE.cbegin();</div>
<div class="line"><span class="lineno"> 4691</span>                 it != ivtx_to_incoming_hlist_FUTURE.cend();</div>
<div class="line"><span class="lineno"> 4692</span>                 ++it) {</div>
<div class="line"><span class="lineno"> 4693</span>                <span class="keywordflow">for</span> (std::vector&lt;hd_t&gt;::const_iterator i = it-&gt;second.cbegin(); i != it-&gt;second.cend(); ++i) {</div>
<div class="line"><span class="lineno"> 4694</span>                    <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> he_local = *i;</div>
<div class="line"><span class="lineno"> 4695</span>                    <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> he_edge_local = <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a92abe1b30dc402b94e53318479d8b242">ed_t</a>((<a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>)he_local / 2);</div>
<div class="line"><span class="lineno"> 4696</span>                    ivtx_to_incoming_hlist[it-&gt;first].push_back(m0_.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(emap, he_edge_local), (<a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>)(he_local % 2)));</div>
<div class="line"><span class="lineno"> 4697</span>                }</div>
<div class="line"><span class="lineno"> 4698</span>            }</div>
<div class="line"><span class="lineno"> 4699</span>        };</div>
<div class="line"><span class="lineno"> 4700</span> </div>
<div class="line"><span class="lineno"> 4701</span>        <span class="comment">// add edges computed by master thread and update local edge (and halfedge) descriptors</span></div>
<div class="line"><span class="lineno"> 4702</span>        merge_local_m0_edges(</div>
<div class="line"><span class="lineno"> 4703</span>            m0,</div>
<div class="line"><span class="lineno"> 4704</span>            ps_to_m0_non_intersecting_edge_MASTER_THREAD_LOCAL,</div>
<div class="line"><span class="lineno"> 4705</span>            ps_iface_to_m0_edge_list_MASTER_THREAD_LOCAL,</div>
<div class="line"><span class="lineno"> 4706</span>            ivtx_to_incoming_hlist_MASTER_THREAD_LOCAL,</div>
<div class="line"><span class="lineno"> 4707</span>            edge_create_info_MASTER_THREAD_LOCAL,</div>
<div class="line"><span class="lineno"> 4708</span>            ps_to_m0_non_intersecting_edge,</div>
<div class="line"><span class="lineno"> 4709</span>            ps_iface_to_m0_edge_list,</div>
<div class="line"><span class="lineno"> 4710</span>            ivtx_to_incoming_hlist);</div>
<div class="line"><span class="lineno"> 4711</span> </div>
<div class="line"><span class="lineno"> 4712</span>        <span class="comment">// merge thread-local output into global data structures</span></div>
<div class="line"><span class="lineno"> 4713</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)futures.size(); ++i) {</div>
<div class="line"><span class="lineno"> 4714</span>            std::future&lt;OutputStorageTypesTuple&gt;&amp; f = futures[i];</div>
<div class="line"><span class="lineno"> 4715</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(f.valid());</div>
<div class="line"><span class="lineno"> 4716</span>            OutputStorageTypesTuple future_result = f.get(); <span class="comment">// &quot;get()&quot; is a blocking function</span></div>
<div class="line"><span class="lineno"> 4717</span> </div>
<div class="line"><span class="lineno"> 4718</span>            <span class="keyword">const</span> std::unordered_map&lt;ed_t, ed_t&gt;&amp; ps_to_m0_non_intersecting_edge_FUTURE = std::get&lt;0&gt;(future_result);</div>
<div class="line"><span class="lineno"> 4719</span>            <span class="keyword">const</span> std::unordered_map&lt;fd_t, std::vector&lt;ed_t&gt;&gt;&amp; ps_iface_to_m0_edge_list_FUTURE = std::get&lt;1&gt;(future_result);</div>
<div class="line"><span class="lineno"> 4720</span>            <span class="keyword">const</span> std::unordered_map&lt;vd_t, std::vector&lt;hd_t&gt;&gt;&amp; ivtx_to_incoming_hlist_FUTURE = std::get&lt;2&gt;(future_result);</div>
<div class="line"><span class="lineno"> 4721</span>            <span class="keyword">const</span> std::vector&lt;std::pair&lt;vd_t, vd_t&gt;&gt;&amp; edge_create_info_FUTURE = std::get&lt;3&gt;(future_result);</div>
<div class="line"><span class="lineno"> 4722</span> </div>
<div class="line"><span class="lineno"> 4723</span>            merge_local_m0_edges(</div>
<div class="line"><span class="lineno"> 4724</span>                m0,</div>
<div class="line"><span class="lineno"> 4725</span>                ps_to_m0_non_intersecting_edge_FUTURE,</div>
<div class="line"><span class="lineno"> 4726</span>                ps_iface_to_m0_edge_list_FUTURE,</div>
<div class="line"><span class="lineno"> 4727</span>                ivtx_to_incoming_hlist_FUTURE,</div>
<div class="line"><span class="lineno"> 4728</span>                edge_create_info_FUTURE,</div>
<div class="line"><span class="lineno"> 4729</span>                ps_to_m0_non_intersecting_edge,</div>
<div class="line"><span class="lineno"> 4730</span>                ps_iface_to_m0_edge_list,</div>
<div class="line"><span class="lineno"> 4731</span>                ivtx_to_incoming_hlist);</div>
<div class="line"><span class="lineno"> 4732</span>        }</div>
<div class="line"><span class="lineno"> 4733</span> </div>
<div class="line"><span class="lineno"> 4734</span>    } <span class="comment">// end of parallel scope</span></div>
<div class="line"><span class="lineno"> 4735</span> </div>
<div class="line"><span class="lineno"> 4736</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno"> 4737</span> </div>
<div class="line"><span class="lineno"> 4738</span>    <span class="comment">// for each ps-edge</span></div>
<div class="line"><span class="lineno"> 4739</span>    <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">edge_array_iterator_t</a> iter_ps_edge = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a8d7c997988ef348807997c1b35d1ba62">edges_begin</a>(); iter_ps_edge != ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a3d290168d74d3af8636faa881a9e3708">edges_end</a>(); ++iter_ps_edge) {</div>
<div class="line"><span class="lineno"> 4740</span> </div>
<div class="line"><span class="lineno"> 4741</span>        <span class="keywordflow">if</span> (ps_edge_to_vertices.empty() == <span class="keyword">false</span> &amp;&amp; ps_edge_to_vertices.find(*iter_ps_edge) != ps_edge_to_vertices.end()) {</div>
<div class="line"><span class="lineno"> 4742</span>            <span class="keywordflow">continue</span>; <span class="comment">// the case of more than 3 vertices (handled above)</span></div>
<div class="line"><span class="lineno"> 4743</span>        }</div>
<div class="line"><span class="lineno"> 4744</span> </div>
<div class="line"><span class="lineno"> 4745</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> ps_edge = *iter_ps_edge; <span class="comment">// edge handle</span></div>
<div class="line"><span class="lineno"> 4746</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> ps_v0 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(ps_edge, 0);</div>
<div class="line"><span class="lineno"> 4747</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> ps_v1 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(ps_edge, 1);</div>
<div class="line"><span class="lineno"> 4748</span> </div>
<div class="line"><span class="lineno"> 4749</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">int</span>)(ps_v0) &lt; (<span class="keywordtype">int</span>)ps_to_m0_vtx.size() <span class="comment">/*ps_to_m0_vtx.find(ps_v0) != ps_to_m0_vtx.cend())*/</span>);</div>
<div class="line"><span class="lineno"> 4750</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_v0 = ps_to_m0_vtx[ps_v0];</div>
<div class="line"><span class="lineno"> 4751</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">int</span>)(ps_v1) &lt; (<span class="keywordtype">int</span>)ps_to_m0_vtx.size() <span class="comment">/*ps_to_m0_vtx.find(ps_v1) != ps_to_m0_vtx.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 4752</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_v1 = ps_to_m0_vtx[ps_v1];</div>
<div class="line"><span class="lineno"> 4753</span> </div>
<div class="line"><span class="lineno"> 4754</span>        std::vector&lt;vd_t&gt; vertices_on_ps_edge = { ps_v0, ps_v1 }; <span class="comment">// get_vertices_on_ps_edge(*iter_ps_edge, m0_ivtx_to_ps_edge, ps, m0_to_ps_vtx);</span></div>
<div class="line"><span class="lineno"> 4755</span>        std::unordered_map&lt;ed_t, std::vector&lt;vd_t&gt;&gt;::const_iterator ps_intersecting_edges_iter = ps_intersecting_edges.find(ps_edge);</div>
<div class="line"><span class="lineno"> 4756</span>        <span class="keywordflow">if</span> (ps_intersecting_edges_iter != ps_intersecting_edges.cend()) {</div>
<div class="line"><span class="lineno"> 4757</span>            vertices_on_ps_edge.insert(vertices_on_ps_edge.end(), ps_intersecting_edges_iter-&gt;second.cbegin(), ps_intersecting_edges_iter-&gt;second.cend());</div>
<div class="line"><span class="lineno"> 4758</span>        }</div>
<div class="line"><span class="lineno"> 4759</span> </div>
<div class="line"><span class="lineno"> 4760</span>        <span class="keyword">const</span> <a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> num_vertices_on_ps_edge = vertices_on_ps_edge.size();</div>
<div class="line"><span class="lineno"> 4761</span> </div>
<div class="line"><span class="lineno"> 4762</span>        <span class="keywordflow">if</span> (num_vertices_on_ps_edge == 2u) <span class="comment">// simple case (edge did not intersect with any polygon)</span></div>
<div class="line"><span class="lineno"> 4763</span>        {</div>
<div class="line"><span class="lineno"> 4764</span> </div>
<div class="line"><span class="lineno"> 4765</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ae64649dd61e0c188c547c686abc8a19e">add_edge</a>(vertices_on_ps_edge[1], vertices_on_ps_edge[0]);</div>
<div class="line"><span class="lineno"> 4766</span> </div>
<div class="line"><span class="lineno"> 4767</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(h != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>());</div>
<div class="line"><span class="lineno"> 4768</span> </div>
<div class="line"><span class="lineno"> 4769</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> edge = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a96e9db918396b86f0b61f5445ef46b18">edge</a>(h);</div>
<div class="line"><span class="lineno"> 4770</span>            ps_to_m0_non_intersecting_edge[ps_edge] = edge; <span class="comment">// associate</span></div>
<div class="line"><span class="lineno"> 4771</span> </div>
<div class="line"><span class="lineno"> 4772</span>            <span class="comment">// similar to Part 1, we also associate the new edge with an intersecting ps-face.</span></div>
<div class="line"><span class="lineno"> 4773</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 2; ++i) {</div>
<div class="line"><span class="lineno"> 4774</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> ps_edge_h = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(ps_edge, i);</div>
<div class="line"><span class="lineno"> 4775</span>                <span class="keywordflow">if</span> (ps_edge_h != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>()) { <span class="comment">// note: ps_edge could be on the border!</span></div>
<div class="line"><span class="lineno"> 4776</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> f = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(ps_edge_h);</div>
<div class="line"><span class="lineno"> 4777</span>                    <span class="keywordtype">bool</span> is_intersecting_ps_face = f != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>() &amp;&amp; ps_iface_to_m0_edge_list.find(f) != ps_iface_to_m0_edge_list.cend();</div>
<div class="line"><span class="lineno"> 4778</span>                    <span class="keywordflow">if</span> (is_intersecting_ps_face) {</div>
<div class="line"><span class="lineno"> 4779</span>                        ps_iface_to_m0_edge_list[f].emplace_back(edge);</div>
<div class="line"><span class="lineno"> 4780</span>                    }</div>
<div class="line"><span class="lineno"> 4781</span>                }</div>
<div class="line"><span class="lineno"> 4782</span>            }</div>
<div class="line"><span class="lineno"> 4783</span>        } <span class="keywordflow">else</span> { <span class="comment">// this is the more complex case where we add minimal set of non overlapping edges between 3 vertices</span></div>
<div class="line"><span class="lineno"> 4784</span> </div>
<div class="line"><span class="lineno"> 4785</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(num_vertices_on_ps_edge == 3u);</div>
<div class="line"><span class="lineno"> 4786</span> </div>
<div class="line"><span class="lineno"> 4787</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> first = vertices_on_ps_edge[0];</div>
<div class="line"><span class="lineno"> 4788</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> second = vertices_on_ps_edge[1];</div>
<div class="line"><span class="lineno"> 4789</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> third = vertices_on_ps_edge[2];</div>
<div class="line"><span class="lineno"> 4790</span> </div>
<div class="line"><span class="lineno"> 4791</span>            <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h0;</div>
<div class="line"><span class="lineno"> 4792</span>            <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h1;</div>
<div class="line"><span class="lineno"> 4793</span> </div>
<div class="line"><span class="lineno"> 4794</span>            <span class="keywordflow">if</span> (!<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(first, ps_vtx_cnt)) { <span class="comment">// o--&gt;...</span></div>
<div class="line"><span class="lineno"> 4795</span>                <span class="keywordflow">if</span> (<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(second, ps_vtx_cnt)) {</div>
<div class="line"><span class="lineno"> 4796</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 4797</span>                    <span class="comment">// o x o</span></div>
<div class="line"><span class="lineno"> 4798</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 4799</span> </div>
<div class="line"><span class="lineno"> 4800</span>                    h0 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ae64649dd61e0c188c547c686abc8a19e">add_edge</a>(first, second);</div>
<div class="line"><span class="lineno"> 4801</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(h0 != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>());</div>
<div class="line"><span class="lineno"> 4802</span> </div>
<div class="line"><span class="lineno"> 4803</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(h0) == second);</div>
<div class="line"><span class="lineno"> 4804</span>                    ivtx_to_incoming_hlist[second].push_back(h0);</div>
<div class="line"><span class="lineno"> 4805</span> </div>
<div class="line"><span class="lineno"> 4806</span>                    h1 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ae64649dd61e0c188c547c686abc8a19e">add_edge</a>(second, third);</div>
<div class="line"><span class="lineno"> 4807</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(h1 != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>());</div>
<div class="line"><span class="lineno"> 4808</span> </div>
<div class="line"><span class="lineno"> 4809</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(h1)) == second);</div>
<div class="line"><span class="lineno"> 4810</span>                    ivtx_to_incoming_hlist[second].push_back(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(h1));</div>
<div class="line"><span class="lineno"> 4811</span>                } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 4812</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 4813</span>                    <span class="comment">//  o o x</span></div>
<div class="line"><span class="lineno"> 4814</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 4815</span> </div>
<div class="line"><span class="lineno"> 4816</span>                    h0 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ae64649dd61e0c188c547c686abc8a19e">add_edge</a>(first, third);</div>
<div class="line"><span class="lineno"> 4817</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(h0 != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>());</div>
<div class="line"><span class="lineno"> 4818</span>                    ivtx_to_incoming_hlist[third].push_back(h0);</div>
<div class="line"><span class="lineno"> 4819</span> </div>
<div class="line"><span class="lineno"> 4820</span>                    h1 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ae64649dd61e0c188c547c686abc8a19e">add_edge</a>(third, second);</div>
<div class="line"><span class="lineno"> 4821</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(h1 != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>());</div>
<div class="line"><span class="lineno"> 4822</span>                    ivtx_to_incoming_hlist[third].push_back(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(h1));</div>
<div class="line"><span class="lineno"> 4823</span>                }</div>
<div class="line"><span class="lineno"> 4824</span>            } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 4825</span>                <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 4826</span>                <span class="comment">// x o o</span></div>
<div class="line"><span class="lineno"> 4827</span>                <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 4828</span> </div>
<div class="line"><span class="lineno"> 4829</span>                h0 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ae64649dd61e0c188c547c686abc8a19e">add_edge</a>(second, first); <span class="comment">// o--&gt;x</span></div>
<div class="line"><span class="lineno"> 4830</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(h0 != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>());</div>
<div class="line"><span class="lineno"> 4831</span>                ivtx_to_incoming_hlist[first].push_back(h0);</div>
<div class="line"><span class="lineno"> 4832</span> </div>
<div class="line"><span class="lineno"> 4833</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(h0)) == second);</div>
<div class="line"><span class="lineno"> 4834</span> </div>
<div class="line"><span class="lineno"> 4835</span>                h1 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ae64649dd61e0c188c547c686abc8a19e">add_edge</a>(first, third); <span class="comment">// x--&gt;o</span></div>
<div class="line"><span class="lineno"> 4836</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(h1 != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>());</div>
<div class="line"><span class="lineno"> 4837</span> </div>
<div class="line"><span class="lineno"> 4838</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(h1)) == first);</div>
<div class="line"><span class="lineno"> 4839</span>                ivtx_to_incoming_hlist[first].push_back(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(h1));</div>
<div class="line"><span class="lineno"> 4840</span>            }</div>
<div class="line"><span class="lineno"> 4841</span> </div>
<div class="line"><span class="lineno"> 4842</span>            <span class="comment">// // associate the new edge with an intersecting ps-face</span></div>
<div class="line"><span class="lineno"> 4843</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 2; ++i) { <span class="comment">// for each halfedge of edge</span></div>
<div class="line"><span class="lineno"> 4844</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> ps_edge_h = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(ps_edge, i);</div>
<div class="line"><span class="lineno"> 4845</span> </div>
<div class="line"><span class="lineno"> 4846</span>                <span class="keywordflow">if</span> (ps_edge_h != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>()) {</div>
<div class="line"><span class="lineno"> 4847</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> f = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(ps_edge_h);</div>
<div class="line"><span class="lineno"> 4848</span>                    <span class="keywordflow">if</span> (f != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>()) <span class="comment">// ps_edge could be on the border!</span></div>
<div class="line"><span class="lineno"> 4849</span>                    {</div>
<div class="line"><span class="lineno"> 4850</span>                        ps_iface_to_m0_edge_list[f].emplace_back(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a96e9db918396b86f0b61f5445ef46b18">edge</a>(h0));</div>
<div class="line"><span class="lineno"> 4851</span>                        ps_iface_to_m0_edge_list[f].emplace_back(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a96e9db918396b86f0b61f5445ef46b18">edge</a>(h1));</div>
<div class="line"><span class="lineno"> 4852</span>                    }</div>
<div class="line"><span class="lineno"> 4853</span>                }</div>
<div class="line"><span class="lineno"> 4854</span>            }</div>
<div class="line"><span class="lineno"> 4855</span>        }</div>
<div class="line"><span class="lineno"> 4856</span>    }</div>
<div class="line"><span class="lineno"> 4857</span> </div>
<div class="line"><span class="lineno"> 4858</span><span class="preprocessor">#endif </span><span class="comment">// #if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 4859</span> </div>
<div class="line"><span class="lineno"> 4860</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>(); <span class="comment">// &amp;&amp;&amp;&amp;&amp;</span></div>
<div class="line"><span class="lineno"> 4861</span> </div>
<div class="line"><span class="lineno"> 4862</span>    ps_intersecting_edges.clear();</div>
<div class="line"><span class="lineno"> 4863</span>    ps_edge_to_vertices.clear(); <span class="comment">// free</span></div>
<div class="line"><span class="lineno"> 4864</span> </div>
<div class="line"><span class="lineno"> 4866</span>    <span class="comment">// Polygon tracing (clipping of intersecting polygon-soup faces)</span></div>
<div class="line"><span class="lineno"> 4868</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 4869</span>    <span class="comment">// Now we start to clip every intersecting face</span></div>
<div class="line"><span class="lineno"> 4870</span>    <span class="comment">// -----------------------------------------------</span></div>
<div class="line"><span class="lineno"> 4871</span> </div>
<div class="line"><span class="lineno"> 4872</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Clip polygons&quot;</span>); <span class="comment">// &amp;&amp;&amp;&amp;&amp;</span></div>
<div class="line"><span class="lineno"> 4873</span> </div>
<div class="line"><span class="lineno"> 4874</span>    <span class="comment">// Stores the all polygons, including new polygons that are produced after clipping</span></div>
<div class="line"><span class="lineno"> 4875</span>    <span class="comment">// and the faces that remained unchanged because they were not intersecting. Note</span></div>
<div class="line"><span class="lineno"> 4876</span>    <span class="comment">// that faces in the polygon soup that were found to be intersecting are replaced</span></div>
<div class="line"><span class="lineno"> 4877</span>    <span class="comment">// with &quot;child&quot; faces that result from their clipping.</span></div>
<div class="line"><span class="lineno"> 4878</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 4879</span>    <span class="comment">// I use the word &quot;polygon&quot; here because they are not yet used to define a mesh -</span></div>
<div class="line"><span class="lineno"> 4880</span>    <span class="comment">// at which point they become faces!</span></div>
<div class="line"><span class="lineno"> 4881</span>    std::vector&lt;traced_polygon_t&gt; m0_polygons;</div>
<div class="line"><span class="lineno"> 4882</span> </div>
<div class="line"><span class="lineno"> 4883</span>    <span class="comment">// m0 polygons adjacent to cutpath from source-mesh faces</span></div>
<div class="line"><span class="lineno"> 4884</span>    std::vector&lt;int&gt; m0_sm_cutpath_adjacent_polygons;</div>
<div class="line"><span class="lineno"> 4885</span>    <span class="comment">// m0 polygons adjacent to cutpath from cut-mesh faces</span></div>
<div class="line"><span class="lineno"> 4886</span>    std::vector&lt;int&gt; m0_cm_cutpath_adjacent_polygons;</div>
<div class="line"><span class="lineno"> 4887</span> </div>
<div class="line"><span class="lineno"> 4888</span>    <span class="keywordtype">int</span> traced_sm_polygon_count = 0;</div>
<div class="line"><span class="lineno"> 4889</span> </div>
<div class="line"><span class="lineno"> 4890</span>    std::unordered_map&lt;int, fd_t&gt; m0_to_ps_face; <span class="comment">// (we&#39;ll later also include reversed polygon patches)</span></div>
<div class="line"><span class="lineno"> 4891</span> </div>
<div class="line"><span class="lineno"> 4892</span><span class="preprocessor">#if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 4893</span>    {</div>
<div class="line"><span class="lineno"> 4894</span>        <span class="keyword">typedef</span> <a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">face_array_iterator_t</a> InputStorageIteratorType;</div>
<div class="line"><span class="lineno"> 4895</span>        <span class="keyword">typedef</span> std::tuple&lt;</div>
<div class="line"><span class="lineno"> 4896</span>            std::vector&lt;traced_polygon_t&gt;, <span class="comment">// m0_polygons;</span></div>
<div class="line"><span class="lineno"> 4897</span>            std::vector&lt;int&gt;, <span class="comment">// m0_sm_cutpath_adjacent_polygons</span></div>
<div class="line"><span class="lineno"> 4898</span>            std::vector&lt;int&gt;, <span class="comment">// m0_cm_cutpath_adjacent_polygons;</span></div>
<div class="line"><span class="lineno"> 4899</span>            <a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>, <span class="comment">// traced_sm_polygon_count</span></div>
<div class="line"><span class="lineno"> 4900</span>            std::unordered_map&lt;int, fd_t&gt;&gt; <span class="comment">// m0_to_ps_face</span></div>
<div class="line"><span class="lineno"> 4901</span>            OutputStorageTypesTuple;</div>
<div class="line"><span class="lineno"> 4902</span> </div>
<div class="line"><span class="lineno"> 4903</span>        <span class="keyword">auto</span> fn_trace_polygons = [&amp;](</div>
<div class="line"><span class="lineno"> 4904</span>                                     InputStorageIteratorType block_start_,</div>
<div class="line"><span class="lineno"> 4905</span>                                     InputStorageIteratorType block_end_) -&gt; OutputStorageTypesTuple {</div>
<div class="line"><span class="lineno"> 4906</span>            OutputStorageTypesTuple local_output;</div>
<div class="line"><span class="lineno"> 4907</span>            <span class="keyword">const</span> <a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> num_elems = (<a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>)<a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(block_start_, block_end_);</div>
<div class="line"><span class="lineno"> 4908</span>            std::vector&lt;traced_polygon_t&gt;&amp; m0_polygons_LOCAL = std::get&lt;0&gt;(local_output);</div>
<div class="line"><span class="lineno"> 4909</span>            m0_polygons_LOCAL.reserve(num_elems);</div>
<div class="line"><span class="lineno"> 4910</span>            std::vector&lt;int&gt;&amp; m0_sm_cutpath_adjacent_polygons_LOCAL = std::get&lt;1&gt;(local_output);</div>
<div class="line"><span class="lineno"> 4911</span>            m0_sm_cutpath_adjacent_polygons_LOCAL.reserve(ps_iface_to_m0_edge_list.size());</div>
<div class="line"><span class="lineno"> 4912</span>            std::vector&lt;int&gt;&amp; m0_cm_cutpath_adjacent_polygons_LOCAL = std::get&lt;2&gt;(local_output);</div>
<div class="line"><span class="lineno"> 4913</span>            m0_cm_cutpath_adjacent_polygons_LOCAL.reserve(ps_iface_to_m0_edge_list.size());</div>
<div class="line"><span class="lineno"> 4914</span>            <span class="keywordtype">int</span>&amp; traced_sm_polygon_count_LOCAL = std::get&lt;3&gt;(local_output);</div>
<div class="line"><span class="lineno"> 4915</span>            std::unordered_map&lt;int, fd_t&gt;&amp; m0_to_ps_face_LOCAL = std::get&lt;4&gt;(local_output);</div>
<div class="line"><span class="lineno"> 4916</span>            m0_to_ps_face_LOCAL.reserve(num_elems);</div>
<div class="line"><span class="lineno"> 4917</span>            traced_sm_polygon_count_LOCAL = 0;</div>
<div class="line"><span class="lineno"> 4918</span> </div>
<div class="line"><span class="lineno"> 4919</span>            <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">face_array_iterator_t</a> ps_face_iter = block_start_; ps_face_iter != block_end_; ++ps_face_iter) {</div>
<div class="line"><span class="lineno"> 4920</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a>&amp; ps_face = *ps_face_iter;</div>
<div class="line"><span class="lineno"> 4921</span> </div>
<div class="line"><span class="lineno"> 4922</span>                <span class="comment">// get all the edges that lie on &quot;ps_face&quot;, including the new one after partiting acording to intersection</span></div>
<div class="line"><span class="lineno"> 4923</span>                <span class="comment">// points, and the old one which did not intersect any face</span></div>
<div class="line"><span class="lineno"> 4924</span>                std::unordered_map&lt;fd_t, std::vector&lt;ed_t&gt;&gt;::iterator ps_iface_to_m0_edge_list_fiter = ps_iface_to_m0_edge_list.find(ps_face);</div>
<div class="line"><span class="lineno"> 4925</span> </div>
<div class="line"><span class="lineno"> 4926</span>                <span class="keywordtype">bool</span> is_intersecting_ps_face = ps_iface_to_m0_edge_list_fiter != ps_iface_to_m0_edge_list.end();</div>
<div class="line"><span class="lineno"> 4927</span>                <span class="keywordtype">bool</span> is_from_cut_mesh = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aaf65fb11520f9cb197774e79efeddfbb">ps_is_cutmesh_face</a>(ps_face, sm_face_count);</div>
<div class="line"><span class="lineno"> 4928</span> </div>
<div class="line"><span class="lineno"> 4929</span>                std::vector&lt;traced_polygon_t&gt; child_polygons; <span class="comment">// new polygons traced on current face</span></div>
<div class="line"><span class="lineno"> 4930</span> </div>
<div class="line"><span class="lineno"> 4931</span>                <span class="keywordflow">if</span> (is_intersecting_ps_face == <span class="keyword">false</span>) { <span class="comment">// non-intersecting face</span></div>
<div class="line"><span class="lineno"> 4932</span> </div>
<div class="line"><span class="lineno"> 4933</span>                    <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a> retraced_poly; <span class="comment">// ordered sequence of halfedges defining the unchanged polygon</span></div>
<div class="line"><span class="lineno"> 4934</span>                    std::vector&lt;hd_t&gt; halfedges_around_face = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a86f122fb5db56b6f79b21b657d3326f9">get_halfedges_around_face</a>(ps_face);</div>
<div class="line"><span class="lineno"> 4935</span>                    retraced_poly.reserve(halfedges_around_face.size()); <span class="comment">// minimum 3 (triangle)</span></div>
<div class="line"><span class="lineno"> 4936</span> </div>
<div class="line"><span class="lineno"> 4937</span>                    <span class="comment">// for each halfedge in the current polygon</span></div>
<div class="line"><span class="lineno"> 4938</span>                    <span class="keywordflow">for</span> (std::vector&lt;hd_t&gt;::const_iterator hbegin = halfedges_around_face.cbegin(); hbegin != halfedges_around_face.cend(); ++hbegin) {</div>
<div class="line"><span class="lineno"> 4939</span>                        <span class="comment">// get the source and target vertex descriptors in the polygon soup</span></div>
<div class="line"><span class="lineno"> 4940</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> ps_h_src = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(*hbegin);</div>
<div class="line"><span class="lineno"> 4941</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> ps_h_tgt = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(*hbegin);</div>
<div class="line"><span class="lineno"> 4942</span> </div>
<div class="line"><span class="lineno"> 4943</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">int</span>)(ps_h_src) &lt; (<span class="keywordtype">int</span>)ps_to_m0_vtx.size());</div>
<div class="line"><span class="lineno"> 4944</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_h_src = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_to_m0_vtx, ps_h_src);</div>
<div class="line"><span class="lineno"> 4945</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">int</span>)(ps_h_tgt) &lt; (<span class="keywordtype">int</span>)ps_to_m0_vtx.size());</div>
<div class="line"><span class="lineno"> 4946</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_h_tgt = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_to_m0_vtx, ps_h_tgt);</div>
<div class="line"><span class="lineno"> 4947</span> </div>
<div class="line"><span class="lineno"> 4948</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> ps_edge = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a96e9db918396b86f0b61f5445ef46b18">edge</a>(*hbegin);</div>
<div class="line"><span class="lineno"> 4949</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> m0_edge = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_to_m0_non_intersecting_edge, ps_edge);</div>
<div class="line"><span class="lineno"> 4950</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m0_edge_h0 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(m0_edge, 0);</div>
<div class="line"><span class="lineno"> 4951</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m0_edge_h1 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(m0_edge, 1);</div>
<div class="line"><span class="lineno"> 4952</span> </div>
<div class="line"><span class="lineno"> 4953</span>                        <span class="comment">// resolve the correct halfedge by match the source and target vertex descriptors</span></div>
<div class="line"><span class="lineno"> 4954</span>                        <span class="keywordflow">if</span> (m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(m0_edge_h0) == m0_h_src &amp;&amp; m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m0_edge_h0) == m0_h_tgt) {</div>
<div class="line"><span class="lineno"> 4955</span>                            retraced_poly.emplace_back(m0_edge_h0);</div>
<div class="line"><span class="lineno"> 4956</span>                        } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 4957</span>                            retraced_poly.emplace_back(m0_edge_h1);</div>
<div class="line"><span class="lineno"> 4958</span>                        }</div>
<div class="line"><span class="lineno"> 4959</span>                    }</div>
<div class="line"><span class="lineno"> 4960</span> </div>
<div class="line"><span class="lineno"> 4961</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(retraced_poly.size() == halfedges_around_face.size());</div>
<div class="line"><span class="lineno"> 4962</span> </div>
<div class="line"><span class="lineno"> 4963</span>                    <span class="keyword">const</span> <span class="keywordtype">int</span> poly_idx = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)(m0_polygons_LOCAL.size() + child_polygons.size());</div>
<div class="line"><span class="lineno"> 4964</span>                    m0_to_ps_face_LOCAL[poly_idx] = ps_face;</div>
<div class="line"><span class="lineno"> 4965</span> </div>
<div class="line"><span class="lineno"> 4966</span>                    child_polygons.emplace_back(retraced_poly);</div>
<div class="line"><span class="lineno"> 4967</span>                } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 4968</span> </div>
<div class="line"><span class="lineno"> 4969</span>                    <span class="comment">// Here we enter the complex case of having to actually clip the current face</span></div>
<div class="line"><span class="lineno"> 4970</span>                    <span class="comment">// because it is intersecting</span></div>
<div class="line"><span class="lineno"> 4971</span>                    <span class="comment">// --------------------------------------------------------------------------</span></div>
<div class="line"><span class="lineno"> 4972</span> </div>
<div class="line"><span class="lineno"> 4973</span>                    <span class="keyword">const</span> std::vector&lt;ed_t&gt;&amp; ps_iface_m0_edge_list = ps_iface_to_m0_edge_list_fiter-&gt;second;</div>
<div class="line"><span class="lineno"> 4974</span>                    <span class="keyword">static</span> <span class="keyword">thread_local</span> std::vector&lt;vd_t&gt; ps_coincident_vertices_tmp;</div>
<div class="line"><span class="lineno"> 4975</span> </div>
<div class="line"><span class="lineno"> 4976</span>                    ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a765a6f3b7249eb47135d246f6d301102">get_vertices_around_face</a>(ps_coincident_vertices_tmp, ps_face);</div>
<div class="line"><span class="lineno"> 4977</span>                    <span class="keyword">const</span> std::vector&lt;vd_t&gt;&amp; ps_coincident_vertices = ps_coincident_vertices_tmp;</div>
<div class="line"><span class="lineno"> 4978</span>                    <span class="keyword">static</span> <span class="keyword">thread_local</span> std::vector&lt;vd_t&gt; coincident_vertices; <span class="comment">// &quot;m0&quot; versions of those stored in &quot;ps_coincident_vertices&quot;</span></div>
<div class="line"><span class="lineno"> 4979</span>                    coincident_vertices.resize(ps_coincident_vertices.size());</div>
<div class="line"><span class="lineno"> 4980</span>                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)ps_coincident_vertices.size(); ++i) {</div>
<div class="line"><span class="lineno"> 4981</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> ps_v = ps_coincident_vertices[i];</div>
<div class="line"><span class="lineno"> 4982</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">int</span>)(ps_v) &lt; (<span class="keywordtype">int</span>)ps_to_m0_vtx.size() <span class="comment">/*ps_to_m0_vtx.find(ps_v) != ps_to_m0_vtx.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 4983</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_v = ps_to_m0_vtx[ps_v];</div>
<div class="line"><span class="lineno"> 4984</span>                        coincident_vertices[i] = m0_v;</div>
<div class="line"><span class="lineno"> 4985</span>                    }</div>
<div class="line"><span class="lineno"> 4986</span> </div>
<div class="line"><span class="lineno"> 4987</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(coincident_vertices.size() == ps_coincident_vertices.size());</div>
<div class="line"><span class="lineno"> 4988</span> </div>
<div class="line"><span class="lineno"> 4989</span>                    <span class="keyword">const</span> std::unordered_map&lt;fd_t, std::vector&lt;vd_t&gt;&gt;::const_iterator ireg_entry_iter = ps_iface_to_ivtx_list.find(ps_face);</div>
<div class="line"><span class="lineno"> 4990</span> </div>
<div class="line"><span class="lineno"> 4991</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ireg_entry_iter != ps_iface_to_ivtx_list.cend());</div>
<div class="line"><span class="lineno"> 4992</span> </div>
<div class="line"><span class="lineno"> 4993</span>                    <span class="keyword">const</span> std::vector&lt;vd_t&gt;&amp; intersection_points_on_face = ireg_entry_iter-&gt;second;</div>
<div class="line"><span class="lineno"> 4994</span>                    coincident_vertices.reserve(coincident_vertices.size() + intersection_points_on_face.size());</div>
<div class="line"><span class="lineno"> 4995</span>                    coincident_vertices.insert(coincident_vertices.end(), intersection_points_on_face.cbegin(), intersection_points_on_face.cend());</div>
<div class="line"><span class="lineno"> 4996</span> </div>
<div class="line"><span class="lineno"> 4997</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(intersection_points_on_face.size() &gt;= 2); <span class="comment">// minimum (two intersecting convex polygons)</span></div>
<div class="line"><span class="lineno"> 4998</span> </div>
<div class="line"><span class="lineno"> 4999</span>                    std::vector&lt;ed_t&gt; incident_edges = ps_iface_m0_edge_list; <span class="comment">// COPY because &quot;incident_edges&quot; will be modified later</span></div>
<div class="line"><span class="lineno"> 5000</span>                    <span class="keywordtype">int</span> incident_boundary_edge_count = 0;</div>
<div class="line"><span class="lineno"> 5001</span> </div>
<div class="line"><span class="lineno"> 5002</span>                    std::partition(incident_edges.begin(), incident_edges.end(),</div>
<div class="line"><span class="lineno"> 5003</span>                        [&amp;](<span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; e) {</div>
<div class="line"><span class="lineno"> 5004</span>                            const vd_t v0 = m0.vertex(e, 0);</div>
<div class="line"><span class="lineno"> 5005</span>                            const vd_t v1 = m0.vertex(e, 1);</div>
<div class="line"><span class="lineno"> 5006</span>                            const bool v0_is_ivtx = m0_is_intersection_point(v0, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 5007</span>                            const bool v1_is_ivtx = m0_is_intersection_point(v1, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 5008</span>                            const bool is_ambiguious_boundary_edge_case = (v0_is_ivtx &amp;&amp; v1_is_ivtx);</div>
<div class="line"><span class="lineno"> 5009</span>                            bool is_valid_ambiguious_boundary_edge = false;</div>
<div class="line"><span class="lineno"> 5010</span> </div>
<div class="line"><span class="lineno"> 5011</span>                            if (is_ambiguious_boundary_edge_case) {</div>
<div class="line"><span class="lineno"> 5012</span>                                MCUT_ASSERT((size_t)v0 - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/* m0_ivtx_to_intersection_registry_entry.find(v0) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 5013</span>                                const std::pair&lt;ed_t, fd_t&gt;&amp; v0_ipair = SAFE_ACCESS(m0_ivtx_to_intersection_registry_entry, (std::size_t)v0 - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 5014</span>                                const ed_t v0_ps_edge = v0_ipair.first; <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_edge, v0); // ps.edge(v0_coincident_ps_halfedge);</span></div>
<div class="line"><span class="lineno"> 5015</span> </div>
<div class="line"><span class="lineno"> 5016</span>                                MCUT_ASSERT((size_t)v1 - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(v1) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 5017</span>                                const std::pair&lt;ed_t, fd_t&gt;&amp; v1_ipair = SAFE_ACCESS(m0_ivtx_to_intersection_registry_entry, (std::size_t)v1 - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 5018</span>                                const ed_t v1_ps_edge = v1_ipair.first; <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_edge, v1); // ps.edge(v1_coincident_ps_halfedge);</span></div>
<div class="line"><span class="lineno"> 5019</span> </div>
<div class="line"><span class="lineno"> 5020</span>                                is_valid_ambiguious_boundary_edge = (v0_ps_edge == v1_ps_edge);</div>
<div class="line"><span class="lineno"> 5021</span>                            }</div>
<div class="line"><span class="lineno"> 5022</span> </div>
<div class="line"><span class="lineno"> 5023</span>                            <span class="keywordtype">bool</span> is_boundary_edge = (!is_ambiguious_boundary_edge_case || is_valid_ambiguious_boundary_edge);</div>
<div class="line"><span class="lineno"> 5024</span>                            <span class="keywordflow">if</span> (is_boundary_edge) {</div>
<div class="line"><span class="lineno"> 5025</span>                                incident_boundary_edge_count++; <span class="comment">// count</span></div>
<div class="line"><span class="lineno"> 5026</span>                            }</div>
<div class="line"><span class="lineno"> 5027</span>                            <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/d25/namespaceigl.html#a39d02bea0e57dce707ada6bc3228d22a">is_boundary_edge</a>;</div>
<div class="line"><span class="lineno"> 5028</span>                        });</div>
<div class="line"><span class="lineno"> 5029</span> </div>
<div class="line"><span class="lineno"> 5030</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(incident_boundary_edge_count &gt;= 3); <span class="comment">// minimum is 3 edge which is for a triangle</span></div>
<div class="line"><span class="lineno"> 5031</span> </div>
<div class="line"><span class="lineno"> 5032</span>                    <span class="comment">// const int interior_edges_on_face = (int)incident_edges.size() - incident_boundary_edge_count;</span></div>
<div class="line"><span class="lineno"> 5033</span>                    std::vector&lt;hd_t&gt; incident_halfedges;</div>
<div class="line"><span class="lineno"> 5034</span>                    <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> first_boundary_halfedge = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno"> 5035</span> </div>
<div class="line"><span class="lineno"> 5036</span>                    <span class="keywordflow">for</span> (std::vector&lt;ed_t&gt;::const_iterator incident_edge_iter = incident_edges.cbegin();</div>
<div class="line"><span class="lineno"> 5037</span>                         incident_edge_iter != incident_edges.cbegin() + incident_boundary_edge_count;</div>
<div class="line"><span class="lineno"> 5038</span>                         ++incident_edge_iter) {</div>
<div class="line"><span class="lineno"> 5039</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; edge = (*incident_edge_iter);</div>
<div class="line"><span class="lineno"> 5040</span> </div>
<div class="line"><span class="lineno"> 5041</span>                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> edge_he_iter = 0; edge_he_iter &lt; 2; ++edge_he_iter) {</div>
<div class="line"><span class="lineno"> 5042</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m0_edge_he = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(edge, edge_he_iter);</div>
<div class="line"><span class="lineno"> 5043</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_edge_he_src = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(m0_edge_he);</div>
<div class="line"><span class="lineno"> 5044</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_edge_he_tgt = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m0_edge_he);</div>
<div class="line"><span class="lineno"> 5045</span>                            <span class="keyword">const</span> <span class="keywordtype">bool</span> m0_edge_he_src_is_ivertex = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0_edge_he_src, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 5046</span>                            <span class="keyword">const</span> <span class="keywordtype">bool</span> m0_edge_he_tgt_is_ivertex = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0_edge_he_tgt, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 5047</span> </div>
<div class="line"><span class="lineno"> 5048</span>                            <span class="keywordflow">if</span> (!m0_edge_he_src_is_ivertex &amp;&amp; !m0_edge_he_tgt_is_ivertex) { <span class="comment">// o--&gt;o (unmodified original edge)</span></div>
<div class="line"><span class="lineno"> 5049</span> </div>
<div class="line"><span class="lineno"> 5050</span>                                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> ps_he_src = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_ps_vtx, m0_edge_he_src);</div>
<div class="line"><span class="lineno"> 5051</span>                                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> ps_he_tgt = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_ps_vtx, m0_edge_he_tgt);</div>
<div class="line"><span class="lineno"> 5052</span>                                <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> ps_he = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(ps_he_src, ps_he_tgt);</div>
<div class="line"><span class="lineno"> 5053</span> </div>
<div class="line"><span class="lineno"> 5054</span>                                <span class="keywordflow">if</span> (ps_he == <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>()) {</div>
<div class="line"><span class="lineno"> 5055</span>                                    <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 5056</span>                                }</div>
<div class="line"><span class="lineno"> 5057</span> </div>
<div class="line"><span class="lineno"> 5058</span>                                <span class="keywordflow">if</span> (ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(ps_he) == ps_face) {</div>
<div class="line"><span class="lineno"> 5059</span>                                    first_boundary_halfedge = m0_edge_he;</div>
<div class="line"><span class="lineno"> 5060</span>                                    <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 5061</span>                                }</div>
<div class="line"><span class="lineno"> 5062</span>                            } <span class="keywordflow">else</span> { <span class="comment">// x--&gt;x OR o--&gt;x OR x--&gt;o</span></div>
<div class="line"><span class="lineno"> 5063</span>                                <span class="keyword">const</span> <span class="keywordtype">bool</span> is_ox = (!m0_edge_he_src_is_ivertex &amp;&amp; m0_edge_he_tgt_is_ivertex);</div>
<div class="line"><span class="lineno"> 5064</span> </div>
<div class="line"><span class="lineno"> 5065</span>                                <span class="keywordflow">if</span> (is_ox) {</div>
<div class="line"><span class="lineno"> 5066</span>                                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)m0_edge_he_tgt - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(m0_edge_he_tgt) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 5067</span>                                    <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt;&amp; m0_edge_he_tgt_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, (std::size_t)m0_edge_he_tgt - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 5068</span> </div>
<div class="line"><span class="lineno"> 5069</span>                                    <span class="comment">// get the incident ps-halfedge of tgt</span></div>
<div class="line"><span class="lineno"> 5070</span>                                    <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> tgt_ps_e = m0_edge_he_tgt_ipair.first;</div>
<div class="line"><span class="lineno"> 5071</span>                                    <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> tgt_ps_h = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(tgt_ps_e, 0);</div>
<div class="line"><span class="lineno"> 5072</span> </div>
<div class="line"><span class="lineno"> 5073</span>                                    <span class="keywordflow">if</span> (ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(tgt_ps_h) != ps_face) {</div>
<div class="line"><span class="lineno"> 5074</span>                                        tgt_ps_h = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(tgt_ps_h);</div>
<div class="line"><span class="lineno"> 5075</span>                                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(tgt_ps_h != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>());</div>
<div class="line"><span class="lineno"> 5076</span>                                    }</div>
<div class="line"><span class="lineno"> 5077</span> </div>
<div class="line"><span class="lineno"> 5078</span>                                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a>&amp; m0_edge_he_src_as_ps_vertex = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_ps_vtx, m0_edge_he_src);</div>
<div class="line"><span class="lineno"> 5079</span> </div>
<div class="line"><span class="lineno"> 5080</span>                                    <span class="keywordflow">if</span> (m0_edge_he_src_as_ps_vertex == ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(tgt_ps_h)) { <span class="comment">// is counter clock-wise halfedge</span></div>
<div class="line"><span class="lineno"> 5081</span>                                        first_boundary_halfedge = m0_edge_he;</div>
<div class="line"><span class="lineno"> 5082</span>                                        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 5083</span>                                    }</div>
<div class="line"><span class="lineno"> 5084</span>                                } <span class="keywordflow">else</span> { <span class="comment">// x--&gt;x OR x--&gt;o</span></div>
<div class="line"><span class="lineno"> 5085</span> </div>
<div class="line"><span class="lineno"> 5086</span>                                    <span class="keyword">const</span> <span class="keywordtype">bool</span> is_xx = m0_edge_he_src_is_ivertex &amp;&amp; m0_edge_he_tgt_is_ivertex;</div>
<div class="line"><span class="lineno"> 5087</span> </div>
<div class="line"><span class="lineno"> 5088</span>                                    <span class="keywordflow">if</span> (is_xx) { <span class="comment">// exterior interior-iedge</span></div>
<div class="line"><span class="lineno"> 5089</span>                                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)m0_edge_he_src - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(m0_edge_he_src) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 5090</span>                                        <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt;&amp; m0_edge_he_src_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, (std::size_t)m0_edge_he_src - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 5091</span>                                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)m0_edge_he_tgt - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(m0_edge_he_tgt) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 5092</span>                                        <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt;&amp; m0_edge_he_tgt_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, (std::size_t)m0_edge_he_tgt - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 5093</span> </div>
<div class="line"><span class="lineno"> 5094</span>                                        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> src_ps_edge = m0_edge_he_src_ipair.first; <span class="comment">// ps.edge(src_coincident_ps_halfedge)</span></div>
<div class="line"><span class="lineno"> 5095</span>                                        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> tgt_ps_edge = m0_edge_he_tgt_ipair.first; <span class="comment">// ps.edge(tgt_ps_h);</span></div>
<div class="line"><span class="lineno"> 5096</span>                                        <span class="keyword">const</span> <span class="keywordtype">bool</span> is_exterior_ih = (src_ps_edge == tgt_ps_edge);</div>
<div class="line"><span class="lineno"> 5097</span> </div>
<div class="line"><span class="lineno"> 5098</span>                                        <span class="keywordflow">if</span> (!is_exterior_ih) {</div>
<div class="line"><span class="lineno"> 5099</span>                                            <span class="keywordflow">continue</span>; <span class="comment">// interior ihalfedges cannot be used as the first exterior ihalfedge</span></div>
<div class="line"><span class="lineno"> 5100</span>                                        }</div>
<div class="line"><span class="lineno"> 5101</span> </div>
<div class="line"><span class="lineno"> 5102</span>                                        <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> ps_halfedge_of_face = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(tgt_ps_edge, 0); <span class="comment">// tgt_ps_h;</span></div>
<div class="line"><span class="lineno"> 5103</span> </div>
<div class="line"><span class="lineno"> 5104</span>                                        <span class="keywordflow">if</span> (ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(ps_halfedge_of_face) != ps_face) {</div>
<div class="line"><span class="lineno"> 5105</span>                                            ps_halfedge_of_face = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(ps_halfedge_of_face);</div>
<div class="line"><span class="lineno"> 5106</span>                                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ps_halfedge_of_face != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>()); <span class="comment">// guarranteed to exist since we have a poly-boundary interior ihalfedge</span></div>
<div class="line"><span class="lineno"> 5107</span>                                        }</div>
<div class="line"><span class="lineno"> 5108</span> </div>
<div class="line"><span class="lineno"> 5109</span>                                        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; incident_ps_edge = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a96e9db918396b86f0b61f5445ef46b18">edge</a>(ps_halfedge_of_face);</div>
<div class="line"><span class="lineno"> 5110</span>                                        std::map&lt;ed_t, std::vector&lt;ed_t&gt;&gt;::const_iterator ps_to_m0_edges_find_iter = ps_to_m0_edges.find(incident_ps_edge);</div>
<div class="line"><span class="lineno"> 5111</span>                                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ps_to_m0_edges_find_iter != ps_to_m0_edges.cend()); <span class="comment">// because incident_ps_edge contains a polygon exterior interior ihalfedge</span></div>
<div class="line"><span class="lineno"> 5112</span> </div>
<div class="line"><span class="lineno"> 5113</span>                                        <span class="keyword">const</span> std::vector&lt;ed_t&gt;&amp; sorted_m0_edges = ps_to_m0_edges_find_iter-&gt;second;</div>
<div class="line"><span class="lineno"> 5114</span>                                        std::vector&lt;hd_t&gt; halfedge_sequence;</div>
<div class="line"><span class="lineno"> 5115</span>                                        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; first_e = sorted_m0_edges.front();</div>
<div class="line"><span class="lineno"> 5116</span>                                        <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> first_he = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(first_e, 0);</div>
<div class="line"><span class="lineno"> 5117</span>                                        <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> first_he_src = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(first_he);</div>
<div class="line"><span class="lineno"> 5118</span> </div>
<div class="line"><span class="lineno"> 5119</span>                                        <span class="keywordflow">if</span> (<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(first_he_src, ps_vtx_cnt)) {</div>
<div class="line"><span class="lineno"> 5120</span>                                            <span class="comment">// TODO: I think this scope is never entered based on how we created &quot;sorted_m0_edges&quot;.</span></div>
<div class="line"><span class="lineno"> 5121</span>                                            <span class="comment">// Thus, the source vertex of the first halfedge in the sequence cannot be an intersection point</span></div>
<div class="line"><span class="lineno"> 5122</span>                                            first_he = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(first_e, 1);</div>
<div class="line"><span class="lineno"> 5123</span>                                            first_he_src = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(first_he);</div>
<div class="line"><span class="lineno"> 5124</span>                                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(!<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(first_he_src, ps_vtx_cnt)); <span class="comment">// expect original vertex since halfedge edge is the first in sequence</span></div>
<div class="line"><span class="lineno"> 5125</span>                                        }</div>
<div class="line"><span class="lineno"> 5126</span> </div>
<div class="line"><span class="lineno"> 5127</span>                                        halfedge_sequence.push_back(first_he);</div>
<div class="line"><span class="lineno"> 5128</span> </div>
<div class="line"><span class="lineno"> 5129</span>                                        <span class="keywordflow">for</span> (std::vector&lt;ed_t&gt;::const_iterator seq_edge_iter = sorted_m0_edges.cbegin() + 1; <span class="comment">// we have already added the first halfedge</span></div>
<div class="line"><span class="lineno"> 5130</span>                                             seq_edge_iter != sorted_m0_edges.cend(); ++seq_edge_iter) {</div>
<div class="line"><span class="lineno"> 5131</span>                                            <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; e = *seq_edge_iter;</div>
<div class="line"><span class="lineno"> 5132</span>                                            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h0 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(e, 0);</div>
<div class="line"><span class="lineno"> 5133</span> </div>
<div class="line"><span class="lineno"> 5134</span>                                            <span class="keywordflow">if</span> (m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(h0) == m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(halfedge_sequence.back())) {</div>
<div class="line"><span class="lineno"> 5135</span>                                                halfedge_sequence.push_back(h0);</div>
<div class="line"><span class="lineno"> 5136</span>                                            } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 5137</span>                                                <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h1 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(e, 1);</div>
<div class="line"><span class="lineno"> 5138</span>                                                halfedge_sequence.push_back(h1);</div>
<div class="line"><span class="lineno"> 5139</span>                                            }</div>
<div class="line"><span class="lineno"> 5140</span>                                        }</div>
<div class="line"><span class="lineno"> 5141</span> </div>
<div class="line"><span class="lineno"> 5142</span>                                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(halfedge_sequence.size() == sorted_m0_edges.size());</div>
<div class="line"><span class="lineno"> 5143</span> </div>
<div class="line"><span class="lineno"> 5144</span>                                        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a>&amp; first_he_src_as_ps_vertex = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_ps_vtx, first_he_src); <span class="comment">// first he of sequence</span></div>
<div class="line"><span class="lineno"> 5145</span> </div>
<div class="line"><span class="lineno"> 5146</span>                                        <span class="keywordflow">if</span> (first_he_src_as_ps_vertex != ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(ps_halfedge_of_face)) {</div>
<div class="line"><span class="lineno"> 5147</span>                                            std::for_each(</div>
<div class="line"><span class="lineno"> 5148</span>                                                halfedge_sequence.begin(),</div>
<div class="line"><span class="lineno"> 5149</span>                                                halfedge_sequence.end(),</div>
<div class="line"><span class="lineno"> 5150</span>                                                [&amp;](<a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; he) {</div>
<div class="line"><span class="lineno"> 5151</span>                                                    he = m0.opposite(he);</div>
<div class="line"><span class="lineno"> 5152</span>                                                }); <span class="comment">// flip seq</span></div>
<div class="line"><span class="lineno"> 5153</span>                                        }</div>
<div class="line"><span class="lineno"> 5154</span> </div>
<div class="line"><span class="lineno"> 5155</span>                                        std::vector&lt;hd_t&gt;::const_iterator matching_he_find_iter = std::find_if(</div>
<div class="line"><span class="lineno"> 5156</span>                                            halfedge_sequence.cbegin(),</div>
<div class="line"><span class="lineno"> 5157</span>                                            halfedge_sequence.cend(),</div>
<div class="line"><span class="lineno"> 5158</span>                                            [&amp;](<span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; he) {</div>
<div class="line"><span class="lineno"> 5159</span>                                                const vd_t&amp; he_src = m0.source(he);</div>
<div class="line"><span class="lineno"> 5160</span>                                                const vd_t&amp; he_tgt = m0.target(he);</div>
<div class="line"><span class="lineno"> 5161</span> </div>
<div class="line"><span class="lineno"> 5162</span>                                                return (he_src == m0_edge_he_src &amp;&amp; he_tgt == m0_edge_he_tgt <span class="comment">/*|| (he_src == m0_edge_he_tgt &amp;&amp; he_tgt == m0_edge_he_src*/</span>);</div>
<div class="line"><span class="lineno"> 5163</span>                                            });</div>
<div class="line"><span class="lineno"> 5164</span> </div>
<div class="line"><span class="lineno"> 5165</span>                                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(matching_he_find_iter != halfedge_sequence.cend()); <span class="comment">// does the potential halfedge actually point in the correct direction or not</span></div>
<div class="line"><span class="lineno"> 5166</span>                                        {</div>
<div class="line"><span class="lineno"> 5167</span>                                            first_boundary_halfedge = *matching_he_find_iter;</div>
<div class="line"><span class="lineno"> 5168</span>                                            <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 5169</span>                                        }</div>
<div class="line"><span class="lineno"> 5170</span>                                    } <span class="comment">// if (is_xx) {</span></div>
<div class="line"><span class="lineno"> 5171</span>                                    <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 5172</span>                                    }</div>
<div class="line"><span class="lineno"> 5173</span>                                } <span class="comment">// } else { // x--&gt;x OR x--&gt;o</span></div>
<div class="line"><span class="lineno"> 5174</span>                            } <span class="comment">// } else { // x--&gt;x OR o--&gt;x OR x--&gt;o</span></div>
<div class="line"><span class="lineno"> 5175</span>                        } <span class="comment">// for (int edge_he_iter = 0; edge_he_iter &lt; 2; ++edge_he_iter) {</span></div>
<div class="line"><span class="lineno"> 5176</span> </div>
<div class="line"><span class="lineno"> 5177</span>                        <span class="keywordflow">if</span> (first_boundary_halfedge != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>()) {</div>
<div class="line"><span class="lineno"> 5178</span>                            <span class="keywordflow">break</span>; <span class="comment">// done</span></div>
<div class="line"><span class="lineno"> 5179</span>                        }</div>
<div class="line"><span class="lineno"> 5180</span>                    }</div>
<div class="line"><span class="lineno"> 5181</span> </div>
<div class="line"><span class="lineno"> 5182</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(first_boundary_halfedge != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>());</div>
<div class="line"><span class="lineno"> 5183</span> </div>
<div class="line"><span class="lineno"> 5184</span>                    <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> current_exterior_halfedge = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno"> 5185</span>                    <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> next_exterior_halfedge = first_boundary_halfedge;</div>
<div class="line"><span class="lineno"> 5186</span>                    std::unordered_map&lt;ed_t, bool&gt; walked_edges;</div>
<div class="line"><span class="lineno"> 5187</span> </div>
<div class="line"><span class="lineno"> 5188</span>                    <span class="keywordflow">do</span> {</div>
<div class="line"><span class="lineno"> 5189</span> </div>
<div class="line"><span class="lineno"> 5190</span>                        current_exterior_halfedge = next_exterior_halfedge;</div>
<div class="line"><span class="lineno"> 5191</span>                        incident_halfedges.push_back(current_exterior_halfedge);</div>
<div class="line"><span class="lineno"> 5192</span>                        walked_edges[m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a96e9db918396b86f0b61f5445ef46b18">edge</a>(current_exterior_halfedge)] = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 5193</span> </div>
<div class="line"><span class="lineno"> 5194</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> current_tgt = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(current_exterior_halfedge);</div>
<div class="line"><span class="lineno"> 5195</span>                        next_exterior_halfedge = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>(); <span class="comment">// reset</span></div>
<div class="line"><span class="lineno"> 5196</span> </div>
<div class="line"><span class="lineno"> 5197</span>                        <span class="comment">// find next boundary halfedge from incident edges</span></div>
<div class="line"><span class="lineno"> 5198</span>                        <span class="keywordflow">for</span> (std::vector&lt;ed_t&gt;::const_iterator incident_edge_iter = incident_edges.cbegin();</div>
<div class="line"><span class="lineno"> 5199</span>                             incident_edge_iter != incident_edges.cbegin() + incident_boundary_edge_count; <span class="comment">// we only want exterior edges;</span></div>
<div class="line"><span class="lineno"> 5200</span>                             ++incident_edge_iter) {</div>
<div class="line"><span class="lineno"> 5201</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; edge = *incident_edge_iter;</div>
<div class="line"><span class="lineno"> 5202</span>                            <span class="keywordtype">bool</span> edge_walked = walked_edges.find(edge) != walked_edges.cend(); <span class="comment">// std::find(walked_edges.cbegin(), walked_edges.cend(), edge) != walked_edges.cend();</span></div>
<div class="line"><span class="lineno"> 5203</span> </div>
<div class="line"><span class="lineno"> 5204</span>                            <span class="keywordflow">if</span> (edge_walked) {</div>
<div class="line"><span class="lineno"> 5205</span>                                <span class="keywordflow">continue</span>; <span class="comment">// skip edge is walked already</span></div>
<div class="line"><span class="lineno"> 5206</span>                            }</div>
<div class="line"><span class="lineno"> 5207</span> </div>
<div class="line"><span class="lineno"> 5208</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> v0 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(edge, 0);</div>
<div class="line"><span class="lineno"> 5209</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> v1 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(edge, 1);</div>
<div class="line"><span class="lineno"> 5210</span> </div>
<div class="line"><span class="lineno"> 5211</span>                            <span class="keywordflow">if</span> (v0 == current_tgt || v1 == current_tgt) <span class="comment">// check if connected to current (i.e. they share one vertex)</span></div>
<div class="line"><span class="lineno"> 5212</span>                            {</div>
<div class="line"><span class="lineno"> 5213</span>                                <span class="keyword">const</span> <span class="keywordtype">bool</span> v0_is_ivtx = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(v0, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 5214</span>                                <span class="keyword">const</span> <span class="keywordtype">bool</span> v1_is_ivtx = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(v1, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 5215</span>                                <span class="keywordtype">bool</span> is_ambiguious_boundary_edge_case = v0_is_ivtx &amp;&amp; v1_is_ivtx;</div>
<div class="line"><span class="lineno"> 5216</span>                                <span class="keywordtype">bool</span> is_valid_ambiguious_boundary_edge = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 5217</span> </div>
<div class="line"><span class="lineno"> 5218</span>                                <span class="keywordflow">if</span> (is_ambiguious_boundary_edge_case) { <span class="comment">// exterior edge with two intersection vertices (ambigious case arising from concave polyhedron cut)</span></div>
<div class="line"><span class="lineno"> 5219</span> </div>
<div class="line"><span class="lineno"> 5220</span>                                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)v0 - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/* m0_ivtx_to_intersection_registry_entry.find(v0) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 5221</span>                                    <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt;&amp; v0_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, (std::size_t)v0 - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 5222</span>                                    <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> v0_ps_edge = v0_ipair.first; <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_edge, v0); //ps.edge(v0_coincident_ps_halfedge);</span></div>
<div class="line"><span class="lineno"> 5223</span> </div>
<div class="line"><span class="lineno"> 5224</span>                                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)v1 - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/* m0_ivtx_to_intersection_registry_entry.find(v1) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 5225</span>                                    <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt;&amp; v1_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, (std::size_t)v1 - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 5226</span>                                    <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> v1_ps_edge = v1_ipair.first; <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_edge, v1); // ps.edge(v1_coincident_ps_halfedge);</span></div>
<div class="line"><span class="lineno"> 5227</span> </div>
<div class="line"><span class="lineno"> 5228</span>                                    is_valid_ambiguious_boundary_edge = (v0_ps_edge == v1_ps_edge); <span class="comment">// see also above when gathering exterior incident edges</span></div>
<div class="line"><span class="lineno"> 5229</span>                                }</div>
<div class="line"><span class="lineno"> 5230</span> </div>
<div class="line"><span class="lineno"> 5231</span>                                <span class="keywordflow">if</span> (!is_ambiguious_boundary_edge_case || is_valid_ambiguious_boundary_edge) {</div>
<div class="line"><span class="lineno"> 5232</span>                                    <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h0 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(edge, 0);</div>
<div class="line"><span class="lineno"> 5233</span>                                    <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h1 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(edge, 1);</div>
<div class="line"><span class="lineno"> 5234</span> </div>
<div class="line"><span class="lineno"> 5235</span>                                    next_exterior_halfedge = h0;</div>
<div class="line"><span class="lineno"> 5236</span> </div>
<div class="line"><span class="lineno"> 5237</span>                                    <span class="keywordflow">if</span> (m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(h0) != current_tgt) <span class="comment">// h0 is facing the opposite dir</span></div>
<div class="line"><span class="lineno"> 5238</span>                                    {</div>
<div class="line"><span class="lineno"> 5239</span>                                        next_exterior_halfedge = h1;</div>
<div class="line"><span class="lineno"> 5240</span>                                    }</div>
<div class="line"><span class="lineno"> 5241</span> </div>
<div class="line"><span class="lineno"> 5242</span>                                    <span class="keywordflow">break</span>; <span class="comment">// found</span></div>
<div class="line"><span class="lineno"> 5243</span>                                }</div>
<div class="line"><span class="lineno"> 5244</span>                            }</div>
<div class="line"><span class="lineno"> 5245</span>                        }</div>
<div class="line"><span class="lineno"> 5246</span>                    } <span class="keywordflow">while</span> (next_exterior_halfedge != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>() <span class="comment">/*first_boundary_halfedge*/</span>);</div>
<div class="line"><span class="lineno"> 5247</span> </div>
<div class="line"><span class="lineno"> 5248</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(incident_halfedges.size() &gt;= 3); <span class="comment">// minimum i.e. for a triangles!</span></div>
<div class="line"><span class="lineno"> 5249</span> </div>
<div class="line"><span class="lineno"> 5250</span>                    <span class="keyword">const</span> <span class="keywordtype">int</span> exterior_halfedge_count = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)incident_halfedges.size();</div>
<div class="line"><span class="lineno"> 5251</span> </div>
<div class="line"><span class="lineno"> 5252</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(exterior_halfedge_count == incident_boundary_edge_count);</div>
<div class="line"><span class="lineno"> 5253</span> </div>
<div class="line"><span class="lineno"> 5254</span>                    <span class="keywordflow">for</span> (std::vector&lt;ed_t&gt;::const_iterator incident_edge_iter = incident_edges.cbegin() + incident_boundary_edge_count; <span class="comment">// start from polygon interior edges offset</span></div>
<div class="line"><span class="lineno"> 5255</span>                         incident_edge_iter != incident_edges.cend();</div>
<div class="line"><span class="lineno"> 5256</span>                         ++incident_edge_iter) {</div>
<div class="line"><span class="lineno"> 5257</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; edge = (*incident_edge_iter);</div>
<div class="line"><span class="lineno"> 5258</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h0 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(edge, 0);</div>
<div class="line"><span class="lineno"> 5259</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h1 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(edge, 1);</div>
<div class="line"><span class="lineno"> 5260</span>                        incident_halfedges.push_back(h0);</div>
<div class="line"><span class="lineno"> 5261</span>                        incident_halfedges.push_back(h1);</div>
<div class="line"><span class="lineno"> 5262</span>                    }</div>
<div class="line"><span class="lineno"> 5263</span> </div>
<div class="line"><span class="lineno"> 5264</span>                    std::vector&lt;hd_t&gt; incident_halfedges_to_be_walked(incident_halfedges.cbegin(), incident_halfedges.cend()); <span class="comment">// copy</span></div>
<div class="line"><span class="lineno"> 5265</span> </div>
<div class="line"><span class="lineno"> 5266</span>                    <span class="keywordflow">do</span> { <span class="comment">// each iteration traces a child polygon</span></div>
<div class="line"><span class="lineno"> 5267</span> </div>
<div class="line"><span class="lineno"> 5268</span>                        <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a> child_polygon;</div>
<div class="line"><span class="lineno"> 5269</span>                        <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> current_halfedge = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno"> 5270</span>                        <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> next_halfedge = incident_halfedges_to_be_walked.front();</div>
<div class="line"><span class="lineno"> 5271</span> </div>
<div class="line"><span class="lineno"> 5272</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(incident_halfedges_to_be_walked.size() &gt;= 2);</div>
<div class="line"><span class="lineno"> 5273</span> </div>
<div class="line"><span class="lineno"> 5274</span>                        <span class="keywordtype">bool</span> is_valid_polygon = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 5275</span>                        <span class="keywordflow">do</span> { <span class="comment">// each iteration walks a halfedge to incremetally trace a child polygon</span></div>
<div class="line"><span class="lineno"> 5276</span> </div>
<div class="line"><span class="lineno"> 5277</span>                            current_halfedge = next_halfedge;</div>
<div class="line"><span class="lineno"> 5278</span>                            child_polygon.push_back(current_halfedge);</div>
<div class="line"><span class="lineno"> 5279</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> current_halfedge_target = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(current_halfedge);</div>
<div class="line"><span class="lineno"> 5280</span>                            next_halfedge = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>(); <span class="comment">// reset</span></div>
<div class="line"><span class="lineno"> 5281</span> </div>
<div class="line"><span class="lineno"> 5282</span>                            {</div>
<div class="line"><span class="lineno"> 5283</span>                                std::vector&lt;hd_t&gt;::iterator find_iter = std::find(incident_halfedges_to_be_walked.begin(), incident_halfedges_to_be_walked.end(), current_halfedge);</div>
<div class="line"><span class="lineno"> 5284</span>                                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(find_iter != incident_halfedges_to_be_walked.cend());</div>
<div class="line"><span class="lineno"> 5285</span>                                incident_halfedges_to_be_walked.erase(find_iter); <span class="comment">// remove</span></div>
<div class="line"><span class="lineno"> 5286</span>                            }</div>
<div class="line"><span class="lineno"> 5287</span> </div>
<div class="line"><span class="lineno"> 5288</span>                            <span class="keywordflow">if</span> (child_polygon.size() &gt;= 3) { <span class="comment">// minimum halfedge count to constitute a valid polygon (triangle)</span></div>
<div class="line"><span class="lineno"> 5289</span> </div>
<div class="line"><span class="lineno"> 5290</span>                                <span class="comment">// source of first halfedge is target of last</span></div>
<div class="line"><span class="lineno"> 5291</span>                                <span class="keywordflow">if</span> (m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(child_polygon.front()) == m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(child_polygon.back())) {</div>
<div class="line"><span class="lineno"> 5292</span>                                    <span class="keywordflow">if</span> (current_halfedge != m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(child_polygon.front())) {</div>
<div class="line"><span class="lineno"> 5293</span>                                        is_valid_polygon = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 5294</span>                                        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 5295</span>                                    } <span class="keywordflow">else</span> { <span class="comment">// ... if the current halfedge is the opposite of the first halfedge in list</span></div>
<div class="line"><span class="lineno"> 5296</span>                                        std::vector&lt;hd_t&gt; premptive_candidate_halfedges;</div>
<div class="line"><span class="lineno"> 5297</span>                                        <span class="keywordflow">for</span> (std::vector&lt;hd_t&gt;::const_iterator incident_halfedges_to_be_walked_iter = incident_halfedges_to_be_walked.cbegin(); incident_halfedges_to_be_walked_iter != incident_halfedges_to_be_walked.cend(); ++incident_halfedges_to_be_walked_iter) {</div>
<div class="line"><span class="lineno"> 5298</span>                                            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; potential_candidate = *incident_halfedges_to_be_walked_iter;</div>
<div class="line"><span class="lineno"> 5299</span>                                            <span class="keywordflow">if</span> (m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(potential_candidate) == current_halfedge_target) {</div>
<div class="line"><span class="lineno"> 5300</span>                                                premptive_candidate_halfedges.push_back(potential_candidate);</div>
<div class="line"><span class="lineno"> 5301</span>                                            }</div>
<div class="line"><span class="lineno"> 5302</span>                                        }</div>
<div class="line"><span class="lineno"> 5303</span> </div>
<div class="line"><span class="lineno"> 5304</span>                                        <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> prime_candidate = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno"> 5305</span>                                        <span class="keywordflow">if</span> (premptive_candidate_halfedges.size() == 2) {</div>
<div class="line"><span class="lineno"> 5306</span> </div>
<div class="line"><span class="lineno"> 5307</span>                                            <span class="keyword">const</span> std::vector&lt;hd_t&gt;::const_iterator current_halfedge_find_iter = std::find(incident_halfedges.cbegin(), incident_halfedges.cend(), current_halfedge);</div>
<div class="line"><span class="lineno"> 5308</span>                                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(current_halfedge_find_iter != incident_halfedges.cend());</div>
<div class="line"><span class="lineno"> 5309</span>                                            <span class="keyword">const</span> <span class="keywordtype">bool</span> current_halfedge_is_exterior = <a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(incident_halfedges.cbegin(), current_halfedge_find_iter) &lt; exterior_halfedge_count;</div>
<div class="line"><span class="lineno"> 5310</span> </div>
<div class="line"><span class="lineno"> 5311</span>                                            <span class="keywordflow">if</span> (current_halfedge_is_exterior) {</div>
<div class="line"><span class="lineno"> 5312</span> </div>
<div class="line"><span class="lineno"> 5313</span>                                                <span class="comment">// pick interior candidate</span></div>
<div class="line"><span class="lineno"> 5314</span>                                                <span class="keyword">const</span> std::vector&lt;hd_t&gt;::const_iterator prime_candidate_find_iter = std::find(incident_halfedges.cbegin(), incident_halfedges.cend(), current_halfedge);</div>
<div class="line"><span class="lineno"> 5315</span>                                                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(prime_candidate_find_iter != incident_halfedges.cend());</div>
<div class="line"><span class="lineno"> 5316</span>                                                <span class="keyword">const</span> <span class="keywordtype">bool</span> prime_candidate_is_exterior = <a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(incident_halfedges.cbegin(), prime_candidate_find_iter) &lt; exterior_halfedge_count;</div>
<div class="line"><span class="lineno"> 5317</span> </div>
<div class="line"><span class="lineno"> 5318</span>                                                <span class="keywordflow">if</span> (prime_candidate_is_exterior) {</div>
<div class="line"><span class="lineno"> 5319</span>                                                    prime_candidate = premptive_candidate_halfedges.back(); <span class="comment">// select correct interior halfedge</span></div>
<div class="line"><span class="lineno"> 5320</span>                                                }</div>
<div class="line"><span class="lineno"> 5321</span>                                            } <span class="keywordflow">else</span> { <span class="comment">// interior</span></div>
<div class="line"><span class="lineno"> 5322</span> </div>
<div class="line"><span class="lineno"> 5323</span>                                                <span class="comment">// pick non-opposite</span></div>
<div class="line"><span class="lineno"> 5324</span>                                                <span class="keyword">const</span> <span class="keywordtype">bool</span> prime_candidate_is_opposite = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(current_halfedge) == prime_candidate;</div>
<div class="line"><span class="lineno"> 5325</span> </div>
<div class="line"><span class="lineno"> 5326</span>                                                <span class="keywordflow">if</span> (prime_candidate_is_opposite) {</div>
<div class="line"><span class="lineno"> 5327</span>                                                    prime_candidate = premptive_candidate_halfedges.back(); <span class="comment">// select correct non-opposite halfedge</span></div>
<div class="line"><span class="lineno"> 5328</span>                                                }</div>
<div class="line"><span class="lineno"> 5329</span>                                            }</div>
<div class="line"><span class="lineno"> 5330</span>                                        }</div>
<div class="line"><span class="lineno"> 5331</span> </div>
<div class="line"><span class="lineno"> 5332</span>                                        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> premptive_next = prime_candidate;</div>
<div class="line"><span class="lineno"> 5333</span> </div>
<div class="line"><span class="lineno"> 5334</span>                                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(premptive_candidate_halfedges.size() &lt;= 2);</div>
<div class="line"><span class="lineno"> 5335</span> </div>
<div class="line"><span class="lineno"> 5336</span>                                        <span class="keywordflow">if</span> (std::find(child_polygon.cbegin(), child_polygon.cend(), premptive_next) != child_polygon.cend()) {</div>
<div class="line"><span class="lineno"> 5337</span>                                            is_valid_polygon = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 5338</span>                                            <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 5339</span>                                        }</div>
<div class="line"><span class="lineno"> 5340</span>                                    }</div>
<div class="line"><span class="lineno"> 5341</span>                                }</div>
<div class="line"><span class="lineno"> 5342</span>                            }</div>
<div class="line"><span class="lineno"> 5343</span> </div>
<div class="line"><span class="lineno"> 5344</span>                            std::vector&lt;hd_t&gt; candidate_halfedges;</div>
<div class="line"><span class="lineno"> 5345</span>                            candidate_halfedges.reserve(2); <span class="comment">// two candidates at most because we filtered out exterior interior-halfedges as well as clockwise (cw) halfedge</span></div>
<div class="line"><span class="lineno"> 5346</span> </div>
<div class="line"><span class="lineno"> 5347</span>                            <span class="keywordflow">for</span> (std::vector&lt;hd_t&gt;::const_iterator incident_halfedges_to_be_walked_iter = incident_halfedges_to_be_walked.cbegin(); incident_halfedges_to_be_walked_iter != incident_halfedges_to_be_walked.cend(); ++incident_halfedges_to_be_walked_iter) {</div>
<div class="line"><span class="lineno"> 5348</span>                                <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; potential_candidate = *incident_halfedges_to_be_walked_iter;</div>
<div class="line"><span class="lineno"> 5349</span>                                <span class="keywordflow">if</span> (m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(potential_candidate) == current_halfedge_target) {</div>
<div class="line"><span class="lineno"> 5350</span>                                    candidate_halfedges.push_back(potential_candidate);</div>
<div class="line"><span class="lineno"> 5351</span>                                }</div>
<div class="line"><span class="lineno"> 5352</span>                            }</div>
<div class="line"><span class="lineno"> 5353</span> </div>
<div class="line"><span class="lineno"> 5354</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(candidate_halfedges.size() &lt;= 2);</div>
<div class="line"><span class="lineno"> 5355</span> </div>
<div class="line"><span class="lineno"> 5356</span>                            <span class="comment">// 2.2. select prime candidate</span></div>
<div class="line"><span class="lineno"> 5357</span>                            <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> prime_candidate = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno"> 5358</span> </div>
<div class="line"><span class="lineno"> 5359</span>                            <span class="keywordflow">if</span> (!candidate_halfedges.empty()) {</div>
<div class="line"><span class="lineno"> 5360</span>                                prime_candidate = candidate_halfedges.front(); <span class="comment">// assuming: candidate_halfedges.size() == 1</span></div>
<div class="line"><span class="lineno"> 5361</span>                            }</div>
<div class="line"><span class="lineno"> 5362</span> </div>
<div class="line"><span class="lineno"> 5363</span>                            <span class="keywordflow">if</span> (candidate_halfedges.size() == 2) {</div>
<div class="line"><span class="lineno"> 5364</span> </div>
<div class="line"><span class="lineno"> 5365</span>                                <span class="keyword">const</span> std::vector&lt;hd_t&gt;::const_iterator current_halfedge_find_iter = std::find(incident_halfedges.cbegin(), incident_halfedges.cend(), current_halfedge);</div>
<div class="line"><span class="lineno"> 5366</span>                                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(current_halfedge_find_iter != incident_halfedges.cend());</div>
<div class="line"><span class="lineno"> 5367</span>                                <span class="keyword">const</span> <span class="keywordtype">bool</span> current_halfedge_is_exterior = <a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(incident_halfedges.cbegin(), current_halfedge_find_iter) &lt; exterior_halfedge_count;</div>
<div class="line"><span class="lineno"> 5368</span> </div>
<div class="line"><span class="lineno"> 5369</span>                                <span class="keywordflow">if</span> (current_halfedge_is_exterior) {</div>
<div class="line"><span class="lineno"> 5370</span>                                    <span class="comment">// pick interior candidate</span></div>
<div class="line"><span class="lineno"> 5371</span>                                    <span class="keyword">const</span> std::vector&lt;hd_t&gt;::const_iterator prime_candidate_find_iter = std::find(incident_halfedges.cbegin(), incident_halfedges.cend(), current_halfedge);</div>
<div class="line"><span class="lineno"> 5372</span>                                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(prime_candidate_find_iter != incident_halfedges.cend());</div>
<div class="line"><span class="lineno"> 5373</span>                                    <span class="keyword">const</span> <span class="keywordtype">bool</span> prime_candidate_is_exterior = <a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(incident_halfedges.cbegin(), prime_candidate_find_iter) &lt; exterior_halfedge_count;</div>
<div class="line"><span class="lineno"> 5374</span> </div>
<div class="line"><span class="lineno"> 5375</span>                                    <span class="keywordflow">if</span> (prime_candidate_is_exterior) {</div>
<div class="line"><span class="lineno"> 5376</span>                                        prime_candidate = candidate_halfedges.back(); <span class="comment">// select correct interior halfedge</span></div>
<div class="line"><span class="lineno"> 5377</span>                                    }</div>
<div class="line"><span class="lineno"> 5378</span>                                } <span class="keywordflow">else</span> { <span class="comment">// interior</span></div>
<div class="line"><span class="lineno"> 5379</span>                                    <span class="keyword">const</span> <span class="keywordtype">bool</span> prime_candidate_is_opposite = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(current_halfedge) == prime_candidate;</div>
<div class="line"><span class="lineno"> 5380</span> </div>
<div class="line"><span class="lineno"> 5381</span>                                    <span class="keywordflow">if</span> (prime_candidate_is_opposite) {</div>
<div class="line"><span class="lineno"> 5382</span>                                        prime_candidate = candidate_halfedges.back(); <span class="comment">// select correct non-opposite halfedge</span></div>
<div class="line"><span class="lineno"> 5383</span>                                    }</div>
<div class="line"><span class="lineno"> 5384</span>                                }</div>
<div class="line"><span class="lineno"> 5385</span>                            }</div>
<div class="line"><span class="lineno"> 5386</span> </div>
<div class="line"><span class="lineno"> 5387</span>                            next_halfedge = prime_candidate;</div>
<div class="line"><span class="lineno"> 5388</span>                        } <span class="keywordflow">while</span> (next_halfedge != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>());</div>
<div class="line"><span class="lineno"> 5389</span> </div>
<div class="line"><span class="lineno"> 5390</span>                        <span class="keywordflow">if</span> (is_valid_polygon) {</div>
<div class="line"><span class="lineno"> 5391</span> </div>
<div class="line"><span class="lineno"> 5392</span>                            <span class="keyword">const</span> <span class="keywordtype">int</span> poly_idx = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)(m0_polygons_LOCAL.size() + child_polygons.size());</div>
<div class="line"><span class="lineno"> 5393</span>                            <span class="keywordflow">if</span> (<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aaf65fb11520f9cb197774e79efeddfbb">ps_is_cutmesh_face</a>(ps_face, sm_face_count)) {</div>
<div class="line"><span class="lineno"> 5394</span>                                m0_cm_cutpath_adjacent_polygons_LOCAL.push_back(poly_idx);</div>
<div class="line"><span class="lineno"> 5395</span>                            } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 5396</span>                                m0_sm_cutpath_adjacent_polygons_LOCAL.push_back(poly_idx);</div>
<div class="line"><span class="lineno"> 5397</span>                            }</div>
<div class="line"><span class="lineno"> 5398</span> </div>
<div class="line"><span class="lineno"> 5399</span>                            m0_to_ps_face_LOCAL[poly_idx] = ps_face;</div>
<div class="line"><span class="lineno"> 5400</span>                            child_polygons.emplace_back(child_polygon);</div>
<div class="line"><span class="lineno"> 5401</span>                        }</div>
<div class="line"><span class="lineno"> 5402</span> </div>
<div class="line"><span class="lineno"> 5403</span>                    } <span class="keywordflow">while</span> (!incident_halfedges_to_be_walked.empty());</div>
<div class="line"><span class="lineno"> 5404</span>                } <span class="comment">// if (!is_intersecting_ps_face) {</span></div>
<div class="line"><span class="lineno"> 5405</span> </div>
<div class="line"><span class="lineno"> 5406</span>                m0_polygons_LOCAL.insert(m0_polygons_LOCAL.end(), child_polygons.cbegin(), child_polygons.cend());</div>
<div class="line"><span class="lineno"> 5407</span> </div>
<div class="line"><span class="lineno"> 5408</span>                <span class="keywordflow">if</span> (!is_from_cut_mesh) {</div>
<div class="line"><span class="lineno"> 5409</span>                    traced_sm_polygon_count_LOCAL += (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)child_polygons.size();</div>
<div class="line"><span class="lineno"> 5410</span>                }</div>
<div class="line"><span class="lineno"> 5411</span>            }</div>
<div class="line"><span class="lineno"> 5412</span> </div>
<div class="line"><span class="lineno"> 5413</span>            <span class="keywordflow">return</span> local_output;</div>
<div class="line"><span class="lineno"> 5414</span>        };</div>
<div class="line"><span class="lineno"> 5415</span> </div>
<div class="line"><span class="lineno"> 5416</span>        std::vector&lt;std::future&lt;OutputStorageTypesTuple&gt;&gt; futures;</div>
<div class="line"><span class="lineno"> 5417</span>        OutputStorageTypesTuple partial_res;</div>
<div class="line"><span class="lineno"> 5418</span> </div>
<div class="line"><span class="lineno"> 5419</span>        <a class="code hl_function" href="../../df/d05/tpool_8h.html#a48d2e68725f7691f1422697f4c359827">parallel_for</a>(</div>
<div class="line"><span class="lineno"> 5420</span>            *input.scheduler,</div>
<div class="line"><span class="lineno"> 5421</span>            ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a913e50afe2e1dc220a379b1dbf8050d2">faces_begin</a>(),</div>
<div class="line"><span class="lineno"> 5422</span>            ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a89e4f1f34dda0bdeced26bc71cb4a4fc">faces_end</a>(),</div>
<div class="line"><span class="lineno"> 5423</span>            fn_trace_polygons,</div>
<div class="line"><span class="lineno"> 5424</span>            partial_res, <span class="comment">// output computed by master thread</span></div>
<div class="line"><span class="lineno"> 5425</span>            futures);</div>
<div class="line"><span class="lineno"> 5426</span> </div>
<div class="line"><span class="lineno"> 5427</span>        <span class="comment">// This lambda merges the local traced face data structures computed by each</span></div>
<div class="line"><span class="lineno"> 5428</span>        <span class="comment">// thread into their corresponding global data structure.</span></div>
<div class="line"><span class="lineno"> 5429</span>        <span class="keyword">auto</span> merge_local_traced_faces = [](</div>
<div class="line"><span class="lineno"> 5430</span>                                            <span class="keyword">const</span> std::vector&lt;traced_polygon_t&gt;&amp; m0_polygons_FUTURE,</div>
<div class="line"><span class="lineno"> 5431</span>                                            <span class="keyword">const</span> std::vector&lt;int&gt;&amp; m0_sm_cutpath_adjacent_polygons_FUTURE,</div>
<div class="line"><span class="lineno"> 5432</span>                                            <span class="keyword">const</span> std::vector&lt;int&gt;&amp; m0_cm_cutpath_adjacent_polygons_FUTURE,</div>
<div class="line"><span class="lineno"> 5433</span>                                            <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; traced_sm_polygon_count_FUTURE,</div>
<div class="line"><span class="lineno"> 5434</span>                                            <span class="keyword">const</span> std::unordered_map&lt;int, fd_t&gt;&amp; m0_to_ps_face_FUTURE,</div>
<div class="line"><span class="lineno"> 5435</span>                                            std::vector&lt;traced_polygon_t&gt;&amp; m0_polygons,</div>
<div class="line"><span class="lineno"> 5436</span>                                            std::vector&lt;int&gt;&amp; m0_sm_cutpath_adjacent_polygons,</div>
<div class="line"><span class="lineno"> 5437</span>                                            std::vector&lt;int&gt;&amp; m0_cm_cutpath_adjacent_polygons,</div>
<div class="line"><span class="lineno"> 5438</span>                                            <span class="keywordtype">int</span>&amp; traced_sm_polygon_count,</div>
<div class="line"><span class="lineno"> 5439</span>                                            std::unordered_map&lt;int, fd_t&gt;&amp; m0_to_ps_face) {</div>
<div class="line"><span class="lineno"> 5440</span>            <span class="keywordtype">int</span> base_offset = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)m0_polygons.size();</div>
<div class="line"><span class="lineno"> 5441</span>            m0_polygons.reserve(m0_polygons.size() + m0_polygons_FUTURE.size());</div>
<div class="line"><span class="lineno"> 5442</span>            m0_polygons.insert(m0_polygons.end(), m0_polygons_FUTURE.cbegin(), m0_polygons_FUTURE.cend());</div>
<div class="line"><span class="lineno"> 5443</span> </div>
<div class="line"><span class="lineno"> 5444</span>            m0_sm_cutpath_adjacent_polygons.reserve(m0_sm_cutpath_adjacent_polygons.size() + m0_sm_cutpath_adjacent_polygons_FUTURE.size());</div>
<div class="line"><span class="lineno"> 5445</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)m0_sm_cutpath_adjacent_polygons_FUTURE.size(); ++i) {</div>
<div class="line"><span class="lineno"> 5446</span>                <span class="keyword">const</span> <span class="keywordtype">int</span> local_polygon_idx = m0_sm_cutpath_adjacent_polygons_FUTURE[i];</div>
<div class="line"><span class="lineno"> 5447</span>                <span class="keyword">const</span> <span class="keywordtype">int</span> global_polygon_idx = local_polygon_idx + base_offset;</div>
<div class="line"><span class="lineno"> 5448</span>                m0_sm_cutpath_adjacent_polygons.push_back(global_polygon_idx);</div>
<div class="line"><span class="lineno"> 5449</span>            }</div>
<div class="line"><span class="lineno"> 5450</span> </div>
<div class="line"><span class="lineno"> 5451</span>            m0_cm_cutpath_adjacent_polygons.reserve(m0_cm_cutpath_adjacent_polygons.size() + m0_cm_cutpath_adjacent_polygons_FUTURE.size());</div>
<div class="line"><span class="lineno"> 5452</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)m0_cm_cutpath_adjacent_polygons_FUTURE.size(); ++i) {</div>
<div class="line"><span class="lineno"> 5453</span>                <span class="keyword">const</span> <span class="keywordtype">int</span> local_polygon_idx = m0_cm_cutpath_adjacent_polygons_FUTURE[i];</div>
<div class="line"><span class="lineno"> 5454</span>                <span class="keyword">const</span> <span class="keywordtype">int</span> global_polygon_idx = local_polygon_idx + base_offset;</div>
<div class="line"><span class="lineno"> 5455</span>                m0_cm_cutpath_adjacent_polygons.push_back(global_polygon_idx);</div>
<div class="line"><span class="lineno"> 5456</span>            }</div>
<div class="line"><span class="lineno"> 5457</span> </div>
<div class="line"><span class="lineno"> 5458</span>            traced_sm_polygon_count += traced_sm_polygon_count_FUTURE;</div>
<div class="line"><span class="lineno"> 5459</span> </div>
<div class="line"><span class="lineno"> 5460</span>            <span class="keywordflow">for</span> (std::unordered_map&lt;int, fd_t&gt;::const_iterator i = m0_to_ps_face_FUTURE.cbegin(); i != m0_to_ps_face_FUTURE.cend(); ++i) {</div>
<div class="line"><span class="lineno"> 5461</span>                <span class="keyword">const</span> <span class="keywordtype">int</span> local_polygon_idx = i-&gt;first;</div>
<div class="line"><span class="lineno"> 5462</span>                <span class="keyword">const</span> <span class="keywordtype">int</span> global_polygon_idx = local_polygon_idx + base_offset;</div>
<div class="line"><span class="lineno"> 5463</span>                m0_to_ps_face[global_polygon_idx] = i-&gt;second;</div>
<div class="line"><span class="lineno"> 5464</span>            }</div>
<div class="line"><span class="lineno"> 5465</span>        };</div>
<div class="line"><span class="lineno"> 5466</span> </div>
<div class="line"><span class="lineno"> 5467</span>        <span class="comment">// merge thread-local output into global data structures</span></div>
<div class="line"><span class="lineno"> 5468</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)futures.size(); ++i) {</div>
<div class="line"><span class="lineno"> 5469</span>            std::future&lt;OutputStorageTypesTuple&gt;&amp; f = futures[i];</div>
<div class="line"><span class="lineno"> 5470</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(f.valid());</div>
<div class="line"><span class="lineno"> 5471</span>            OutputStorageTypesTuple future_result = f.get(); <span class="comment">// &quot;get()&quot; is a blocking function</span></div>
<div class="line"><span class="lineno"> 5472</span> </div>
<div class="line"><span class="lineno"> 5473</span>            <span class="keyword">const</span> std::vector&lt;traced_polygon_t&gt;&amp; m0_polygons_FUTURE = std::get&lt;0&gt;(future_result);</div>
<div class="line"><span class="lineno"> 5474</span>            <span class="keyword">const</span> std::vector&lt;int&gt;&amp; m0_sm_cutpath_adjacent_polygons_FUTURE = std::get&lt;1&gt;(future_result);</div>
<div class="line"><span class="lineno"> 5475</span>            <span class="keyword">const</span> std::vector&lt;int&gt;&amp; m0_cm_cutpath_adjacent_polygons_FUTURE = std::get&lt;2&gt;(future_result);</div>
<div class="line"><span class="lineno"> 5476</span>            <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; traced_sm_polygon_count_FUTURE = std::get&lt;3&gt;(future_result);</div>
<div class="line"><span class="lineno"> 5477</span>            <span class="keyword">const</span> std::unordered_map&lt;int, fd_t&gt;&amp; m0_to_ps_face_FUTURE = std::get&lt;4&gt;(future_result);</div>
<div class="line"><span class="lineno"> 5478</span> </div>
<div class="line"><span class="lineno"> 5479</span>            merge_local_traced_faces(</div>
<div class="line"><span class="lineno"> 5480</span>                m0_polygons_FUTURE,</div>
<div class="line"><span class="lineno"> 5481</span>                m0_sm_cutpath_adjacent_polygons_FUTURE,</div>
<div class="line"><span class="lineno"> 5482</span>                m0_cm_cutpath_adjacent_polygons_FUTURE,</div>
<div class="line"><span class="lineno"> 5483</span>                traced_sm_polygon_count_FUTURE,</div>
<div class="line"><span class="lineno"> 5484</span>                m0_to_ps_face_FUTURE,</div>
<div class="line"><span class="lineno"> 5485</span>                m0_polygons,</div>
<div class="line"><span class="lineno"> 5486</span>                m0_sm_cutpath_adjacent_polygons,</div>
<div class="line"><span class="lineno"> 5487</span>                m0_cm_cutpath_adjacent_polygons,</div>
<div class="line"><span class="lineno"> 5488</span>                traced_sm_polygon_count,</div>
<div class="line"><span class="lineno"> 5489</span>                m0_to_ps_face);</div>
<div class="line"><span class="lineno"> 5490</span>        }</div>
<div class="line"><span class="lineno"> 5491</span> </div>
<div class="line"><span class="lineno"> 5492</span>        <span class="comment">// merge master thread output at the end to that we maintain the order of the traced polygons</span></div>
<div class="line"><span class="lineno"> 5493</span>        <span class="comment">// This order is important for a number of tricks employed throughout the code in following parts</span></div>
<div class="line"><span class="lineno"> 5494</span>        <span class="comment">// e.g. using integer offsets to infer the start of cm traced polygons etc.</span></div>
<div class="line"><span class="lineno"> 5495</span>        <span class="keyword">const</span> std::vector&lt;traced_polygon_t&gt;&amp; m0_polygons_MASTER_THREAD_LOCAL = std::get&lt;0&gt;(partial_res);</div>
<div class="line"><span class="lineno"> 5496</span>        <span class="keyword">const</span> std::vector&lt;int&gt;&amp; m0_sm_cutpath_adjacent_polygons_MASTER_THREAD_LOCAL = std::get&lt;1&gt;(partial_res);</div>
<div class="line"><span class="lineno"> 5497</span>        <span class="keyword">const</span> std::vector&lt;int&gt;&amp; m0_cm_cutpath_adjacent_polygons_MASTER_THREAD_LOCAL = std::get&lt;2&gt;(partial_res);</div>
<div class="line"><span class="lineno"> 5498</span>        <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; traced_sm_polygon_count_MASTER_THREAD_LOCAL = std::get&lt;3&gt;(partial_res);</div>
<div class="line"><span class="lineno"> 5499</span>        <span class="keyword">const</span> std::unordered_map&lt;int, fd_t&gt;&amp; m0_to_ps_face_MASTER_THREAD_LOCAL = std::get&lt;4&gt;(partial_res);</div>
<div class="line"><span class="lineno"> 5500</span> </div>
<div class="line"><span class="lineno"> 5501</span>        merge_local_traced_faces(</div>
<div class="line"><span class="lineno"> 5502</span>            m0_polygons_MASTER_THREAD_LOCAL,</div>
<div class="line"><span class="lineno"> 5503</span>            m0_sm_cutpath_adjacent_polygons_MASTER_THREAD_LOCAL,</div>
<div class="line"><span class="lineno"> 5504</span>            m0_cm_cutpath_adjacent_polygons_MASTER_THREAD_LOCAL,</div>
<div class="line"><span class="lineno"> 5505</span>            traced_sm_polygon_count_MASTER_THREAD_LOCAL,</div>
<div class="line"><span class="lineno"> 5506</span>            m0_to_ps_face_MASTER_THREAD_LOCAL,</div>
<div class="line"><span class="lineno"> 5507</span>            m0_polygons,</div>
<div class="line"><span class="lineno"> 5508</span>            m0_sm_cutpath_adjacent_polygons,</div>
<div class="line"><span class="lineno"> 5509</span>            m0_cm_cutpath_adjacent_polygons,</div>
<div class="line"><span class="lineno"> 5510</span>            traced_sm_polygon_count,</div>
<div class="line"><span class="lineno"> 5511</span>            m0_to_ps_face);</div>
<div class="line"><span class="lineno"> 5512</span>    } <span class="comment">// end of parallel scope</span></div>
<div class="line"><span class="lineno"> 5513</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno"> 5514</span>    <span class="comment">// for each face in the polygon-soup mesh</span></div>
<div class="line"><span class="lineno"> 5515</span>    <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">face_array_iterator_t</a> ps_face_iter = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a913e50afe2e1dc220a379b1dbf8050d2">faces_begin</a>(); ps_face_iter != ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a89e4f1f34dda0bdeced26bc71cb4a4fc">faces_end</a>(); ++ps_face_iter) {</div>
<div class="line"><span class="lineno"> 5516</span> </div>
<div class="line"><span class="lineno"> 5517</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a>&amp; ps_face = *ps_face_iter;</div>
<div class="line"><span class="lineno"> 5518</span> </div>
<div class="line"><span class="lineno"> 5519</span>        <span class="comment">// get all the edges that lie on &quot;ps_face&quot;, including the new one after partiting acording to intersection</span></div>
<div class="line"><span class="lineno"> 5520</span>        <span class="comment">// points, and the old one which did not intersect any face</span></div>
<div class="line"><span class="lineno"> 5521</span>        std::unordered_map&lt;fd_t, std::vector&lt;ed_t&gt;&gt;::iterator ps_iface_to_m0_edge_list_fiter = ps_iface_to_m0_edge_list.find(ps_face);</div>
<div class="line"><span class="lineno"> 5522</span> </div>
<div class="line"><span class="lineno"> 5523</span>        <span class="keywordtype">bool</span> is_intersecting_ps_face = ps_iface_to_m0_edge_list_fiter != ps_iface_to_m0_edge_list.end();</div>
<div class="line"><span class="lineno"> 5524</span>        <span class="keywordtype">bool</span> is_from_cut_mesh = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aaf65fb11520f9cb197774e79efeddfbb">ps_is_cutmesh_face</a>(ps_face, sm_face_count);</div>
<div class="line"><span class="lineno"> 5525</span> </div>
<div class="line"><span class="lineno"> 5526</span>        std::vector&lt;traced_polygon_t&gt; child_polygons; <span class="comment">// new polygons traced on current face</span></div>
<div class="line"><span class="lineno"> 5527</span> </div>
<div class="line"><span class="lineno"> 5528</span>        <span class="keywordflow">if</span> (is_intersecting_ps_face == <span class="keyword">false</span>) { <span class="comment">// non-intersecting face</span></div>
<div class="line"><span class="lineno"> 5529</span> </div>
<div class="line"><span class="lineno"> 5530</span>            <span class="comment">// NOTE: here we just copy the polygon as-is because it does not change.</span></div>
<div class="line"><span class="lineno"> 5531</span>            <span class="comment">// --------------------------------------------------------------------</span></div>
<div class="line"><span class="lineno"> 5532</span> </div>
<div class="line"><span class="lineno"> 5533</span>            <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a> retraced_poly; <span class="comment">// ordered sequence of halfedges defining the unchanged polygon</span></div>
<div class="line"><span class="lineno"> 5534</span> </div>
<div class="line"><span class="lineno"> 5535</span>            <span class="comment">// query the halfedge sequence in the polygon soup that defines our polygon</span></div>
<div class="line"><span class="lineno"> 5536</span>            std::vector&lt;hd_t&gt; halfedges_around_face = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a86f122fb5db56b6f79b21b657d3326f9">get_halfedges_around_face</a>(ps_face);</div>
<div class="line"><span class="lineno"> 5537</span> </div>
<div class="line"><span class="lineno"> 5538</span>            retraced_poly.reserve(halfedges_around_face.size()); <span class="comment">// minimum 3 (triangle)</span></div>
<div class="line"><span class="lineno"> 5539</span> </div>
<div class="line"><span class="lineno"> 5540</span>            <span class="comment">// what we are going to do now is:</span></div>
<div class="line"><span class="lineno"> 5541</span>            <span class="comment">//  for each halfedge in &quot;halfedges_around_face&quot; (ps), find its equivalent halfedge in &quot;m0&quot;</span></div>
<div class="line"><span class="lineno"> 5542</span>            <span class="comment">//  The found m0-halfedges will then define &quot;retraced_poly&quot;</span></div>
<div class="line"><span class="lineno"> 5543</span>            <span class="comment">// ----------------------------------------------------------------------------------------</span></div>
<div class="line"><span class="lineno"> 5544</span> </div>
<div class="line"><span class="lineno"> 5545</span>            <span class="comment">// for each halfedge in the current polygon</span></div>
<div class="line"><span class="lineno"> 5546</span>            <span class="keywordflow">for</span> (std::vector&lt;hd_t&gt;::const_iterator hbegin = halfedges_around_face.cbegin(); hbegin != halfedges_around_face.cend(); ++hbegin) {</div>
<div class="line"><span class="lineno"> 5547</span> </div>
<div class="line"><span class="lineno"> 5548</span>                <span class="comment">// get the source and target vertex descriptors in the polygon soup</span></div>
<div class="line"><span class="lineno"> 5549</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> ps_h_src = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(*hbegin);</div>
<div class="line"><span class="lineno"> 5550</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> ps_h_tgt = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(*hbegin);</div>
<div class="line"><span class="lineno"> 5551</span> </div>
<div class="line"><span class="lineno"> 5552</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">int</span>)(ps_h_src) &lt; (<span class="keywordtype">int</span>)ps_to_m0_vtx.size() <span class="comment">/*ps_to_m0_vtx.find(ps_h_src) != ps_to_m0_vtx.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 5553</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_h_src = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_to_m0_vtx, ps_h_src);</div>
<div class="line"><span class="lineno"> 5554</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">int</span>)(ps_h_tgt) &lt; (<span class="keywordtype">int</span>)ps_to_m0_vtx.size() <span class="comment">/*ps_to_m0_vtx.find(ps_h_tgt) != ps_to_m0_vtx.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 5555</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_h_tgt = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_to_m0_vtx, ps_h_tgt);</div>
<div class="line"><span class="lineno"> 5556</span> </div>
<div class="line"><span class="lineno"> 5557</span>                <span class="comment">// Now we find the actual &quot;m0&quot; halfedge equivalent to &quot;*hbegin&quot; using</span></div>
<div class="line"><span class="lineno"> 5558</span>                <span class="comment">// our &quot;m0&quot; source and target descriptors</span></div>
<div class="line"><span class="lineno"> 5559</span>                <span class="comment">// --------------------------------------------------------------------</span></div>
<div class="line"><span class="lineno"> 5560</span> </div>
<div class="line"><span class="lineno"> 5561</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> ps_edge = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a96e9db918396b86f0b61f5445ef46b18">edge</a>(*hbegin); <span class="comment">// polygon soup version of the edge of the current halfedge</span></div>
<div class="line"><span class="lineno"> 5562</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> m0_edge = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_to_m0_non_intersecting_edge, ps_edge); <span class="comment">// &quot;m0&quot; version of edge</span></div>
<div class="line"><span class="lineno"> 5563</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m0_edge_h0 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(m0_edge, 0);</div>
<div class="line"><span class="lineno"> 5564</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m0_edge_h1 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(m0_edge, 1);</div>
<div class="line"><span class="lineno"> 5565</span> </div>
<div class="line"><span class="lineno"> 5566</span>                <span class="comment">// resolve the correct halfedge by match the source and target vertex descriptors</span></div>
<div class="line"><span class="lineno"> 5567</span>                <span class="keywordflow">if</span> (m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(m0_edge_h0) == m0_h_src &amp;&amp; m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m0_edge_h0) == m0_h_tgt) {</div>
<div class="line"><span class="lineno"> 5568</span> </div>
<div class="line"><span class="lineno"> 5569</span>                    retraced_poly.emplace_back(m0_edge_h0);</div>
<div class="line"><span class="lineno"> 5570</span>                } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 5571</span> </div>
<div class="line"><span class="lineno"> 5572</span>                    retraced_poly.emplace_back(m0_edge_h1);</div>
<div class="line"><span class="lineno"> 5573</span>                }</div>
<div class="line"><span class="lineno"> 5574</span>            }</div>
<div class="line"><span class="lineno"> 5575</span> </div>
<div class="line"><span class="lineno"> 5576</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(retraced_poly.size() == halfedges_around_face.size());</div>
<div class="line"><span class="lineno"> 5577</span> </div>
<div class="line"><span class="lineno"> 5578</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> poly_idx = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)(m0_polygons.size() + child_polygons.size());</div>
<div class="line"><span class="lineno"> 5579</span>            m0_to_ps_face[poly_idx] = ps_face;</div>
<div class="line"><span class="lineno"> 5580</span> </div>
<div class="line"><span class="lineno"> 5581</span>            <span class="comment">// save the retraced polygon, using the information in &quot;m0&quot; from &quot;ps&quot;</span></div>
<div class="line"><span class="lineno"> 5582</span>            child_polygons.emplace_back(retraced_poly);</div>
<div class="line"><span class="lineno"> 5583</span>        } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 5584</span> </div>
<div class="line"><span class="lineno"> 5585</span>            <span class="comment">// Here we enter the complex case of having to actually clip the current face</span></div>
<div class="line"><span class="lineno"> 5586</span>            <span class="comment">// because it is intersecting</span></div>
<div class="line"><span class="lineno"> 5587</span>            <span class="comment">// --------------------------------------------------------------------------</span></div>
<div class="line"><span class="lineno"> 5588</span> </div>
<div class="line"><span class="lineno"> 5589</span>            <span class="comment">// retrieve the list of edges which lie on the face (some new and some original)</span></div>
<div class="line"><span class="lineno"> 5590</span>            <span class="keyword">const</span> std::vector&lt;ed_t&gt;&amp; ps_iface_m0_edge_list = ps_iface_to_m0_edge_list_fiter-&gt;second;</div>
<div class="line"><span class="lineno"> 5591</span> </div>
<div class="line"><span class="lineno"> 5592</span>            <span class="comment">// Now we gather vertices on face (including intersection points)</span></div>
<div class="line"><span class="lineno"> 5593</span>            <span class="comment">// ------------------------------------------------------</span></div>
<div class="line"><span class="lineno"> 5594</span> </div>
<div class="line"><span class="lineno"> 5595</span>            <span class="comment">// Get the original vertices first, which we do by first querying them from &quot;ps&quot;</span></div>
<div class="line"><span class="lineno"> 5596</span>            <span class="comment">// and then using our maps to get their &quot;m0&quot; versions.</span></div>
<div class="line"><span class="lineno"> 5597</span>            <span class="keyword">static</span> <span class="keyword">thread_local</span> std::vector&lt;vd_t&gt; ps_coincident_vertices_tmp;</div>
<div class="line"><span class="lineno"> 5598</span>            ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a765a6f3b7249eb47135d246f6d301102">get_vertices_around_face</a>(ps_coincident_vertices_tmp, ps_face);</div>
<div class="line"><span class="lineno"> 5599</span>            <span class="keyword">const</span> std::vector&lt;vd_t&gt;&amp; ps_coincident_vertices = ps_coincident_vertices_tmp;</div>
<div class="line"><span class="lineno"> 5600</span>            <span class="keyword">static</span> <span class="keyword">thread_local</span> std::vector&lt;vd_t&gt; coincident_vertices; <span class="comment">// &quot;m0&quot; versions of those stored in &quot;ps_coincident_vertices&quot;</span></div>
<div class="line"><span class="lineno"> 5601</span>            coincident_vertices.resize(ps_coincident_vertices.size());</div>
<div class="line"><span class="lineno"> 5602</span>            <span class="comment">// gather the original (m0) vertices on the face</span></div>
<div class="line"><span class="lineno"> 5603</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)ps_coincident_vertices.size(); ++i) {</div>
<div class="line"><span class="lineno"> 5604</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> ps_v = ps_coincident_vertices[i];</div>
<div class="line"><span class="lineno"> 5605</span> </div>
<div class="line"><span class="lineno"> 5606</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">int</span>)(ps_v) &lt; (<span class="keywordtype">int</span>)ps_to_m0_vtx.size() <span class="comment">/*ps_to_m0_vtx.find(ps_v) != ps_to_m0_vtx.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 5607</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_v = ps_to_m0_vtx[ps_v];</div>
<div class="line"><span class="lineno"> 5608</span> </div>
<div class="line"><span class="lineno"> 5609</span>                coincident_vertices[i] = m0_v;</div>
<div class="line"><span class="lineno"> 5610</span>            }</div>
<div class="line"><span class="lineno"> 5611</span> </div>
<div class="line"><span class="lineno"> 5612</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(coincident_vertices.size() == ps_coincident_vertices.size());</div>
<div class="line"><span class="lineno"> 5613</span> </div>
<div class="line"><span class="lineno"> 5614</span>            <span class="comment">// now we gather the intersection-points on the face</span></div>
<div class="line"><span class="lineno"> 5615</span>            <span class="keyword">const</span> std::unordered_map&lt;fd_t, std::vector&lt;vd_t&gt;&gt;::const_iterator ireg_entry_iter = ps_iface_to_ivtx_list.find(ps_face);</div>
<div class="line"><span class="lineno"> 5616</span> </div>
<div class="line"><span class="lineno"> 5617</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ireg_entry_iter != ps_iface_to_ivtx_list.cend());</div>
<div class="line"><span class="lineno"> 5618</span> </div>
<div class="line"><span class="lineno"> 5619</span>            <span class="comment">// const int coincident_ps_vertex_count = (int)coincident_vertices.size();</span></div>
<div class="line"><span class="lineno"> 5620</span>            <span class="keyword">const</span> std::vector&lt;vd_t&gt;&amp; intersection_points_on_face = ireg_entry_iter-&gt;second;</div>
<div class="line"><span class="lineno"> 5621</span>            coincident_vertices.reserve(coincident_vertices.size() + intersection_points_on_face.size());</div>
<div class="line"><span class="lineno"> 5622</span>            coincident_vertices.insert(coincident_vertices.end(), intersection_points_on_face.cbegin(), intersection_points_on_face.cend());</div>
<div class="line"><span class="lineno"> 5623</span> </div>
<div class="line"><span class="lineno"> 5624</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(intersection_points_on_face.size() &gt;= 2); <span class="comment">// minimum (two intersecting convex polygons)</span></div>
<div class="line"><span class="lineno"> 5625</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 5626</span>            <span class="comment">// dump to log</span></div>
<div class="line"><span class="lineno"> 5627</span>            <span class="keywordflow">if</span> (input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#acbacc55f2163529291e5a45671fed3d1">verbose</a>) {</div>
<div class="line"><span class="lineno"> 5628</span> </div>
<div class="line"><span class="lineno"> 5629</span>                <span class="keywordflow">for</span> (std::vector&lt;vd_t&gt;::const_iterator j = coincident_vertices.cbegin(); j != coincident_vertices.cend(); ++j) {</div>
<div class="line"><span class="lineno"> 5630</span>                }</div>
<div class="line"><span class="lineno"> 5631</span>            }</div>
<div class="line"><span class="lineno"> 5632</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 5633</span>            <span class="comment">// After gathering the vertices above, we will now collect edges on the face</span></div>
<div class="line"><span class="lineno"> 5634</span>            <span class="comment">// -------------------------------------------------------------------------</span></div>
<div class="line"><span class="lineno"> 5635</span> </div>
<div class="line"><span class="lineno"> 5636</span>            <span class="comment">// edges on face</span></div>
<div class="line"><span class="lineno"> 5637</span>            std::vector&lt;ed_t&gt; incident_edges = ps_iface_m0_edge_list; <span class="comment">// COPY because &quot;incident_edges&quot; will be modified later</span></div>
<div class="line"><span class="lineno"> 5638</span> </div>
<div class="line"><span class="lineno"> 5639</span>            <span class="comment">// number of boundary edges on the face</span></div>
<div class="line"><span class="lineno"> 5640</span>            <span class="keywordtype">int</span> incident_boundary_edge_count = 0;</div>
<div class="line"><span class="lineno"> 5641</span> </div>
<div class="line"><span class="lineno"> 5642</span>            <span class="comment">// We will now partition the list of incident edges into boundary/exterior and interior.</span></div>
<div class="line"><span class="lineno"> 5643</span>            <span class="comment">// Boundary edges come first, then interior ones. We do this because it makes it easier for us</span></div>
<div class="line"><span class="lineno"> 5644</span>            <span class="comment">// to filter our interior edges if they are consecutive in the list (i.e. in &quot;incident_edges&quot;)</span></div>
<div class="line"><span class="lineno"> 5645</span>            std::partition(incident_edges.begin(), incident_edges.end(),</div>
<div class="line"><span class="lineno"> 5646</span>                [&amp;](<span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; e) {</div>
<div class="line"><span class="lineno"> 5647</span>                    <span class="comment">// calculate if edge is exterior</span></div>
<div class="line"><span class="lineno"> 5648</span>                    <span class="comment">// -----------------------------</span></div>
<div class="line"><span class="lineno"> 5649</span> </div>
<div class="line"><span class="lineno"> 5650</span>                    <span class="comment">// get vertices defining edge</span></div>
<div class="line"><span class="lineno"> 5651</span>                    const vd_t v0 = m0.vertex(e, 0);</div>
<div class="line"><span class="lineno"> 5652</span>                    const vd_t v1 = m0.vertex(e, 1);</div>
<div class="line"><span class="lineno"> 5653</span> </div>
<div class="line"><span class="lineno"> 5654</span>                    <span class="comment">// are both vertices intersection points (the main property of interior edges)</span></div>
<div class="line"><span class="lineno"> 5655</span>                    const bool v0_is_ivtx = m0_is_intersection_point(v0, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 5656</span>                    const bool v1_is_ivtx = m0_is_intersection_point(v1, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 5657</span> </div>
<div class="line"><span class="lineno"> 5658</span>                    <span class="comment">// if both vertices are intersection points, we must be careful to make an extra</span></div>
<div class="line"><span class="lineno"> 5659</span>                    <span class="comment">// check that the edge is really on the boundary. Moreover, it is possible that</span></div>
<div class="line"><span class="lineno"> 5660</span>                    <span class="comment">// their exist an edge on the boundary whose vertices are both intersection</span></div>
<div class="line"><span class="lineno"> 5661</span>                    <span class="comment">// points - hence the possible ambiguity.</span></div>
<div class="line"><span class="lineno"> 5662</span>                    <span class="comment">// A boundary edge defined by two intersection points can arise from &quot;carve-out&quot;</span></div>
<div class="line"><span class="lineno"> 5663</span>                    <span class="comment">// cuts..</span></div>
<div class="line"><span class="lineno"> 5664</span>                    const bool is_ambiguious_boundary_edge_case = (v0_is_ivtx &amp;&amp; v1_is_ivtx);</div>
<div class="line"><span class="lineno"> 5665</span>                    bool is_valid_ambiguious_boundary_edge = false;</div>
<div class="line"><span class="lineno"> 5666</span> </div>
<div class="line"><span class="lineno"> 5667</span>                    if (is_ambiguious_boundary_edge_case) {</div>
<div class="line"><span class="lineno"> 5668</span>                        <span class="comment">// get their edges</span></div>
<div class="line"><span class="lineno"> 5669</span>                        MCUT_ASSERT((size_t)v0 - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/* m0_ivtx_to_intersection_registry_entry.find(v0) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 5670</span>                        const std::pair&lt;ed_t, fd_t&gt;&amp; v0_ipair = SAFE_ACCESS(m0_ivtx_to_intersection_registry_entry, v0 - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 5671</span>                        const ed_t v0_ps_edge = v0_ipair.first; <span class="comment">// m0_ivtx_to_ps_edge, v0); // ps.edge(v0_coincident_ps_halfedge);</span></div>
<div class="line"><span class="lineno"> 5672</span> </div>
<div class="line"><span class="lineno"> 5673</span>                        MCUT_ASSERT((size_t)v1 - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(v1) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 5674</span>                        const std::pair&lt;ed_t, fd_t&gt;&amp; v1_ipair = SAFE_ACCESS(m0_ivtx_to_intersection_registry_entry, v1 - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 5675</span>                        const ed_t v1_ps_edge = v1_ipair.first; <span class="comment">// m0_ivtx_to_ps_edge, v1); // ps.edge(v1_coincident_ps_halfedge);</span></div>
<div class="line"><span class="lineno"> 5676</span> </div>
<div class="line"><span class="lineno"> 5677</span>                        <span class="comment">// This is true if v0 and v1 where produced by multiple intersections of one edge</span></div>
<div class="line"><span class="lineno"> 5678</span>                        <span class="comment">// with two different faces</span></div>
<div class="line"><span class="lineno"> 5679</span>                        is_valid_ambiguious_boundary_edge = (v0_ps_edge == v1_ps_edge);</div>
<div class="line"><span class="lineno"> 5680</span>                    }</div>
<div class="line"><span class="lineno"> 5681</span> </div>
<div class="line"><span class="lineno"> 5682</span>                    <span class="keywordtype">bool</span> is_boundary_edge = (!is_ambiguious_boundary_edge_case || is_valid_ambiguious_boundary_edge);</div>
<div class="line"><span class="lineno"> 5683</span>                    <span class="keywordflow">if</span> (is_boundary_edge) {</div>
<div class="line"><span class="lineno"> 5684</span>                        incident_boundary_edge_count++; <span class="comment">// count</span></div>
<div class="line"><span class="lineno"> 5685</span>                    }</div>
<div class="line"><span class="lineno"> 5686</span>                    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/d25/namespaceigl.html#a39d02bea0e57dce707ada6bc3228d22a">is_boundary_edge</a>;</div>
<div class="line"><span class="lineno"> 5687</span>                });</div>
<div class="line"><span class="lineno"> 5688</span> </div>
<div class="line"><span class="lineno"> 5689</span>            <span class="comment">// dump info to log</span></div>
<div class="line"><span class="lineno"> 5690</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 5691</span>            <span class="keywordflow">if</span> (lg.<a class="code hl_function" href="../../d8/d0d/classlogger__t.html#a03f98d9b0cd3e0fd02fcda7292f5f472">verbose</a>()) {</div>
<div class="line"><span class="lineno"> 5692</span>                <span class="keywordflow">for</span> (std::vector&lt;ed_t&gt;::const_iterator exterior_edge_iter = incident_edges.cbegin();</div>
<div class="line"><span class="lineno"> 5693</span>                     exterior_edge_iter != incident_edges.cbegin() + incident_boundary_edge_count;</div>
<div class="line"><span class="lineno"> 5694</span>                     ++exterior_edge_iter) {</div>
<div class="line"><span class="lineno"> 5695</span>                }</div>
<div class="line"><span class="lineno"> 5696</span>            }</div>
<div class="line"><span class="lineno"> 5697</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 5698</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(incident_boundary_edge_count &gt;= 3); <span class="comment">// minimum is 3 edge which is for a triangle</span></div>
<div class="line"><span class="lineno"> 5699</span> </div>
<div class="line"><span class="lineno"> 5700</span>            <span class="comment">// const int interior_edges_on_face = (int)incident_edges.size() - incident_boundary_edge_count;</span></div>
<div class="line"><span class="lineno"> 5701</span> </div>
<div class="line"><span class="lineno"> 5702</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 5703</span>            <span class="comment">// We have the essential set of edges which will be used for clipping, the next step</span></div>
<div class="line"><span class="lineno"> 5704</span>            <span class="comment">// is to gather the halfedges on the clipped face from these edges.</span></div>
<div class="line"><span class="lineno"> 5705</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 5706</span>            <span class="comment">// Note that the gathered set of halfedges will contain some halfedges that are redundant.</span></div>
<div class="line"><span class="lineno"> 5707</span>            <span class="comment">// These redundant halfedges are those which lie on the boundary of the clipped polygon and</span></div>
<div class="line"><span class="lineno"> 5708</span>            <span class="comment">// have a winding order which is opposite to the winding order of the input mesh which contained</span></div>
<div class="line"><span class="lineno"> 5709</span>            <span class="comment">// &quot;ps_face&quot; (i.e. either the cut-mesh or source-mesh).</span></div>
<div class="line"><span class="lineno"> 5710</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 5711</span>            <span class="comment">// Thus, we need one more filtering step which will remove these redundant halfedges from</span></div>
<div class="line"><span class="lineno"> 5712</span>            <span class="comment">// the gather set.</span></div>
<div class="line"><span class="lineno"> 5713</span> </div>
<div class="line"><span class="lineno"> 5714</span>            std::vector&lt;hd_t&gt; incident_halfedges;</div>
<div class="line"><span class="lineno"> 5715</span> </div>
<div class="line"><span class="lineno"> 5716</span>            <span class="comment">// 1. find an exterior halfedge (any)</span></div>
<div class="line"><span class="lineno"> 5717</span>            <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> first_boundary_halfedge = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno"> 5718</span> </div>
<div class="line"><span class="lineno"> 5719</span>            <span class="comment">// for each edge on clipped polygon, (i.e. from the filtered set)</span></div>
<div class="line"><span class="lineno"> 5720</span>            <span class="keywordflow">for</span> (std::vector&lt;ed_t&gt;::const_iterator incident_edge_iter = incident_edges.cbegin();</div>
<div class="line"><span class="lineno"> 5721</span>                 incident_edge_iter != incident_edges.cbegin() + incident_boundary_edge_count; <span class="comment">// we only want exterior edges</span></div>
<div class="line"><span class="lineno"> 5722</span>                 ++incident_edge_iter) {</div>
<div class="line"><span class="lineno"> 5723</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; edge = (*incident_edge_iter);</div>
<div class="line"><span class="lineno"> 5724</span> </div>
<div class="line"><span class="lineno"> 5725</span>                <span class="comment">// for each halfedge on the current edge</span></div>
<div class="line"><span class="lineno"> 5726</span>                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> edge_he_iter = 0; edge_he_iter &lt; 2; ++edge_he_iter) {</div>
<div class="line"><span class="lineno"> 5727</span> </div>
<div class="line"><span class="lineno"> 5728</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m0_edge_he = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(edge, edge_he_iter);</div>
<div class="line"><span class="lineno"> 5729</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_edge_he_src = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(m0_edge_he);</div>
<div class="line"><span class="lineno"> 5730</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_edge_he_tgt = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m0_edge_he);</div>
<div class="line"><span class="lineno"> 5731</span>                    <span class="keyword">const</span> <span class="keywordtype">bool</span> m0_edge_he_src_is_ivertex = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0_edge_he_src, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 5732</span>                    <span class="keyword">const</span> <span class="keywordtype">bool</span> m0_edge_he_tgt_is_ivertex = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0_edge_he_tgt, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 5733</span> </div>
<div class="line"><span class="lineno"> 5734</span>                    <span class="keywordflow">if</span> (!m0_edge_he_src_is_ivertex &amp;&amp; !m0_edge_he_tgt_is_ivertex) { <span class="comment">// o--&gt;o (unmodified original edge)</span></div>
<div class="line"><span class="lineno"> 5735</span> </div>
<div class="line"><span class="lineno"> 5736</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> ps_he_src = m0_to_ps_vtx[m0_edge_he_src];</div>
<div class="line"><span class="lineno"> 5737</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> ps_he_tgt = m0_to_ps_vtx[m0_edge_he_tgt];</div>
<div class="line"><span class="lineno"> 5738</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> ps_he = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(ps_he_src, ps_he_tgt);</div>
<div class="line"><span class="lineno"> 5739</span> </div>
<div class="line"><span class="lineno"> 5740</span>                        <span class="keywordflow">if</span> (ps_he == <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>()) {</div>
<div class="line"><span class="lineno"> 5741</span>                            <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 5742</span>                        }</div>
<div class="line"><span class="lineno"> 5743</span> </div>
<div class="line"><span class="lineno"> 5744</span>                        <span class="keywordflow">if</span> (ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(ps_he) == ps_face) {</div>
<div class="line"><span class="lineno"> 5745</span>                            first_boundary_halfedge = m0_edge_he;</div>
<div class="line"><span class="lineno"> 5746</span>                            <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 5747</span>                        }</div>
<div class="line"><span class="lineno"> 5748</span>                    } <span class="keywordflow">else</span> { <span class="comment">// x--&gt;x OR o--&gt;x OR x--&gt;o</span></div>
<div class="line"><span class="lineno"> 5749</span> </div>
<div class="line"><span class="lineno"> 5750</span>                        <span class="comment">// o--&gt;x : We want the ihalfedges which point into the sm whose tgt lays on the</span></div>
<div class="line"><span class="lineno"> 5751</span>                        <span class="comment">// sm-face of tgt (they have an opposite direction wrt the face normal)</span></div>
<div class="line"><span class="lineno"> 5752</span>                        <span class="keyword">const</span> <span class="keywordtype">bool</span> is_ox = (!m0_edge_he_src_is_ivertex &amp;&amp; m0_edge_he_tgt_is_ivertex);</div>
<div class="line"><span class="lineno"> 5753</span> </div>
<div class="line"><span class="lineno"> 5754</span>                        <span class="keywordflow">if</span> (is_ox) {</div>
<div class="line"><span class="lineno"> 5755</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)m0_edge_he_tgt - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(m0_edge_he_tgt) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 5756</span>                            <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt;&amp; m0_edge_he_tgt_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, m0_edge_he_tgt - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 5757</span> </div>
<div class="line"><span class="lineno"> 5758</span>                            <span class="comment">// get the incident ps-halfedge of tgt</span></div>
<div class="line"><span class="lineno"> 5759</span>                            <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> tgt_ps_e = m0_edge_he_tgt_ipair.first; <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_edge, m0_edge_he_tgt);</span></div>
<div class="line"><span class="lineno"> 5760</span>                            <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> tgt_ps_h = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(tgt_ps_e, 0);</div>
<div class="line"><span class="lineno"> 5761</span> </div>
<div class="line"><span class="lineno"> 5762</span>                            <span class="keywordflow">if</span> (ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(tgt_ps_h) != ps_face) {</div>
<div class="line"><span class="lineno"> 5763</span>                                tgt_ps_h = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(tgt_ps_h); <span class="comment">// i.e. &quot;m0.halfedge(tgt_ps_e, 1);&quot;</span></div>
<div class="line"><span class="lineno"> 5764</span>                                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(tgt_ps_h != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>()); <span class="comment">// must be true if ps_face exists!</span></div>
<div class="line"><span class="lineno"> 5765</span>                            }</div>
<div class="line"><span class="lineno"> 5766</span> </div>
<div class="line"><span class="lineno"> 5767</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a>&amp; m0_edge_he_src_as_ps_vertex = m0_to_ps_vtx[m0_edge_he_src];</div>
<div class="line"><span class="lineno"> 5768</span> </div>
<div class="line"><span class="lineno"> 5769</span>                            <span class="keywordflow">if</span> (m0_edge_he_src_as_ps_vertex == ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(tgt_ps_h)) { <span class="comment">// is counter clock-wise halfedge</span></div>
<div class="line"><span class="lineno"> 5770</span>                                first_boundary_halfedge = m0_edge_he;</div>
<div class="line"><span class="lineno"> 5771</span>                                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 5772</span>                            }</div>
<div class="line"><span class="lineno"> 5773</span>                        } <span class="keywordflow">else</span> { <span class="comment">// x--&gt;x OR x--&gt;o</span></div>
<div class="line"><span class="lineno"> 5774</span> </div>
<div class="line"><span class="lineno"> 5775</span>                            <span class="keyword">const</span> <span class="keywordtype">bool</span> is_xx = m0_edge_he_src_is_ivertex &amp;&amp; m0_edge_he_tgt_is_ivertex;</div>
<div class="line"><span class="lineno"> 5776</span> </div>
<div class="line"><span class="lineno"> 5777</span>                            <span class="keywordflow">if</span> (is_xx) { <span class="comment">// exterior interior-iedge</span></div>
<div class="line"><span class="lineno"> 5778</span> </div>
<div class="line"><span class="lineno"> 5779</span>                                <span class="comment">// const hd_t src_coincident_ps_halfedge = m0_ivtx_to_ps_edge, m0_edge_he_src);</span></div>
<div class="line"><span class="lineno"> 5780</span>                                <span class="comment">// const hd_t tgt_ps_h = m0_ivtx_to_ps_edge, m0_edge_he_tgt);</span></div>
<div class="line"><span class="lineno"> 5781</span>                                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)m0_edge_he_src - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(m0_edge_he_src) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 5782</span>                                <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt;&amp; m0_edge_he_src_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, m0_edge_he_src - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 5783</span>                                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)m0_edge_he_tgt - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(m0_edge_he_tgt) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 5784</span>                                <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt;&amp; m0_edge_he_tgt_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, m0_edge_he_tgt - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 5785</span> </div>
<div class="line"><span class="lineno"> 5786</span>                                <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> src_ps_edge = m0_edge_he_src_ipair.first; <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_edge, m0_edge_he_src); // ps.edge(src_coincident_ps_halfedge)</span></div>
<div class="line"><span class="lineno"> 5787</span> </div>
<div class="line"><span class="lineno"> 5788</span>                                <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> tgt_ps_edge = m0_edge_he_tgt_ipair.first; <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_edge, m0_edge_he_tgt); // ps.edge(tgt_ps_h);</span></div>
<div class="line"><span class="lineno"> 5789</span>                                <span class="keyword">const</span> <span class="keywordtype">bool</span> is_exterior_ih = (src_ps_edge == tgt_ps_edge);</div>
<div class="line"><span class="lineno"> 5790</span> </div>
<div class="line"><span class="lineno"> 5791</span>                                <span class="keywordflow">if</span> (!is_exterior_ih) {</div>
<div class="line"><span class="lineno"> 5792</span>                                    <span class="keywordflow">continue</span>; <span class="comment">// interior ihalfedges cannot be used as the first exterior ihalfedge</span></div>
<div class="line"><span class="lineno"> 5793</span>                                }</div>
<div class="line"><span class="lineno"> 5794</span> </div>
<div class="line"><span class="lineno"> 5795</span>                                <span class="comment">/*</span></div>
<div class="line"><span class="lineno"> 5796</span><span class="comment">                                At this point, vertex information alone is insufficient to select the correct</span></div>
<div class="line"><span class="lineno"> 5797</span><span class="comment">                                ihalfedge from the edge. This is because the two vertices are topologically equivalent</span></div>
<div class="line"><span class="lineno"> 5798</span><span class="comment">                                if we just try to distinguish them following similar rules as other iedge types.</span></div>
<div class="line"><span class="lineno"> 5799</span><span class="comment">                                To solve this problem, we must instead use the connectivity information of</span></div>
<div class="line"><span class="lineno"> 5800</span><span class="comment">                                the polygon soup by relying on the incident ps-halfedge common to both vertices</span></div>
<div class="line"><span class="lineno"> 5801</span><span class="comment">                                (in their registry entries). The rough idea/steps:</span></div>
<div class="line"><span class="lineno"> 5802</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 5803</span><span class="comment">                                1. get incident ps-halfedge incident to both src and tgt</span></div>
<div class="line"><span class="lineno"> 5804</span><span class="comment">                                2. get m0 edges incident to the edge on &lt;1&gt;</span></div>
<div class="line"><span class="lineno"> 5805</span><span class="comment">                                3. sort &lt;2&gt; with the first edge containing the source of &lt;1&gt;</span></div>
<div class="line"><span class="lineno"> 5806</span><span class="comment">                                4. get the halfedge sequence in &lt;3&gt; where src of the first he is the src of &lt;1&gt; and the tgt of the last he is the tgt of &lt;1&gt;</span></div>
<div class="line"><span class="lineno"> 5807</span><span class="comment">                                5. get the halfedge in &lt;4&gt; which is incident to the same ivertices as the current potential first-boundary halfedge</span></div>
<div class="line"><span class="lineno"> 5808</span><span class="comment">                                6. if the ps-face of &lt;1&gt; is the same as the current face</span></div>
<div class="line"><span class="lineno"> 5809</span><span class="comment">                                    7. set first polygon-boundary halfedge as &lt;5&gt;</span></div>
<div class="line"><span class="lineno"> 5810</span><span class="comment">                                8. else</span></div>
<div class="line"><span class="lineno"> 5811</span><span class="comment">                                    9. set first polygon-boundary halfedge as opposite of &lt;5&gt;</span></div>
<div class="line"><span class="lineno"> 5812</span><span class="comment">                            */</span></div>
<div class="line"><span class="lineno"> 5813</span> </div>
<div class="line"><span class="lineno"> 5814</span>                                <span class="comment">// 1. get incident ps-halfedge incident to both src and tgt</span></div>
<div class="line"><span class="lineno"> 5815</span>                                <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> ps_halfedge_of_face = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(tgt_ps_edge, 0); <span class="comment">// tgt_ps_h;</span></div>
<div class="line"><span class="lineno"> 5816</span> </div>
<div class="line"><span class="lineno"> 5817</span>                                <span class="comment">// equivalent to the check done at step 6. so that we know the correct halfedge to use in the steps ahead</span></div>
<div class="line"><span class="lineno"> 5818</span>                                <span class="keywordflow">if</span> (ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(ps_halfedge_of_face) != ps_face) {</div>
<div class="line"><span class="lineno"> 5819</span>                                    ps_halfedge_of_face = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(ps_halfedge_of_face);</div>
<div class="line"><span class="lineno"> 5820</span>                                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ps_halfedge_of_face != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>()); <span class="comment">// guarranteed to exist since we have a poly-boundary interior ihalfedge</span></div>
<div class="line"><span class="lineno"> 5821</span>                                }</div>
<div class="line"><span class="lineno"> 5822</span> </div>
<div class="line"><span class="lineno"> 5823</span>                                <span class="comment">// 2. get m0 edges incident to the edge on &lt;1&gt;</span></div>
<div class="line"><span class="lineno"> 5824</span>                                <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; incident_ps_edge = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a96e9db918396b86f0b61f5445ef46b18">edge</a>(ps_halfedge_of_face);</div>
<div class="line"><span class="lineno"> 5825</span>                                std::map&lt;ed_t, std::vector&lt;ed_t&gt;&gt;::const_iterator ps_to_m0_edges_find_iter = ps_to_m0_edges.find(incident_ps_edge);</div>
<div class="line"><span class="lineno"> 5826</span>                                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ps_to_m0_edges_find_iter != ps_to_m0_edges.cend()); <span class="comment">// because incident_ps_edge contains a polygon exterior interior ihalfedge</span></div>
<div class="line"><span class="lineno"> 5827</span> </div>
<div class="line"><span class="lineno"> 5828</span>                                <span class="comment">// 3. sort &lt;2&gt; with the first edge containing the source of &lt;1&gt;</span></div>
<div class="line"><span class="lineno"> 5829</span>                                <span class="comment">//  NOTE: The edges are already sorted based on how we created &quot;edges between the sorted vertices that are coincident on the same</span></div>
<div class="line"><span class="lineno"> 5830</span>                                <span class="comment">//  ps-edge that has more-than 3 incident vertices.&quot; (Refer to that step for details)</span></div>
<div class="line"><span class="lineno"> 5831</span>                                <span class="keyword">const</span> std::vector&lt;ed_t&gt;&amp; sorted_m0_edges = ps_to_m0_edges_find_iter-&gt;second;</div>
<div class="line"><span class="lineno"> 5832</span> </div>
<div class="line"><span class="lineno"> 5833</span>                                <span class="comment">// 4. get the halfedge sequence in &lt;3&gt; where src of the first he is the src of &lt;1&gt; and the tgt of the last he is the tgt of &lt;1&gt;</span></div>
<div class="line"><span class="lineno"> 5834</span>                                std::vector&lt;hd_t&gt; halfedge_sequence;</div>
<div class="line"><span class="lineno"> 5835</span> </div>
<div class="line"><span class="lineno"> 5836</span>                                <span class="comment">// add the first halfedge (its source must be an original vertex)</span></div>
<div class="line"><span class="lineno"> 5837</span>                                <span class="comment">// NOTE: its does not matter whether &quot;first_he&quot; point in the wrong direction or not right now (read on...)</span></div>
<div class="line"><span class="lineno"> 5838</span>                                <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; first_e = sorted_m0_edges.front();</div>
<div class="line"><span class="lineno"> 5839</span>                                <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> first_he = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(first_e, 0);</div>
<div class="line"><span class="lineno"> 5840</span>                                <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> first_he_src = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(first_he);</div>
<div class="line"><span class="lineno"> 5841</span> </div>
<div class="line"><span class="lineno"> 5842</span>                                <span class="keywordflow">if</span> (<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(first_he_src, ps_vtx_cnt)) {</div>
<div class="line"><span class="lineno"> 5843</span>                                    <span class="comment">// TODO: I think this scope is never entered based on how we created &quot;sorted_m0_edges&quot;.</span></div>
<div class="line"><span class="lineno"> 5844</span>                                    <span class="comment">// Thus, the source vertex of the first halfedge in the sequence cannot be an intersection point</span></div>
<div class="line"><span class="lineno"> 5845</span>                                    first_he = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(first_e, 1);</div>
<div class="line"><span class="lineno"> 5846</span>                                    first_he_src = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(first_he);</div>
<div class="line"><span class="lineno"> 5847</span>                                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(!<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(first_he_src, ps_vtx_cnt)); <span class="comment">// expect original vertex since halfedge edge is the first in sequence</span></div>
<div class="line"><span class="lineno"> 5848</span>                                }</div>
<div class="line"><span class="lineno"> 5849</span> </div>
<div class="line"><span class="lineno"> 5850</span>                                halfedge_sequence.push_back(first_he);</div>
<div class="line"><span class="lineno"> 5851</span> </div>
<div class="line"><span class="lineno"> 5852</span>                                <span class="comment">// get the remaining halfedge of sequence</span></div>
<div class="line"><span class="lineno"> 5853</span>                                <span class="keywordflow">for</span> (std::vector&lt;ed_t&gt;::const_iterator seq_edge_iter = sorted_m0_edges.cbegin() + 1; <span class="comment">// we have already added the first halfedge</span></div>
<div class="line"><span class="lineno"> 5854</span>                                     seq_edge_iter != sorted_m0_edges.cend(); ++seq_edge_iter) {</div>
<div class="line"><span class="lineno"> 5855</span> </div>
<div class="line"><span class="lineno"> 5856</span>                                    <span class="comment">// if (seq_edge_iter == sorted_m0_edges.cbegin()) {</span></div>
<div class="line"><span class="lineno"> 5857</span>                                    <span class="comment">//     continue; // we have already added the first halfedge</span></div>
<div class="line"><span class="lineno"> 5858</span>                                    <span class="comment">// }</span></div>
<div class="line"><span class="lineno"> 5859</span> </div>
<div class="line"><span class="lineno"> 5860</span>                                    <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; e = *seq_edge_iter;</div>
<div class="line"><span class="lineno"> 5861</span>                                    <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h0 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(e, 0);</div>
<div class="line"><span class="lineno"> 5862</span> </div>
<div class="line"><span class="lineno"> 5863</span>                                    <span class="keywordflow">if</span> (m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(h0) == m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(halfedge_sequence.back())) {</div>
<div class="line"><span class="lineno"> 5864</span>                                        halfedge_sequence.emplace_back(h0);</div>
<div class="line"><span class="lineno"> 5865</span>                                    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 5866</span>                                        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h1 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(e, 1);</div>
<div class="line"><span class="lineno"> 5867</span>                                        halfedge_sequence.emplace_back(h1);</div>
<div class="line"><span class="lineno"> 5868</span>                                    }</div>
<div class="line"><span class="lineno"> 5869</span>                                }</div>
<div class="line"><span class="lineno"> 5870</span> </div>
<div class="line"><span class="lineno"> 5871</span>                                <span class="comment">// we have our sequence but it is not gurranteed to point in the correct direction</span></div>
<div class="line"><span class="lineno"> 5872</span>                                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(halfedge_sequence.size() == sorted_m0_edges.size());</div>
<div class="line"><span class="lineno"> 5873</span> </div>
<div class="line"><span class="lineno"> 5874</span>                                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a>&amp; first_he_src_as_ps_vertex = m0_to_ps_vtx[first_he_src]; <span class="comment">// first he of sequence</span></div>
<div class="line"><span class="lineno"> 5875</span> </div>
<div class="line"><span class="lineno"> 5876</span>                                <span class="keywordflow">if</span> (first_he_src_as_ps_vertex != ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(ps_halfedge_of_face)) {</div>
<div class="line"><span class="lineno"> 5877</span> </div>
<div class="line"><span class="lineno"> 5878</span>                                    <span class="comment">// flip the sequence to make it point in the right direction</span></div>
<div class="line"><span class="lineno"> 5879</span>                                    std::for_each(</div>
<div class="line"><span class="lineno"> 5880</span>                                        halfedge_sequence.begin(),</div>
<div class="line"><span class="lineno"> 5881</span>                                        halfedge_sequence.end(),</div>
<div class="line"><span class="lineno"> 5882</span>                                        [&amp;](<a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; he) {</div>
<div class="line"><span class="lineno"> 5883</span>                                            he = m0.opposite(he);</div>
<div class="line"><span class="lineno"> 5884</span>                                        }); <span class="comment">// flip seq</span></div>
<div class="line"><span class="lineno"> 5885</span>                                }</div>
<div class="line"><span class="lineno"> 5886</span> </div>
<div class="line"><span class="lineno"> 5887</span>                                <span class="comment">// 5. get the halfedge in &lt;4&gt; which is incident to the same ivertices as the current potential first-exterior halfedge</span></div>
<div class="line"><span class="lineno"> 5888</span> </div>
<div class="line"><span class="lineno"> 5889</span>                                std::vector&lt;hd_t&gt;::const_iterator matching_he_find_iter = std::find_if(</div>
<div class="line"><span class="lineno"> 5890</span>                                    halfedge_sequence.cbegin(),</div>
<div class="line"><span class="lineno"> 5891</span>                                    halfedge_sequence.cend(),</div>
<div class="line"><span class="lineno"> 5892</span>                                    [&amp;](<span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; he) {</div>
<div class="line"><span class="lineno"> 5893</span>                                        const vd_t&amp; he_src = m0.source(he);</div>
<div class="line"><span class="lineno"> 5894</span>                                        const vd_t&amp; he_tgt = m0.target(he);</div>
<div class="line"><span class="lineno"> 5895</span> </div>
<div class="line"><span class="lineno"> 5896</span>                                        return (he_src == m0_edge_he_src &amp;&amp; he_tgt == m0_edge_he_tgt <span class="comment">/*|| (he_src == m0_edge_he_tgt &amp;&amp; he_tgt == m0_edge_he_src*/</span>);</div>
<div class="line"><span class="lineno"> 5897</span>                                    });</div>
<div class="line"><span class="lineno"> 5898</span> </div>
<div class="line"><span class="lineno"> 5899</span>                                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(matching_he_find_iter != halfedge_sequence.cend()); <span class="comment">// does the potential halfedge actually point in the correct direction or not</span></div>
<div class="line"><span class="lineno"> 5900</span>                                {</div>
<div class="line"><span class="lineno"> 5901</span>                                    <span class="comment">// 6. if the ps-face of &lt;1&gt; is the same as the current face</span></div>
<div class="line"><span class="lineno"> 5902</span>                                    <span class="comment">//      7. set first polygon-exterior halfedge as &lt;5&gt;</span></div>
<div class="line"><span class="lineno"> 5903</span>                                    <span class="comment">// 8. else</span></div>
<div class="line"><span class="lineno"> 5904</span>                                    <span class="comment">//      9. set first polygon-exterior halfedge as opposite of &lt;5&gt;</span></div>
<div class="line"><span class="lineno"> 5905</span>                                    <span class="comment">// if (ps.face(incident_ps_halfedge) == ps_face) {</span></div>
<div class="line"><span class="lineno"> 5906</span>                                    first_boundary_halfedge = *matching_he_find_iter;</div>
<div class="line"><span class="lineno"> 5907</span>                                    <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 5908</span>                                }</div>
<div class="line"><span class="lineno"> 5909</span>                            } <span class="comment">// if (is_xx) {</span></div>
<div class="line"><span class="lineno"> 5910</span>                            <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 5911</span>                                <span class="comment">// TODO: implement logic for is_xo</span></div>
<div class="line"><span class="lineno"> 5912</span> </div>
<div class="line"><span class="lineno"> 5913</span>                                <span class="comment">// NOTE: The code is able to work without implementing this scope due to the order-dependent nature in which</span></div>
<div class="line"><span class="lineno"> 5914</span>                                <span class="comment">// edges are traversed (its guarranteed that oo ox and xx edges are encountered first) to find the first</span></div>
<div class="line"><span class="lineno"> 5915</span>                                <span class="comment">// boundary halfedge</span></div>
<div class="line"><span class="lineno"> 5916</span>                            }</div>
<div class="line"><span class="lineno"> 5917</span>                        } <span class="comment">// } else { // x--&gt;x OR x--&gt;o</span></div>
<div class="line"><span class="lineno"> 5918</span>                    } <span class="comment">// } else { // x--&gt;x OR o--&gt;x OR x--&gt;o</span></div>
<div class="line"><span class="lineno"> 5919</span>                } <span class="comment">// for (int edge_he_iter = 0; edge_he_iter &lt; 2; ++edge_he_iter) {</span></div>
<div class="line"><span class="lineno"> 5920</span> </div>
<div class="line"><span class="lineno"> 5921</span>                <span class="keywordflow">if</span> (first_boundary_halfedge != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>()) {</div>
<div class="line"><span class="lineno"> 5922</span>                    <span class="keywordflow">break</span>; <span class="comment">// done</span></div>
<div class="line"><span class="lineno"> 5923</span>                }</div>
<div class="line"><span class="lineno"> 5924</span>            }</div>
<div class="line"><span class="lineno"> 5925</span> </div>
<div class="line"><span class="lineno"> 5926</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(first_boundary_halfedge != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>());</div>
<div class="line"><span class="lineno"> 5927</span> </div>
<div class="line"><span class="lineno"> 5928</span>            <span class="comment">// Now that we have a halfedge which lies on the boundary of the clipped polygon,</span></div>
<div class="line"><span class="lineno"> 5929</span>            <span class="comment">// we will traverse/walk the clipped polygon&#39;s exterior to collect all other boundary halfedges</span></div>
<div class="line"><span class="lineno"> 5930</span>            <span class="comment">// that have the same winding order as the input meshes (i.e. the source-mesh and cut-mesh).</span></div>
<div class="line"><span class="lineno"> 5931</span> </div>
<div class="line"><span class="lineno"> 5932</span>            <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> current_exterior_halfedge = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno"> 5933</span>            <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> next_exterior_halfedge = first_boundary_halfedge;</div>
<div class="line"><span class="lineno"> 5934</span>            std::unordered_map&lt;ed_t, bool&gt; walked_edges;</div>
<div class="line"><span class="lineno"> 5935</span>            <span class="comment">// walked_edges.reserve(incident_edges.size());</span></div>
<div class="line"><span class="lineno"> 5936</span>            <span class="keywordflow">do</span> {</div>
<div class="line"><span class="lineno"> 5937</span> </div>
<div class="line"><span class="lineno"> 5938</span>                current_exterior_halfedge = next_exterior_halfedge;</div>
<div class="line"><span class="lineno"> 5939</span>                incident_halfedges.emplace_back(current_exterior_halfedge);</div>
<div class="line"><span class="lineno"> 5940</span>                walked_edges[m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a96e9db918396b86f0b61f5445ef46b18">edge</a>(current_exterior_halfedge)] = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 5941</span> </div>
<div class="line"><span class="lineno"> 5942</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> current_tgt = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(current_exterior_halfedge);</div>
<div class="line"><span class="lineno"> 5943</span>                next_exterior_halfedge = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>(); <span class="comment">// reset</span></div>
<div class="line"><span class="lineno"> 5944</span> </div>
<div class="line"><span class="lineno"> 5945</span>                <span class="comment">// find next boundary halfedge from incident edges</span></div>
<div class="line"><span class="lineno"> 5946</span>                <span class="keywordflow">for</span> (std::vector&lt;ed_t&gt;::const_iterator incident_edge_iter = incident_edges.cbegin();</div>
<div class="line"><span class="lineno"> 5947</span>                     incident_edge_iter != incident_edges.cbegin() + incident_boundary_edge_count; <span class="comment">// we only want exterior edges;</span></div>
<div class="line"><span class="lineno"> 5948</span>                     ++incident_edge_iter) {</div>
<div class="line"><span class="lineno"> 5949</span>                    <span class="comment">// const int incident_edge_idx = (int)std::distance(incident_edges.cbegin(), incident_edge_iter);</span></div>
<div class="line"><span class="lineno"> 5950</span>                    <span class="comment">// if (incident_edge_idx &gt;= incident_boundary_edge_count) {</span></div>
<div class="line"><span class="lineno"> 5951</span>                    <span class="comment">//     continue; // we only want exterior halfedge</span></div>
<div class="line"><span class="lineno"> 5952</span>                    <span class="comment">// }</span></div>
<div class="line"><span class="lineno"> 5953</span> </div>
<div class="line"><span class="lineno"> 5954</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; edge = *incident_edge_iter;</div>
<div class="line"><span class="lineno"> 5955</span> </div>
<div class="line"><span class="lineno"> 5956</span>                    <span class="keywordtype">bool</span> edge_walked = walked_edges.find(edge) != walked_edges.cend(); <span class="comment">// std::find(walked_edges.cbegin(), walked_edges.cend(), edge) != walked_edges.cend();</span></div>
<div class="line"><span class="lineno"> 5957</span> </div>
<div class="line"><span class="lineno"> 5958</span>                    <span class="keywordflow">if</span> (edge_walked) {</div>
<div class="line"><span class="lineno"> 5959</span>                        <span class="keywordflow">continue</span>; <span class="comment">// skip edge is walked already</span></div>
<div class="line"><span class="lineno"> 5960</span>                    }</div>
<div class="line"><span class="lineno"> 5961</span> </div>
<div class="line"><span class="lineno"> 5962</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> v0 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(edge, 0);</div>
<div class="line"><span class="lineno"> 5963</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> v1 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(edge, 1);</div>
<div class="line"><span class="lineno"> 5964</span> </div>
<div class="line"><span class="lineno"> 5965</span>                    <span class="keywordflow">if</span> (v0 == current_tgt || v1 == current_tgt) <span class="comment">// check if connected to current (i.e. they share one vertex)</span></div>
<div class="line"><span class="lineno"> 5966</span>                    {</div>
<div class="line"><span class="lineno"> 5967</span>                        <span class="keyword">const</span> <span class="keywordtype">bool</span> v0_is_ivtx = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(v0, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 5968</span>                        <span class="keyword">const</span> <span class="keywordtype">bool</span> v1_is_ivtx = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(v1, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 5969</span>                        <span class="keywordtype">bool</span> is_ambiguious_boundary_edge_case = v0_is_ivtx &amp;&amp; v1_is_ivtx;</div>
<div class="line"><span class="lineno"> 5970</span>                        <span class="keywordtype">bool</span> is_valid_ambiguious_boundary_edge = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 5971</span> </div>
<div class="line"><span class="lineno"> 5972</span>                        <span class="keywordflow">if</span> (is_ambiguious_boundary_edge_case) { <span class="comment">// exterior edge with two intersection vertices (ambigious case arising from concave polyhedron cut)</span></div>
<div class="line"><span class="lineno"> 5973</span> </div>
<div class="line"><span class="lineno"> 5974</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)v0 - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/* m0_ivtx_to_intersection_registry_entry.find(v0) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 5975</span>                            <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt;&amp; v0_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, v0 - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 5976</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> v0_ps_edge = v0_ipair.first; <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_edge, v0); //ps.edge(v0_coincident_ps_halfedge);</span></div>
<div class="line"><span class="lineno"> 5977</span> </div>
<div class="line"><span class="lineno"> 5978</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)v1 - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/* m0_ivtx_to_intersection_registry_entry.find(v1) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 5979</span>                            <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt;&amp; v1_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, v1 - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 5980</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> v1_ps_edge = v1_ipair.first; <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_edge, v1); // ps.edge(v1_coincident_ps_halfedge);</span></div>
<div class="line"><span class="lineno"> 5981</span> </div>
<div class="line"><span class="lineno"> 5982</span>                            is_valid_ambiguious_boundary_edge = (v0_ps_edge == v1_ps_edge); <span class="comment">// see also above when gathering exterior incident edges</span></div>
<div class="line"><span class="lineno"> 5983</span>                        }</div>
<div class="line"><span class="lineno"> 5984</span> </div>
<div class="line"><span class="lineno"> 5985</span>                        <span class="keywordflow">if</span> (!is_ambiguious_boundary_edge_case || is_valid_ambiguious_boundary_edge) {</div>
<div class="line"><span class="lineno"> 5986</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h0 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(edge, 0);</div>
<div class="line"><span class="lineno"> 5987</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h1 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(edge, 1);</div>
<div class="line"><span class="lineno"> 5988</span> </div>
<div class="line"><span class="lineno"> 5989</span>                            next_exterior_halfedge = h0;</div>
<div class="line"><span class="lineno"> 5990</span> </div>
<div class="line"><span class="lineno"> 5991</span>                            <span class="keywordflow">if</span> (m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(h0) != current_tgt) <span class="comment">// h0 is facing the opposite dir</span></div>
<div class="line"><span class="lineno"> 5992</span>                            {</div>
<div class="line"><span class="lineno"> 5993</span>                                next_exterior_halfedge = h1;</div>
<div class="line"><span class="lineno"> 5994</span>                            }</div>
<div class="line"><span class="lineno"> 5995</span> </div>
<div class="line"><span class="lineno"> 5996</span>                            <span class="keywordflow">break</span>; <span class="comment">// found</span></div>
<div class="line"><span class="lineno"> 5997</span>                        }</div>
<div class="line"><span class="lineno"> 5998</span>                    }</div>
<div class="line"><span class="lineno"> 5999</span>                }</div>
<div class="line"><span class="lineno"> 6000</span> </div>
<div class="line"><span class="lineno"> 6001</span>            } <span class="keywordflow">while</span> (next_exterior_halfedge != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>() <span class="comment">/*first_boundary_halfedge*/</span>);</div>
<div class="line"><span class="lineno"> 6002</span> </div>
<div class="line"><span class="lineno"> 6003</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(incident_halfedges.size() &gt;= 3); <span class="comment">// minimum i.e. for a triangles!</span></div>
<div class="line"><span class="lineno"> 6004</span> </div>
<div class="line"><span class="lineno"> 6005</span>            <span class="comment">// Note: at this stage we have gathered all of the [exterior] halfedges needed to traced child polygons</span></div>
<div class="line"><span class="lineno"> 6006</span> </div>
<div class="line"><span class="lineno"> 6007</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> exterior_halfedge_count = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)incident_halfedges.size();</div>
<div class="line"><span class="lineno"> 6008</span> </div>
<div class="line"><span class="lineno"> 6009</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(exterior_halfedge_count == incident_boundary_edge_count);</div>
<div class="line"><span class="lineno"> 6010</span> </div>
<div class="line"><span class="lineno"> 6011</span>            <span class="comment">// Now we are going to also gather interior halfedges (those passing inside the area of &quot;ps_face&quot;, and defined only by intersection points</span></div>
<div class="line"><span class="lineno"> 6012</span>            <span class="comment">// where the src and tgt vertex do not share the same incident ihalfedge in their registry entry.</span></div>
<div class="line"><span class="lineno"> 6013</span> </div>
<div class="line"><span class="lineno"> 6014</span>            <span class="keywordflow">for</span> (std::vector&lt;ed_t&gt;::const_iterator incident_edge_iter = incident_edges.cbegin() + incident_boundary_edge_count; <span class="comment">// start from polygon interior edges offset</span></div>
<div class="line"><span class="lineno"> 6015</span>                 incident_edge_iter != incident_edges.cend();</div>
<div class="line"><span class="lineno"> 6016</span>                 ++incident_edge_iter) {</div>
<div class="line"><span class="lineno"> 6017</span> </div>
<div class="line"><span class="lineno"> 6018</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; edge = (*incident_edge_iter);</div>
<div class="line"><span class="lineno"> 6019</span> </div>
<div class="line"><span class="lineno"> 6020</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h0 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(edge, 0);</div>
<div class="line"><span class="lineno"> 6021</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h1 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(edge, 1);</div>
<div class="line"><span class="lineno"> 6022</span>                incident_halfedges.emplace_back(h0);</div>
<div class="line"><span class="lineno"> 6023</span>                incident_halfedges.emplace_back(h1);</div>
<div class="line"><span class="lineno"> 6024</span>            }</div>
<div class="line"><span class="lineno"> 6025</span> </div>
<div class="line"><span class="lineno"> 6026</span>            <span class="comment">// Note: at this stage, we have all the halfedges that we need to trace child polygons.</span></div>
<div class="line"><span class="lineno"> 6027</span>            <span class="comment">// Thus, the next step is the actual tracing to clip ps_face</span></div>
<div class="line"><span class="lineno"> 6028</span> </div>
<div class="line"><span class="lineno"> 6029</span>            <span class="comment">// Trace child polygons on ps_face to clip it</span></div>
<div class="line"><span class="lineno"> 6030</span>            <span class="comment">//-------------------------------------------</span></div>
<div class="line"><span class="lineno"> 6031</span> </div>
<div class="line"><span class="lineno"> 6032</span>            std::vector&lt;hd_t&gt; incident_halfedges_to_be_walked(incident_halfedges.cbegin(), incident_halfedges.cend()); <span class="comment">// copy</span></div>
<div class="line"><span class="lineno"> 6033</span> </div>
<div class="line"><span class="lineno"> 6034</span>            <span class="keywordflow">do</span> { <span class="comment">// each iteration traces a child polygon</span></div>
<div class="line"><span class="lineno"> 6035</span> </div>
<div class="line"><span class="lineno"> 6036</span>                <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a> child_polygon;</div>
<div class="line"><span class="lineno"> 6037</span> </div>
<div class="line"><span class="lineno"> 6038</span>                <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> current_halfedge = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno"> 6039</span>                <span class="comment">// can be any boundary halfedge in vector (NOTE: boundary halfedges come first in the std::vector)</span></div>
<div class="line"><span class="lineno"> 6040</span>                <span class="comment">// Its important that we start from boundary halfedge as it simplies the conditions for when a</span></div>
<div class="line"><span class="lineno"> 6041</span>                <span class="comment">// valid polygon has been constructed</span></div>
<div class="line"><span class="lineno"> 6042</span>                <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> next_halfedge = incident_halfedges_to_be_walked[0];</div>
<div class="line"><span class="lineno"> 6043</span> </div>
<div class="line"><span class="lineno"> 6044</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(incident_halfedges_to_be_walked.size() &gt;= 2);</div>
<div class="line"><span class="lineno"> 6045</span> </div>
<div class="line"><span class="lineno"> 6046</span>                <span class="keywordtype">bool</span> is_valid_polygon = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 6047</span>                <span class="keywordflow">do</span> { <span class="comment">// each iteration walks a halfedge to incremetally trace a child polygon</span></div>
<div class="line"><span class="lineno"> 6048</span> </div>
<div class="line"><span class="lineno"> 6049</span>                    <span class="comment">// 1. update state</span></div>
<div class="line"><span class="lineno"> 6050</span>                    current_halfedge = next_halfedge;</div>
<div class="line"><span class="lineno"> 6051</span> </div>
<div class="line"><span class="lineno"> 6052</span>                    child_polygon.push_back(current_halfedge);</div>
<div class="line"><span class="lineno"> 6053</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> current_halfedge_target = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(current_halfedge);</div>
<div class="line"><span class="lineno"> 6054</span>                    next_halfedge = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>(); <span class="comment">// reset</span></div>
<div class="line"><span class="lineno"> 6055</span> </div>
<div class="line"><span class="lineno"> 6056</span>                    <span class="comment">// remove next halfedge so that we dont walk it again</span></div>
<div class="line"><span class="lineno"> 6057</span>                    {</div>
<div class="line"><span class="lineno"> 6058</span>                        std::vector&lt;hd_t&gt;::iterator find_iter = std::find(incident_halfedges_to_be_walked.begin(), incident_halfedges_to_be_walked.end(), current_halfedge);</div>
<div class="line"><span class="lineno"> 6059</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(find_iter != incident_halfedges_to_be_walked.end());</div>
<div class="line"><span class="lineno"> 6060</span>                        incident_halfedges_to_be_walked.erase(find_iter); <span class="comment">// remove</span></div>
<div class="line"><span class="lineno"> 6061</span>                    }</div>
<div class="line"><span class="lineno"> 6062</span> </div>
<div class="line"><span class="lineno"> 6063</span>                    <span class="keywordflow">if</span> (child_polygon.size() &gt;= 3) { <span class="comment">// minimum halfedge count to constitute a valid polygon (triangle)</span></div>
<div class="line"><span class="lineno"> 6064</span> </div>
<div class="line"><span class="lineno"> 6065</span>                        <span class="comment">// source of first halfedge is target of last</span></div>
<div class="line"><span class="lineno"> 6066</span>                        <span class="keywordflow">if</span> (m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(child_polygon.front()) == m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(child_polygon.back())) {</div>
<div class="line"><span class="lineno"> 6067</span> </div>
<div class="line"><span class="lineno"> 6068</span>                            <span class="comment">// the current halfedge is [not] the opposite of the first halfedge in list</span></div>
<div class="line"><span class="lineno"> 6069</span>                            <span class="comment">// This is an important edge case for when you walk a halfedge connecting two vertices not in alpha (intersection).</span></div>
<div class="line"><span class="lineno"> 6070</span>                            <span class="comment">// Example: case of tracing a polygon analogous to a cheek slash.</span></div>
<div class="line"><span class="lineno"> 6071</span>                            <span class="comment">// See also the comment above the declaration of &quot;next_halfedge&quot;</span></div>
<div class="line"><span class="lineno"> 6072</span>                            <span class="keywordflow">if</span> (current_halfedge != m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(child_polygon.front())) {</div>
<div class="line"><span class="lineno"> 6073</span>                                is_valid_polygon = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 6074</span> </div>
<div class="line"><span class="lineno"> 6075</span>                                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 6076</span>                            } <span class="keywordflow">else</span> { <span class="comment">// ... if the current halfedge is the opposite of the first halfedge in list</span></div>
<div class="line"><span class="lineno"> 6077</span> </div>
<div class="line"><span class="lineno"> 6078</span>                                <span class="comment">// peak forward to see what the next halfedge will be (if the next halfedge is in &quot;child_polygon&quot; then we are done)</span></div>
<div class="line"><span class="lineno"> 6079</span>                                std::vector&lt;hd_t&gt; premptive_candidate_halfedges;</div>
<div class="line"><span class="lineno"> 6080</span>                                <span class="keywordflow">for</span> (std::vector&lt;hd_t&gt;::const_iterator incident_halfedges_to_be_walked_iter = incident_halfedges_to_be_walked.cbegin(); incident_halfedges_to_be_walked_iter != incident_halfedges_to_be_walked.cend(); ++incident_halfedges_to_be_walked_iter) {</div>
<div class="line"><span class="lineno"> 6081</span>                                    <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; potential_candidate = *incident_halfedges_to_be_walked_iter;</div>
<div class="line"><span class="lineno"> 6082</span>                                    <span class="keywordflow">if</span> (m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(potential_candidate) == current_halfedge_target) {</div>
<div class="line"><span class="lineno"> 6083</span>                                        premptive_candidate_halfedges.push_back(potential_candidate);</div>
<div class="line"><span class="lineno"> 6084</span>                                    }</div>
<div class="line"><span class="lineno"> 6085</span>                                }</div>
<div class="line"><span class="lineno"> 6086</span> </div>
<div class="line"><span class="lineno"> 6087</span>                                <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> prime_candidate = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno"> 6088</span>                                <span class="keywordflow">if</span> (premptive_candidate_halfedges.size() == 2) {</div>
<div class="line"><span class="lineno"> 6089</span> </div>
<div class="line"><span class="lineno"> 6090</span>                                    <span class="keyword">const</span> std::vector&lt;hd_t&gt;::const_iterator current_halfedge_find_iter = std::find(incident_halfedges.cbegin(), incident_halfedges.cend(), current_halfedge);</div>
<div class="line"><span class="lineno"> 6091</span>                                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(current_halfedge_find_iter != incident_halfedges.cend());</div>
<div class="line"><span class="lineno"> 6092</span>                                    <span class="keyword">const</span> <span class="keywordtype">bool</span> current_halfedge_is_exterior = <a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(incident_halfedges.cbegin(), current_halfedge_find_iter) &lt; exterior_halfedge_count;</div>
<div class="line"><span class="lineno"> 6093</span> </div>
<div class="line"><span class="lineno"> 6094</span>                                    <span class="keywordflow">if</span> (current_halfedge_is_exterior) {</div>
<div class="line"><span class="lineno"> 6095</span> </div>
<div class="line"><span class="lineno"> 6096</span>                                        <span class="comment">// pick interior candidate</span></div>
<div class="line"><span class="lineno"> 6097</span>                                        <span class="keyword">const</span> std::vector&lt;hd_t&gt;::const_iterator prime_candidate_find_iter = std::find(incident_halfedges.cbegin(), incident_halfedges.cend(), current_halfedge);</div>
<div class="line"><span class="lineno"> 6098</span>                                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(prime_candidate_find_iter != incident_halfedges.cend());</div>
<div class="line"><span class="lineno"> 6099</span>                                        <span class="keyword">const</span> <span class="keywordtype">bool</span> prime_candidate_is_exterior = <a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(incident_halfedges.cbegin(), prime_candidate_find_iter) &lt; exterior_halfedge_count;</div>
<div class="line"><span class="lineno"> 6100</span> </div>
<div class="line"><span class="lineno"> 6101</span>                                        <span class="keywordflow">if</span> (prime_candidate_is_exterior) {</div>
<div class="line"><span class="lineno"> 6102</span>                                            prime_candidate = premptive_candidate_halfedges.back(); <span class="comment">// select correct interior halfedge</span></div>
<div class="line"><span class="lineno"> 6103</span>                                        }</div>
<div class="line"><span class="lineno"> 6104</span>                                    } <span class="keywordflow">else</span> { <span class="comment">// interior</span></div>
<div class="line"><span class="lineno"> 6105</span> </div>
<div class="line"><span class="lineno"> 6106</span>                                        <span class="comment">// pick non-opposite</span></div>
<div class="line"><span class="lineno"> 6107</span>                                        <span class="keyword">const</span> <span class="keywordtype">bool</span> prime_candidate_is_opposite = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(current_halfedge) == prime_candidate;</div>
<div class="line"><span class="lineno"> 6108</span> </div>
<div class="line"><span class="lineno"> 6109</span>                                        <span class="keywordflow">if</span> (prime_candidate_is_opposite) {</div>
<div class="line"><span class="lineno"> 6110</span>                                            prime_candidate = premptive_candidate_halfedges.back(); <span class="comment">// select correct non-opposite halfedge</span></div>
<div class="line"><span class="lineno"> 6111</span>                                        }</div>
<div class="line"><span class="lineno"> 6112</span>                                    }</div>
<div class="line"><span class="lineno"> 6113</span>                                }</div>
<div class="line"><span class="lineno"> 6114</span> </div>
<div class="line"><span class="lineno"> 6115</span>                                <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> premptive_next = prime_candidate;</div>
<div class="line"><span class="lineno"> 6116</span> </div>
<div class="line"><span class="lineno"> 6117</span>                                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(premptive_candidate_halfedges.size() &lt;= 2);</div>
<div class="line"><span class="lineno"> 6118</span> </div>
<div class="line"><span class="lineno"> 6119</span>                                <span class="keywordflow">if</span> (std::find(child_polygon.cbegin(), child_polygon.cend(), premptive_next) != child_polygon.cend()) {</div>
<div class="line"><span class="lineno"> 6120</span>                                    is_valid_polygon = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 6121</span> </div>
<div class="line"><span class="lineno"> 6122</span>                                    <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 6123</span>                                }</div>
<div class="line"><span class="lineno"> 6124</span>                            }</div>
<div class="line"><span class="lineno"> 6125</span>                        }</div>
<div class="line"><span class="lineno"> 6126</span>                    }</div>
<div class="line"><span class="lineno"> 6127</span> </div>
<div class="line"><span class="lineno"> 6128</span>                    <span class="comment">// 2. find next halfedge</span></div>
<div class="line"><span class="lineno"> 6129</span> </div>
<div class="line"><span class="lineno"> 6130</span>                    <span class="comment">// 2.1. get candidates (halfedges whose source vertex is the target of current)</span></div>
<div class="line"><span class="lineno"> 6131</span>                    std::vector&lt;hd_t&gt; candidate_halfedges;</div>
<div class="line"><span class="lineno"> 6132</span>                    candidate_halfedges.reserve(2); <span class="comment">// two candidates at most because we filtered out exterior interior-halfedges as well as clockwise (cw) halfedge</span></div>
<div class="line"><span class="lineno"> 6133</span> </div>
<div class="line"><span class="lineno"> 6134</span>                    <span class="keywordflow">for</span> (std::vector&lt;hd_t&gt;::const_iterator incident_halfedges_to_be_walked_iter = incident_halfedges_to_be_walked.cbegin(); incident_halfedges_to_be_walked_iter != incident_halfedges_to_be_walked.cend(); ++incident_halfedges_to_be_walked_iter) {</div>
<div class="line"><span class="lineno"> 6135</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; potential_candidate = *incident_halfedges_to_be_walked_iter;</div>
<div class="line"><span class="lineno"> 6136</span>                        <span class="keywordflow">if</span> (m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(potential_candidate) == current_halfedge_target) {</div>
<div class="line"><span class="lineno"> 6137</span>                            candidate_halfedges.push_back(potential_candidate);</div>
<div class="line"><span class="lineno"> 6138</span>                        }</div>
<div class="line"><span class="lineno"> 6139</span>                    }</div>
<div class="line"><span class="lineno"> 6140</span> </div>
<div class="line"><span class="lineno"> 6141</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(candidate_halfedges.size() &lt;= 2);</div>
<div class="line"><span class="lineno"> 6142</span> </div>
<div class="line"><span class="lineno"> 6143</span>                    <span class="comment">// 2.2. select prime candidate</span></div>
<div class="line"><span class="lineno"> 6144</span>                    <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> prime_candidate = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno"> 6145</span> </div>
<div class="line"><span class="lineno"> 6146</span>                    <span class="keywordflow">if</span> (!candidate_halfedges.empty()) {</div>
<div class="line"><span class="lineno"> 6147</span>                        prime_candidate = candidate_halfedges[0]; <span class="comment">// assuming: candidate_halfedges.size() == 1</span></div>
<div class="line"><span class="lineno"> 6148</span>                    }</div>
<div class="line"><span class="lineno"> 6149</span> </div>
<div class="line"><span class="lineno"> 6150</span>                    <span class="keywordflow">if</span> (candidate_halfedges.size() == 2) {</div>
<div class="line"><span class="lineno"> 6151</span> </div>
<div class="line"><span class="lineno"> 6152</span>                        <span class="keyword">const</span> std::vector&lt;hd_t&gt;::const_iterator current_halfedge_find_iter = std::find(incident_halfedges.cbegin(), incident_halfedges.cend(), current_halfedge);</div>
<div class="line"><span class="lineno"> 6153</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(current_halfedge_find_iter != incident_halfedges.cend());</div>
<div class="line"><span class="lineno"> 6154</span>                        <span class="keyword">const</span> <span class="keywordtype">bool</span> current_halfedge_is_exterior = <a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(incident_halfedges.cbegin(), current_halfedge_find_iter) &lt; exterior_halfedge_count;</div>
<div class="line"><span class="lineno"> 6155</span> </div>
<div class="line"><span class="lineno"> 6156</span>                        <span class="keywordflow">if</span> (current_halfedge_is_exterior) {</div>
<div class="line"><span class="lineno"> 6157</span> </div>
<div class="line"><span class="lineno"> 6158</span>                            <span class="comment">// pick interior candidate</span></div>
<div class="line"><span class="lineno"> 6159</span>                            <span class="keyword">const</span> std::vector&lt;hd_t&gt;::const_iterator prime_candidate_find_iter = std::find(incident_halfedges.cbegin(), incident_halfedges.cend(), current_halfedge);</div>
<div class="line"><span class="lineno"> 6160</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(prime_candidate_find_iter != incident_halfedges.cend());</div>
<div class="line"><span class="lineno"> 6161</span>                            <span class="keyword">const</span> <span class="keywordtype">bool</span> prime_candidate_is_exterior = <a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(incident_halfedges.cbegin(), prime_candidate_find_iter) &lt; exterior_halfedge_count;</div>
<div class="line"><span class="lineno"> 6162</span> </div>
<div class="line"><span class="lineno"> 6163</span>                            <span class="keywordflow">if</span> (prime_candidate_is_exterior) {</div>
<div class="line"><span class="lineno"> 6164</span>                                prime_candidate = candidate_halfedges.back(); <span class="comment">// select correct interior halfedge</span></div>
<div class="line"><span class="lineno"> 6165</span>                            }</div>
<div class="line"><span class="lineno"> 6166</span>                        } <span class="keywordflow">else</span> { <span class="comment">// interior</span></div>
<div class="line"><span class="lineno"> 6167</span> </div>
<div class="line"><span class="lineno"> 6168</span>                            <span class="comment">// pick non-opposite</span></div>
<div class="line"><span class="lineno"> 6169</span>                            <span class="keyword">const</span> <span class="keywordtype">bool</span> prime_candidate_is_opposite = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(current_halfedge) == prime_candidate;</div>
<div class="line"><span class="lineno"> 6170</span> </div>
<div class="line"><span class="lineno"> 6171</span>                            <span class="keywordflow">if</span> (prime_candidate_is_opposite) {</div>
<div class="line"><span class="lineno"> 6172</span>                                prime_candidate = candidate_halfedges.back(); <span class="comment">// select correct non-opposite halfedge</span></div>
<div class="line"><span class="lineno"> 6173</span>                            }</div>
<div class="line"><span class="lineno"> 6174</span>                        }</div>
<div class="line"><span class="lineno"> 6175</span>                    }</div>
<div class="line"><span class="lineno"> 6176</span> </div>
<div class="line"><span class="lineno"> 6177</span>                    next_halfedge = prime_candidate;</div>
<div class="line"><span class="lineno"> 6178</span> </div>
<div class="line"><span class="lineno"> 6179</span>                } <span class="keywordflow">while</span> (next_halfedge != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>());</div>
<div class="line"><span class="lineno"> 6180</span> </div>
<div class="line"><span class="lineno"> 6181</span>                <span class="keywordflow">if</span> (is_valid_polygon) {</div>
<div class="line"><span class="lineno"> 6182</span> </div>
<div class="line"><span class="lineno"> 6183</span>                    <span class="keyword">const</span> <span class="keywordtype">int</span> poly_idx = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)(m0_polygons.size() + child_polygons.size());</div>
<div class="line"><span class="lineno"> 6184</span>                    <span class="keywordflow">if</span> (<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aaf65fb11520f9cb197774e79efeddfbb">ps_is_cutmesh_face</a>(ps_face, sm_face_count)) {</div>
<div class="line"><span class="lineno"> 6185</span>                        m0_cm_cutpath_adjacent_polygons.push_back(poly_idx);</div>
<div class="line"><span class="lineno"> 6186</span>                    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 6187</span>                        m0_sm_cutpath_adjacent_polygons.push_back(poly_idx);</div>
<div class="line"><span class="lineno"> 6188</span>                    }</div>
<div class="line"><span class="lineno"> 6189</span> </div>
<div class="line"><span class="lineno"> 6190</span>                    m0_to_ps_face[poly_idx] = ps_face;</div>
<div class="line"><span class="lineno"> 6191</span> </div>
<div class="line"><span class="lineno"> 6192</span>                    child_polygons.emplace_back(child_polygon);</div>
<div class="line"><span class="lineno"> 6193</span>                }</div>
<div class="line"><span class="lineno"> 6194</span> </div>
<div class="line"><span class="lineno"> 6195</span>            } <span class="keywordflow">while</span> (!incident_halfedges_to_be_walked.empty());</div>
<div class="line"><span class="lineno"> 6196</span>        } <span class="comment">// if (!is_intersecting_ps_face) {</span></div>
<div class="line"><span class="lineno"> 6197</span> </div>
<div class="line"><span class="lineno"> 6198</span>        m0_polygons.insert(m0_polygons.end(), child_polygons.cbegin(), child_polygons.cend());</div>
<div class="line"><span class="lineno"> 6199</span> </div>
<div class="line"><span class="lineno"> 6200</span>        <span class="keywordflow">if</span> (!is_from_cut_mesh ) {</div>
<div class="line"><span class="lineno"> 6201</span>            traced_sm_polygon_count += (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)child_polygons.size();</div>
<div class="line"><span class="lineno"> 6202</span>        }</div>
<div class="line"><span class="lineno"> 6203</span> </div>
<div class="line"><span class="lineno"> 6204</span>    } <span class="comment">// for each ps-face to trace</span></div>
<div class="line"><span class="lineno"> 6205</span> </div>
<div class="line"><span class="lineno"> 6206</span><span class="preprocessor">#endif </span><span class="comment">// #if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 6207</span> </div>
<div class="line"><span class="lineno"> 6208</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>(); <span class="comment">// &amp;&amp;&amp;&amp;&amp;</span></div>
<div class="line"><span class="lineno"> 6209</span> </div>
<div class="line"><span class="lineno"> 6210</span>    <span class="comment">// m0_ivtx_to_ps_faces.clear(); // free</span></div>
<div class="line"><span class="lineno"> 6211</span>    ps_iface_to_m0_edge_list.clear(); <span class="comment">// free</span></div>
<div class="line"><span class="lineno"> 6212</span>    ps_to_m0_edges.clear(); <span class="comment">// free</span></div>
<div class="line"><span class="lineno"> 6213</span>    ps_to_m0_non_intersecting_edge.clear(); <span class="comment">// free</span></div>
<div class="line"><span class="lineno"> 6214</span>    ps_iface_to_ivtx_list.clear(); <span class="comment">// free</span></div>
<div class="line"><span class="lineno"> 6215</span> </div>
<div class="line"><span class="lineno"> 6216</span>    <span class="comment">// Note: at this stage, we have traced all polygons. This means that any intersecting face in the polygon</span></div>
<div class="line"><span class="lineno"> 6217</span>    <span class="comment">// soup data structure will also now have been clipped.</span></div>
<div class="line"><span class="lineno"> 6218</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6219</span>    <span class="comment">// The connectivity of all traced polygons is stored as a vector/array of halfedges, for each</span></div>
<div class="line"><span class="lineno"> 6220</span>    <span class="comment">// traced polygon. The halfedge data structure (i.e. &quot;m0&quot;) still holds the underlying mesh data</span></div>
<div class="line"><span class="lineno"> 6221</span>    <span class="comment">// over-which we are abstracting this connectivity i.e. &quot;m0&quot; stores vertices (e.g. intersection</span></div>
<div class="line"><span class="lineno"> 6222</span>    <span class="comment">// points), edges, and halfeges.</span></div>
<div class="line"><span class="lineno"> 6223</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6224</span>    <span class="comment">// The lists of halfedges that we are using to represent the traced polygons avoids &quot;2-manifold restrictions&quot;:</span></div>
<div class="line"><span class="lineno"> 6225</span>    <span class="comment">// Storing the traced polygons inside a halfedge data structure is not always possible because we could violate the</span></div>
<div class="line"><span class="lineno"> 6226</span>    <span class="comment">// priniciple rule that an edge must be incident to at-most 2 faces (2-manifold surface mesh rule).</span></div>
<div class="line"><span class="lineno"> 6227</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6228</span>    <span class="comment">// There is a other benefit to using lists: it makes for a more logical implementation for the remainder of the</span></div>
<div class="line"><span class="lineno"> 6229</span>    <span class="comment">// cutting algorithm i.e when duplicating intersection points, creating cut-mesh patches, stitching (hole</span></div>
<div class="line"><span class="lineno"> 6230</span>    <span class="comment">// filling), and more.</span></div>
<div class="line"><span class="lineno"> 6231</span> </div>
<div class="line"><span class="lineno"> 6232</span>    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">int</span>)m0_polygons.size() &gt;= ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a08178cf3f846017dbec208b96c970ac7">number_of_faces</a>());</div>
<div class="line"><span class="lineno"> 6233</span> </div>
<div class="line"><span class="lineno"> 6234</span>    <span class="keyword">const</span> std::vector&lt;traced_polygon_t&gt;::iterator traced_sm_polygons_iter_end = m0_polygons.begin() + traced_sm_polygon_count;</div>
<div class="line"><span class="lineno"> 6235</span>    <span class="comment">// const std::vector&lt;traced_polygon_t&gt;::iterator&amp; traced_cs_polygons_iter_begin = traced_sm_polygons_iter_end;</span></div>
<div class="line"><span class="lineno"> 6236</span>    <span class="keyword">const</span> std::vector&lt;traced_polygon_t&gt;::const_iterator m0_traced_sm_polygons_iter_cend = m0_polygons.cbegin() + traced_sm_polygon_count;</div>
<div class="line"><span class="lineno"> 6237</span>    <span class="keyword">const</span> std::vector&lt;traced_polygon_t&gt;::const_iterator&amp; traced_cs_polygons_iter_cbegin = traced_sm_polygons_iter_end;</div>
<div class="line"><span class="lineno"> 6238</span> </div>
<div class="line"><span class="lineno"> 6239</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Mark seam edges *&quot;</span>);</div>
<div class="line"><span class="lineno"> 6240</span>    <span class="comment">// extract the seam vertices</span></div>
<div class="line"><span class="lineno"> 6241</span>    std::vector&lt;bool&gt; m0_vertex_to_seam_flag;</div>
<div class="line"><span class="lineno"> 6242</span>    <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a7095d6c7279faa9121a2a2722a51a814">mark_seam_vertices</a>(m0_vertex_to_seam_flag, m0, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 6243</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 6244</span> </div>
<div class="line"><span class="lineno"> 6245</span>    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(!m0_vertex_to_seam_flag.empty());</div>
<div class="line"><span class="lineno"> 6246</span> </div>
<div class="line"><span class="lineno"> 6248</span>    <span class="comment">// Dump meshes for the source-mesh and cut-mesh using the traced polygons</span></div>
<div class="line"><span class="lineno"> 6250</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 6251</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6252</span>    <span class="comment">// NOTE: we cannot always create meshes using the traced polygons because of</span></div>
<div class="line"><span class="lineno"> 6253</span>    <span class="comment">// a possible violation of the surface mesh contruction rules. Basically, we cannot</span></div>
<div class="line"><span class="lineno"> 6254</span>    <span class="comment">// reference a halfedge and its opposite in the same face because it violates</span></div>
<div class="line"><span class="lineno"> 6255</span>    <span class="comment">// halfedge construction rules (2-manifold surface mesh). This issue occurs</span></div>
<div class="line"><span class="lineno"> 6256</span>    <span class="comment">// whenever ps polygon is partially cut.</span></div>
<div class="line"><span class="lineno"> 6257</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6258</span>    <span class="comment">// Thus, we will only dump meshes if can gaurranteed not to violate halfedge</span></div>
<div class="line"><span class="lineno"> 6259</span>    <span class="comment">// mesh rules (to avoid potentially crashing the program due to logic error).</span></div>
<div class="line"><span class="lineno"> 6260</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6261</span> </div>
<div class="line"><span class="lineno"> 6262</span>    <span class="keywordtype">bool</span> all_cutpaths_are_circular = (num_explicit_circular_cutpaths == num_explicit_cutpath_sequences);</div>
<div class="line"><span class="lineno"> 6263</span> </div>
<div class="line"><span class="lineno"> 6264</span>    <span class="comment">// dump traced src-mesh polygons.</span></div>
<div class="line"><span class="lineno"> 6265</span>    <span class="keywordflow">if</span> (input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a1e245a3c69ddc2f357fa5bbcb837dc8e">keep_srcmesh_seam</a>) {</div>
<div class="line"><span class="lineno"> 6266</span>        <span class="comment">// dump traced polygons only if the cut paths are circular or complete linear cuts (prevents us</span></div>
<div class="line"><span class="lineno"> 6267</span>        <span class="comment">// from violating halfedge construction rules)</span></div>
<div class="line"><span class="lineno"> 6268</span> </div>
<div class="line"><span class="lineno"> 6269</span>        <span class="keywordtype">bool</span> all_cutpaths_linear_and_without_making_holes = (num_explicit_circular_cutpaths == 0) &amp;&amp; ((<span class="keywordtype">int</span>)explicit_cutpaths_severing_srcmesh.size() == num_explicit_linear_cutpaths);</div>
<div class="line"><span class="lineno"> 6270</span> </div>
<div class="line"><span class="lineno"> 6271</span>        <span class="keywordflow">if</span> (cm_is_watertight || (all_cutpaths_are_circular || all_cutpaths_linear_and_without_making_holes)) {</div>
<div class="line"><span class="lineno"> 6272</span> </div>
<div class="line"><span class="lineno"> 6273</span>            std::map&lt;std::size_t, std::vector&lt;std::pair&lt;std::shared_ptr&lt;hmesh_t&gt;, <a class="code hl_struct" href="../../dd/d24/kernel_8cpp.html#d7/dd7/structconnected__component__info__t">connected_component_info_t</a>&gt;&gt;&gt; separated_src_mesh_fragments;</div>
<div class="line"><span class="lineno"> 6274</span>            std::unordered_map&lt;int, int&gt; _1;</div>
<div class="line"><span class="lineno"> 6275</span>            <span class="comment">// NOTE: The result is a mesh identical to the original source mesh except at the edges introduced by the cut..</span></div>
<div class="line"><span class="lineno"> 6276</span>            <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a34276907046e706af5626787b2e2b05a">extract_connected_components</a>(</div>
<div class="line"><span class="lineno"> 6277</span>#<span class="keywordflow">if</span> defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</div>
<div class="line"><span class="lineno"> 6278</span>                *input.scheduler,</div>
<div class="line"><span class="lineno"> 6279</span>#endif</div>
<div class="line"><span class="lineno"> 6280</span>                separated_src_mesh_fragments,</div>
<div class="line"><span class="lineno"> 6281</span>                m0,</div>
<div class="line"><span class="lineno"> 6282</span>                0, <span class="comment">// no offset because traced source-mesh polygons start from the beginning of &quot;m0_polygons&quot;</span></div>
<div class="line"><span class="lineno"> 6283</span>                std::vector&lt;traced_polygon_t&gt;(m0_polygons.begin(), traced_sm_polygons_iter_end),</div>
<div class="line"><span class="lineno"> 6284</span>                std::vector&lt;int&gt;(), <span class="comment">// sm_polygons_below_cs</span></div>
<div class="line"><span class="lineno"> 6285</span>                std::vector&lt;int&gt;(), <span class="comment">// sm_polygons_above_cs</span></div>
<div class="line"><span class="lineno"> 6286</span>                m0_vertex_to_seam_flag,</div>
<div class="line"><span class="lineno"> 6287</span>                std::vector&lt;vd_t&gt;(), <span class="comment">// Unused ... because we are extracting from &quot;m0&quot;</span></div>
<div class="line"><span class="lineno"> 6288</span>                std::unordered_map&lt;vd_t, vd_t&gt;(), <span class="comment">// Unused ... because we are extracting from &quot;m0&quot;</span></div>
<div class="line"><span class="lineno"> 6289</span>                _1, <span class="comment">// Unused ... because we are extracting from &quot;m0&quot;</span></div>
<div class="line"><span class="lineno"> 6290</span>                m0_to_ps_vtx,</div>
<div class="line"><span class="lineno"> 6291</span>                m0_to_ps_face,</div>
<div class="line"><span class="lineno"> 6292</span>                ps_to_sm_vtx,</div>
<div class="line"><span class="lineno"> 6293</span>                ps_to_sm_face,</div>
<div class="line"><span class="lineno"> 6294</span>                ps_to_cm_vtx,</div>
<div class="line"><span class="lineno"> 6295</span>                ps_to_cm_face,</div>
<div class="line"><span class="lineno"> 6296</span>                sm_vtx_cnt,</div>
<div class="line"><span class="lineno"> 6297</span>                sm_face_count,</div>
<div class="line"><span class="lineno"> 6298</span>                input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a0b23c3ae4df4369125ff8b489a42260b">populate_vertex_maps</a>,</div>
<div class="line"><span class="lineno"> 6299</span>                input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8307155337693cbe5ebf0f61ea8ffd81">populate_face_maps</a>,</div>
<div class="line"><span class="lineno"> 6300</span>                <span class="keyword">false</span>, <span class="comment">// unused ...</span></div>
<div class="line"><span class="lineno"> 6301</span>                <span class="keyword">false</span>, <span class="comment">// unused ...</span></div>
<div class="line"><span class="lineno"> 6302</span>                <span class="keyword">false</span> <span class="comment">// unused ...</span></div>
<div class="line"><span class="lineno"> 6303</span>            );</div>
<div class="line"><span class="lineno"> 6304</span> </div>
<div class="line"><span class="lineno"> 6305</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(separated_src_mesh_fragments.size() == 1); <span class="comment">// one cc</span></div>
<div class="line"><span class="lineno"> 6306</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(separated_src_mesh_fragments.cbegin()-&gt;second.size() == 1); <span class="comment">// one instance</span></div>
<div class="line"><span class="lineno"> 6307</span>            output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a70dd466fbfb5cfaaff8a0936766247f4">seamed_src_mesh</a> = std::shared_ptr&lt;output_mesh_info_t&gt;(<span class="keyword">new</span> <a class="code hl_struct" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#de/de4/structoutput__mesh__info__t">output_mesh_info_t</a>);</div>
<div class="line"><span class="lineno"> 6308</span>            output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a70dd466fbfb5cfaaff8a0936766247f4">seamed_src_mesh</a>-&gt;mesh = (separated_src_mesh_fragments.begin()-&gt;second.front().first);</div>
<div class="line"><span class="lineno"> 6309</span>            output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a70dd466fbfb5cfaaff8a0936766247f4">seamed_src_mesh</a>-&gt;seam_vertices = std::move(separated_src_mesh_fragments.begin()-&gt;second.front().second.seam_vertices);</div>
<div class="line"><span class="lineno"> 6310</span>            output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a70dd466fbfb5cfaaff8a0936766247f4">seamed_src_mesh</a>-&gt;data_maps = std::move(separated_src_mesh_fragments.begin()-&gt;second.front().second.data_maps);</div>
<div class="line"><span class="lineno"> 6311</span> </div>
<div class="line"><span class="lineno"> 6312</span>            <span class="keywordflow">if</span> (input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#acbacc55f2163529291e5a45671fed3d1">verbose</a>) {</div>
<div class="line"><span class="lineno"> 6313</span>                <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a9bb440c35b34b7ecd91a6ce4eca6941e">dump_mesh</a>(output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a70dd466fbfb5cfaaff8a0936766247f4">seamed_src_mesh</a>-&gt;mesh.get()[0], <span class="stringliteral">&quot;src-mesh-traced-poly&quot;</span>);</div>
<div class="line"><span class="lineno"> 6314</span>            }</div>
<div class="line"><span class="lineno"> 6315</span>        }</div>
<div class="line"><span class="lineno"> 6316</span>    } <span class="comment">// if (input.include_seam_srcmesh) {</span></div>
<div class="line"><span class="lineno"> 6317</span> </div>
<div class="line"><span class="lineno"> 6318</span>    <span class="comment">// dump traced cut-mesh polygons</span></div>
<div class="line"><span class="lineno"> 6319</span>    <span class="keywordflow">if</span> (input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#adc6ef77d23b46f2f9eec5c968e43c030">keep_cutmesh_seam</a>) {</div>
<div class="line"><span class="lineno"> 6320</span> </div>
<div class="line"><span class="lineno"> 6321</span>        <span class="comment">// bool all_cutpaths_linear_and_make_holes = (num_explicit_circular_cutpaths == 0) &amp;&amp; (explicit_cutpaths_severing_srcmesh.size() == 0);</span></div>
<div class="line"><span class="lineno"> 6322</span> </div>
<div class="line"><span class="lineno"> 6323</span>        <span class="keywordflow">if</span> (sm_is_watertight || (all_cutpaths_are_circular <span class="comment">/*|| all_cutpaths_linear_and_make_holes*/</span>)) {</div>
<div class="line"><span class="lineno"> 6324</span>            std::map&lt;std::size_t, std::vector&lt;std::pair&lt;std::shared_ptr&lt;hmesh_t&gt;, <a class="code hl_struct" href="../../dd/d24/kernel_8cpp.html#d7/dd7/structconnected__component__info__t">connected_component_info_t</a>&gt;&gt;&gt; separated_cut_mesh_fragments;</div>
<div class="line"><span class="lineno"> 6325</span>            std::unordered_map&lt;int, int&gt; _1;</div>
<div class="line"><span class="lineno"> 6326</span>            <a class="code hl_class" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> merged = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a34276907046e706af5626787b2e2b05a">extract_connected_components</a>(</div>
<div class="line"><span class="lineno"> 6327</span>#<span class="keywordflow">if</span> defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</div>
<div class="line"><span class="lineno"> 6328</span>                *input.scheduler,</div>
<div class="line"><span class="lineno"> 6329</span>#endif</div>
<div class="line"><span class="lineno"> 6330</span>                separated_cut_mesh_fragments,</div>
<div class="line"><span class="lineno"> 6331</span>                m0,</div>
<div class="line"><span class="lineno"> 6332</span>                traced_sm_polygon_count, <span class="comment">// offset to start of traced cut-mesh polygons in &quot;m0_polygons&quot;.</span></div>
<div class="line"><span class="lineno"> 6333</span>                std::vector&lt;traced_polygon_t&gt;(traced_cs_polygons_iter_cbegin, m0_polygons.cend()),</div>
<div class="line"><span class="lineno"> 6334</span>                std::vector&lt;int&gt;(),</div>
<div class="line"><span class="lineno"> 6335</span>                std::vector&lt;int&gt;(),</div>
<div class="line"><span class="lineno"> 6336</span>                m0_vertex_to_seam_flag,</div>
<div class="line"><span class="lineno"> 6337</span>                std::vector&lt;vd_t&gt;(), <span class="comment">// Unused ... because we are extracting from &quot;m0&quot;</span></div>
<div class="line"><span class="lineno"> 6338</span>                std::unordered_map&lt;vd_t, vd_t&gt;(), <span class="comment">// Unused ... because we are extracting from &quot;m0&quot;</span></div>
<div class="line"><span class="lineno"> 6339</span>                _1, <span class="comment">// Unused ... because we are extracting from &quot;m0&quot;</span></div>
<div class="line"><span class="lineno"> 6340</span>                m0_to_ps_vtx,</div>
<div class="line"><span class="lineno"> 6341</span>                m0_to_ps_face,</div>
<div class="line"><span class="lineno"> 6342</span>                ps_to_sm_vtx,</div>
<div class="line"><span class="lineno"> 6343</span>                ps_to_sm_face,</div>
<div class="line"><span class="lineno"> 6344</span>                ps_to_cm_vtx,</div>
<div class="line"><span class="lineno"> 6345</span>                ps_to_cm_face,</div>
<div class="line"><span class="lineno"> 6346</span>                sm_vtx_cnt,</div>
<div class="line"><span class="lineno"> 6347</span>                sm_face_count,</div>
<div class="line"><span class="lineno"> 6348</span>                input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a0b23c3ae4df4369125ff8b489a42260b">populate_vertex_maps</a>,</div>
<div class="line"><span class="lineno"> 6349</span>                input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8307155337693cbe5ebf0f61ea8ffd81">populate_face_maps</a>,</div>
<div class="line"><span class="lineno"> 6350</span>                <span class="keyword">false</span>, <span class="comment">// Unused ...</span></div>
<div class="line"><span class="lineno"> 6351</span>                <span class="keyword">false</span>, <span class="comment">// Unused ...</span></div>
<div class="line"><span class="lineno"> 6352</span>                <span class="keyword">false</span> <span class="comment">// Unused ...</span></div>
<div class="line"><span class="lineno"> 6353</span>            );</div>
<div class="line"><span class="lineno"> 6354</span> </div>
<div class="line"><span class="lineno"> 6355</span>            <span class="keywordflow">if</span> (separated_cut_mesh_fragments.size() == 1) { <span class="comment">// usual case</span></div>
<div class="line"><span class="lineno"> 6356</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(separated_cut_mesh_fragments.cbegin()-&gt;second.size() == 1); <span class="comment">// one instance</span></div>
<div class="line"><span class="lineno"> 6357</span>                output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a353f1f2c3cc7f006065052026878d7e2">seamed_cut_mesh</a> = std::shared_ptr&lt;output_mesh_info_t&gt;(<span class="keyword">new</span> <a class="code hl_struct" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#de/de4/structoutput__mesh__info__t">output_mesh_info_t</a>);</div>
<div class="line"><span class="lineno"> 6358</span>                output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a353f1f2c3cc7f006065052026878d7e2">seamed_cut_mesh</a>-&gt;mesh = (separated_cut_mesh_fragments.begin()-&gt;second.front().first);</div>
<div class="line"><span class="lineno"> 6359</span>                output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a353f1f2c3cc7f006065052026878d7e2">seamed_cut_mesh</a>-&gt;seam_vertices = std::move(separated_cut_mesh_fragments.begin()-&gt;second.front().second.seam_vertices);</div>
<div class="line"><span class="lineno"> 6360</span>                output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a353f1f2c3cc7f006065052026878d7e2">seamed_cut_mesh</a>-&gt;data_maps = std::move(separated_cut_mesh_fragments.begin()-&gt;second.front().second.data_maps);</div>
<div class="line"><span class="lineno"> 6361</span> </div>
<div class="line"><span class="lineno"> 6362</span>                <span class="keywordflow">if</span> (input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#acbacc55f2163529291e5a45671fed3d1">verbose</a>) {</div>
<div class="line"><span class="lineno"> 6363</span>                    <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a9bb440c35b34b7ecd91a6ce4eca6941e">dump_mesh</a>(output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a353f1f2c3cc7f006065052026878d7e2">seamed_cut_mesh</a>-&gt;mesh.get()[0], <span class="stringliteral">&quot;cut-mesh-traced-poly&quot;</span>);</div>
<div class="line"><span class="lineno"> 6364</span>                }</div>
<div class="line"><span class="lineno"> 6365</span>            }</div>
<div class="line"><span class="lineno"> 6366</span>        }</div>
<div class="line"><span class="lineno"> 6367</span>    } <span class="comment">// if (input.include_seam_srcmesh) {</span></div>
<div class="line"><span class="lineno"> 6368</span> </div>
<div class="line"><span class="lineno"> 6369</span>    <span class="keywordflow">if</span> (<span class="keyword">false</span> == (input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a07e9992982b4f9497d1499f1cfb2826d">keep_fragments_below_cutmesh</a> || <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6370</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#ababb18b60ba667267d374ba263e889af">keep_fragments_above_cutmesh</a> || <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6371</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a6558e59317164c8e7d141f2f8fce00b5">keep_fragments_partially_cut</a> || <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6372</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a2e0e9766f9dd9d594f607e107c855e26">keep_unsealed_fragments</a> || <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6373</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a4d23d907262b78c2d865f4d52bb65757">keep_fragments_sealed_inside</a> || <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6374</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#aff3651e310bd220d4f65bd450af94f16">keep_fragments_sealed_outside</a> || input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a18ab3e0c7ed366d45a0c1aaccddc4eee">keep_fragments_sealed_inside_exhaustive</a> || <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6375</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a719e59e63d8bf7d7c665f69d3213327b">keep_fragments_sealed_outside_exhaustive</a> || <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6376</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a69d05b5eabcaa02ad142e51104f16502">keep_inside_patches</a> || <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6377</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af5ee3a08c24f72b6d9f88a2a651159d1">keep_outside_patches</a>)) {</div>
<div class="line"><span class="lineno"> 6378</span>        <span class="comment">// if the user simply wants seams, then we should not have to proceed further.</span></div>
<div class="line"><span class="lineno"> 6379</span>        <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno"> 6380</span>    }</div>
<div class="line"><span class="lineno"> 6381</span> </div>
<div class="line"><span class="lineno"> 6383</span>    <span class="comment">// Map each halfedge to the traced polygons that uses it</span></div>
<div class="line"><span class="lineno"> 6385</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 6386</span>    <span class="comment">// We now need to manually maintain halfedge incidence (i.e. &quot;used-by&quot;) information since</span></div>
<div class="line"><span class="lineno"> 6387</span>    <span class="comment">// the traced-polygon connectivity is not stored inside our halfedge mesh data structure.</span></div>
<div class="line"><span class="lineno"> 6388</span>    <span class="comment">// A halfedge data structure would normally store such incidence information for us but this is</span></div>
<div class="line"><span class="lineno"> 6389</span>    <span class="comment">// no longer possible for reasons mentioned above (see long comment after tracing loop).</span></div>
<div class="line"><span class="lineno"> 6390</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6391</span>    <span class="comment">// So the first incidence information that we need to keep around is the mapping from every</span></div>
<div class="line"><span class="lineno"> 6392</span>    <span class="comment">// halfedge (in &quot;m0&quot;) which is used to trace a polygon, to the traced polygon(s) that uses</span></div>
<div class="line"><span class="lineno"> 6393</span>    <span class="comment">// that halfedge. Thus, halfedges which are not used for tracing [at all] have an entry in this</span></div>
<div class="line"><span class="lineno"> 6394</span>    <span class="comment">// vector but the value (std::vector) is empty. We will use this information later, like to</span></div>
<div class="line"><span class="lineno"> 6395</span>    <span class="comment">// stitch cut-mesh patches to src-mesh fragments.</span></div>
<div class="line"><span class="lineno"> 6396</span> </div>
<div class="line"><span class="lineno"> 6397</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Map halfedges to polygons&quot;</span>);</div>
<div class="line"><span class="lineno"> 6398</span>    <span class="comment">// std::map&lt;</span></div>
<div class="line"><span class="lineno"> 6399</span>    <span class="comment">//     hd_t,            // a halfedge that is used to trace a polygon</span></div>
<div class="line"><span class="lineno"> 6400</span>    <span class="comment">//    std::vector&lt;int&gt; // list of indices of  traced polygons that are traced with the halfedge</span></div>
<div class="line"><span class="lineno"> 6401</span>    <span class="comment">//    &gt;</span></div>
<div class="line"><span class="lineno"> 6402</span>    <span class="comment">//    m0_h_to_ply;</span></div>
<div class="line"><span class="lineno"> 6403</span>    std::vector&lt;std::vector&lt;int&gt;&gt; m0_h_to_ply(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a38154c743bff113eea931e14eaea6ddd">number_of_halfedges</a>());</div>
<div class="line"><span class="lineno"> 6404</span> </div>
<div class="line"><span class="lineno"> 6405</span>    <span class="comment">// for each traced polygon</span></div>
<div class="line"><span class="lineno"> 6406</span>    <span class="keywordflow">for</span> (std::vector&lt;traced_polygon_t&gt;::const_iterator traced_polygon_iter = m0_polygons.cbegin();</div>
<div class="line"><span class="lineno"> 6407</span>         traced_polygon_iter != m0_polygons.cend();</div>
<div class="line"><span class="lineno"> 6408</span>         ++traced_polygon_iter) {</div>
<div class="line"><span class="lineno"> 6409</span> </div>
<div class="line"><span class="lineno"> 6410</span>        <span class="keyword">const</span> <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a>&amp; traced_polygon = *traced_polygon_iter;</div>
<div class="line"><span class="lineno"> 6411</span>        <span class="keyword">const</span> <span class="keywordtype">int</span> traced_polygon_index = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)<a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(m0_polygons.cbegin(), traced_polygon_iter);</div>
<div class="line"><span class="lineno"> 6412</span> </div>
<div class="line"><span class="lineno"> 6413</span>        <span class="comment">// for each halfedge in polygon</span></div>
<div class="line"><span class="lineno"> 6414</span>        <span class="keywordflow">for</span> (traced_polygon_t::const_iterator traced_polygon_halfedge_iter = traced_polygon.cbegin();</div>
<div class="line"><span class="lineno"> 6415</span>             traced_polygon_halfedge_iter != traced_polygon.cend();</div>
<div class="line"><span class="lineno"> 6416</span>             ++traced_polygon_halfedge_iter) {</div>
<div class="line"><span class="lineno"> 6417</span> </div>
<div class="line"><span class="lineno"> 6418</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; traced_polygon_halfedge = *traced_polygon_halfedge_iter;</div>
<div class="line"><span class="lineno"> 6419</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 6420</span>                </div>
<div class="line"><span class="lineno"> 6421</span> </div>
<div class="line"><span class="lineno"> 6422</span>                std::pair&lt;std::map&lt;hd_t, std::vector&lt;int&gt;&gt;::iterator, <span class="keywordtype">bool</span>&gt; <a class="code hl_struct" href="../../df/de8/structpair.html">pair</a> = m0_h_to_ply.insert(std::make_pair(traced_polygon_halfedge, std::vector&lt;int&gt;()));</div>
<div class="line"><span class="lineno"> 6423</span> </div>
<div class="line"><span class="lineno"> 6424</span>                <span class="keywordflow">if</span> (<a class="code hl_struct" href="../../df/de8/structpair.html">pair</a>.second == <span class="keyword">false</span>) <span class="comment">// element exists (m0 halfedges (only interior ihalfedges) can be reused by more than one polygon. upto two polygons!)</span></div>
<div class="line"><span class="lineno"> 6425</span>                {</div>
<div class="line"><span class="lineno"> 6426</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(!<a class="code hl_struct" href="../../df/de8/structpair.html">pair</a>.first-&gt;second.empty());</div>
<div class="line"><span class="lineno"> 6427</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(std::find(<a class="code hl_struct" href="../../df/de8/structpair.html">pair</a>.first-&gt;second.cbegin(), <a class="code hl_struct" href="../../df/de8/structpair.html">pair</a>.first-&gt;second.cend(), traced_polygon_index) == <a class="code hl_struct" href="../../df/de8/structpair.html">pair</a>.first-&gt;second.cend());</div>
<div class="line"><span class="lineno"> 6428</span>                }</div>
<div class="line"><span class="lineno"> 6429</span> </div>
<div class="line"><span class="lineno"> 6430</span>                <a class="code hl_struct" href="../../df/de8/structpair.html">pair</a>.first-&gt;second.push_back(traced_polygon_index);</div>
<div class="line"><span class="lineno"> 6431</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(<a class="code hl_struct" href="../../df/de8/structpair.html">pair</a>.first-&gt;second.size() &lt;= 2);</div>
<div class="line"><span class="lineno"> 6432</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno"> 6433</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, traced_polygon_halfedge).push_back(traced_polygon_index);</div>
<div class="line"><span class="lineno"> 6434</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, traced_polygon_halfedge).<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a809275ccd755fb7b88661d952134b14d">size</a>() &lt;= 2);</div>
<div class="line"><span class="lineno"> 6435</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 6436</span>        }</div>
<div class="line"><span class="lineno"> 6437</span>    }</div>
<div class="line"><span class="lineno"> 6438</span> </div>
<div class="line"><span class="lineno"> 6439</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 6440</span>    <span class="comment">// dump</span></div>
<div class="line"><span class="lineno"> 6441</span>    <span class="keywordflow">for</span> (std::map&lt;<a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>, std::vector&lt;int&gt;&gt;::const_iterator i = m0_h_to_ply.cbegin(); i != m0_h_to_ply.cend(); ++i) {</div>
<div class="line"><span class="lineno"> 6442</span>        </div>
<div class="line"><span class="lineno"> 6443</span>        <span class="keywordflow">for</span> (std::vector&lt;int&gt;::const_iterator j = i-&gt;second.cbegin(); j != i-&gt;second.cend(); ++j) {</div>
<div class="line"><span class="lineno"> 6444</span>            </div>
<div class="line"><span class="lineno"> 6445</span>            </div>
<div class="line"><span class="lineno"> 6446</span>            </div>
<div class="line"><span class="lineno"> 6447</span>        }</div>
<div class="line"><span class="lineno"> 6448</span>        </div>
<div class="line"><span class="lineno"> 6449</span>    }</div>
<div class="line"><span class="lineno"> 6450</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 6451</span> </div>
<div class="line"><span class="lineno"> 6452</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 6453</span> </div>
<div class="line"><span class="lineno"> 6454</span>    <span class="comment">// bool all_cutpaths_make_holes = ((int)explicit_cutpaths_making_holes.size() == num_explicit_cutpath_sequences);</span></div>
<div class="line"><span class="lineno"> 6455</span> </div>
<div class="line"><span class="lineno"> 6456</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Find exterior cut-mesh polygons&quot;</span>);</div>
<div class="line"><span class="lineno"> 6458</span>    <span class="comment">// Find all cut-mesh polygons which are &quot;exterior&quot; relative to the source-mesh</span></div>
<div class="line"><span class="lineno"> 6460</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 6461</span>    <span class="comment">// Here we will explicitly find a subset of the traced cut-mesh polygons which lie</span></div>
<div class="line"><span class="lineno"> 6462</span>    <span class="comment">// outside/exterior w.r.t the source-mesh. We find these polygons using the</span></div>
<div class="line"><span class="lineno"> 6463</span>    <span class="comment">// &quot;re-entrant&quot; vertices that where identified while calculating intersection</span></div>
<div class="line"><span class="lineno"> 6464</span>    <span class="comment">// points. These will be used (later) to mark cut-mesh patches as either interior</span></div>
<div class="line"><span class="lineno"> 6465</span>    <span class="comment">// or exterior w.r.t the source-mesh.</span></div>
<div class="line"><span class="lineno"> 6466</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6467</span>    <span class="comment">// Note that these polygons will be the new &quot;child polygons&quot; which are new as a result of</span></div>
<div class="line"><span class="lineno"> 6468</span>    <span class="comment">// the intersections.</span></div>
<div class="line"><span class="lineno"> 6469</span> </div>
<div class="line"><span class="lineno"> 6470</span>    <span class="comment">// An element here represents the index of an exterior cut-mesh polygon, and the index of</span></div>
<div class="line"><span class="lineno"> 6471</span>    <span class="comment">// halfedge which touches the source-mesh and points torward the interior (inside) of the src-mesh.</span></div>
<div class="line"><span class="lineno"> 6472</span>    std::unordered_map&lt;<span class="keywordtype">int</span> <span class="comment">/*m0 cs poly*/</span>, <span class="keywordtype">int</span> <span class="comment">/*he idx*/</span>&gt; known_exterior_cm_polygons;</div>
<div class="line"><span class="lineno"> 6473</span> </div>
<div class="line"><span class="lineno"> 6474</span>    <span class="keywordflow">if</span> (explicit_cutpaths_making_holes.size() &gt; 0) { <span class="comment">// atleast one cut-path makes a hole to be sealed later</span></div>
<div class="line"><span class="lineno"> 6475</span> </div>
<div class="line"><span class="lineno"> 6476</span>        <span class="comment">// for each traced cut-mesh polygon</span></div>
<div class="line"><span class="lineno"> 6477</span> </div>
<div class="line"><span class="lineno"> 6478</span>        <span class="keywordflow">for</span> (std::vector&lt;int&gt;::const_iterator cs_ipoly_iter = m0_cm_cutpath_adjacent_polygons.cbegin();</div>
<div class="line"><span class="lineno"> 6479</span>             cs_ipoly_iter != m0_cm_cutpath_adjacent_polygons.cend();</div>
<div class="line"><span class="lineno"> 6480</span>             ++cs_ipoly_iter) {</div>
<div class="line"><span class="lineno"> 6481</span>            <span class="comment">// for (std::vector&lt;traced_polygon_t&gt;::const_iterator cs_poly_iter = traced_cs_polygons_iter_cbegin;</span></div>
<div class="line"><span class="lineno"> 6482</span>            <span class="comment">//      cs_poly_iter != m0_polygons.cend();</span></div>
<div class="line"><span class="lineno"> 6483</span>            <span class="comment">//      ++cs_poly_iter) {</span></div>
<div class="line"><span class="lineno"> 6484</span> </div>
<div class="line"><span class="lineno"> 6485</span>            <span class="comment">// const traced_polygon_t&amp; cs_poly = *cs_poly_iter;</span></div>
<div class="line"><span class="lineno"> 6486</span>            <span class="comment">// const int cs_poly_idx = (int)std::distance(m0_polygons.cbegin(), cs_poly_iter);</span></div>
<div class="line"><span class="lineno"> 6487</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> cs_poly_idx = *cs_ipoly_iter;</div>
<div class="line"><span class="lineno"> 6488</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(cs_poly_idx &lt; (<span class="keywordtype">int</span>)m0_polygons.size());</div>
<div class="line"><span class="lineno"> 6489</span> </div>
<div class="line"><span class="lineno"> 6490</span>            <span class="keywordflow">if</span> (known_exterior_cm_polygons.find(cs_poly_idx) != known_exterior_cm_polygons.cend()) {</div>
<div class="line"><span class="lineno"> 6491</span>                <span class="keywordflow">continue</span>; <span class="comment">// we have already tagged the polygon as being exterior!</span></div>
<div class="line"><span class="lineno"> 6492</span>            }</div>
<div class="line"><span class="lineno"> 6493</span> </div>
<div class="line"><span class="lineno"> 6494</span>            <span class="keyword">const</span> <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a>&amp; cs_poly = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_polygons, cs_poly_idx);</div>
<div class="line"><span class="lineno"> 6495</span> </div>
<div class="line"><span class="lineno"> 6496</span>            <span class="comment">// for each halfedge of polygon</span></div>
<div class="line"><span class="lineno"> 6497</span>            <span class="keywordflow">for</span> (traced_polygon_t::const_iterator cs_poly_he_iter = cs_poly.cbegin();</div>
<div class="line"><span class="lineno"> 6498</span>                 cs_poly_he_iter != cs_poly.cend();</div>
<div class="line"><span class="lineno"> 6499</span>                 ++cs_poly_he_iter) {</div>
<div class="line"><span class="lineno"> 6500</span> </div>
<div class="line"><span class="lineno"> 6501</span>                <span class="comment">// we want to use class-1 ihalfedges : o--&gt;x. This type of halfedge was the</span></div>
<div class="line"><span class="lineno"> 6502</span>                <span class="comment">// one used to calculate re-entrant vertices</span></div>
<div class="line"><span class="lineno"> 6503</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; cs_poly_he = *cs_poly_he_iter;</div>
<div class="line"><span class="lineno"> 6504</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> cs_poly_he_src = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(cs_poly_he);</div>
<div class="line"><span class="lineno"> 6505</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> cs_poly_he_tgt = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(cs_poly_he);</div>
<div class="line"><span class="lineno"> 6506</span>                <span class="keyword">const</span> <span class="keywordtype">bool</span> tgt_is_ivertex = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(cs_poly_he_tgt, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 6507</span>                <span class="keyword">const</span> <span class="keywordtype">bool</span> src_is_ivertex = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(cs_poly_he_src, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 6508</span> </div>
<div class="line"><span class="lineno"> 6509</span>                <span class="keywordflow">if</span> (!tgt_is_ivertex) {</div>
<div class="line"><span class="lineno"> 6510</span>                    <span class="keywordflow">continue</span>; <span class="comment">// either class-0 or class-2</span></div>
<div class="line"><span class="lineno"> 6511</span>                }</div>
<div class="line"><span class="lineno"> 6512</span> </div>
<div class="line"><span class="lineno"> 6513</span>                <span class="comment">// check that the target vertex is along a cut-path making a hole</span></div>
<div class="line"><span class="lineno"> 6514</span>                <span class="keyword">const</span> <span class="keywordtype">int</span> tgt_explicit_cutpath_sequence_idx = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_cutpath_sequence, cs_poly_he_tgt);</div>
<div class="line"><span class="lineno"> 6515</span>                <span class="keywordtype">bool</span> cutpath_makes_a_hole = std::find(explicit_cutpaths_making_holes.cbegin(),</div>
<div class="line"><span class="lineno"> 6516</span>                                                explicit_cutpaths_making_holes.cend(),</div>
<div class="line"><span class="lineno"> 6517</span>                                                tgt_explicit_cutpath_sequence_idx)</div>
<div class="line"><span class="lineno"> 6518</span>                    != explicit_cutpaths_making_holes.cend();</div>
<div class="line"><span class="lineno"> 6519</span> </div>
<div class="line"><span class="lineno"> 6520</span>                <span class="keywordflow">if</span> (cutpath_makes_a_hole == <span class="keyword">false</span>) {</div>
<div class="line"><span class="lineno"> 6521</span>                    <span class="comment">// skip because the patch of the curent polygon will not be used</span></div>
<div class="line"><span class="lineno"> 6522</span>                    <span class="comment">// for sealing/stitching holes. Thus, there is no need to tag the</span></div>
<div class="line"><span class="lineno"> 6523</span>                    <span class="comment">// polygon as being either interior or exterior. That is, its</span></div>
<div class="line"><span class="lineno"> 6524</span>                    <span class="comment">// adjacent cutpath does not make a hole!</span></div>
<div class="line"><span class="lineno"> 6525</span>                    <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 6526</span>                }</div>
<div class="line"><span class="lineno"> 6527</span> </div>
<div class="line"><span class="lineno"> 6528</span>                <span class="comment">// get the intersection info which was calculated earlier (src-mesh normal vector )</span></div>
<div class="line"><span class="lineno"> 6529</span>                <span class="comment">// NOTE: this is exactly the same numerical calculation that was computed previously.</span></div>
<div class="line"><span class="lineno"> 6530</span>                <span class="comment">// const std::map&lt;vd_t, vec3&gt;::const_iterator cs_nonborder_reentrant_ivertices_find_iter = cm_nonborder_reentrant_ivtx_list.find(cs_poly_he_tgt);</span></div>
<div class="line"><span class="lineno"> 6531</span>                <span class="comment">// const bool tgt_is_nonborder_reentrant_vertex = cs_nonborder_reentrant_ivertices_find_iter != cm_nonborder_reentrant_ivtx_list.cend();</span></div>
<div class="line"><span class="lineno"> 6532</span>                <span class="comment">// std::vector&lt;vd_t&gt;::const_iterator border_reentrant_vertex_find_iter = std::find(cm_border_reentrant_ivtx_list.cbegin(), cm_border_reentrant_ivtx_list.cend(), cs_poly_he_tgt);</span></div>
<div class="line"><span class="lineno"> 6533</span>                <span class="comment">// const bool tgt_is_border_reentrant_vertex = border_reentrant_vertex_find_iter != cm_border_reentrant_ivtx_list.cend();</span></div>
<div class="line"><span class="lineno"> 6534</span> </div>
<div class="line"><span class="lineno"> 6535</span>                <span class="comment">// MCUT_ASSERT(!(tgt_is_nonborder_reentrant_vertex &amp;&amp; tgt_is_border_reentrant_vertex)); // a re-entrant vertex cannot be both a border and norborder</span></div>
<div class="line"><span class="lineno"> 6536</span> </div>
<div class="line"><span class="lineno"> 6537</span>                <span class="comment">// if (!tgt_is_nonborder_reentrant_vertex &amp;&amp; !tgt_is_border_reentrant_vertex) {</span></div>
<div class="line"><span class="lineno"> 6538</span>                <span class="comment">//     continue; // cs_poly_he_tgt is an ivertex but it is not a nonborder re-entrant vertex ( was not saved as one)</span></div>
<div class="line"><span class="lineno"> 6539</span>                <span class="comment">// }</span></div>
<div class="line"><span class="lineno"> 6540</span> </div>
<div class="line"><span class="lineno"> 6541</span>                <span class="comment">// o--&gt;x : We want the intersection halfedges which point &quot;into&quot; the source-mesh, i.e. whose tgt is on</span></div>
<div class="line"><span class="lineno"> 6542</span>                <span class="comment">// the source-mesh face of tgt (found in the registry entry). This implies that the current</span></div>
<div class="line"><span class="lineno"> 6543</span>                <span class="comment">// cut-mesh halfedge must have an opposite direction w.r.t the normal of the src-mesh face.</span></div>
<div class="line"><span class="lineno"> 6544</span>                <span class="keyword">const</span> <span class="keywordtype">bool</span> is_ox = (!src_is_ivertex &amp;&amp; tgt_is_ivertex);</div>
<div class="line"><span class="lineno"> 6545</span>                <span class="keywordtype">bool</span> is_boundary_ih = <span class="keyword">false</span>; <span class="comment">// i.e. is and intersecting halfedge</span></div>
<div class="line"><span class="lineno"> 6546</span> </div>
<div class="line"><span class="lineno"> 6547</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)cs_poly_he_tgt - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/* m0_ivtx_to_intersection_registry_entry.find(cs_poly_he_tgt) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 6548</span>                <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt;&amp; cs_poly_he_tgt_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, (std::size_t)cs_poly_he_tgt - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 6549</span> </div>
<div class="line"><span class="lineno"> 6550</span>                <span class="keywordflow">if</span> (src_is_ivertex &amp;&amp; tgt_is_ivertex) {</div>
<div class="line"><span class="lineno"> 6551</span>                    <span class="comment">// const hd_t src_coincident_ps_halfedge = SAFE_ACCESS(m0_ivtx_to_ps_edge, m0.source(cs_poly_he));</span></div>
<div class="line"><span class="lineno"> 6552</span>                    <span class="comment">//  const hd_t tgt_ps_h = SAFE_ACCESS(m0_ivtx_to_ps_edge, m0.target(cs_poly_he));</span></div>
<div class="line"><span class="lineno"> 6553</span>                    <span class="comment">// const ed_t src_ps_edge = SAFE_ACCESS(m0_ivtx_to_ps_edge, m0.source(cs_poly_he)); // ps.edge(src_coincident_ps_halfedge);</span></div>
<div class="line"><span class="lineno"> 6554</span>                    <span class="comment">// const ed_t tgt_ps_edge = SAFE_ACCESS(m0_ivtx_to_ps_edge, m0.target(cs_poly_he)); // ps.edge(tgt_ps_h);</span></div>
<div class="line"><span class="lineno"> 6555</span> </div>
<div class="line"><span class="lineno"> 6556</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)cs_poly_he_src - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/* m0_ivtx_to_intersection_registry_entry.find(cs_poly_he_src) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 6557</span>                    <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt;&amp; cs_poly_he_src_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, (std::size_t)cs_poly_he_src - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 6558</span> </div>
<div class="line"><span class="lineno"> 6559</span>                    is_boundary_ih = (cs_poly_he_src_ipair.first == cs_poly_he_tgt_ipair.first);</div>
<div class="line"><span class="lineno"> 6560</span>                }</div>
<div class="line"><span class="lineno"> 6561</span> </div>
<div class="line"><span class="lineno"> 6562</span>                <span class="keywordflow">if</span> (!(is_ox || is_boundary_ih)) {</div>
<div class="line"><span class="lineno"> 6563</span>                    <span class="keywordflow">continue</span>; <span class="comment">// is interior-ihalfedge</span></div>
<div class="line"><span class="lineno"> 6564</span>                }</div>
<div class="line"><span class="lineno"> 6565</span> </div>
<div class="line"><span class="lineno"> 6566</span>                <span class="comment">// if tgt is a border re-entrant vertex then the polygon is (by definition) on the border</span></div>
<div class="line"><span class="lineno"> 6567</span>                <span class="comment">// given the properties of a border re-entrant vertex. Basically, this is due to the</span></div>
<div class="line"><span class="lineno"> 6568</span>                <span class="comment">// type of halfedge that we are looking for and the fact that border re-entrant vertices</span></div>
<div class="line"><span class="lineno"> 6569</span>                <span class="comment">// occur only on the border of the cut-mesh.</span></div>
<div class="line"><span class="lineno"> 6570</span>                <span class="comment">// bool is_border_polygon = tgt_is_border_reentrant_vertex;</span></div>
<div class="line"><span class="lineno"> 6571</span> </div>
<div class="line"><span class="lineno"> 6572</span>                <span class="comment">// if (!is_border_polygon &amp;&amp; tgt_is_nonborder_reentrant_vertex) {</span></div>
<div class="line"><span class="lineno"> 6573</span>                <span class="comment">//  Re-calculate the geometry operation as as we did before we calculated the</span></div>
<div class="line"><span class="lineno"> 6574</span>                <span class="comment">//  tgt-ivertex (i.e. with scalar product) using the halfedge&#39;s src and tgt</span></div>
<div class="line"><span class="lineno"> 6575</span>                <span class="comment">//  coordinates and the normal of the face which was intersected to produce</span></div>
<div class="line"><span class="lineno"> 6576</span>                <span class="comment">//  the tgt vertex.</span></div>
<div class="line"><span class="lineno"> 6577</span>                <span class="comment">// const vec3&amp; polygon_normal = cs_nonborder_reentrant_ivertices_find_iter-&gt;second;</span></div>
<div class="line"><span class="lineno"> 6578</span>                <span class="comment">// MCUT_ASSERT(m0_ivtx_to_tested_polygon_normal.find(cs_poly_he_tgt) != m0_ivtx_to_tested_polygon_normal.cend());</span></div>
<div class="line"><span class="lineno"> 6579</span> </div>
<div class="line"><span class="lineno"> 6580</span>                <span class="comment">// get the registry entry edge</span></div>
<div class="line"><span class="lineno"> 6581</span> </div>
<div class="line"><span class="lineno"> 6582</span>                <span class="comment">// const std::vector&lt;fd_t&gt; set_edge0_v0_registry = ps_get_ivtx_registry_entry_faces(ps, set_edge0_v0_ipair);</span></div>
<div class="line"><span class="lineno"> 6583</span>                <span class="comment">// const ed_t&amp; registry_entry_edge = cs_poly_he_tgt_ipair.first; // SAFE_ACCESS(m0_ivtx_to_ps_edge, cs_poly_he_tgt);</span></div>
<div class="line"><span class="lineno"> 6584</span>                <span class="comment">//  get registry entry faces</span></div>
<div class="line"><span class="lineno"> 6585</span> </div>
<div class="line"><span class="lineno"> 6586</span>                <span class="comment">// const std::vector&lt;fd_t&gt;&amp; registry_entry_faces = SAFE_ACCESS(m0_ivtx_to_ps_faces, cs_poly_he_tgt);</span></div>
<div class="line"><span class="lineno"> 6587</span>                <span class="keyword">const</span> std::vector&lt;fd_t&gt; registry_entry_faces = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#abcaa230eb10486e26a5167bae360d451">ps_get_ivtx_registry_entry_faces</a>(ps, cs_poly_he_tgt_ipair);</div>
<div class="line"><span class="lineno"> 6588</span> </div>
<div class="line"><span class="lineno"> 6589</span>                <span class="comment">// get the registry-entry face which is not incident to edge</span></div>
<div class="line"><span class="lineno"> 6590</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> registry_entry_edge_v0 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(cs_poly_he_tgt_ipair.first, 0);</div>
<div class="line"><span class="lineno"> 6591</span>                std::vector&lt;fd_t&gt;::const_iterator tested_face; <span class="comment">// which was intersected by &quot;registry_entry_edge&quot; to get &quot;cs_poly_he_tgt&quot;</span></div>
<div class="line"><span class="lineno"> 6592</span>                <span class="keywordtype">bool</span> registry_entry_edge_is_from_cutmesh = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a426849b7f7105963c5e2767bdd31b155">ps_is_cutmesh_vertex</a>(registry_entry_edge_v0, sm_vtx_cnt);</div>
<div class="line"><span class="lineno"> 6593</span>                <span class="keywordflow">if</span> (registry_entry_edge_is_from_cutmesh) {</div>
<div class="line"><span class="lineno"> 6594</span>                    <span class="comment">// ... then intersected face was from the source mesh</span></div>
<div class="line"><span class="lineno"> 6595</span>                    tested_face = std::find_if(registry_entry_faces.cbegin(), registry_entry_faces.cend(),</div>
<div class="line"><span class="lineno"> 6596</span>                        [&amp;](<span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a>&amp; f) {</div>
<div class="line"><span class="lineno"> 6597</span>                            bool is_sm_face = !ps_is_cutmesh_face(f, sm_face_count) &amp;&amp; f != hmesh_t::null_face();</div>
<div class="line"><span class="lineno"> 6598</span>                            return is_sm_face;</div>
<div class="line"><span class="lineno"> 6599</span>                        });</div>
<div class="line"><span class="lineno"> 6600</span>                } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 6601</span>                    <span class="comment">// ... then intersected face was from the cut mesh</span></div>
<div class="line"><span class="lineno"> 6602</span>                    tested_face = std::find_if(registry_entry_faces.cbegin(), registry_entry_faces.cend(),</div>
<div class="line"><span class="lineno"> 6603</span>                        [&amp;](<span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a>&amp; f) {</div>
<div class="line"><span class="lineno"> 6604</span>                            bool is_cm_face = ps_is_cutmesh_face(f, sm_face_count) &amp;&amp; f != hmesh_t::null_face();</div>
<div class="line"><span class="lineno"> 6605</span>                            return is_cm_face;</div>
<div class="line"><span class="lineno"> 6606</span>                        });</div>
<div class="line"><span class="lineno"> 6607</span>                }</div>
<div class="line"><span class="lineno"> 6608</span> </div>
<div class="line"><span class="lineno"> 6609</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(tested_face != registry_entry_faces.cend()); <span class="comment">// &quot;registry_entry_faces&quot; must have at least one face from cm and at least one from sm</span></div>
<div class="line"><span class="lineno"> 6610</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ps_tested_face_to_plane_normal.find(*tested_face) != ps_tested_face_to_plane_normal.cend());</div>
<div class="line"><span class="lineno"> 6611</span> </div>
<div class="line"><span class="lineno"> 6612</span>                <span class="comment">// get normal of face</span></div>
<div class="line"><span class="lineno"> 6613</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a>&amp; polygon_normal = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_tested_face_to_plane_normal, *tested_face); <span class="comment">// SAFE_ACCESS(m0_ivtx_to_tested_polygon_normal, cs_poly_he_tgt);</span></div>
<div class="line"><span class="lineno"> 6614</span>                <span class="comment">// const vec3&amp; polygon_normal = geometric_data.first; // source-mesh face normal</span></div>
<div class="line"><span class="lineno"> 6615</span>                <span class="comment">// const double&amp; orig_scalar_prod = geometric_data.second; // the dot product result we computed earlier</span></div>
<div class="line"><span class="lineno"> 6616</span> </div>
<div class="line"><span class="lineno"> 6617</span>                <span class="comment">// MCUT_ASSERT(sign(orig_scalar_prod) == NEGATIVE);</span></div>
<div class="line"><span class="lineno"> 6618</span> </div>
<div class="line"><span class="lineno"> 6619</span>                <span class="comment">// calculate the vector represented by the current halfedge</span></div>
<div class="line"><span class="lineno"> 6620</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a> cs_poly_he_vector = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(cs_poly_he_tgt) - m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(cs_poly_he_src);</div>
<div class="line"><span class="lineno"> 6621</span>                <span class="comment">// calculate dot product with the src-mesh normal</span></div>
<div class="line"><span class="lineno"> 6622</span>                <span class="keyword">const</span> <span class="keywordtype">double</span> scalar_prod = <a class="code hl_function" href="../../df/db1/math_8h.html#a0b6cff67f1f57a1096b42782cf5397da">dot_product</a>(polygon_normal, cs_poly_he_vector);</div>
<div class="line"><span class="lineno"> 6623</span>                <span class="comment">// the original ps-halfedge was &quot;incoming&quot; (pointing inwards) and gave a</span></div>
<div class="line"><span class="lineno"> 6624</span>                <span class="comment">// negative scalar-product with the src-mesh face normal.</span></div>
<div class="line"><span class="lineno"> 6625</span>                <span class="comment">// check that it is the same</span></div>
<div class="line"><span class="lineno"> 6626</span>                <span class="comment">// Note: we want the same sign (i.e. cs_poly_he_vector has negative scalar-product)</span></div>
<div class="line"><span class="lineno"> 6627</span>                <span class="comment">// because we want the class-1 ihalfedge which is exterior but points inside the src-mesh</span></div>
<div class="line"><span class="lineno"> 6628</span>                <span class="comment">// is_border_polygon = (sign(scalar_prod) == NEGATIVE);</span></div>
<div class="line"><span class="lineno"> 6629</span>                <span class="comment">//}</span></div>
<div class="line"><span class="lineno"> 6630</span> </div>
<div class="line"><span class="lineno"> 6631</span>                <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d4/df0/_array_cwise_unary_ops_8h.html#a281eccb624a3ff6dacbe305828e43a82">sign</a>(scalar_prod) == <a class="code hl_enumvalue" href="../../df/db1/math_8h.html#a6912657a051f0b1fc01a0d3095158b43a62d66a51fa7574c652597716f7709865">NEGATIVE</a>) { <span class="comment">// the current halfedge passed the sign test</span></div>
<div class="line"><span class="lineno"> 6632</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(known_exterior_cm_polygons.find(cs_poly_idx) == known_exterior_cm_polygons.cend());</div>
<div class="line"><span class="lineno"> 6633</span>                    known_exterior_cm_polygons[cs_poly_idx] = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)<a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(cs_poly.cbegin(), cs_poly_he_iter);</div>
<div class="line"><span class="lineno"> 6634</span>                    <span class="keywordflow">break</span>; <span class="comment">// done, we now know &quot;cs_poly_idx&quot; as an exterior polygon</span></div>
<div class="line"><span class="lineno"> 6635</span>                }</div>
<div class="line"><span class="lineno"> 6636</span>            }</div>
<div class="line"><span class="lineno"> 6637</span>        }</div>
<div class="line"><span class="lineno"> 6638</span>    }</div>
<div class="line"><span class="lineno"> 6639</span> </div>
<div class="line"><span class="lineno"> 6640</span>    <span class="comment">// cm_nonborder_reentrant_ivtx_list.clear(); // free</span></div>
<div class="line"><span class="lineno"> 6641</span>    m0_ivtx_to_cutpath_sequence.clear(); <span class="comment">// free</span></div>
<div class="line"><span class="lineno"> 6642</span> </div>
<div class="line"><span class="lineno"> 6643</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 6644</span> </div>
<div class="line"><span class="lineno"> 6645</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Find source mesh polygon above and below cm&quot;</span>);</div>
<div class="line"><span class="lineno"> 6647</span>    <span class="comment">// Find the source-mesh polygons (next to cutpath) which are above and below</span></div>
<div class="line"><span class="lineno"> 6649</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 6650</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6651</span>    <span class="comment">// We are searching through all of the traced source-mesh polygons to find those</span></div>
<div class="line"><span class="lineno"> 6652</span>    <span class="comment">// which are adjacent to the cut path. We then identify them as being either</span></div>
<div class="line"><span class="lineno"> 6653</span>    <span class="comment">// &quot;above&quot; or &quot;below&quot; the cut-mesh which we do using the source-mesh re-entrant</span></div>
<div class="line"><span class="lineno"> 6654</span>    <span class="comment">// vertices.</span></div>
<div class="line"><span class="lineno"> 6655</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6656</span> </div>
<div class="line"><span class="lineno"> 6657</span>    std::vector&lt;int&gt; sm_polygons_below_cs;</div>
<div class="line"><span class="lineno"> 6658</span>    std::vector&lt;int&gt; sm_polygons_above_cs;</div>
<div class="line"><span class="lineno"> 6659</span> </div>
<div class="line"><span class="lineno"> 6660</span>    <span class="comment">// for each traced source-mesh polygon along cutpath</span></div>
<div class="line"><span class="lineno"> 6661</span>    <span class="keywordflow">for</span> (std::vector&lt;int&gt;::const_iterator sm_ipoly_iter = m0_sm_cutpath_adjacent_polygons.cbegin();</div>
<div class="line"><span class="lineno"> 6662</span>         sm_ipoly_iter != m0_sm_cutpath_adjacent_polygons.cend();</div>
<div class="line"><span class="lineno"> 6663</span>         ++sm_ipoly_iter) {</div>
<div class="line"><span class="lineno"> 6664</span>        <span class="comment">// for (std::vector&lt;traced_polygon_t&gt;::const_iterator sm_poly_iter = m0_polygons.cbegin();</span></div>
<div class="line"><span class="lineno"> 6665</span>        <span class="comment">//    sm_poly_iter != traced_sm_polygons_iter_end;</span></div>
<div class="line"><span class="lineno"> 6666</span>        <span class="comment">//  ++sm_poly_iter) {</span></div>
<div class="line"><span class="lineno"> 6667</span>        <span class="comment">// const traced_polygon_t&amp; sm_poly = *sm_poly_iter;</span></div>
<div class="line"><span class="lineno"> 6668</span>        <span class="comment">// const int sm_poly_idx = (int)std::distance(m0_polygons.cbegin(), sm_poly_iter);</span></div>
<div class="line"><span class="lineno"> 6669</span>        <span class="keyword">const</span> <span class="keywordtype">int</span> sm_poly_idx = *sm_ipoly_iter;</div>
<div class="line"><span class="lineno"> 6670</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(sm_poly_idx &lt; (<span class="keywordtype">int</span>)m0_polygons.size());</div>
<div class="line"><span class="lineno"> 6671</span>        <span class="keyword">const</span> <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a>&amp; sm_poly = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_polygons, sm_poly_idx);</div>
<div class="line"><span class="lineno"> 6672</span> </div>
<div class="line"><span class="lineno"> 6673</span>        <span class="comment">// for each halfedge of polygon</span></div>
<div class="line"><span class="lineno"> 6674</span>        <span class="keywordflow">for</span> (traced_polygon_t::const_iterator sm_poly_he_iter = sm_poly.cbegin();</div>
<div class="line"><span class="lineno"> 6675</span>             sm_poly_he_iter != sm_poly.cend();</div>
<div class="line"><span class="lineno"> 6676</span>             ++sm_poly_he_iter) {</div>
<div class="line"><span class="lineno"> 6677</span> </div>
<div class="line"><span class="lineno"> 6678</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; sm_poly_he = *sm_poly_he_iter; <span class="comment">// we want class-1 ihalfedges : o--&gt;x</span></div>
<div class="line"><span class="lineno"> 6679</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> sm_poly_he_src = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(sm_poly_he);</div>
<div class="line"><span class="lineno"> 6680</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> sm_poly_he_tgt = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(sm_poly_he);</div>
<div class="line"><span class="lineno"> 6681</span>            <span class="keyword">const</span> <span class="keywordtype">bool</span> tgt_is_ivertex = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(sm_poly_he_tgt, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 6682</span>            <span class="keyword">const</span> <span class="keywordtype">bool</span> src_is_ivertex = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(sm_poly_he_src, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 6683</span> </div>
<div class="line"><span class="lineno"> 6684</span>            <span class="keywordflow">if</span> (!tgt_is_ivertex) {</div>
<div class="line"><span class="lineno"> 6685</span>                <span class="keywordflow">continue</span>; <span class="comment">// either class-0 (o--&gt;o) or class-2 (x--&gt;o)</span></div>
<div class="line"><span class="lineno"> 6686</span>            }</div>
<div class="line"><span class="lineno"> 6687</span> </div>
<div class="line"><span class="lineno"> 6688</span>            <span class="comment">// const std::map&lt;vd_t, vec3&gt;::const_iterator sm_nonborder_reentrant_ivertices_find_iter = sm_nonborder_reentrant_ivtx_list.find(sm_poly_he_tgt);</span></div>
<div class="line"><span class="lineno"> 6689</span>            <span class="comment">// const bool tgt_is_sm_nonborder_reentrant_vertex = sm_nonborder_reentrant_ivertices_find_iter != sm_nonborder_reentrant_ivtx_list.cend();</span></div>
<div class="line"><span class="lineno"> 6690</span> </div>
<div class="line"><span class="lineno"> 6691</span>            <span class="comment">// NOTE: we do not need source-mesh border re-entrant vertices because they are not useful for the</span></div>
<div class="line"><span class="lineno"> 6692</span>            <span class="comment">// determining whether traced source-mesh polygons are either &quot;above&quot; or &quot;below&quot; the cut-mesh. The notion</span></div>
<div class="line"><span class="lineno"> 6693</span>            <span class="comment">// of above or below is defined only for source-mesh fragements w.r.t. the cut-mesh. The is because</span></div>
<div class="line"><span class="lineno"> 6694</span>            <span class="comment">// we are only interested in partitioning the source-mesh and not the cut-mesh</span></div>
<div class="line"><span class="lineno"> 6695</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6696</span> </div>
<div class="line"><span class="lineno"> 6697</span>            <span class="comment">// if (!tgt_is_sm_nonborder_reentrant_vertex) {</span></div>
<div class="line"><span class="lineno"> 6698</span>            <span class="comment">//    continue; // cs_poly_he_tgt is an ivertex but it is not a regular re-entrant vertex</span></div>
<div class="line"><span class="lineno"> 6699</span>            <span class="comment">// }</span></div>
<div class="line"><span class="lineno"> 6700</span> </div>
<div class="line"><span class="lineno"> 6701</span>            <span class="comment">// o--&gt;x : We want the intersection halfedges which point into the cut-mesh and whose tgt lays on the cut-mesh face of tgt</span></div>
<div class="line"><span class="lineno"> 6702</span>            <span class="comment">// (they have an opposite direction wrt the face normal)</span></div>
<div class="line"><span class="lineno"> 6703</span>            <span class="keyword">const</span> <span class="keywordtype">bool</span> is_ox = (!src_is_ivertex &amp;&amp; tgt_is_ivertex);</div>
<div class="line"><span class="lineno"> 6704</span> </div>
<div class="line"><span class="lineno"> 6705</span>            <span class="keyword">const</span> <span class="keywordtype">bool</span> is_boundary_halfedge = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#ad0e7884ca4d03bad54f0f83d198676e5">m0_is_polygon_boundary_halfedge</a>(sm_poly_he, m0_num_cutpath_halfedges);</div>
<div class="line"><span class="lineno"> 6706</span>            <span class="keywordtype">bool</span> is_boundary_ih = is_boundary_halfedge;</div>
<div class="line"><span class="lineno"> 6707</span> </div>
<div class="line"><span class="lineno"> 6708</span>            <span class="comment">// const hd_t src_coincident_ps_halfedge = SAFE_ACCESS(m0_ivtx_to_ps_edge, sm_poly_he_src);</span></div>
<div class="line"><span class="lineno"> 6709</span>            <span class="comment">// const hd_t tgt_ps_h = SAFE_ACCESS(m0_ivtx_to_ps_edge, sm_poly_he_tgt);</span></div>
<div class="line"><span class="lineno"> 6710</span> </div>
<div class="line"><span class="lineno"> 6711</span>            <span class="comment">// const ed_t tgt_ps_edge = SAFE_ACCESS(m0_ivtx_to_ps_edge, sm_poly_he_tgt); //ps.edge(tgt_ps_h);</span></div>
<div class="line"><span class="lineno"> 6712</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)sm_poly_he_tgt - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(sm_poly_he_tgt) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 6713</span>            <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt;&amp; sm_poly_he_tgt_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, (std::size_t)sm_poly_he_tgt - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 6714</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; tgt_ps_edge = sm_poly_he_tgt_ipair.first;</div>
<div class="line"><span class="lineno"> 6715</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 6716</span>                <span class="keywordflow">if</span> (src_is_ivertex &amp;&amp; tgt_is_ivertex)</div>
<div class="line"><span class="lineno"> 6717</span>                {</div>
<div class="line"><span class="lineno"> 6718</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)sm_poly_he_src - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(sm_poly_he_src) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 6719</span>                    <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt; &amp;sm_poly_he_src_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, sm_poly_he_src - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 6720</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> &amp;src_ps_edge = sm_poly_he_src_ipair.first; <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_edge, sm_poly_he_src); //ps.edge(src_coincident_ps_halfedge);</span></div>
<div class="line"><span class="lineno"> 6721</span> </div>
<div class="line"><span class="lineno"> 6722</span>                    is_boundary_ih = (src_ps_edge == tgt_ps_edge);</div>
<div class="line"><span class="lineno"> 6723</span>                }</div>
<div class="line"><span class="lineno"> 6724</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 6725</span>            <span class="keywordflow">if</span> (!(is_ox || is_boundary_ih)) {</div>
<div class="line"><span class="lineno"> 6726</span>                <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 6727</span>            }</div>
<div class="line"><span class="lineno"> 6728</span> </div>
<div class="line"><span class="lineno"> 6729</span>            <span class="comment">// Re-calculate the exact same geometry operation as the time we calculated</span></div>
<div class="line"><span class="lineno"> 6730</span>            <span class="comment">// the tgt-ivertex (scalar product using the halfedge&#39;s src and tgt coordinates</span></div>
<div class="line"><span class="lineno"> 6731</span>            <span class="comment">// and and the normal of the cut-mesh face that was intersected to produce</span></div>
<div class="line"><span class="lineno"> 6732</span>            <span class="comment">// the tgt vertex).</span></div>
<div class="line"><span class="lineno"> 6733</span>            <span class="comment">// MCUT_ASSERT(m0_ivtx_to_tested_polygon_normal.find(sm_poly_he_tgt) != m0_ivtx_to_tested_polygon_normal.cend());</span></div>
<div class="line"><span class="lineno"> 6734</span>            <span class="comment">// get the registry entry edge</span></div>
<div class="line"><span class="lineno"> 6735</span> </div>
<div class="line"><span class="lineno"> 6736</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; registry_entry_edge = tgt_ps_edge; <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_edge, sm_poly_he_tgt);</span></div>
<div class="line"><span class="lineno"> 6737</span>            <span class="comment">// get registry entry faces</span></div>
<div class="line"><span class="lineno"> 6738</span>            <span class="keyword">const</span> std::vector&lt;fd_t&gt; registry_entry_faces = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#abcaa230eb10486e26a5167bae360d451">ps_get_ivtx_registry_entry_faces</a>(ps, sm_poly_he_tgt_ipair); <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_faces, sm_poly_he_tgt);</span></div>
<div class="line"><span class="lineno"> 6739</span>            <span class="comment">// get the registry-entry face which is not incident to edge</span></div>
<div class="line"><span class="lineno"> 6740</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> registry_entry_edge_v0 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(registry_entry_edge, 0);</div>
<div class="line"><span class="lineno"> 6741</span>            std::vector&lt;fd_t&gt;::const_iterator tested_face; <span class="comment">// which was intersected by &quot;registry_entry_edge&quot; to get &quot;cs_poly_he_tgt&quot;</span></div>
<div class="line"><span class="lineno"> 6742</span>            <span class="keywordtype">bool</span> registry_entry_edge_is_from_cutmesh = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a426849b7f7105963c5e2767bdd31b155">ps_is_cutmesh_vertex</a>(registry_entry_edge_v0, sm_vtx_cnt);</div>
<div class="line"><span class="lineno"> 6743</span>            <span class="keywordflow">if</span> (registry_entry_edge_is_from_cutmesh) {</div>
<div class="line"><span class="lineno"> 6744</span>                <span class="comment">// ... then intersected face was from the source mesh</span></div>
<div class="line"><span class="lineno"> 6745</span>                tested_face = std::find_if(registry_entry_faces.cbegin(), registry_entry_faces.cend(),</div>
<div class="line"><span class="lineno"> 6746</span>                    [&amp;](<span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a>&amp; f) {</div>
<div class="line"><span class="lineno"> 6747</span>                        bool is_sm_face = !ps_is_cutmesh_face(f, sm_face_count) &amp;&amp; f != hmesh_t::null_face();</div>
<div class="line"><span class="lineno"> 6748</span>                        return is_sm_face;</div>
<div class="line"><span class="lineno"> 6749</span>                    });</div>
<div class="line"><span class="lineno"> 6750</span>            } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 6751</span>                <span class="comment">// ... then intersected face was from the cut mesh</span></div>
<div class="line"><span class="lineno"> 6752</span>                tested_face = std::find_if(registry_entry_faces.cbegin(), registry_entry_faces.cend(),</div>
<div class="line"><span class="lineno"> 6753</span>                    [&amp;](<span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a>&amp; f) {</div>
<div class="line"><span class="lineno"> 6754</span>                        bool is_cm_face = ps_is_cutmesh_face(f, sm_face_count) &amp;&amp; f != hmesh_t::null_face();</div>
<div class="line"><span class="lineno"> 6755</span>                        return is_cm_face;</div>
<div class="line"><span class="lineno"> 6756</span>                    });</div>
<div class="line"><span class="lineno"> 6757</span>            }</div>
<div class="line"><span class="lineno"> 6758</span> </div>
<div class="line"><span class="lineno"> 6759</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(tested_face != registry_entry_faces.cend()); <span class="comment">// &quot;registry_entry_faces&quot; must have at least one face from cm and at least one from sm</span></div>
<div class="line"><span class="lineno"> 6760</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ps_tested_face_to_plane_normal.find(*tested_face) != ps_tested_face_to_plane_normal.cend());</div>
<div class="line"><span class="lineno"> 6761</span> </div>
<div class="line"><span class="lineno"> 6762</span>            <span class="comment">// get normal of face</span></div>
<div class="line"><span class="lineno"> 6763</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a>&amp; polygon_normal = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_tested_face_to_plane_normal, *tested_face);</div>
<div class="line"><span class="lineno"> 6764</span>            <span class="comment">// const vec3&amp; polygon_normal = SAFE_ACCESS(m0_ivtx_to_tested_polygon_normal, sm_poly_he_tgt);</span></div>
<div class="line"><span class="lineno"> 6765</span>            <span class="comment">// const vec3&amp; polygon_normal = geometric_data.first;</span></div>
<div class="line"><span class="lineno"> 6766</span>            <span class="comment">// const double&amp; orig_scalar_prod = geometric_data.second;</span></div>
<div class="line"><span class="lineno"> 6767</span> </div>
<div class="line"><span class="lineno"> 6768</span>            <span class="comment">// MCUT_ASSERT(sign(orig_scalar_prod) == NEGATIVE);</span></div>
<div class="line"><span class="lineno"> 6769</span> </div>
<div class="line"><span class="lineno"> 6770</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a> sm_poly_he_vector = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(sm_poly_he_tgt) - m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(sm_poly_he_src);</div>
<div class="line"><span class="lineno"> 6771</span>            <span class="keyword">const</span> <span class="keywordtype">double</span> scalar_prod = <a class="code hl_function" href="../../df/db1/math_8h.html#a0b6cff67f1f57a1096b42782cf5397da">dot_product</a>(polygon_normal, sm_poly_he_vector);</div>
<div class="line"><span class="lineno"> 6772</span> </div>
<div class="line"><span class="lineno"> 6773</span>            <span class="comment">// Again, the notion of exterior is denoted by a negative dot-product.</span></div>
<div class="line"><span class="lineno"> 6774</span>            <span class="comment">// Original ps-halfedge was &quot;incoming&quot; and gave a negative scalar-product</span></div>
<div class="line"><span class="lineno"> 6775</span>            <span class="comment">// with the cut-mesh face normal.</span></div>
<div class="line"><span class="lineno"> 6776</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6777</span>            <span class="comment">// We want the same sign (i.e. cs_poly_he_vector has negative scalar-product) because we want</span></div>
<div class="line"><span class="lineno"> 6778</span>            <span class="comment">// the class-1 ihalfedge which is exterior but points &quot;inside&quot; the cut-mesh (i.e. torward</span></div>
<div class="line"><span class="lineno"> 6779</span>            <span class="comment">// the negative side)</span></div>
<div class="line"><span class="lineno"> 6780</span>            <span class="keywordflow">if</span> (<a class="code hl_function" href="../../d4/df0/_array_cwise_unary_ops_8h.html#a281eccb624a3ff6dacbe305828e43a82">sign</a>(scalar_prod) == <a class="code hl_enumvalue" href="../../df/db1/math_8h.html#a6912657a051f0b1fc01a0d3095158b43a62d66a51fa7574c652597716f7709865">NEGATIVE</a>) {</div>
<div class="line"><span class="lineno"> 6781</span> </div>
<div class="line"><span class="lineno"> 6782</span>                <span class="comment">// At this point, we have found our class-1 (or class 3, x--&gt;x) source-mesh halfedge</span></div>
<div class="line"><span class="lineno"> 6783</span>                <span class="comment">// from which we can infer whether the current polygon is &quot;above&quot; (outside) or</span></div>
<div class="line"><span class="lineno"> 6784</span>                <span class="comment">// &quot;below&quot; (inside) the cut-mesh.</span></div>
<div class="line"><span class="lineno"> 6785</span>                <span class="comment">// Also, by using the traced halfedge connectivity, we can determine the adjacent polygon</span></div>
<div class="line"><span class="lineno"> 6786</span>                <span class="comment">// which shares an edge with the curent polygon. This shared edge is the edge of the</span></div>
<div class="line"><span class="lineno"> 6787</span>                <span class="comment">// &quot;next&quot; halfedge (of the current halfedge) and it is always an interior edge.</span></div>
<div class="line"><span class="lineno"> 6788</span> </div>
<div class="line"><span class="lineno"> 6789</span>                <span class="comment">// Check if the current polygon is already found to be &quot;above&quot; the cut-mesh</span></div>
<div class="line"><span class="lineno"> 6790</span>                <span class="keyword">const</span> <span class="keywordtype">bool</span> cur_poly_already_marked_as_above = std::find(sm_polygons_above_cs.cbegin(), sm_polygons_above_cs.cend(), sm_poly_idx) != sm_polygons_above_cs.cend();</div>
<div class="line"><span class="lineno"> 6791</span> </div>
<div class="line"><span class="lineno"> 6792</span>                <span class="keywordflow">if</span> (!cur_poly_already_marked_as_above) {</div>
<div class="line"><span class="lineno"> 6793</span>                    sm_polygons_above_cs.push_back(sm_poly_idx);</div>
<div class="line"><span class="lineno"> 6794</span>                }</div>
<div class="line"><span class="lineno"> 6795</span> </div>
<div class="line"><span class="lineno"> 6796</span>                <span class="comment">// Here we can conviniently find and save the the neighbouring polygon that is on the</span></div>
<div class="line"><span class="lineno"> 6797</span>                <span class="comment">// other side i.e. &quot;below&quot; the cut-mesh. This is made possible because we can easily</span></div>
<div class="line"><span class="lineno"> 6798</span>                <span class="comment">// search through the halfedge connectivity.</span></div>
<div class="line"><span class="lineno"> 6799</span> </div>
<div class="line"><span class="lineno"> 6800</span>                <span class="comment">// index of current halfedge in the current polygon</span></div>
<div class="line"><span class="lineno"> 6801</span>                <span class="keyword">const</span> <span class="keywordtype">int</span> sm_poly_he_idx = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)<a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(sm_poly.cbegin(), sm_poly_he_iter);</div>
<div class="line"><span class="lineno"> 6802</span>                <span class="comment">// index of the &quot;next&quot; halfedge in the current polygon</span></div>
<div class="line"><span class="lineno"> 6803</span>                <span class="keyword">const</span> <span class="keywordtype">int</span> sm_poly_next_he_idx = <a class="code hl_function" href="../../d5/d60/utils_8h.html#ad42d4789f60996516823b4b4cfb9c04d">wrap_integer</a>(sm_poly_he_idx + 1, 0, (<span class="keywordtype">int</span>)sm_poly.size() - 1);</div>
<div class="line"><span class="lineno"> 6804</span>                <span class="comment">// the handle of the next halfedge in the current polygon</span></div>
<div class="line"><span class="lineno"> 6805</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; sm_poly_next_he = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(sm_poly, sm_poly_next_he_idx);</div>
<div class="line"><span class="lineno"> 6806</span>                <span class="comment">// now we query the handle of the opposite-halfedge of the next-halfedge.</span></div>
<div class="line"><span class="lineno"> 6807</span>                <span class="comment">// This is facilitated by the incidence information that is maintained inside</span></div>
<div class="line"><span class="lineno"> 6808</span>                <span class="comment">// our halfedge data structure &quot;m0&quot; which stores our vertices (including intersection</span></div>
<div class="line"><span class="lineno"> 6809</span>                <span class="comment">// points) and edges that we calculated in earlier stages of the pipeline).</span></div>
<div class="line"><span class="lineno"> 6810</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> opp_of_sm_poly_next_he = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(sm_poly_next_he);</div>
<div class="line"><span class="lineno"> 6811</span>                <span class="comment">// using our halfedge-to-traced-polygon map, we then get the polygon index of the</span></div>
<div class="line"><span class="lineno"> 6812</span>                <span class="comment">// opposite-halfedge</span></div>
<div class="line"><span class="lineno"> 6813</span>                <span class="keyword">const</span> std::vector&lt;int&gt;&amp; coincident_polys = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, opp_of_sm_poly_next_he); <span class="comment">// coincident polygons (one cs and one sm)</span></div>
<div class="line"><span class="lineno"> 6814</span>                <span class="keyword">const</span> std::vector&lt;int&gt;::const_iterator find_iter = std::find_if(</div>
<div class="line"><span class="lineno"> 6815</span>                    coincident_polys.cbegin(), coincident_polys.cend(),</div>
<div class="line"><span class="lineno"> 6816</span>                    [&amp;](<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; e) { return (e &lt; traced_sm_polygon_count); });</div>
<div class="line"><span class="lineno"> 6817</span> </div>
<div class="line"><span class="lineno"> 6818</span>                <span class="comment">// must always exist since &quot;opp_of_sm_poly_next_he&quot; is an interior ihalfedge</span></div>
<div class="line"><span class="lineno"> 6819</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(find_iter != coincident_polys.cend());</div>
<div class="line"><span class="lineno"> 6820</span> </div>
<div class="line"><span class="lineno"> 6821</span>                <span class="comment">// we have found the other source-mesh polygon which is &quot;below&quot; (inside) the cut-mesh</span></div>
<div class="line"><span class="lineno"> 6822</span>                <span class="keyword">const</span> <span class="keywordtype">int</span> coincident_sm_poly_idx = *find_iter;</div>
<div class="line"><span class="lineno"> 6823</span>                <span class="keyword">const</span> <span class="keywordtype">bool</span> neigh_poly_already_marked_as_below = std::find(sm_polygons_below_cs.cbegin(), sm_polygons_below_cs.cend(), sm_poly_idx) != sm_polygons_below_cs.cend();</div>
<div class="line"><span class="lineno"> 6824</span> </div>
<div class="line"><span class="lineno"> 6825</span>                <span class="keywordflow">if</span> (!neigh_poly_already_marked_as_below) {</div>
<div class="line"><span class="lineno"> 6826</span>                    sm_polygons_below_cs.push_back(coincident_sm_poly_idx);</div>
<div class="line"><span class="lineno"> 6827</span>                }</div>
<div class="line"><span class="lineno"> 6828</span>            }</div>
<div class="line"><span class="lineno"> 6829</span>        }</div>
<div class="line"><span class="lineno"> 6830</span>    }</div>
<div class="line"><span class="lineno"> 6831</span> </div>
<div class="line"><span class="lineno"> 6832</span>    <span class="comment">// sort that we can do binary search over it</span></div>
<div class="line"><span class="lineno"> 6833</span>    std::sort(sm_polygons_below_cs.begin(), sm_polygons_below_cs.end());</div>
<div class="line"><span class="lineno"> 6834</span>    std::sort(sm_polygons_above_cs.begin(), sm_polygons_above_cs.end());</div>
<div class="line"><span class="lineno"> 6835</span> </div>
<div class="line"><span class="lineno"> 6836</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 6837</span> </div>
<div class="line"><span class="lineno"> 6838</span>    <span class="comment">// sm_nonborder_reentrant_ivtx_list.clear();</span></div>
<div class="line"><span class="lineno"> 6839</span> </div>
<div class="line"><span class="lineno"> 6840</span>    <span class="comment">// Here, we check for the unique case in which we could not find any traced source-mesh</span></div>
<div class="line"><span class="lineno"> 6841</span>    <span class="comment">// polygons along the cut path which could be identified as either &quot;above&quot; (outside)</span></div>
<div class="line"><span class="lineno"> 6842</span>    <span class="comment">// or &quot;below&quot; (inside).</span></div>
<div class="line"><span class="lineno"> 6843</span>    <span class="comment">// Such a situation is rare and happens when the source-mesh has one face where the</span></div>
<div class="line"><span class="lineno"> 6844</span>    <span class="comment">// intersection with the cut-mesh is a partial cut</span></div>
<div class="line"><span class="lineno"> 6845</span> </div>
<div class="line"><span class="lineno"> 6846</span>    <span class="comment">// if (sm_polygons_above_cs.empty() &amp;&amp; sm_polygons_below_cs.empty()) {</span></div>
<div class="line"><span class="lineno"> 6847</span>    <span class="comment">//     MCUT_ASSERT(sm_face_count == 1);</span></div>
<div class="line"><span class="lineno"> 6848</span>    <span class="comment">//     sm_polygons_above_cs.push_back(0); // sm polygons are stored first theirfore sm polygon will ccse first (see &quot;ps&quot; definition)</span></div>
<div class="line"><span class="lineno"> 6849</span>    <span class="comment">//     sm_polygons_below_cs.push_back(0);</span></div>
<div class="line"><span class="lineno"> 6850</span>    <span class="comment">// }</span></div>
<div class="line"><span class="lineno"> 6851</span> </div>
<div class="line"><span class="lineno"> 6852</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Map source mesh ihalfedges to bool&quot;</span>);</div>
<div class="line"><span class="lineno"> 6853</span> </div>
<div class="line"><span class="lineno"> 6855</span>    <span class="comment">// Map source-mesh intersection halfedges to a boolean value</span></div>
<div class="line"><span class="lineno"> 6857</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 6858</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6859</span>    <span class="comment">// Here we will map every source-mesh halfedge connected to an intersection point to a boolean.</span></div>
<div class="line"><span class="lineno"> 6860</span>    <span class="comment">// This boolean value indicates if the halfedge has been `transformed`. The notion</span></div>
<div class="line"><span class="lineno"> 6861</span>    <span class="comment">// of &quot;transformation&quot; is used to indicate whether a halfedge has been &quot;processed&quot;</span></div>
<div class="line"><span class="lineno"> 6862</span>    <span class="comment">// to assign it to a distinct fragment connected component of the source-mesh.</span></div>
<div class="line"><span class="lineno"> 6863</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6864</span>    <span class="comment">// We call a halfedge connected to at-least one intersection point note an &quot;intersection</span></div>
<div class="line"><span class="lineno"> 6865</span>    <span class="comment">// halfedge&quot;</span></div>
<div class="line"><span class="lineno"> 6866</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6867</span> </div>
<div class="line"><span class="lineno"> 6868</span>    std::unordered_map&lt;</div>
<div class="line"><span class="lineno"> 6869</span>        <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a>, <span class="comment">// intersection halfedge which is used for tracing</span></div>
<div class="line"><span class="lineno"> 6870</span>        <span class="keywordtype">bool</span> <span class="comment">// flag for indicating if halfedge has been transformed</span></div>
<div class="line"><span class="lineno"> 6871</span>        &gt;</div>
<div class="line"><span class="lineno"> 6872</span>        m0_sm_ihe_to_flag;</div>
<div class="line"><span class="lineno"> 6873</span> </div>
<div class="line"><span class="lineno"> 6874</span>    <span class="comment">// for (edge_array_iterator_t edge_iter = m0.edges_begin(); edge_iter != m0.edges_end(); ++edge_iter) {</span></div>
<div class="line"><span class="lineno"> 6875</span>    <span class="keywordflow">for</span> (std::unordered_map&lt;<a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a>, std::vector&lt;hd_t&gt;&gt;::const_iterator ivtx_iter = ivtx_to_incoming_hlist.cbegin(); ivtx_iter != ivtx_to_incoming_hlist.cend(); ++ivtx_iter) {</div>
<div class="line"><span class="lineno"> 6876</span>        <span class="keywordflow">for</span> (std::vector&lt;hd_t&gt;::const_iterator halfedge_iter = ivtx_iter-&gt;second.cbegin(); halfedge_iter != ivtx_iter-&gt;second.cend(); ++halfedge_iter) {</div>
<div class="line"><span class="lineno"> 6877</span>            <span class="comment">// const ed_t&amp; edge = (*edge_iter);</span></div>
<div class="line"><span class="lineno"> 6878</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; edge = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a96e9db918396b86f0b61f5445ef46b18">edge</a>(*halfedge_iter);</div>
<div class="line"><span class="lineno"> 6879</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> v0 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(edge, 0);</div>
<div class="line"><span class="lineno"> 6880</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> v1 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(edge, 1);</div>
<div class="line"><span class="lineno"> 6881</span> </div>
<div class="line"><span class="lineno"> 6882</span>            <span class="keyword">const</span> <span class="keywordtype">bool</span> v0_is_ivtx = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(v0, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 6883</span>            <span class="keyword">const</span> <span class="keywordtype">bool</span> v1_is_ivtx = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(v1, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 6884</span> </div>
<div class="line"><span class="lineno"> 6885</span>            <span class="keywordflow">if</span> (!v0_is_ivtx &amp;&amp; !v1_is_ivtx) { <span class="comment">// o--&gt;o</span></div>
<div class="line"><span class="lineno"> 6886</span>                <span class="comment">// we only want halfedges with an intersection point</span></div>
<div class="line"><span class="lineno"> 6887</span>                <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 6888</span>            }</div>
<div class="line"><span class="lineno"> 6889</span> </div>
<div class="line"><span class="lineno"> 6890</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6891</span>            <span class="comment">// check if current edge is a cut-mesh edge</span></div>
<div class="line"><span class="lineno"> 6892</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6893</span> </div>
<div class="line"><span class="lineno"> 6894</span>            <span class="keywordflow">if</span> (v0_is_ivtx &amp;&amp; !v1_is_ivtx) { <span class="comment">// x--&gt;o</span></div>
<div class="line"><span class="lineno"> 6895</span> </div>
<div class="line"><span class="lineno"> 6896</span>                <span class="comment">// get the polygon-soup version of tgt descriptor</span></div>
<div class="line"><span class="lineno"> 6897</span>                <span class="comment">// std::map&lt;vd_t, vd_t&gt;::const_iterator m0_to_ps_vtx_find_v1_iter = std::find_if(</span></div>
<div class="line"><span class="lineno"> 6898</span>                <span class="comment">//    m0_to_ps_vtx.cbegin(), m0_to_ps_vtx.cend(),</span></div>
<div class="line"><span class="lineno"> 6899</span>                <span class="comment">//    [&amp;](const std::pair&lt;vd_t, vd_t&gt; &amp;e) { return e.first == v1; });</span></div>
<div class="line"><span class="lineno"> 6900</span> </div>
<div class="line"><span class="lineno"> 6901</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">int</span>)v1 &lt; (<span class="keywordtype">int</span>)m0_to_ps_vtx.size() <span class="comment">/*m0_to_ps_vtx_find_v1_iter != m0_to_ps_vtx.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 6902</span> </div>
<div class="line"><span class="lineno"> 6903</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a>&amp; ps_v1 = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_ps_vtx, v1); <span class="comment">// m0_to_ps_vtx_find_v1_iter-&gt;second;</span></div>
<div class="line"><span class="lineno"> 6904</span> </div>
<div class="line"><span class="lineno"> 6905</span>                <span class="keywordflow">if</span> (<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a426849b7f7105963c5e2767bdd31b155">ps_is_cutmesh_vertex</a>(ps_v1, sm_vtx_cnt)) { <span class="comment">// is it a cut-mesh vertex..?</span></div>
<div class="line"><span class="lineno"> 6906</span>                    <span class="comment">// we want only source-mesh edges</span></div>
<div class="line"><span class="lineno"> 6907</span>                    <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 6908</span>                }</div>
<div class="line"><span class="lineno"> 6909</span>            }</div>
<div class="line"><span class="lineno"> 6910</span> </div>
<div class="line"><span class="lineno"> 6911</span>            <span class="keywordflow">if</span> (!v0_is_ivtx &amp;&amp; v1_is_ivtx) { <span class="comment">// o--&gt;x</span></div>
<div class="line"><span class="lineno"> 6912</span>                <span class="comment">// std::map&lt;vd_t, vd_t&gt;::const_iterator m0_to_ps_vtx_find_v0_iter = std::find_if(</span></div>
<div class="line"><span class="lineno"> 6913</span>                <span class="comment">//     m0_to_ps_vtx.cbegin(), m0_to_ps_vtx.cend(),</span></div>
<div class="line"><span class="lineno"> 6914</span>                <span class="comment">//     [&amp;](const std::pair&lt;vd_t, vd_t&gt; &amp;e) { return e.first == v0; });</span></div>
<div class="line"><span class="lineno"> 6915</span> </div>
<div class="line"><span class="lineno"> 6916</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)v0 &lt; m0_to_ps_vtx.size()); <span class="comment">// m0_to_ps_vtx_find_v0_iter != m0_to_ps_vtx.cend());</span></div>
<div class="line"><span class="lineno"> 6917</span> </div>
<div class="line"><span class="lineno"> 6918</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a>&amp; ps_v0 = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_ps_vtx, v0); <span class="comment">// m0_to_ps_vtx_find_v0_iter-&gt;second;</span></div>
<div class="line"><span class="lineno"> 6919</span> </div>
<div class="line"><span class="lineno"> 6920</span>                <span class="keywordflow">if</span> (<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a426849b7f7105963c5e2767bdd31b155">ps_is_cutmesh_vertex</a>(ps_v0, sm_vtx_cnt)) {</div>
<div class="line"><span class="lineno"> 6921</span>                    <span class="keywordflow">continue</span>; <span class="comment">// is a cut-mesh edge</span></div>
<div class="line"><span class="lineno"> 6922</span>                }</div>
<div class="line"><span class="lineno"> 6923</span>            }</div>
<div class="line"><span class="lineno"> 6924</span> </div>
<div class="line"><span class="lineno"> 6925</span>            <span class="comment">// TODO: we also need to check for cut-mesh edges of the form x--&gt;x [but only the polygon boundary type]</span></div>
<div class="line"><span class="lineno"> 6926</span>            <span class="comment">// At the moment, &quot;m0_sm_ihe_to_flag&quot; will also include those cut-mesh halfedges!</span></div>
<div class="line"><span class="lineno"> 6927</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6928</span>            <span class="comment">// ** I&#39;m not convinced that this is a problem</span></div>
<div class="line"><span class="lineno"> 6929</span> </div>
<div class="line"><span class="lineno"> 6930</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 6931</span>        <span class="keywordtype">bool</span> is_ambiguious_boundary_edge_case = v0_is_ivtx &amp;&amp; v1_is_ivtx;</div>
<div class="line"><span class="lineno"> 6932</span> </div>
<div class="line"><span class="lineno"> 6933</span>        <span class="keywordflow">if</span> (is_ambiguious_boundary_edge_case) { <span class="comment">// exterior edge with two intersection vertices (ambigious case arising from concave polyhedron cut)</span></div>
<div class="line"><span class="lineno"> 6934</span> </div>
<div class="line"><span class="lineno"> 6935</span>          <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> v0_coincident_ps_halfedge = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_ps_edge, v0);</div>
<div class="line"><span class="lineno"> 6936</span>          <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> v1_coincident_ps_halfedge = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_ps_edge, v1);</div>
<div class="line"><span class="lineno"> 6937</span>          <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> v0_ps_edge = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a96e9db918396b86f0b61f5445ef46b18">edge</a>(v0_coincident_ps_halfedge);</div>
<div class="line"><span class="lineno"> 6938</span>          <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> v1_ps_edge = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a96e9db918396b86f0b61f5445ef46b18">edge</a>(v1_coincident_ps_halfedge);</div>
<div class="line"><span class="lineno"> 6939</span>          <span class="keywordtype">bool</span> is_valid_ambiguious_boundary_edge = (v0_ps_edge == v1_ps_edge); <span class="comment">// see also above when gathering exterior incident edges</span></div>
<div class="line"><span class="lineno"> 6940</span>          <span class="keywordflow">if</span> (is_valid_ambiguious_boundary_edge &amp;&amp; !cm_is_watertight) <span class="comment">// x--&gt;x where o--&gt;x--&gt;x--&gt;o</span></div>
<div class="line"><span class="lineno"> 6941</span>          {</div>
<div class="line"><span class="lineno"> 6942</span>            <span class="comment">// Exterior ihalfedges (and hence their respective halfedges) are not transformed.</span></div>
<div class="line"><span class="lineno"> 6943</span>            <span class="comment">// Only interior ihalfedges need to be transformed to create incisions that allow openings of the sm via transformations.</span></div>
<div class="line"><span class="lineno"> 6944</span>            <span class="comment">// NOTE: when cs is watertight we still include polygon-exterior interior-ihalfedge because they a needed to &quot;bite&quot; a chuck out of the cs (see example 19)</span></div>
<div class="line"><span class="lineno"> 6945</span>            <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 6946</span>          }</div>
<div class="line"><span class="lineno"> 6947</span>      }</div>
<div class="line"><span class="lineno"> 6948</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 6949</span> </div>
<div class="line"><span class="lineno"> 6950</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6951</span>            <span class="comment">// save the halfegdes of the current edge (if they are used to trace a polygon)</span></div>
<div class="line"><span class="lineno"> 6952</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6953</span> </div>
<div class="line"><span class="lineno"> 6954</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h0 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(edge, 0);</div>
<div class="line"><span class="lineno"> 6955</span> </div>
<div class="line"><span class="lineno"> 6956</span>            <span class="keywordflow">if</span> (<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, h0).size() &gt; 0 <span class="comment">/*m0_h_to_ply.find(h0) != m0_h_to_ply.end()*/</span> &amp;&amp; m0_sm_ihe_to_flag.find(h0) == m0_sm_ihe_to_flag.cend()) { <span class="comment">// check if used to trace polygon</span></div>
<div class="line"><span class="lineno"> 6957</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_sm_ihe_to_flag.count(h0) == 0);</div>
<div class="line"><span class="lineno"> 6958</span>                m0_sm_ihe_to_flag[h0] = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 6959</span>                <span class="comment">// std::pair&lt;std::map&lt;hd_t, bool&gt;::const_iterator, bool&gt; pair0 = m0_sm_ihe_to_flag.insert(std::make_pair(h0, false));</span></div>
<div class="line"><span class="lineno"> 6960</span>                <span class="comment">// MCUT_ASSERT(pair0.second == true);</span></div>
<div class="line"><span class="lineno"> 6961</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_sm_ihe_to_flag.count(h0) == 1);</div>
<div class="line"><span class="lineno"> 6962</span>            }</div>
<div class="line"><span class="lineno"> 6963</span> </div>
<div class="line"><span class="lineno"> 6964</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h1 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(edge, 1);</div>
<div class="line"><span class="lineno"> 6965</span> </div>
<div class="line"><span class="lineno"> 6966</span>            <span class="keywordflow">if</span> (<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, h1).<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a809275ccd755fb7b88661d952134b14d">size</a>() &gt; 0 <span class="comment">/*m0_h_to_ply.find(h1) != m0_h_to_ply.end()*/</span> &amp;&amp; m0_sm_ihe_to_flag.find(h1) == m0_sm_ihe_to_flag.cend()) { <span class="comment">// check id used to trace polygon</span></div>
<div class="line"><span class="lineno"> 6967</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_sm_ihe_to_flag.count(h1) == 0);</div>
<div class="line"><span class="lineno"> 6968</span>                m0_sm_ihe_to_flag[h1] = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 6969</span>                <span class="comment">// std::pair&lt;std::map&lt;hd_t, bool&gt;::const_iterator, bool&gt; pair1 = m0_sm_ihe_to_flag.insert(std::make_pair(h1, false));</span></div>
<div class="line"><span class="lineno"> 6970</span>                <span class="comment">// MCUT_ASSERT(pair1.second == true);</span></div>
<div class="line"><span class="lineno"> 6971</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_sm_ihe_to_flag.count(h1) == 1);</div>
<div class="line"><span class="lineno"> 6972</span>            }</div>
<div class="line"><span class="lineno"> 6973</span>        }</div>
<div class="line"><span class="lineno"> 6974</span>    }</div>
<div class="line"><span class="lineno"> 6975</span> </div>
<div class="line"><span class="lineno"> 6976</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 6977</span> </div>
<div class="line"><span class="lineno"> 6979</span>    <span class="comment">// create the second auxilliary halfedge data structure (&quot;m1&quot;)</span></div>
<div class="line"><span class="lineno"> 6981</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 6982</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Create m1&quot;</span>);</div>
<div class="line"><span class="lineno"> 6983</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6984</span>    <span class="comment">// At this point, we create another auxilliary halfedge data structure called &quot;m1&quot;.</span></div>
<div class="line"><span class="lineno"> 6985</span>    <span class="comment">// It will store the vertices and edges like &quot;m0&quot; but will also include the</span></div>
<div class="line"><span class="lineno"> 6986</span>    <span class="comment">// duplicate copy of (most/all) intersection points, as well as some new edges. The new</span></div>
<div class="line"><span class="lineno"> 6987</span>    <span class="comment">// edges are created to partition/separate the source-mesh as we process intersection</span></div>
<div class="line"><span class="lineno"> 6988</span>    <span class="comment">// halfedges by assigning them the correct copy of dupicated intersection</span></div>
<div class="line"><span class="lineno"> 6989</span>    <span class="comment">// points. Thus along the cut path, we will create new connectivity that</span></div>
<div class="line"><span class="lineno"> 6990</span>    <span class="comment">// allows us to partition the source-mesh along this path.</span></div>
<div class="line"><span class="lineno"> 6991</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 6992</span> </div>
<div class="line"><span class="lineno"> 6993</span>    <span class="comment">// store&#39;s the (unsealed) connected components (fragments of the source-mesh)</span></div>
<div class="line"><span class="lineno"> 6994</span>    <a class="code hl_class" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> m1;</div>
<div class="line"><span class="lineno"> 6995</span>    m1.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a0c71c904363d4a3932bd674812f8478e">reserve_for_additional_elements</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a35ce6de1cc36d41e9eb48edb3e23e795">number_of_vertices</a>() + m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a35ce6de1cc36d41e9eb48edb3e23e795">number_of_vertices</a>() * 0.25);</div>
<div class="line"><span class="lineno"> 6996</span>    <span class="comment">// copy vertices from m0 t0 m1 (and save mapping to avoid assumptions).</span></div>
<div class="line"><span class="lineno"> 6997</span>    <span class="comment">// This map DOES NOT include patch intersection points because they are new</span></div>
<div class="line"><span class="lineno"> 6998</span>    <span class="comment">// i.e. we keep only the points represent original vertices in the source-mesh</span></div>
<div class="line"><span class="lineno"> 6999</span>    <span class="comment">// and cut-mesh (used as data for client tex coord mapping usage)</span></div>
<div class="line"><span class="lineno"> 7000</span>    std::vector&lt;vd_t&gt; m0_to_m1_vtx(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a35ce6de1cc36d41e9eb48edb3e23e795">number_of_vertices</a>());</div>
<div class="line"><span class="lineno"> 7001</span>    std::vector&lt;vd_t&gt; m1_to_m0_ovtx(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a35ce6de1cc36d41e9eb48edb3e23e795">number_of_vertices</a>());</div>
<div class="line"><span class="lineno"> 7002</span>    <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">vertex_array_iterator_t</a> v = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a0bf160ae73193f77064cc3d8f01e63a3">vertices_begin</a>(); v != m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a80ac49a03f1085744f5b121cc4acbf2c">vertices_end</a>(); ++v) {</div>
<div class="line"><span class="lineno"> 7003</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m1_vd = m1.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a0d2a1a79406b7352af07d4fc56707782">add_vertex</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(*v));</div>
<div class="line"><span class="lineno"> 7004</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m1_vd != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ab448d0b9684fd2f648195b2e5edb83f2">hmesh_t::null_vertex</a>());</div>
<div class="line"><span class="lineno"> 7005</span> </div>
<div class="line"><span class="lineno"> 7006</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)(*v) &lt; m0_to_m1_vtx.size() <span class="comment">/*m0_to_m1_vtx.count(*v) == 0*/</span> &amp;&amp; (<span class="keywordtype">size_t</span>)m1_vd &lt; m1_to_m0_ovtx.size() <span class="comment">/* m1_to_m0_ovtx.count(m1_vd) == 0*/</span>);</div>
<div class="line"><span class="lineno"> 7007</span>        <span class="comment">// std::pair&lt;std::map&lt;vd_t, vd_t&gt;::const_iterator, bool&gt; pair = m0_to_m1_vtx.insert(std::make_pair(*v, m1_vd));</span></div>
<div class="line"><span class="lineno"> 7008</span>        <span class="comment">// MCUT_ASSERT(pair.second == true);</span></div>
<div class="line"><span class="lineno"> 7009</span>        m0_to_m1_vtx[*v] = m1_vd;</div>
<div class="line"><span class="lineno"> 7010</span>        m1_to_m0_ovtx[m1_vd] = *v;</div>
<div class="line"><span class="lineno"> 7011</span>        <span class="comment">// MCUT_ASSERT(m0_to_m1_vtx.count(*v) == 1);</span></div>
<div class="line"><span class="lineno"> 7012</span>    }</div>
<div class="line"><span class="lineno"> 7013</span> </div>
<div class="line"><span class="lineno"> 7014</span>    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m1.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a35ce6de1cc36d41e9eb48edb3e23e795">number_of_vertices</a>() == m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a35ce6de1cc36d41e9eb48edb3e23e795">number_of_vertices</a>());</div>
<div class="line"><span class="lineno"> 7015</span> </div>
<div class="line"><span class="lineno"> 7016</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 7017</span> </div>
<div class="line"><span class="lineno"> 7018</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Map m0 to m1 halfedges&quot;</span>);</div>
<div class="line"><span class="lineno"> 7019</span> </div>
<div class="line"><span class="lineno"> 7020</span>    <span class="comment">// copy m0 edges and halfedges [which are not intersection-halfedges] and</span></div>
<div class="line"><span class="lineno"> 7021</span>    <span class="comment">// build a mapping between m0 and m1. This mapping is needed because as we</span></div>
<div class="line"><span class="lineno"> 7022</span>    <span class="comment">// begin to transform halfedges incident to the cut-path, some of their opposites</span></div>
<div class="line"><span class="lineno"> 7023</span>    <span class="comment">// will become invalidated. This is because for each interior edge we will</span></div>
<div class="line"><span class="lineno"> 7024</span>    <span class="comment">// essentially create a new edge.</span></div>
<div class="line"><span class="lineno"> 7025</span>    <span class="comment">// We must also relate halfedges (in &quot;m1&quot;) to their opposites explicitly (essentially</span></div>
<div class="line"><span class="lineno"> 7026</span>    <span class="comment">// copying the information already stored in &quot;m0&quot;). Because this information will be</span></div>
<div class="line"><span class="lineno"> 7027</span>    <span class="comment">// lost after duplicating intersection points and transforming all halfedges</span></div>
<div class="line"><span class="lineno"> 7028</span>    <span class="comment">// along the cut-path.</span></div>
<div class="line"><span class="lineno"> 7029</span> </div>
<div class="line"><span class="lineno"> 7030</span>    std::unordered_map&lt;hd_t, hd_t&gt; m0_to_m1_he;</div>
<div class="line"><span class="lineno"> 7031</span>    m0_to_m1_he.reserve(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ac759578dea5f6dd7eebcef3f1a5af705">number_of_edges</a>() * 2);</div>
<div class="line"><span class="lineno"> 7032</span> </div>
<div class="line"><span class="lineno"> 7033</span>    <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">edge_array_iterator_t</a> e = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a8d7c997988ef348807997c1b35d1ba62">edges_begin</a>(); e != m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a3d290168d74d3af8636faa881a9e3708">edges_end</a>(); ++e) {</div>
<div class="line"><span class="lineno"> 7034</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; m0_edge = (*e);</div>
<div class="line"><span class="lineno"> 7035</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_v0 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(m0_edge, 0);</div>
<div class="line"><span class="lineno"> 7036</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_v1 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(m0_edge, 1);</div>
<div class="line"><span class="lineno"> 7037</span>        <span class="comment">// const bool m0_v0_is_ivtx = m0_is_intersection_point(m0_v0, ps_vtx_cnt);</span></div>
<div class="line"><span class="lineno"> 7038</span>        <span class="comment">// const bool m0_v1_is_ivtx = m0_is_intersection_point(m0_v1, ps_vtx_cnt);</span></div>
<div class="line"><span class="lineno"> 7039</span> </div>
<div class="line"><span class="lineno"> 7040</span>        <span class="keywordflow">if</span> (!(<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0_v0, ps_vtx_cnt) || <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0_v1, ps_vtx_cnt))) { <span class="comment">// not coincident to an intersection vertex (i.e. is class-0 edge)</span></div>
<div class="line"><span class="lineno"> 7041</span> </div>
<div class="line"><span class="lineno"> 7042</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m1_v0 = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_m1_vtx, m0_v0);</div>
<div class="line"><span class="lineno"> 7043</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m1_v1 = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_m1_vtx, m0_v1);</div>
<div class="line"><span class="lineno"> 7044</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m1_halfedge = m1.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ae64649dd61e0c188c547c686abc8a19e">add_edge</a>(m1_v0, m1_v1); <span class="comment">// add m1</span></div>
<div class="line"><span class="lineno"> 7045</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m0_h0 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(m0_edge, 0);</div>
<div class="line"><span class="lineno"> 7046</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_h0_src = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(m0_h0);</div>
<div class="line"><span class="lineno"> 7047</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m0_h1 = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(m0_edge, 1);</div>
<div class="line"><span class="lineno"> 7048</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m1_halfedge_src = m1.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(m1_halfedge);</div>
<div class="line"><span class="lineno"> 7049</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m1_halfedge_tgt = m1.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m1_halfedge);</div>
<div class="line"><span class="lineno"> 7050</span> </div>
<div class="line"><span class="lineno"> 7051</span>            <span class="keywordflow">if</span> (<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_m1_vtx, m0_h0_src) == m1_halfedge_src) { <span class="comment">// i.e. &quot;is the m0_h0 equivalent to m1_halfedge?&quot;</span></div>
<div class="line"><span class="lineno"> 7052</span>                m0_to_m1_he.insert(std::make_pair(m0_h0, m1_halfedge));</div>
<div class="line"><span class="lineno"> 7053</span>                m0_to_m1_he.insert(std::make_pair(m0_h1, m1.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(m1_halfedge)));</div>
<div class="line"><span class="lineno"> 7054</span>            } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 7055</span>                m0_to_m1_he.insert(std::make_pair(m0_h1, m1_halfedge));</div>
<div class="line"><span class="lineno"> 7056</span>                m0_to_m1_he.insert(std::make_pair(m0_h0, m1.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(m1_halfedge)));</div>
<div class="line"><span class="lineno"> 7057</span>            }</div>
<div class="line"><span class="lineno"> 7058</span>        }</div>
<div class="line"><span class="lineno"> 7059</span>    }</div>
<div class="line"><span class="lineno"> 7060</span> </div>
<div class="line"><span class="lineno"> 7061</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 7062</span> </div>
<div class="line"><span class="lineno"> 7063</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;m0 source mesh set next&quot;</span>);</div>
<div class="line"><span class="lineno"> 7064</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7065</span>    <span class="comment">// For each src-mesh halfedge we store &quot;next-halfedge&quot; state for quick-lookup in &quot;m0&quot;.</span></div>
<div class="line"><span class="lineno"> 7066</span>    <span class="comment">// We store this information in &quot;m0&quot; because it allows for a more expedient state-lookup during</span></div>
<div class="line"><span class="lineno"> 7067</span>    <span class="comment">// connected-component re-assignment.</span></div>
<div class="line"><span class="lineno"> 7068</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7069</span>    <span class="comment">// Note: this is only made possible because 1) from this point onwards &quot;m0&quot; will not be modified</span></div>
<div class="line"><span class="lineno"> 7070</span>    <span class="comment">// at all, and 2) we can safely assume that its okay to store &quot;next-halfedge&quot; state without `technically`</span></div>
<div class="line"><span class="lineno"> 7071</span>    <span class="comment">// violating 2-manifold rules since this information is only for the src-mesh polygons.</span></div>
<div class="line"><span class="lineno"> 7072</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7073</span>    <span class="comment">// We will ultimately use this saved state to extract the intersection-halfedges which are coincident</span></div>
<div class="line"><span class="lineno"> 7074</span>    <span class="comment">// to intersection-vertices during connected-component re-assignment.</span></div>
<div class="line"><span class="lineno"> 7075</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7076</span> </div>
<div class="line"><span class="lineno"> 7077</span>    <span class="comment">// for each source-mesh polygon</span></div>
<div class="line"><span class="lineno"> 7078</span>    <span class="keywordflow">for</span> (std::vector&lt;traced_polygon_t&gt;::const_iterator traced_sm_polygon_iter = m0_polygons.cbegin();</div>
<div class="line"><span class="lineno"> 7079</span>         traced_sm_polygon_iter != m0_traced_sm_polygons_iter_cend;</div>
<div class="line"><span class="lineno"> 7080</span>         ++traced_sm_polygon_iter) {</div>
<div class="line"><span class="lineno"> 7081</span>        <span class="keyword">const</span> <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a>&amp; traced_sm_polygon = *traced_sm_polygon_iter;</div>
<div class="line"><span class="lineno"> 7082</span> </div>
<div class="line"><span class="lineno"> 7083</span>        <span class="comment">// for each halfedge of polygon</span></div>
<div class="line"><span class="lineno"> 7084</span>        <span class="keywordflow">for</span> (traced_polygon_t::const_iterator traced_sm_polygon_halfedge_iter = traced_sm_polygon.cbegin();</div>
<div class="line"><span class="lineno"> 7085</span>             traced_sm_polygon_halfedge_iter != traced_sm_polygon.cend();</div>
<div class="line"><span class="lineno"> 7086</span>             ++traced_sm_polygon_halfedge_iter) {</div>
<div class="line"><span class="lineno"> 7087</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> i = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)<a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(traced_sm_polygon.cbegin(), traced_sm_polygon_halfedge_iter);</div>
<div class="line"><span class="lineno"> 7088</span> </div>
<div class="line"><span class="lineno"> 7089</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; cur = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(traced_sm_polygon, i);</div>
<div class="line"><span class="lineno"> 7090</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; next = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(traced_sm_polygon, ((<span class="keywordtype">size_t</span>)i + 1) % traced_sm_polygon.size());</div>
<div class="line"><span class="lineno"> 7091</span>            m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af607b174b89bf1bf89c26672ef1647bb">set_next</a>(cur, next); <span class="comment">// update state</span></div>
<div class="line"><span class="lineno"> 7092</span>        }</div>
<div class="line"><span class="lineno"> 7093</span>    }</div>
<div class="line"><span class="lineno"> 7094</span> </div>
<div class="line"><span class="lineno"> 7095</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 7096</span> </div>
<div class="line"><span class="lineno"> 7098</span>    <span class="comment">// source-mesh partitioning</span></div>
<div class="line"><span class="lineno"> 7100</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 7101</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Source mesh partitioning&quot;</span>); <span class="comment">// &amp;&amp;&amp;&amp;&amp;</span></div>
<div class="line"><span class="lineno"> 7102</span> </div>
<div class="line"><span class="lineno"> 7103</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7104</span>    <span class="comment">// Here we partition the traced source-mesh polygons into disjoint connected components</span></div>
<div class="line"><span class="lineno"> 7105</span>    <span class="comment">// by circulating around each intersection point and creating a copy for</span></div>
<div class="line"><span class="lineno"> 7106</span>    <span class="comment">// each distinct connected component seen. In the case of a complete (through) cut,</span></div>
<div class="line"><span class="lineno"> 7107</span>    <span class="comment">// all intersection points are duplicated. However, in the case of a partial</span></div>
<div class="line"><span class="lineno"> 7108</span>    <span class="comment">// cut, we only duplicate the intersection points which are along the cut path</span></div>
<div class="line"><span class="lineno"> 7109</span>    <span class="comment">// but exclude those which are the terminal vertices of a sequence.</span></div>
<div class="line"><span class="lineno"> 7110</span>    <span class="comment">// A sequence here is an ordered list of edges passing through intersection</span></div>
<div class="line"><span class="lineno"> 7111</span>    <span class="comment">// points (along the cut path). In the case of a partial cut, a sequence</span></div>
<div class="line"><span class="lineno"> 7112</span>    <span class="comment">// does not form a loop.</span></div>
<div class="line"><span class="lineno"> 7113</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7114</span> </div>
<div class="line"><span class="lineno"> 7115</span>    <span class="comment">/*</span></div>
<div class="line"><span class="lineno"> 7116</span><span class="comment">  Goal:</span></div>
<div class="line"><span class="lineno"> 7117</span><span class="comment">  Assign the correct intersection point instance (descriptor) to each intersection halfedge.</span></div>
<div class="line"><span class="lineno"> 7118</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 7119</span><span class="comment">  For reference there following are the types of halfedges we have</span></div>
<div class="line"><span class="lineno"> 7120</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 7121</span><span class="comment">  class : instance : definition (what will happen)</span></div>
<div class="line"><span class="lineno"> 7122</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 7123</span><span class="comment">  0 : o--&gt;o : Exterior/Boundary (nothing, we already copied this type of edge into m1)</span></div>
<div class="line"><span class="lineno"> 7124</span><span class="comment">  1 : o--&gt;x : Exterior/Boundary (tgt may be assigned duplicate instance of descriptor)</span></div>
<div class="line"><span class="lineno"> 7125</span><span class="comment">  2 : x--&gt;o : Exterior/Boundary (src may be assigned duplicate instance of descriptor)</span></div>
<div class="line"><span class="lineno"> 7126</span><span class="comment">  3 : x--&gt;x : Interior OR Exterior/Boundary (tgt and src may be assigned duplicate instance of descriptor)</span></div>
<div class="line"><span class="lineno"> 7127</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 7128</span><span class="comment">  o - original-vertex</span></div>
<div class="line"><span class="lineno"> 7129</span><span class="comment">  x - intersection-vertex/point</span></div>
<div class="line"><span class="lineno"> 7130</span><span class="comment">*/</span></div>
<div class="line"><span class="lineno"> 7131</span> </div>
<div class="line"><span class="lineno"> 7132</span>    <span class="comment">// This data structure will map the descriptors of intersection-halfedges in &quot;m0&quot;</span></div>
<div class="line"><span class="lineno"> 7133</span>    <span class="comment">// to their descriptor in &quot;m1&quot;. Thus, some halfedges (in &quot;m0&quot;) will be mapped to</span></div>
<div class="line"><span class="lineno"> 7134</span>    <span class="comment">// new halfedges which are not in &quot;m0&quot; but will be added into &quot;m1&quot;.</span></div>
<div class="line"><span class="lineno"> 7135</span>    std::unordered_map&lt;</div>
<div class="line"><span class="lineno"> 7136</span>        <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a>, <span class="comment">// &quot;m0&quot; halfedge</span></div>
<div class="line"><span class="lineno"> 7137</span>        <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> <span class="comment">// &quot;m1&quot; version</span></div>
<div class="line"><span class="lineno"> 7138</span>        &gt;</div>
<div class="line"><span class="lineno"> 7139</span>        m0_to_m1_ihe;</div>
<div class="line"><span class="lineno"> 7140</span> </div>
<div class="line"><span class="lineno"> 7141</span>    <span class="comment">// lamda checks the intersection halfedge that has not been transformed/processed already</span></div>
<div class="line"><span class="lineno"> 7142</span>    std::function&lt;bool(<span class="keyword">const</span> std::pair&lt;hd_t, bool&gt;&amp;)&gt; check_if_halfedge_is_transformed = [&amp;](<span class="keyword">const</span> std::pair&lt;hd_t, bool&gt;&amp; e) {</div>
<div class="line"><span class="lineno"> 7143</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; m0_ihe = e.first;</div>
<div class="line"><span class="lineno"> 7144</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_ihe_src_vertex = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(m0_ihe);</div>
<div class="line"><span class="lineno"> 7145</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> src_is_ivertex = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0_ihe_src_vertex, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 7146</span> </div>
<div class="line"><span class="lineno"> 7147</span>        <span class="keywordflow">if</span> (src_is_ivertex) {</div>
<div class="line"><span class="lineno"> 7148</span>            <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// has to be original vertex</span></div>
<div class="line"><span class="lineno"> 7149</span>        }</div>
<div class="line"><span class="lineno"> 7150</span> </div>
<div class="line"><span class="lineno"> 7151</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> is_transformed = e.second;</div>
<div class="line"><span class="lineno"> 7152</span> </div>
<div class="line"><span class="lineno"> 7153</span>        <span class="keywordflow">if</span> (is_transformed) {</div>
<div class="line"><span class="lineno"> 7154</span>            <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// cannot have been transformed already.</span></div>
<div class="line"><span class="lineno"> 7155</span>        }</div>
<div class="line"><span class="lineno"> 7156</span> </div>
<div class="line"><span class="lineno"> 7157</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a>&amp; m0_ihe_tgt_vertex = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m0_ihe);</div>
<div class="line"><span class="lineno"> 7158</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> tgt_is_ivertex = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0_ihe_tgt_vertex, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 7159</span> </div>
<div class="line"><span class="lineno"> 7160</span>        <span class="keywordflow">if</span> (tgt_is_ivertex) { <span class="comment">// tgt is an intersection point</span></div>
<div class="line"><span class="lineno"> 7161</span> </div>
<div class="line"><span class="lineno"> 7162</span>            <span class="comment">// is the current halfedge used to traced a polygon (i.e. those we stored in &quot;m0&quot;)</span></div>
<div class="line"><span class="lineno"> 7163</span>            <span class="keyword">const</span> <span class="keywordtype">bool</span> is_incident_to_traced_polygon = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, m0_ihe).size() &gt; 0 <span class="comment">/*m0_h_to_ply.find(m0_ihe) != m0_h_to_ply.end()*/</span>;</div>
<div class="line"><span class="lineno"> 7164</span> </div>
<div class="line"><span class="lineno"> 7165</span>            <span class="keywordflow">if</span> (is_incident_to_traced_polygon) {</div>
<div class="line"><span class="lineno"> 7166</span>                <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7167</span>                <span class="comment">// We now need to make sure that the preceeding (prevous) halfedge of the</span></div>
<div class="line"><span class="lineno"> 7168</span>                <span class="comment">// current (in its polygon) is class0 or class2</span></div>
<div class="line"><span class="lineno"> 7169</span>                <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7170</span> </div>
<div class="line"><span class="lineno"> 7171</span>                <span class="comment">// find coincident polygon</span></div>
<div class="line"><span class="lineno"> 7172</span>                <span class="keyword">const</span> std::vector&lt;int&gt;&amp; incident_polys = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, m0_ihe);</div>
<div class="line"><span class="lineno"> 7173</span> </div>
<div class="line"><span class="lineno"> 7174</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(incident_polys.size() == 1); <span class="comment">// class-1 halfedges are incident to exactly one polygon</span></div>
<div class="line"><span class="lineno"> 7175</span> </div>
<div class="line"><span class="lineno"> 7176</span>                <span class="keyword">const</span> <span class="keywordtype">int</span> incident_poly_idx = incident_polys.front();</div>
<div class="line"><span class="lineno"> 7177</span>                <span class="keyword">const</span> <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a>&amp; incident_poly = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_polygons, incident_poly_idx);</div>
<div class="line"><span class="lineno"> 7178</span>                <span class="comment">// find the reference to the current halfedde (in the traced polygon)</span></div>
<div class="line"><span class="lineno"> 7179</span>                traced_polygon_t::const_iterator he_find_iter = std::find(incident_poly.cbegin(), incident_poly.cend(), m0_ihe);</div>
<div class="line"><span class="lineno"> 7180</span> </div>
<div class="line"><span class="lineno"> 7181</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(he_find_iter != incident_poly.cend()); <span class="comment">// if its incident to a polygon then that polygon must have it!</span></div>
<div class="line"><span class="lineno"> 7182</span> </div>
<div class="line"><span class="lineno"> 7183</span>                <span class="comment">// halfedge index in polygon</span></div>
<div class="line"><span class="lineno"> 7184</span>                <span class="keyword">const</span> <span class="keywordtype">int</span> he_index = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)<a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(incident_poly.cbegin(), he_find_iter);</div>
<div class="line"><span class="lineno"> 7185</span>                <span class="comment">// index of previous halfedge in polygon</span></div>
<div class="line"><span class="lineno"> 7186</span>                <span class="keyword">const</span> <span class="keywordtype">int</span> preceeding_he_idx = <a class="code hl_function" href="../../d5/d60/utils_8h.html#ad42d4789f60996516823b4b4cfb9c04d">wrap_integer</a>(he_index - 1, 0, (<span class="keywordtype">int</span>)incident_poly.size() - 1);</div>
<div class="line"><span class="lineno"> 7187</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; preceeding_he = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(incident_poly, preceeding_he_idx);</div>
<div class="line"><span class="lineno"> 7188</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> preceeding_he_src = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(preceeding_he);</div>
<div class="line"><span class="lineno"> 7189</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> preceeding_he_tgt = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(preceeding_he);</div>
<div class="line"><span class="lineno"> 7190</span>                <span class="keyword">const</span> <span class="keywordtype">bool</span> preceeding_he_src_is_ivertex = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(preceeding_he_src, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 7191</span>                <span class="keyword">const</span> <span class="keywordtype">bool</span> preceeding_he_tgt_is_ivertex = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(preceeding_he_tgt, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 7192</span>                <span class="comment">// classify preceeding halfedge</span></div>
<div class="line"><span class="lineno"> 7193</span>                <span class="keyword">const</span> <span class="keywordtype">bool</span> preceeding_he_is_class0 = !preceeding_he_src_is_ivertex &amp;&amp; !preceeding_he_tgt_is_ivertex; <span class="comment">// o--&gt;o</span></div>
<div class="line"><span class="lineno"> 7194</span>                <span class="keyword">const</span> <span class="keywordtype">bool</span> preceeding_he_is_class2 = preceeding_he_src_is_ivertex &amp;&amp; !preceeding_he_tgt_is_ivertex; <span class="comment">// x--&gt;o</span></div>
<div class="line"><span class="lineno"> 7195</span>                <span class="comment">// count the original vertices that are contained in the polygon the current halfedge.</span></div>
<div class="line"><span class="lineno"> 7196</span>                <span class="comment">// we need this check to detect a special edge case.</span></div>
<div class="line"><span class="lineno"> 7197</span>                <span class="keyword">const</span> <span class="keywordtype">int</span> overtices_in_poly = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)std::count_if(</div>
<div class="line"><span class="lineno"> 7198</span>                    incident_poly.cbegin(), incident_poly.cend(),</div>
<div class="line"><span class="lineno"> 7199</span>                    [&amp;](<span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; e) { <span class="keywordflow">return</span> !<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(e), ps_vtx_cnt); });</div>
<div class="line"><span class="lineno"> 7200</span> </div>
<div class="line"><span class="lineno"> 7201</span>                <span class="keywordflow">return</span> (preceeding_he_is_class0 || (preceeding_he_is_class2 &amp;&amp; overtices_in_poly == 1));</div>
<div class="line"><span class="lineno"> 7202</span>            }</div>
<div class="line"><span class="lineno"> 7203</span>        }</div>
<div class="line"><span class="lineno"> 7204</span> </div>
<div class="line"><span class="lineno"> 7205</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 7206</span>    };</div>
<div class="line"><span class="lineno"> 7207</span> </div>
<div class="line"><span class="lineno"> 7208</span>    <span class="comment">// our routine will start from an untransformed class-1 intersection-halfedge. We do this because it makes</span></div>
<div class="line"><span class="lineno"> 7209</span>    <span class="comment">// transformation process easier for us by reducing the number of steps.</span></div>
<div class="line"><span class="lineno"> 7210</span>    std::unordered_map&lt;hd_t, bool&gt;::iterator m0_1st_sm_ihe_fiter = std::find_if( <span class="comment">// for each src-mesh intersection halfedge</span></div>
<div class="line"><span class="lineno"> 7211</span>        m0_sm_ihe_to_flag.begin(),</div>
<div class="line"><span class="lineno"> 7212</span>        m0_sm_ihe_to_flag.end(),</div>
<div class="line"><span class="lineno"> 7213</span>        check_if_halfedge_is_transformed);</div>
<div class="line"><span class="lineno"> 7214</span> </div>
<div class="line"><span class="lineno"> 7215</span>    <span class="comment">// Here we have queue of intersection halfedges which will be used to begin a transformation walk/traversal</span></div>
<div class="line"><span class="lineno"> 7216</span>    <span class="comment">// around the polygon of each contained halfedge. For each polygon along the cut path there will ever be at</span></div>
<div class="line"><span class="lineno"> 7217</span>    <span class="comment">// most one of its halfedges in this queue.</span></div>
<div class="line"><span class="lineno"> 7218</span>    <span class="comment">// To assign a polygon along the cut-path to the correct connected component, we will traverse a subset (or full set)</span></div>
<div class="line"><span class="lineno"> 7219</span>    <span class="comment">// of it halfedges in order to assign the correct instance of each referenced intersection point to the traversed</span></div>
<div class="line"><span class="lineno"> 7220</span>    <span class="comment">// halfedge (s).</span></div>
<div class="line"><span class="lineno"> 7221</span>    std::vector&lt;hd_t&gt; m0_ox_hlist;</div>
<div class="line"><span class="lineno"> 7222</span> </div>
<div class="line"><span class="lineno"> 7223</span>    <span class="comment">// used to specifically prevent duplicate ox and xo halfedges</span></div>
<div class="line"><span class="lineno"> 7224</span>    <span class="comment">// Map-key=an intersection-vertex in m1;</span></div>
<div class="line"><span class="lineno"> 7225</span>    <span class="comment">// Map-value=list of (vertex,halfedge) pairs.</span></div>
<div class="line"><span class="lineno"> 7226</span>    <span class="comment">//  The first elem in a pair is a vertex connected to [Map-key].</span></div>
<div class="line"><span class="lineno"> 7227</span>    <span class="comment">//  The second element in a pair is the halfedge connecting [Map-key] and the first element in the pair</span></div>
<div class="line"><span class="lineno"> 7228</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7229</span>    <span class="comment">// NOTE: [Map-key] is always the src vertex of the halfedge which is the second element in a pair of [Map-value]</span></div>
<div class="line"><span class="lineno"> 7230</span>    std::unordered_map&lt;</div>
<div class="line"><span class="lineno"> 7231</span>        <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a>, <span class="comment">// &quot;m1&quot; intersection point</span></div>
<div class="line"><span class="lineno"> 7232</span>        std::vector&lt; <span class="comment">// list of (vertex,halfedge) pairs.</span></div>
<div class="line"><span class="lineno"> 7233</span>            std::pair&lt;</div>
<div class="line"><span class="lineno"> 7234</span>                <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a>, <span class="comment">// vertex connected to &quot;m1&quot; intersection point (i.e. the key of this map)</span></div>
<div class="line"><span class="lineno"> 7235</span>                <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> <span class="comment">// the halfedge connecting the vertices</span></div>
<div class="line"><span class="lineno"> 7236</span>                &gt;&gt;&gt;</div>
<div class="line"><span class="lineno"> 7237</span>        m1_ivtx_to_h;</div>
<div class="line"><span class="lineno"> 7238</span> </div>
<div class="line"><span class="lineno"> 7239</span>    <span class="comment">// At this point we also introduce the notion of a so-called &quot;strongly connected border set&quot; (SCBS).</span></div>
<div class="line"><span class="lineno"> 7240</span>    <span class="comment">// An SCBS is set of adjacent source-mesh polygons along the partitioned cut-path (&quot;partitioned&quot; implies that the</span></div>
<div class="line"><span class="lineno"> 7241</span>    <span class="comment">// source-mesh polygons along the cut-path are no longer &quot;topologically connected&quot;).</span></div>
<div class="line"><span class="lineno"> 7242</span>    <span class="comment">// int strongly_connected_sm_boundary_seq_iter_id = -1;</span></div>
<div class="line"><span class="lineno"> 7243</span> </div>
<div class="line"><span class="lineno"> 7244</span>    <span class="comment">// for each strongly-connected set of sm-boundary sequences.</span></div>
<div class="line"><span class="lineno"> 7245</span>    <span class="comment">// one iteration pertains to a transformation of a set of sm-boundary sequences which all belong to the same connected ccsponent.</span></div>
<div class="line"><span class="lineno"> 7246</span>    <span class="comment">// sets of sm-boundary sequences which belong to the same (sm) connected component may be produced different iterations.</span></div>
<div class="line"><span class="lineno"> 7247</span> </div>
<div class="line"><span class="lineno"> 7248</span>    <span class="keywordflow">do</span> {</div>
<div class="line"><span class="lineno"> 7249</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7250</span> </div>
<div class="line"><span class="lineno"> 7251</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((m0_1st_sm_ihe_fiter != m0_sm_ihe_to_flag.end())); <span class="comment">// their must be at least one halfedge from which we can start walking!</span></div>
<div class="line"><span class="lineno"> 7252</span> </div>
<div class="line"><span class="lineno"> 7253</span>        m0_ox_hlist.push_back(m0_1st_sm_ihe_fiter-&gt;first); <span class="comment">// add to queue</span></div>
<div class="line"><span class="lineno"> 7254</span> </div>
<div class="line"><span class="lineno"> 7255</span>        <span class="comment">// The following do-while loop will transform/process the halfedges which belong</span></div>
<div class="line"><span class="lineno"> 7256</span>        <span class="comment">// to exactly one SCBS</span></div>
<div class="line"><span class="lineno"> 7257</span>        <span class="keywordflow">do</span> {</div>
<div class="line"><span class="lineno"> 7258</span> </div>
<div class="line"><span class="lineno"> 7259</span>            <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m0_cur_h = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno"> 7260</span>            <span class="comment">// get first intersection halfedge which determine&#39;s the first polygon of the current SCBS.</span></div>
<div class="line"><span class="lineno"> 7261</span>            <span class="comment">// Note that the current SCBS is determined implicitely from this initial intersection halfedge.</span></div>
<div class="line"><span class="lineno"> 7262</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> seq_init_ihe = m0_ox_hlist.back();</div>
<div class="line"><span class="lineno"> 7263</span> </div>
<div class="line"><span class="lineno"> 7264</span>            m0_ox_hlist.pop_back(); <span class="comment">// remove &quot;seq_init_ihe&quot; from queue</span></div>
<div class="line"><span class="lineno"> 7265</span>            <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m0_nxt_h = seq_init_ihe;</div>
<div class="line"><span class="lineno"> 7266</span> </div>
<div class="line"><span class="lineno"> 7267</span>            <span class="comment">// The following do-while loop will transform/process the halfedges which belong</span></div>
<div class="line"><span class="lineno"> 7268</span>            <span class="comment">// to [a part] of the current SCBS (i.e. a swept surface of polygons next to the</span></div>
<div class="line"><span class="lineno"> 7269</span>            <span class="comment">// partitioned cut-path).</span></div>
<div class="line"><span class="lineno"> 7270</span>            <span class="keywordflow">do</span> { <span class="comment">// process ih sequence starting from &quot;seq_init_ihe&quot;</span></div>
<div class="line"><span class="lineno"> 7271</span> </div>
<div class="line"><span class="lineno"> 7272</span>                m0_cur_h = m0_nxt_h; <span class="comment">// current</span></div>
<div class="line"><span class="lineno"> 7273</span> </div>
<div class="line"><span class="lineno"> 7274</span>                m0_nxt_h = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a9d7a7440367b78413f762626d2d7dd43">next</a>(m0_cur_h); <span class="comment">// next</span></div>
<div class="line"><span class="lineno"> 7275</span> </div>
<div class="line"><span class="lineno"> 7276</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_cur_h_src = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(m0_cur_h);</div>
<div class="line"><span class="lineno"> 7277</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_cur_h_tgt = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m0_cur_h);</div>
<div class="line"><span class="lineno"> 7278</span>                <span class="keyword">const</span> <span class="keywordtype">bool</span> m0_cur_h_src_is_ivtx = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0_cur_h_src, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 7279</span>                <span class="keyword">const</span> <span class="keywordtype">bool</span> m0_cur_h_tgt_is_ivtx = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0_cur_h_tgt, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 7280</span>                <span class="keyword">const</span> <span class="keywordtype">bool</span> m0_cur_h_is_ox = !m0_cur_h_src_is_ivtx &amp;&amp; m0_cur_h_tgt_is_ivtx; <span class="comment">// o--&gt;x</span></div>
<div class="line"><span class="lineno"> 7281</span> </div>
<div class="line"><span class="lineno"> 7282</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)m0_cur_h_src &lt; m0_to_m1_vtx.size() <span class="comment">/* m0_to_m1_vtx.find(m0_cur_h_src) != m0_to_m1_vtx.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 7283</span> </div>
<div class="line"><span class="lineno"> 7284</span>                <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m1_cur_h_src = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_m1_vtx, m0_cur_h_src); <span class="comment">// from m0 to m1 descriptor</span></div>
<div class="line"><span class="lineno"> 7285</span> </div>
<div class="line"><span class="lineno"> 7286</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)m0_cur_h_tgt &lt; m0_to_m1_vtx.size() <span class="comment">/*m0_to_m1_vtx.find(m0_cur_h_tgt) != m0_to_m1_vtx.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 7287</span> </div>
<div class="line"><span class="lineno"> 7288</span>                <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m1_cur_h_tgt = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_m1_vtx, m0_cur_h_tgt); <span class="comment">// from m0 to m1 descriptor</span></div>
<div class="line"><span class="lineno"> 7289</span> </div>
<div class="line"><span class="lineno"> 7290</span>                <span class="comment">// o--&gt;x OR x--&gt;x</span></div>
<div class="line"><span class="lineno"> 7291</span>                <span class="keywordflow">if</span> (m0_cur_h_tgt_is_ivtx) { <span class="comment">// tgt vertex of current halfedge is an intersection point</span></div>
<div class="line"><span class="lineno"> 7292</span> </div>
<div class="line"><span class="lineno"> 7293</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7294</span>                    <span class="comment">// check if the next halfedge has been processed/transformed</span></div>
<div class="line"><span class="lineno"> 7295</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7296</span> </div>
<div class="line"><span class="lineno"> 7297</span>                    <span class="comment">// can we find the m1 version of the next halfedge</span></div>
<div class="line"><span class="lineno"> 7298</span>                    std::unordered_map&lt;hd_t, hd_t&gt;::const_iterator m1_nxt_h_fiter = m0_to_m1_ihe.find(m0_nxt_h);</div>
<div class="line"><span class="lineno"> 7299</span>                    <span class="keyword">const</span> <span class="keywordtype">bool</span> nxt_is_processed = m1_nxt_h_fiter != m0_to_m1_ihe.cend();</div>
<div class="line"><span class="lineno"> 7300</span> </div>
<div class="line"><span class="lineno"> 7301</span>                    <span class="keywordflow">if</span> (nxt_is_processed) {</div>
<div class="line"><span class="lineno"> 7302</span>                        <span class="comment">// Since the next halfedge has been processed, we can simply set</span></div>
<div class="line"><span class="lineno"> 7303</span>                        <span class="comment">// target vertex instance of the current (&quot;m1&quot;) halfedge to the source of the</span></div>
<div class="line"><span class="lineno"> 7304</span>                        <span class="comment">// next halfedge</span></div>
<div class="line"><span class="lineno"> 7305</span>                        m1_cur_h_tgt = m1.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(m1_nxt_h_fiter-&gt;second);</div>
<div class="line"><span class="lineno"> 7306</span>                    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 7307</span>                        <span class="comment">// otherwise, we need to determined the correct instance of the tgt</span></div>
<div class="line"><span class="lineno"> 7308</span>                        <span class="comment">// vertex to be used (see paper for details)</span></div>
<div class="line"><span class="lineno"> 7309</span>                        m1_cur_h_tgt = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a0299dc00caf656e5713f528574c77a02">resolve_intersection_point_descriptor</a>(ps, m0, m1, m0_cur_h, m0_cur_h_tgt, m1_cur_h_tgt, m0_cur_h_is_ox,</div>
<div class="line"><span class="lineno"> 7310</span>                            m0_h_to_ply, ivtx_to_incoming_hlist, m0_sm_ihe_to_flag, m0_ivtx_to_intersection_registry_entry, m0_to_m1_ihe, m0_to_ps_vtx, ps_vtx_cnt, sm_vtx_cnt, sm_face_count, m0_num_cutpath_halfedges);</div>
<div class="line"><span class="lineno"> 7311</span>                    }</div>
<div class="line"><span class="lineno"> 7312</span>                }</div>
<div class="line"><span class="lineno"> 7313</span> </div>
<div class="line"><span class="lineno"> 7314</span>                <span class="comment">// x--&gt;o OR x--&gt;x</span></div>
<div class="line"><span class="lineno"> 7315</span>                <span class="keywordflow">if</span> (m0_cur_h_src_is_ivtx) { <span class="comment">// src vertex of current halfedge is an intersection point</span></div>
<div class="line"><span class="lineno"> 7316</span>                    <span class="keywordflow">if</span> (m0_cur_h == seq_init_ihe) <span class="comment">// is it the first halfedge of the current SCBS?</span></div>
<div class="line"><span class="lineno"> 7317</span>                    {</div>
<div class="line"><span class="lineno"> 7318</span>                        <span class="comment">// get the opposite halfedge</span></div>
<div class="line"><span class="lineno"> 7319</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> opp = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(m0_cur_h); <span class="comment">// NOTE: m0_cur_h_src == target(opp)</span></div>
<div class="line"><span class="lineno"> 7320</span>                        <span class="comment">// we need to determined the correct instance of the src vertex to be used (see paper for details)</span></div>
<div class="line"><span class="lineno"> 7321</span>                        m1_cur_h_src = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a0299dc00caf656e5713f528574c77a02">resolve_intersection_point_descriptor</a>(ps, m0, m1, opp, m0_cur_h_src, m1_cur_h_src, m0_cur_h_is_ox,</div>
<div class="line"><span class="lineno"> 7322</span>                            m0_h_to_ply, ivtx_to_incoming_hlist, m0_sm_ihe_to_flag, m0_ivtx_to_intersection_registry_entry, m0_to_m1_ihe, m0_to_ps_vtx, ps_vtx_cnt, sm_vtx_cnt, sm_face_count, m0_num_cutpath_halfedges);</div>
<div class="line"><span class="lineno"> 7323</span>                    } <span class="keywordflow">else</span> { <span class="comment">// current halfedge is not the first halfedge of the current SCBS</span></div>
<div class="line"><span class="lineno"> 7324</span> </div>
<div class="line"><span class="lineno"> 7325</span>                        <span class="comment">// get the previous halfedge</span></div>
<div class="line"><span class="lineno"> 7326</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m0_prv_h = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ab4bb1cdfa7306e352d20eb92417580ed">prev</a>(m0_cur_h);</div>
<div class="line"><span class="lineno"> 7327</span> </div>
<div class="line"><span class="lineno"> 7328</span>                        <span class="comment">// The previous halfedge must have been transformed since the current halfedge</span></div>
<div class="line"><span class="lineno"> 7329</span>                        <span class="comment">// is not the first halfedge of the current SCBS. TODO: explain further for why</span></div>
<div class="line"><span class="lineno"> 7330</span>                        <span class="comment">// this is true when halfedge is x--&gt;x (i.e. exterior, and from scoop cut)</span></div>
<div class="line"><span class="lineno"> 7331</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_to_m1_ihe.find(m0_prv_h) != m0_to_m1_ihe.cend());</div>
<div class="line"><span class="lineno"> 7332</span> </div>
<div class="line"><span class="lineno"> 7333</span>                        <span class="comment">// get transformed instance of previous halfedge (&quot;m1&quot; version )</span></div>
<div class="line"><span class="lineno"> 7334</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m1_prv_h = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_m1_ihe, m0_prv_h);</div>
<div class="line"><span class="lineno"> 7335</span>                        <span class="comment">// Since the previous halfedge has been processed, we can simply set</span></div>
<div class="line"><span class="lineno"> 7336</span>                        <span class="comment">// src vertex instance of the current (&quot;m1&quot;) halfedge to the source of the</span></div>
<div class="line"><span class="lineno"> 7337</span>                        <span class="comment">// next halfedge</span></div>
<div class="line"><span class="lineno"> 7338</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m1_prv_h_tgt = m1.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m1_prv_h);</div>
<div class="line"><span class="lineno"> 7339</span>                        m1_cur_h_src = m1_prv_h_tgt;</div>
<div class="line"><span class="lineno"> 7340</span>                    }</div>
<div class="line"><span class="lineno"> 7341</span>                }</div>
<div class="line"><span class="lineno"> 7342</span> </div>
<div class="line"><span class="lineno"> 7343</span>                <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7344</span>                <span class="comment">// Now that we have resolved the correct descriptor instance to use for the src and/or tgt vertex,</span></div>
<div class="line"><span class="lineno"> 7345</span>                <span class="comment">// we will create an edge in halfedge data structure (&quot;m1&quot;) connecting &quot;m1_cur_h_src&quot; and</span></div>
<div class="line"><span class="lineno"> 7346</span>                <span class="comment">// &quot;m1_cur_h_tgt&quot; if this edge does not already exist.</span></div>
<div class="line"><span class="lineno"> 7347</span>                <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7348</span> </div>
<div class="line"><span class="lineno"> 7349</span>                <span class="comment">// bool m1_cur_h_exists = false;</span></div>
<div class="line"><span class="lineno"> 7350</span>                <span class="comment">// const bool m0_cur_h_is_xx = m0_cur_h_src_is_ivtx &amp;&amp; m0_cur_h_tgt_is_ivtx;</span></div>
<div class="line"><span class="lineno"> 7351</span>                <span class="comment">// std::map&lt;vd_t, std::vector&lt;std::pair&lt;vd_t, hd_t&gt; &gt; &gt;::iterator fiter = m1_ivtx_to_h.end();</span></div>
<div class="line"><span class="lineno"> 7352</span> </div>
<div class="line"><span class="lineno"> 7353</span>                <span class="keyword">const</span> <span class="keywordtype">bool</span> is_boundary_halfedge = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#ad0e7884ca4d03bad54f0f83d198676e5">m0_is_polygon_boundary_halfedge</a>(m0_cur_h, m0_num_cutpath_halfedges);</div>
<div class="line"><span class="lineno"> 7354</span>                <span class="keywordtype">bool</span> m0_cur_h_is_exterior = is_boundary_halfedge;</div>
<div class="line"><span class="lineno"> 7355</span> </div>
<div class="line"><span class="lineno"> 7356</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 7357</span>                    <span class="keywordflow">if</span> (m0_cur_h_is_xx)</div>
<div class="line"><span class="lineno"> 7358</span>                    {</div>
<div class="line"><span class="lineno"> 7359</span>                        <span class="comment">//const hd_t m0_cur_h_src_ps_h = SAFE_ACCESS(m0_ivtx_to_ps_edge, m0_cur_h_src);</span></div>
<div class="line"><span class="lineno"> 7360</span>                        <span class="comment">//const hd_t m0_cur_h_tgt_ps_h = SAFE_ACCESS(m0_ivtx_to_ps_edge, m0_cur_h_tgt);</span></div>
<div class="line"><span class="lineno"> 7361</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)m0_cur_h_src - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(m0_cur_h_src) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 7362</span>                        <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt; &amp;m0_cur_h_src_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, m0_cur_h_src - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 7363</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> m0_cur_h_src_ps_e = m0_cur_h_src_ipair.first; <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_edge, m0_cur_h_src); //ps.edge(m0_cur_h_src_ps_h);</span></div>
<div class="line"><span class="lineno"> 7364</span> </div>
<div class="line"><span class="lineno"> 7365</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)m0_cur_h_tgt - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(m0_cur_h_tgt) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 7366</span>                        <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt; &amp;m0_cur_h_tgt_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, m0_cur_h_tgt - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 7367</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> m0_cur_h_tgt_ps_e = m0_cur_h_tgt_ipair.first; <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_edge, m0_cur_h_tgt); // ps.edge(m0_cur_h_tgt_ps_h);</span></div>
<div class="line"><span class="lineno"> 7368</span>                        m0_cur_h_is_exterior = (m0_cur_h_src_ps_e == m0_cur_h_tgt_ps_e);</div>
<div class="line"><span class="lineno"> 7369</span>                    }</div>
<div class="line"><span class="lineno"> 7370</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 7371</span>                <span class="comment">// get the opposite of the current halfedge (&quot;m0&quot;)</span></div>
<div class="line"><span class="lineno"> 7372</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> opp = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(m0_cur_h);</div>
<div class="line"><span class="lineno"> 7373</span>                <span class="comment">// check if this opposite halfedge was used to traced a polygon</span></div>
<div class="line"><span class="lineno"> 7374</span>                <span class="keyword">const</span> <span class="keywordtype">bool</span> opp_used_for_tracing = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, opp).size() &gt; 0 <span class="comment">/*m0_h_to_ply.find(opp) != m0_h_to_ply.end()*/</span>;</div>
<div class="line"><span class="lineno"> 7375</span> </div>
<div class="line"><span class="lineno"> 7376</span>                <span class="comment">// if 1) the current halfedge is an interior halfedge (x--&gt;x), OR</span></div>
<div class="line"><span class="lineno"> 7377</span>                <span class="comment">// 2) the  current halfedge is an exterior halfedge AND it has not been processed</span></div>
<div class="line"><span class="lineno"> 7378</span>                <span class="keywordflow">if</span> (!m0_cur_h_is_exterior || (m0_cur_h_is_exterior &amp;&amp; m0_to_m1_ihe.find(m0_cur_h) == m0_to_m1_ihe.cend())) {</div>
<div class="line"><span class="lineno"> 7379</span> </div>
<div class="line"><span class="lineno"> 7380</span>                    <span class="comment">// create processed version (i.e. &quot;m1&quot; version) of &quot;m0_cur_h&quot;</span></div>
<div class="line"><span class="lineno"> 7381</span>                    <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m1_cur_h = m1.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ae64649dd61e0c188c547c686abc8a19e">add_edge</a>(m1_cur_h_src, m1_cur_h_tgt);</div>
<div class="line"><span class="lineno"> 7382</span> </div>
<div class="line"><span class="lineno"> 7383</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m1_cur_h != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>());</div>
<div class="line"><span class="lineno"> 7384</span> </div>
<div class="line"><span class="lineno"> 7385</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7386</span>                    <span class="comment">// here, we update the list containing the vertices and halfedge that are connected</span></div>
<div class="line"><span class="lineno"> 7387</span>                    <span class="comment">// to the &quot;m1_cur_h_src&quot; and &quot;m1_cur_h_tgt&quot; i.e. adjacency information</span></div>
<div class="line"><span class="lineno"> 7388</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7389</span> </div>
<div class="line"><span class="lineno"> 7390</span>                    <span class="keywordflow">if</span> (m0_cur_h_is_exterior) { <span class="comment">// is the current halfedge an exterior halfedge..?</span></div>
<div class="line"><span class="lineno"> 7391</span> </div>
<div class="line"><span class="lineno"> 7392</span>                        <span class="comment">// find entry in the adjancency vector</span></div>
<div class="line"><span class="lineno"> 7393</span> </div>
<div class="line"><span class="lineno"> 7394</span>                        <span class="comment">// src</span></div>
<div class="line"><span class="lineno"> 7395</span>                        std::unordered_map&lt;vd_t, std::vector&lt;std::pair&lt;vd_t, hd_t&gt;&gt;&gt;::iterator fiter = m1_ivtx_to_h.find(m1_cur_h_src);</div>
<div class="line"><span class="lineno"> 7396</span> </div>
<div class="line"><span class="lineno"> 7397</span>                        <span class="keywordflow">if</span> (fiter != m1_ivtx_to_h.cend()) <span class="comment">// check src&#39;s entry exists</span></div>
<div class="line"><span class="lineno"> 7398</span>                        {</div>
<div class="line"><span class="lineno"> 7399</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(std::find_if(fiter-&gt;second.cbegin(), fiter-&gt;second.cend(), [&amp;](<span class="keyword">const</span> std::pair&lt;vd_t, hd_t&gt;&amp; p) { return p.first == m1_cur_h_tgt; }) == fiter-&gt;second.cend());</div>
<div class="line"><span class="lineno"> 7400</span>                            fiter-&gt;second.emplace_back(m1_cur_h_tgt, m1_cur_h); <span class="comment">// record connection and save connecting halfedge</span></div>
<div class="line"><span class="lineno"> 7401</span>                        } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 7402</span>                            std::pair&lt;std::unordered_map&lt;vd_t, std::vector&lt;std::pair&lt;vd_t, hd_t&gt;&gt;&gt;::iterator, <span class="keywordtype">bool</span>&gt; p = m1_ivtx_to_h.emplace(m1_cur_h_src, std::vector&lt;std::pair&lt;vd_t, hd_t&gt;&gt;());</div>
<div class="line"><span class="lineno"> 7403</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(p.second == <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 7404</span>                            fiter = p.first;</div>
<div class="line"><span class="lineno"> 7405</span>                            fiter-&gt;second.emplace_back(m1_cur_h_tgt, m1_cur_h);</div>
<div class="line"><span class="lineno"> 7406</span>                        }</div>
<div class="line"><span class="lineno"> 7407</span> </div>
<div class="line"><span class="lineno"> 7408</span>                        <span class="comment">// repeat for tgt</span></div>
<div class="line"><span class="lineno"> 7409</span> </div>
<div class="line"><span class="lineno"> 7410</span>                        fiter = m1_ivtx_to_h.find(m1_cur_h_tgt); <span class="comment">// check if the tgt&#39;s entry exists and update it</span></div>
<div class="line"><span class="lineno"> 7411</span> </div>
<div class="line"><span class="lineno"> 7412</span>                        <span class="keywordflow">if</span> (fiter != m1_ivtx_to_h.cend()) <span class="comment">// check tgt&#39;s entry exists</span></div>
<div class="line"><span class="lineno"> 7413</span>                        {</div>
<div class="line"><span class="lineno"> 7414</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(std::find_if(fiter-&gt;second.cbegin(), fiter-&gt;second.cend(), [&amp;](<span class="keyword">const</span> std::pair&lt;vd_t, hd_t&gt;&amp; p) { return p.first == m1_cur_h_src; }) == fiter-&gt;second.cend());</div>
<div class="line"><span class="lineno"> 7415</span>                            fiter-&gt;second.emplace_back(m1_cur_h_src, m1.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(m1_cur_h)); <span class="comment">// record that it is connected to src (by the opp he of m1_cur_h)</span></div>
<div class="line"><span class="lineno"> 7416</span>                        } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 7417</span>                            std::pair&lt;std::unordered_map&lt;vd_t, std::vector&lt;std::pair&lt;vd_t, hd_t&gt;&gt;&gt;::iterator, <span class="keywordtype">bool</span>&gt; p = m1_ivtx_to_h.emplace(m1_cur_h_tgt, std::vector&lt;std::pair&lt;vd_t, hd_t&gt;&gt;());</div>
<div class="line"><span class="lineno"> 7418</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(p.second == <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 7419</span>                            fiter = p.first;</div>
<div class="line"><span class="lineno"> 7420</span>                            fiter-&gt;second.emplace_back(m1_cur_h_src, m1.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(m1_cur_h)); <span class="comment">// record that it is connected to src (by the opp he of m1_cur_h)</span></div>
<div class="line"><span class="lineno"> 7421</span>                        }</div>
<div class="line"><span class="lineno"> 7422</span>                    }</div>
<div class="line"><span class="lineno"> 7423</span> </div>
<div class="line"><span class="lineno"> 7424</span>                    <span class="comment">// map m0 to m1 version of current halfedge</span></div>
<div class="line"><span class="lineno"> 7425</span>                    m0_to_m1_ihe.emplace(m0_cur_h, m1_cur_h);</div>
<div class="line"><span class="lineno"> 7426</span> </div>
<div class="line"><span class="lineno"> 7427</span>                    <span class="comment">// if 1) the current halfedge is an exterior halfedge, AND</span></div>
<div class="line"><span class="lineno"> 7428</span>                    <span class="comment">// 2) the opposite of the current halfedge was used to trace a polygon</span></div>
<div class="line"><span class="lineno"> 7429</span>                    <span class="keywordflow">if</span> (m0_cur_h_is_exterior &amp;&amp; opp_used_for_tracing) {</div>
<div class="line"><span class="lineno"> 7430</span>                        <span class="comment">// Thanks of the halfedge data structure (each edge has 2 halfedges),</span></div>
<div class="line"><span class="lineno"> 7431</span>                        <span class="comment">// we also have the m1 version/copy of opposite halfedge.</span></div>
<div class="line"><span class="lineno"> 7432</span>                        <span class="comment">// NOTE however, the opposite halfedge it is still not &quot;processed&quot;, and</span></div>
<div class="line"><span class="lineno"> 7433</span>                        <span class="comment">// we will do so only when we traverse/walk it!</span></div>
<div class="line"><span class="lineno"> 7434</span>                        m0_to_m1_ihe.emplace(opp, m1.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(m1_cur_h));</div>
<div class="line"><span class="lineno"> 7435</span>                    }</div>
<div class="line"><span class="lineno"> 7436</span> </div>
<div class="line"><span class="lineno"> 7437</span>                    <span class="comment">// NOTE: keep in mind that two opposite halfedges which are interior halfedges</span></div>
<div class="line"><span class="lineno"> 7438</span>                    <span class="comment">// will belong to separate connected components after all processing is complete.</span></div>
<div class="line"><span class="lineno"> 7439</span>                    <span class="comment">// (exterior halfedges on the other hand will share the same connected component</span></div>
<div class="line"><span class="lineno"> 7440</span>                    <span class="comment">// as their opposites).</span></div>
<div class="line"><span class="lineno"> 7441</span>                } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 7442</span> </div>
<div class="line"><span class="lineno"> 7443</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7444</span>                    <span class="comment">// here, we have an exterior halfedge whose &quot;m1&quot; version has already been created.</span></div>
<div class="line"><span class="lineno"> 7445</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7446</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_to_m1_ihe.find(m0_cur_h) != m0_to_m1_ihe.cend());</div>
<div class="line"><span class="lineno"> 7447</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m1_cur_h = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_m1_ihe, m0_cur_h);</div>
<div class="line"><span class="lineno"> 7448</span>                }</div>
<div class="line"><span class="lineno"> 7449</span> </div>
<div class="line"><span class="lineno"> 7450</span>                <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7451</span>                <span class="comment">// update queue of ox halfedges which will be the initial halfedges of</span></div>
<div class="line"><span class="lineno"> 7452</span>                <span class="comment">// (potentially parts of) SCBS&#39;s to be processed</span></div>
<div class="line"><span class="lineno"> 7453</span>                <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7454</span> </div>
<div class="line"><span class="lineno"> 7455</span>                <span class="comment">// x--&gt;o</span></div>
<div class="line"><span class="lineno"> 7456</span>                <span class="keyword">const</span> <span class="keywordtype">bool</span> m0_cur_h_is_xo = m0_cur_h_src_is_ivtx &amp;&amp; !m0_cur_h_tgt_is_ivtx;</div>
<div class="line"><span class="lineno"> 7457</span> </div>
<div class="line"><span class="lineno"> 7458</span>                <span class="comment">// if 1) curreent halfedge is x--&gt;o AND 2) it&#39;s opposites has been using to trace a polygon, AND</span></div>
<div class="line"><span class="lineno"> 7459</span>                <span class="comment">// 3) this opposite has not already been processed</span></div>
<div class="line"><span class="lineno"> 7460</span>                <span class="keywordflow">if</span> (m0_cur_h_is_xo &amp;&amp; opp_used_for_tracing &amp;&amp; !<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_sm_ihe_to_flag, opp)) {</div>
<div class="line"><span class="lineno"> 7461</span> </div>
<div class="line"><span class="lineno"> 7462</span>                    <span class="comment">// get the next halfedge</span></div>
<div class="line"><span class="lineno"> 7463</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> nxt = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a9d7a7440367b78413f762626d2d7dd43">next</a>(m0_cur_h);</div>
<div class="line"><span class="lineno"> 7464</span>                    <span class="comment">// is the next halfedge an intersection halfedge &quot;o--&gt;x&quot;</span></div>
<div class="line"><span class="lineno"> 7465</span>                    <span class="keyword">const</span> <span class="keywordtype">bool</span> nxt_is_ih = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(nxt), ps_vtx_cnt); <span class="comment">// check if is last halfedge</span></div>
<div class="line"><span class="lineno"> 7466</span> </div>
<div class="line"><span class="lineno"> 7467</span>                    <span class="keywordflow">if</span> ((nxt_is_ih &amp;&amp; nxt == seq_init_ihe) || !nxt_is_ih) {</div>
<div class="line"><span class="lineno"> 7468</span>                        <span class="comment">// here we add the next SCBS&#39;s first halfedge from which SCBS processing will begin.</span></div>
<div class="line"><span class="lineno"> 7469</span>                        m0_ox_hlist.push_back(opp);</div>
<div class="line"><span class="lineno"> 7470</span>                    }</div>
<div class="line"><span class="lineno"> 7471</span>                }</div>
<div class="line"><span class="lineno"> 7472</span> </div>
<div class="line"><span class="lineno"> 7473</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_sm_ihe_to_flag.find(m0_cur_h) != m0_sm_ihe_to_flag.cend());</div>
<div class="line"><span class="lineno"> 7474</span> </div>
<div class="line"><span class="lineno"> 7475</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_sm_ihe_to_flag, m0_cur_h) = <span class="keyword">true</span>; <span class="comment">// mark as &quot;processed&quot;</span></div>
<div class="line"><span class="lineno"> 7476</span> </div>
<div class="line"><span class="lineno"> 7477</span>            } <span class="keywordflow">while</span> (</div>
<div class="line"><span class="lineno"> 7478</span>                <span class="comment">// &quot;next&quot; is ihalfedge</span></div>
<div class="line"><span class="lineno"> 7479</span>                (<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(m0_nxt_h), ps_vtx_cnt) || <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m0_nxt_h), ps_vtx_cnt)) &amp;&amp;</div>
<div class="line"><span class="lineno"> 7480</span>                <span class="comment">// &quot;next&quot; is not transformed. For case when ihalfedge-sequence forms a loop.</span></div>
<div class="line"><span class="lineno"> 7481</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_sm_ihe_to_flag, m0_nxt_h) == <span class="keyword">false</span>); <span class="comment">// TODO: I think this last condition is the same as &quot;m0_nxt_h&quot; == &quot;seq_init_ihe&quot; (try it bcz using m0_sm_ihe_to_flag will be slower)</span></div>
<div class="line"><span class="lineno"> 7482</span> </div>
<div class="line"><span class="lineno"> 7483</span>        } <span class="keywordflow">while</span> (!m0_ox_hlist.empty());</div>
<div class="line"><span class="lineno"> 7484</span> </div>
<div class="line"><span class="lineno"> 7485</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7486</span>        <span class="comment">// find next class1 halfedge which has not been transformed ( possibly in the same connected ccsponent )</span></div>
<div class="line"><span class="lineno"> 7487</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7488</span> </div>
<div class="line"><span class="lineno"> 7489</span>        m0_1st_sm_ihe_fiter = std::find_if( <span class="comment">// find o--&gt;x halfedge</span></div>
<div class="line"><span class="lineno"> 7490</span>            m0_sm_ihe_to_flag.begin(),</div>
<div class="line"><span class="lineno"> 7491</span>            m0_sm_ihe_to_flag.end(),</div>
<div class="line"><span class="lineno"> 7492</span>            check_if_halfedge_is_transformed);</div>
<div class="line"><span class="lineno"> 7493</span> </div>
<div class="line"><span class="lineno"> 7494</span>        <span class="comment">// True only if there exists a src-mesh ps-edge which has [at least] two intersection points</span></div>
<div class="line"><span class="lineno"> 7495</span>        <span class="comment">// This means that the source-mesh has a scoop cut (see example 19)</span></div>
<div class="line"><span class="lineno"> 7496</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> class1_ihalfedge_found = (m0_1st_sm_ihe_fiter != m0_sm_ihe_to_flag.end());</div>
<div class="line"><span class="lineno"> 7497</span> </div>
<div class="line"><span class="lineno"> 7498</span>        <span class="keywordflow">if</span> (!class1_ihalfedge_found) { <span class="comment">// The above search failed to find an untransformed class-1 halfedge.</span></div>
<div class="line"><span class="lineno"> 7499</span> </div>
<div class="line"><span class="lineno"> 7500</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7501</span>            <span class="comment">// So now we instead try to search an untransformed polygon-boundary interior-ihalfedge (x--&gt;x).</span></div>
<div class="line"><span class="lineno"> 7502</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7503</span> </div>
<div class="line"><span class="lineno"> 7504</span>            m0_1st_sm_ihe_fiter = std::find_if( <span class="comment">// for each intersection halfedge</span></div>
<div class="line"><span class="lineno"> 7505</span>                m0_sm_ihe_to_flag.begin(), m0_sm_ihe_to_flag.end(),</div>
<div class="line"><span class="lineno"> 7506</span>                [&amp;](<span class="keyword">const</span> std::pair&lt;hd_t, bool&gt;&amp; e) {</div>
<div class="line"><span class="lineno"> 7507</span>                    const bool is_transformed = e.second; <span class="comment">// has it already been transformed..?</span></div>
<div class="line"><span class="lineno"> 7508</span> </div>
<div class="line"><span class="lineno"> 7509</span>                    if (is_transformed) {</div>
<div class="line"><span class="lineno"> 7510</span>                        return false; <span class="comment">// we want only the transformed intersection halfedges</span></div>
<div class="line"><span class="lineno"> 7511</span>                    }</div>
<div class="line"><span class="lineno"> 7512</span> </div>
<div class="line"><span class="lineno"> 7513</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; m0_ihe = e.first;</div>
<div class="line"><span class="lineno"> 7514</span> </div>
<div class="line"><span class="lineno"> 7515</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_ihe_src_vertex = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(m0_ihe);</div>
<div class="line"><span class="lineno"> 7516</span>                    <span class="keyword">const</span> <span class="keywordtype">bool</span> src_is_ivertex = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0_ihe_src_vertex, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 7517</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_ihe_tgt_vertex = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m0_ihe);</div>
<div class="line"><span class="lineno"> 7518</span>                    <span class="keyword">const</span> <span class="keywordtype">bool</span> tgt_is_ivertex = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0_ihe_tgt_vertex, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 7519</span> </div>
<div class="line"><span class="lineno"> 7520</span>                    <span class="keywordflow">if</span> (!(src_is_ivertex &amp;&amp; tgt_is_ivertex)) {</div>
<div class="line"><span class="lineno"> 7521</span>                        <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// we want only class-3 intersection halfedges (x--&gt;x)</span></div>
<div class="line"><span class="lineno"> 7522</span>                    }</div>
<div class="line"><span class="lineno"> 7523</span> </div>
<div class="line"><span class="lineno"> 7524</span><span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7525</span><span class="comment">// checf is halfedge is really an exterior one (ambigious case arising from concave polyhedron cut)</span></div>
<div class="line"><span class="lineno"> 7526</span><span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7527</span><span class="comment">// const hd_t v0_coincident_ps_halfedge = SAFE_ACCESS(m0_ivtx_to_ps_edge, m0_ihe_src_vertex);</span></div>
<div class="line"><span class="lineno"> 7528</span><span class="comment">// const hd_t v1_coincident_ps_halfedge = SAFE_ACCESS(m0_ivtx_to_ps_edge, m0_ihe_tgt_vertex);</span></div>
<div class="line"><span class="lineno"> 7529</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 7530</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)m0_ihe_src_vertex - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(m0_ihe_src_vertex) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 7531</span>                        <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt; &amp;m0_ihe_src_vertex_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, m0_ihe_src_vertex - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 7532</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> v0_ps_edge = m0_ihe_src_vertex_ipair.first; <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_edge, m0_ihe_src_vertex); //ps.edge(v0_coincident_ps_halfedge);</span></div>
<div class="line"><span class="lineno"> 7533</span> </div>
<div class="line"><span class="lineno"> 7534</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)m0_ihe_tgt_vertex - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(m0_ihe_tgt_vertex) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 7535</span>                        <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt; &amp;m0_ihe_tgt_vertex_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, m0_ihe_tgt_vertex - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 7536</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> v1_ps_edge = m0_ihe_tgt_vertex_ipair.first; <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_edge, m0_ihe_tgt_vertex); // ps.edge(v1_coincident_ps_halfedge);</span></div>
<div class="line"><span class="lineno"> 7537</span> </div>
<div class="line"><span class="lineno"> 7538</span>                        <span class="keyword">const</span> <span class="keywordtype">bool</span> is_poly_exterior_interior_ihalfedge = (v0_ps_edge == v1_ps_edge);</div>
<div class="line"><span class="lineno"> 7539</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 7540</span>                    <span class="keyword">const</span> <span class="keywordtype">bool</span> is_boundary_halfedge = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#ad0e7884ca4d03bad54f0f83d198676e5">m0_is_polygon_boundary_halfedge</a>(m0_ihe, m0_num_cutpath_halfedges);</div>
<div class="line"><span class="lineno"> 7541</span> </div>
<div class="line"><span class="lineno"> 7542</span>                    <span class="keywordflow">if</span> (is_boundary_halfedge <span class="comment">/*is_poly_exterior_interior_ihalfedge*/</span>) { <span class="comment">// we want only polygon-exterior interior ihalfedges</span></div>
<div class="line"><span class="lineno"> 7543</span> </div>
<div class="line"><span class="lineno"> 7544</span>                        <span class="comment">// get the traced polygon which uses the current halfedge</span></div>
<div class="line"><span class="lineno"> 7545</span>                        <span class="keyword">const</span> std::vector&lt;std::vector&lt;int&gt;&gt;::const_iterator coincident_poly_find_iter = m0_h_to_ply.cbegin() + m0_ihe; <span class="comment">/* m0_h_to_ply.find(m0_ihe);*/</span></div>
<div class="line"><span class="lineno"> 7546</span> </div>
<div class="line"><span class="lineno"> 7547</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(coincident_poly_find_iter != m0_h_to_ply.end());</div>
<div class="line"><span class="lineno"> 7548</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(coincident_poly_find_iter-&gt;size() == 1); <span class="comment">// polygon-exterior interior-ihalfedges are incident to exactly one polygon</span></div>
<div class="line"><span class="lineno"> 7549</span> </div>
<div class="line"><span class="lineno"> 7550</span>                        <span class="keyword">const</span> <span class="keywordtype">bool</span> is_used_to_trace_src_mesh_polygon = (coincident_poly_find_iter-&gt;front() &lt; traced_sm_polygon_count);</div>
<div class="line"><span class="lineno"> 7551</span> </div>
<div class="line"><span class="lineno"> 7552</span>                        <span class="keywordflow">return</span> (is_used_to_trace_src_mesh_polygon);</div>
<div class="line"><span class="lineno"> 7553</span>                    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 7554</span>                        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 7555</span>                    }</div>
<div class="line"><span class="lineno"> 7556</span>                });</div>
<div class="line"><span class="lineno"> 7557</span>        }</div>
<div class="line"><span class="lineno"> 7558</span> </div>
<div class="line"><span class="lineno"> 7559</span>        <span class="comment">// loop while there exists a &quot;non-transformed&quot; exterior intersection-halfedge</span></div>
<div class="line"><span class="lineno"> 7560</span>        <span class="comment">// from which we can start building a SCBS</span></div>
<div class="line"><span class="lineno"> 7561</span>    } <span class="keywordflow">while</span> (m0_1st_sm_ihe_fiter != m0_sm_ihe_to_flag.end());</div>
<div class="line"><span class="lineno"> 7562</span> </div>
<div class="line"><span class="lineno"> 7563</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 7564</span>    <span class="comment">// dump</span></div>
<div class="line"><span class="lineno"> 7565</span>    </div>
<div class="line"><span class="lineno"> 7566</span> </div>
<div class="line"><span class="lineno"> 7567</span>    <span class="keywordflow">for</span> (std::map&lt;hd_t, hd_t&gt;::const_iterator i = m0_to_m1_ihe.cbegin(); i != m0_to_m1_ihe.cend(); ++i) {</div>
<div class="line"><span class="lineno"> 7568</span>        </div>
<div class="line"><span class="lineno"> 7569</span>    }</div>
<div class="line"><span class="lineno"> 7570</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 7571</span> </div>
<div class="line"><span class="lineno"> 7572</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>(); <span class="comment">// &amp;&amp;&amp;&amp;&amp;</span></div>
<div class="line"><span class="lineno"> 7573</span> </div>
<div class="line"><span class="lineno"> 7574</span>    <span class="comment">// m0_to_ps_vtx.clear(); // free</span></div>
<div class="line"><span class="lineno"> 7575</span>    ivtx_to_incoming_hlist.clear(); <span class="comment">// free</span></div>
<div class="line"><span class="lineno"> 7576</span>    m0_sm_ihe_to_flag.clear(); <span class="comment">// free</span></div>
<div class="line"><span class="lineno"> 7577</span>    <span class="comment">// m0_to_m1_vtx.clear(); // free</span></div>
<div class="line"><span class="lineno"> 7578</span>    m0_ox_hlist.clear(); <span class="comment">// free</span></div>
<div class="line"><span class="lineno"> 7579</span>    m1_ivtx_to_h.clear(); <span class="comment">// free</span></div>
<div class="line"><span class="lineno"> 7580</span> </div>
<div class="line"><span class="lineno"> 7581</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7582</span>    <span class="comment">// NOTE: at this stage, we have calculated all the vertices, edges, halfedges and meta-data</span></div>
<div class="line"><span class="lineno"> 7583</span>    <span class="comment">// which describes the connectivity of the partitioned (topologically split) source-mesh along</span></div>
<div class="line"><span class="lineno"> 7584</span>    <span class="comment">// the cut-path.</span></div>
<div class="line"><span class="lineno"> 7585</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7586</span> </div>
<div class="line"><span class="lineno"> 7588</span>    <span class="comment">// Save the number of vertices in &quot;m1&quot; after source-mesh partitioning</span></div>
<div class="line"><span class="lineno"> 7590</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 7591</span>    <span class="comment">// saving the number of vertices here will allow us to infer exactly which vertices</span></div>
<div class="line"><span class="lineno"> 7592</span>    <span class="comment">// lie on the seam.</span></div>
<div class="line"><span class="lineno"> 7593</span> </div>
<div class="line"><span class="lineno"> 7594</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> m1_num_vertices_after_srcmesh_partitioning = m1.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a35ce6de1cc36d41e9eb48edb3e23e795">number_of_vertices</a>();</div>
<div class="line"><span class="lineno"> 7595</span> </div>
<div class="line"><span class="lineno"> 7597</span>    <span class="comment">// Update the traced polygons to represent the partitioned src-mesh</span></div>
<div class="line"><span class="lineno"> 7599</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 7600</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Update traced polygons&quot;</span>);</div>
<div class="line"><span class="lineno"> 7601</span> </div>
<div class="line"><span class="lineno"> 7602</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7603</span>    <span class="comment">// We are basically re-tracing the polygons that we traced earlier (in &quot;m0&quot;).</span></div>
<div class="line"><span class="lineno"> 7604</span>    <span class="comment">// These retraced polygon are stored in &quot;m1&quot;. The re-traced polygons which</span></div>
<div class="line"><span class="lineno"> 7605</span>    <span class="comment">// where next to the cut-path will now reside (i.e. reference vertices and</span></div>
<div class="line"><span class="lineno"> 7606</span>    <span class="comment">// halfedges) in the correct connected component to separate the source mesh.</span></div>
<div class="line"><span class="lineno"> 7607</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7608</span> </div>
<div class="line"><span class="lineno"> 7609</span>    <span class="comment">// the updated polygons (with the partitioning)</span></div>
<div class="line"><span class="lineno"> 7610</span>    std::vector&lt;traced_polygon_t&gt; m1_polygons;</div>
<div class="line"><span class="lineno"> 7611</span>    m1_polygons.resize(traced_sm_polygon_count); <span class="comment">// resize to match</span></div>
<div class="line"><span class="lineno"> 7612</span> </div>
<div class="line"><span class="lineno"> 7613</span>    <span class="comment">// NOTE: this map contains polygons which are traced on the source mesh only.</span></div>
<div class="line"><span class="lineno"> 7614</span>    <span class="comment">// We do this because cut-mesh polygon will have two version each, where</span></div>
<div class="line"><span class="lineno"> 7615</span>    <span class="comment">// a version corresponds to those that are stitched on the exterior and those interior.</span></div>
<div class="line"><span class="lineno"> 7616</span>    <span class="comment">// We will duplicate the &quot;m1&quot; mesh later into two copies.</span></div>
<div class="line"><span class="lineno"> 7617</span>    std::unordered_map&lt;int, int&gt; m0_to_m1_face; <span class="comment">// std::map&lt;int, int&gt; m0_to_m1_face;</span></div>
<div class="line"><span class="lineno"> 7618</span>    std::unordered_map&lt;int, int&gt; m1_to_m0_face;</div>
<div class="line"><span class="lineno"> 7619</span> </div>
<div class="line"><span class="lineno"> 7620</span>    <span class="comment">// for each traced polygon (in &quot;m0&quot;)</span></div>
<div class="line"><span class="lineno"> 7621</span>    <span class="keywordflow">for</span> (std::vector&lt;traced_polygon_t&gt;::const_iterator m0_traced_sm_polygon_iter = m0_polygons.cbegin();</div>
<div class="line"><span class="lineno"> 7622</span>         m0_traced_sm_polygon_iter != m0_traced_sm_polygons_iter_cend;</div>
<div class="line"><span class="lineno"> 7623</span>         ++m0_traced_sm_polygon_iter) {</div>
<div class="line"><span class="lineno"> 7624</span>        <span class="keyword">const</span> <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a>&amp; m0_sm_polygon = *m0_traced_sm_polygon_iter; <span class="comment">// m0 version (unpartitioned)</span></div>
<div class="line"><span class="lineno"> 7625</span>        <span class="comment">// get index of polygon</span></div>
<div class="line"><span class="lineno"> 7626</span>        <span class="keyword">const</span> <span class="keywordtype">int</span> polygon_index = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)<a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(m0_polygons.cbegin(), m0_traced_sm_polygon_iter);</div>
<div class="line"><span class="lineno"> 7627</span> </div>
<div class="line"><span class="lineno"> 7628</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(polygon_index &lt; (<span class="keywordtype">int</span>)m1_polygons.size()); <span class="comment">// sanity check</span></div>
<div class="line"><span class="lineno"> 7629</span> </div>
<div class="line"><span class="lineno"> 7630</span>        <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a>&amp; m1_sm_polygon = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m1_polygons, polygon_index); <span class="comment">// m1 version (partitioned)</span></div>
<div class="line"><span class="lineno"> 7631</span>        m1_sm_polygon.resize(m0_sm_polygon.size()); <span class="comment">// resize to match</span></div>
<div class="line"><span class="lineno"> 7632</span> </div>
<div class="line"><span class="lineno"> 7633</span>        <span class="comment">// for each halfedge of current polygon</span></div>
<div class="line"><span class="lineno"> 7634</span>        <span class="keywordflow">for</span> (traced_polygon_t::const_iterator m0_traced_sm_polygon_halfedge_iter = m0_sm_polygon.cbegin();</div>
<div class="line"><span class="lineno"> 7635</span>             m0_traced_sm_polygon_halfedge_iter != m0_sm_polygon.cend();</div>
<div class="line"><span class="lineno"> 7636</span>             ++m0_traced_sm_polygon_halfedge_iter) {</div>
<div class="line"><span class="lineno"> 7637</span> </div>
<div class="line"><span class="lineno"> 7638</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; m0_he = *m0_traced_sm_polygon_halfedge_iter;</div>
<div class="line"><span class="lineno"> 7639</span>            <span class="keyword">const</span> <span class="keywordtype">bool</span> m0_he_src_is_ivertex = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(m0_he), ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 7640</span>            <span class="keyword">const</span> <span class="keywordtype">bool</span> m0_he_tgt_is_ivertex = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m0_he), ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 7641</span>            <span class="comment">// is the halfedge connected to an intersection point...?</span></div>
<div class="line"><span class="lineno"> 7642</span>            <span class="keyword">const</span> <span class="keywordtype">bool</span> is_ihalfedge = m0_he_src_is_ivertex || m0_he_tgt_is_ivertex;</div>
<div class="line"><span class="lineno"> 7643</span> </div>
<div class="line"><span class="lineno"> 7644</span>            <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m1_he = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno"> 7645</span> </div>
<div class="line"><span class="lineno"> 7646</span>            <span class="keywordflow">if</span> (is_ihalfedge) { <span class="comment">// its an intersection halfedge</span></div>
<div class="line"><span class="lineno"> 7647</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_to_m1_ihe.find(m0_he) != m0_to_m1_ihe.cend()); <span class="comment">// must have been walked/traversed</span></div>
<div class="line"><span class="lineno"> 7648</span> </div>
<div class="line"><span class="lineno"> 7649</span>                m1_he = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_m1_ihe, m0_he); <span class="comment">// m1 version</span></div>
<div class="line"><span class="lineno"> 7650</span>            } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 7651</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_to_m1_he.find(m0_he) != m0_to_m1_he.cend());</div>
<div class="line"><span class="lineno"> 7652</span> </div>
<div class="line"><span class="lineno"> 7653</span>                m1_he = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_m1_he, m0_he); <span class="comment">// m1 version</span></div>
<div class="line"><span class="lineno"> 7654</span>            }</div>
<div class="line"><span class="lineno"> 7655</span> </div>
<div class="line"><span class="lineno"> 7656</span>            <span class="comment">// get halfedge index in polygon</span></div>
<div class="line"><span class="lineno"> 7657</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> halfedge_index = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)<a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(m0_sm_polygon.cbegin(), m0_traced_sm_polygon_halfedge_iter);</div>
<div class="line"><span class="lineno"> 7658</span> </div>
<div class="line"><span class="lineno"> 7659</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(halfedge_index &lt; (<span class="keywordtype">int</span>)m1_sm_polygon.size()); <span class="comment">// array was resized with the same capacity as m0 polygon</span></div>
<div class="line"><span class="lineno"> 7660</span> </div>
<div class="line"><span class="lineno"> 7661</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m1_sm_polygon, halfedge_index) = m1_he;</div>
<div class="line"><span class="lineno"> 7662</span>        }</div>
<div class="line"><span class="lineno"> 7663</span> </div>
<div class="line"><span class="lineno"> 7664</span>        m0_to_m1_face[polygon_index] = polygon_index; <span class="comment">// one to one mapping because we are only dealing with source-mesh traced polygons</span></div>
<div class="line"><span class="lineno"> 7665</span>        m1_to_m0_face[polygon_index] = polygon_index;</div>
<div class="line"><span class="lineno"> 7666</span>    }</div>
<div class="line"><span class="lineno"> 7667</span> </div>
<div class="line"><span class="lineno"> 7668</span>    m0_to_m1_he.clear();</div>
<div class="line"><span class="lineno"> 7669</span> </div>
<div class="line"><span class="lineno"> 7670</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 7671</span> </div>
<div class="line"><span class="lineno"> 7672</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7673</span>    <span class="comment">// NOTE: at this stage &quot;m1_polygons&quot; (and &quot;m0_to_m1...&quot;) contains only source-mesh polygons.</span></div>
<div class="line"><span class="lineno"> 7674</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7675</span> </div>
<div class="line"><span class="lineno"> 7676</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Mark seam edges&quot;</span>);</div>
<div class="line"><span class="lineno"> 7677</span>    <span class="comment">// extract the seam vertices</span></div>
<div class="line"><span class="lineno"> 7678</span>    <span class="comment">// NOTE: the size of this vector include only ps vertices, intersection points, and</span></div>
<div class="line"><span class="lineno"> 7679</span>    <span class="comment">// the duplicates of intersection points (for separating the source mesh).</span></div>
<div class="line"><span class="lineno"> 7680</span>    <span class="comment">// new vertices that will later be created (by duplicate ps cut-mesh vertices during stitching)</span></div>
<div class="line"><span class="lineno"> 7681</span>    <span class="comment">// are not included</span></div>
<div class="line"><span class="lineno"> 7682</span>    std::vector&lt;bool&gt; m1_vertex_to_seam_flag;</div>
<div class="line"><span class="lineno"> 7683</span>    <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a7095d6c7279faa9121a2a2722a51a814">mark_seam_vertices</a>(m1_vertex_to_seam_flag, m1, ps_vtx_cnt, m1_num_vertices_after_srcmesh_partitioning);</div>
<div class="line"><span class="lineno"> 7684</span> </div>
<div class="line"><span class="lineno"> 7685</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 7686</span> </div>
<div class="line"><span class="lineno"> 7687</span>    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(!m1_vertex_to_seam_flag.empty());</div>
<div class="line"><span class="lineno"> 7688</span> </div>
<div class="line"><span class="lineno"> 7689</span>    <span class="keywordflow">if</span> (input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a2e0e9766f9dd9d594f607e107c855e26">keep_unsealed_fragments</a> || input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a6558e59317164c8e7d141f2f8fce00b5">keep_fragments_partially_cut</a>) {</div>
<div class="line"><span class="lineno"> 7691</span>        <span class="comment">// Extract the partitioned connected components for output</span></div>
<div class="line"><span class="lineno"> 7693</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 7694</span>        std::map&lt;std::size_t, std::vector&lt;std::pair&lt;std::shared_ptr&lt;hmesh_t&gt;, <a class="code hl_struct" href="../../dd/d24/kernel_8cpp.html#d7/dd7/structconnected__component__info__t">connected_component_info_t</a>&gt;&gt;&gt; unsealed_connected_components;</div>
<div class="line"><span class="lineno"> 7695</span> </div>
<div class="line"><span class="lineno"> 7696</span>        <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a34276907046e706af5626787b2e2b05a">extract_connected_components</a>(</div>
<div class="line"><span class="lineno"> 7697</span>#<span class="keywordflow">if</span> defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</div>
<div class="line"><span class="lineno"> 7698</span>            *input.scheduler,</div>
<div class="line"><span class="lineno"> 7699</span>#endif</div>
<div class="line"><span class="lineno"> 7700</span>            unsealed_connected_components,</div>
<div class="line"><span class="lineno"> 7701</span>            m1,</div>
<div class="line"><span class="lineno"> 7702</span>            0,</div>
<div class="line"><span class="lineno"> 7703</span>            m1_polygons,</div>
<div class="line"><span class="lineno"> 7704</span>            sm_polygons_below_cs,</div>
<div class="line"><span class="lineno"> 7705</span>            sm_polygons_above_cs,</div>
<div class="line"><span class="lineno"> 7706</span>            m1_vertex_to_seam_flag,</div>
<div class="line"><span class="lineno"> 7707</span>            m1_to_m0_ovtx,</div>
<div class="line"><span class="lineno"> 7708</span>            std::unordered_map&lt;vd_t, vd_t&gt;(), <span class="comment">// ... because data is only available during &quot;m1&quot; stitching stage (later), and its not needed here</span></div>
<div class="line"><span class="lineno"> 7709</span>            m1_to_m0_face,</div>
<div class="line"><span class="lineno"> 7710</span>            m0_to_ps_vtx,</div>
<div class="line"><span class="lineno"> 7711</span>            m0_to_ps_face,</div>
<div class="line"><span class="lineno"> 7712</span>            ps_to_sm_vtx,</div>
<div class="line"><span class="lineno"> 7713</span>            ps_to_sm_face,</div>
<div class="line"><span class="lineno"> 7714</span>            ps_to_cm_vtx,</div>
<div class="line"><span class="lineno"> 7715</span>            ps_to_cm_face,</div>
<div class="line"><span class="lineno"> 7716</span>            sm_vtx_cnt,</div>
<div class="line"><span class="lineno"> 7717</span>            sm_face_count,</div>
<div class="line"><span class="lineno"> 7718</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a0b23c3ae4df4369125ff8b489a42260b">populate_vertex_maps</a>,</div>
<div class="line"><span class="lineno"> 7719</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8307155337693cbe5ebf0f61ea8ffd81">populate_face_maps</a>,</div>
<div class="line"><span class="lineno"> 7720</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a07e9992982b4f9497d1499f1cfb2826d">keep_fragments_below_cutmesh</a>,</div>
<div class="line"><span class="lineno"> 7721</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#ababb18b60ba667267d374ba263e889af">keep_fragments_above_cutmesh</a>,</div>
<div class="line"><span class="lineno"> 7722</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a6558e59317164c8e7d141f2f8fce00b5">keep_fragments_partially_cut</a>);</div>
<div class="line"><span class="lineno"> 7723</span> </div>
<div class="line"><span class="lineno"> 7724</span>        <span class="comment">// for each connected component (i.e. mesh)</span></div>
<div class="line"><span class="lineno"> 7725</span>        <span class="keywordflow">for</span> (std::map&lt;std::size_t, std::vector&lt;std::pair&lt;std::shared_ptr&lt;hmesh_t&gt;, <a class="code hl_struct" href="../../dd/d24/kernel_8cpp.html#d7/dd7/structconnected__component__info__t">connected_component_info_t</a>&gt;&gt;&gt;::iterator cc_iter = unsealed_connected_components.begin();</div>
<div class="line"><span class="lineno"> 7726</span>             cc_iter != unsealed_connected_components.end();</div>
<div class="line"><span class="lineno"> 7727</span>             ++cc_iter) {</div>
<div class="line"><span class="lineno"> 7728</span> </div>
<div class="line"><span class="lineno"> 7729</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> cc_id = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(cc_iter-&gt;first);</div>
<div class="line"><span class="lineno"> 7730</span>            std::vector&lt;std::pair&lt;std::shared_ptr&lt;hmesh_t&gt;, <a class="code hl_struct" href="../../dd/d24/kernel_8cpp.html#d7/dd7/structconnected__component__info__t">connected_component_info_t</a>&gt;&gt;&amp; mesh_data = cc_iter-&gt;second;</div>
<div class="line"><span class="lineno"> 7731</span> </div>
<div class="line"><span class="lineno"> 7732</span>            <span class="comment">// there will only be one element of the mesh since &quot;unsealed_connected_components&quot;</span></div>
<div class="line"><span class="lineno"> 7733</span>            <span class="comment">// is empty before calling &quot;extract_connected_components&quot;</span></div>
<div class="line"><span class="lineno"> 7734</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(mesh_data.size() == 1);</div>
<div class="line"><span class="lineno"> 7735</span>            <span class="keywordflow">if</span> (input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#acbacc55f2163529291e5a45671fed3d1">verbose</a>) {</div>
<div class="line"><span class="lineno"> 7736</span>                <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a9bb440c35b34b7ecd91a6ce4eca6941e">dump_mesh</a>(mesh_data.front().first.get()[0], (<span class="stringliteral">&quot;fragment.unsealed.&quot;</span> + std::to_string(cc_id) + <span class="stringliteral">&quot;.&quot;</span> + <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#ac170ee95cd3318133c47c23a4a4412b8">to_string</a>(mesh_data.front().second.location)).c_str());</div>
<div class="line"><span class="lineno"> 7737</span>            }</div>
<div class="line"><span class="lineno"> 7738</span>            std::pair&lt;std::shared_ptr&lt;hmesh_t&gt;, <a class="code hl_struct" href="../../dd/d24/kernel_8cpp.html#d7/dd7/structconnected__component__info__t">connected_component_info_t</a>&gt;&amp; md = mesh_data.front();</div>
<div class="line"><span class="lineno"> 7739</span>            std::shared_ptr&lt;output_mesh_info_t&gt; omi = std::shared_ptr&lt;output_mesh_info_t&gt;(<span class="keyword">new</span> <a class="code hl_struct" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#de/de4/structoutput__mesh__info__t">output_mesh_info_t</a>);</div>
<div class="line"><span class="lineno"> 7740</span>            omi-&gt;mesh = md.first;</div>
<div class="line"><span class="lineno"> 7741</span>            omi-&gt;seam_vertices = std::move(md.second.seam_vertices);</div>
<div class="line"><span class="lineno"> 7742</span>            omi-&gt;data_maps = std::move(md.second.data_maps);</div>
<div class="line"><span class="lineno"> 7743</span>            output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a56c95c706afd7615de473f7e46c6fb35">unsealed_cc</a>[md.second.location].emplace_back((omi));</div>
<div class="line"><span class="lineno"> 7744</span>        }</div>
<div class="line"><span class="lineno"> 7745</span> </div>
<div class="line"><span class="lineno"> 7746</span>        unsealed_connected_components.clear();</div>
<div class="line"><span class="lineno"> 7747</span>    }</div>
<div class="line"><span class="lineno"> 7748</span> </div>
<div class="line"><span class="lineno"> 7750</span>    <span class="comment">// Check if the pipeline needs to terminate at this point</span></div>
<div class="line"><span class="lineno"> 7752</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 7753</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7754</span>    <span class="comment">// Note that  we do not ever continue to fill holes if the cut-mesh cuts</span></div>
<div class="line"><span class="lineno"> 7755</span>    <span class="comment">// the source-mesh multiple times where most cuts are complete but there is at-least one partial.</span></div>
<div class="line"><span class="lineno"> 7756</span>    <span class="comment">// So long as there is a partial cut and the input mesh is not water tight, we wont patch.</span></div>
<div class="line"><span class="lineno"> 7757</span>    <span class="comment">// This is because patching becomes complex as we then need to account for skipping the task of stitching patches which are incident to hole-bounding-sequences which are not loops.</span></div>
<div class="line"><span class="lineno"> 7758</span>    <span class="comment">// Maybe future work..?</span></div>
<div class="line"><span class="lineno"> 7759</span>    <span class="keyword">const</span> <span class="keywordtype">bool</span> proceed_to_fill_holes = explicit_cutpaths_making_holes.size() == m0_cutpath_sequences.size();</div>
<div class="line"><span class="lineno"> 7760</span> </div>
<div class="line"><span class="lineno"> 7761</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7762</span>    <span class="comment">// The pipeline stops here if there are no holes to fill.</span></div>
<div class="line"><span class="lineno"> 7763</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7764</span>    <span class="comment">// NOTE: non-watertight meshes with a complete cut by a single cut-surface polygon cannot be &quot;sealed&quot;</span></div>
<div class="line"><span class="lineno"> 7765</span>    <span class="comment">// since no edges of the cut-mesh polygon will be intersected.</span></div>
<div class="line"><span class="lineno"> 7766</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7767</span> </div>
<div class="line"><span class="lineno"> 7768</span>    <span class="keywordflow">if</span> (proceed_to_fill_holes == <span class="keyword">false</span>) {</div>
<div class="line"><span class="lineno"> 7769</span>        printf(<span class="stringliteral">&quot;[mcut-kernel]: detected a configuration that does not permit filling holes. input-mesh verification advised.\n&quot;</span>);</div>
<div class="line"><span class="lineno"> 7770</span>        <span class="keywordflow">return</span>; <span class="comment">// done</span></div>
<div class="line"><span class="lineno"> 7771</span>    }</div>
<div class="line"><span class="lineno"> 7772</span> </div>
<div class="line"><span class="lineno"> 7773</span>    <span class="keywordflow">if</span> (<span class="keyword">false</span> == (input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a07e9992982b4f9497d1499f1cfb2826d">keep_fragments_below_cutmesh</a> || <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7774</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#ababb18b60ba667267d374ba263e889af">keep_fragments_above_cutmesh</a> || <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7775</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a4d23d907262b78c2d865f4d52bb65757">keep_fragments_sealed_inside</a> || <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7776</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#aff3651e310bd220d4f65bd450af94f16">keep_fragments_sealed_outside</a> || input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a18ab3e0c7ed366d45a0c1aaccddc4eee">keep_fragments_sealed_inside_exhaustive</a> || <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7777</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a719e59e63d8bf7d7c665f69d3213327b">keep_fragments_sealed_outside_exhaustive</a> || <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7778</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a69d05b5eabcaa02ad142e51104f16502">keep_inside_patches</a> || <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7779</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af5ee3a08c24f72b6d9f88a2a651159d1">keep_outside_patches</a>)) {</div>
<div class="line"><span class="lineno"> 7780</span>        <span class="comment">// if the user simply wants [unsealed] fragments that may be [partially cut], then we should not have to proceed further.</span></div>
<div class="line"><span class="lineno"> 7781</span>        <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno"> 7782</span>    }</div>
<div class="line"><span class="lineno"> 7783</span> </div>
<div class="line"><span class="lineno"> 7785</span>    <span class="comment">// The remainder of the pipeline performs hole-filling if there exists</span></div>
<div class="line"><span class="lineno"> 7786</span>    <span class="comment">// atleast one from a circular/linear cut-path which creates a hole in the</span></div>
<div class="line"><span class="lineno"> 7787</span>    <span class="comment">// source-mesh.</span></div>
<div class="line"><span class="lineno"> 7788</span>    <span class="comment">// Specifically, we will seal each connected component by</span></div>
<div class="line"><span class="lineno"> 7789</span>    <span class="comment">// identifying and then &quot;stitching&quot; patches of cut-mesh polygons to the</span></div>
<div class="line"><span class="lineno"> 7790</span>    <span class="comment">// source-mesh connected components</span></div>
<div class="line"><span class="lineno"> 7792</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 7793</span>    <span class="comment">// Please refer to: `docs/notes.md`, section &quot;Hole Filling&quot;</span></div>
<div class="line"><span class="lineno"> 7794</span> </div>
<div class="line"><span class="lineno"> 7796</span>    <span class="comment">// Gather a primary intersection-halfedge for each patch (i.e. cut-path)</span></div>
<div class="line"><span class="lineno"> 7798</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 7799</span>    <span class="comment">// Here, we gather one interior intersection-halfedge (in &quot;m0&quot;) for each patch,</span></div>
<div class="line"><span class="lineno"> 7800</span>    <span class="comment">// (this halfedge is used to trace a cut-mesh polygon). We will use these</span></div>
<div class="line"><span class="lineno"> 7801</span>    <span class="comment">// halfedges as starting points to iteratively build patches. Building a patch</span></div>
<div class="line"><span class="lineno"> 7802</span>    <span class="comment">// is analogous to labelling each cut-mesh polygon with a patch id. We use halfedges along</span></div>
<div class="line"><span class="lineno"> 7803</span>    <span class="comment">// cut-paths since they mark/represent the border/boundary between patches.</span></div>
<div class="line"><span class="lineno"> 7804</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7805</span>    <span class="comment">// Thus, in the following std::vector, each element is a pair of a 1) cut-mesh polygon index</span></div>
<div class="line"><span class="lineno"> 7806</span>    <span class="comment">// and 2) the index of a halfedge (on a cut-path) in that polygon (&quot;m0&quot; version).</span></div>
<div class="line"><span class="lineno"> 7807</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7808</span> </div>
<div class="line"><span class="lineno"> 7809</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Find primary halfedges for patch identification&quot;</span>);</div>
<div class="line"><span class="lineno"> 7810</span> </div>
<div class="line"><span class="lineno"> 7811</span>    std::vector&lt;std::pair&lt;int, int&gt;&gt; patch_discovery_seeds;</div>
<div class="line"><span class="lineno"> 7812</span> </div>
<div class="line"><span class="lineno"> 7813</span>    <span class="comment">// for each cutpath that makes a hole</span></div>
<div class="line"><span class="lineno"> 7814</span>    <span class="keywordflow">for</span> (std::vector&lt;int&gt;::const_iterator ecpmh_iter = explicit_cutpaths_making_holes.cbegin();</div>
<div class="line"><span class="lineno"> 7815</span>         ecpmh_iter != explicit_cutpaths_making_holes.cend();</div>
<div class="line"><span class="lineno"> 7816</span>         ++ecpmh_iter) {</div>
<div class="line"><span class="lineno"> 7817</span> </div>
<div class="line"><span class="lineno"> 7818</span>        <span class="keyword">const</span> <span class="keywordtype">int</span> ecpmh_idx = *ecpmh_iter; <span class="comment">// index of cutpath</span></div>
<div class="line"><span class="lineno"> 7819</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ecpmh_idx &lt; (<span class="keywordtype">int</span>)m0_cutpath_sequences.size());</div>
<div class="line"><span class="lineno"> 7820</span>        <span class="keyword">const</span> std::vector&lt;ed_t&gt;&amp; m0_explicit_cutpath_sequence = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_cutpath_sequences, ecpmh_idx);</div>
<div class="line"><span class="lineno"> 7821</span> </div>
<div class="line"><span class="lineno"> 7822</span>        <span class="comment">// pick any edge (we choose the first one)</span></div>
<div class="line"><span class="lineno"> 7823</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a>&amp; edge = m0_explicit_cutpath_sequence.front();</div>
<div class="line"><span class="lineno"> 7824</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(edge != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aabb2a87d3b736883d381532fb871389e">hmesh_t::null_edge</a>());</div>
<div class="line"><span class="lineno"> 7825</span> </div>
<div class="line"><span class="lineno"> 7826</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 2; ++i) { <span class="comment">// for each halfedge of current edge</span></div>
<div class="line"><span class="lineno"> 7827</span>            <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(edge, i);</div>
<div class="line"><span class="lineno"> 7828</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(h != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>());</div>
<div class="line"><span class="lineno"> 7829</span> </div>
<div class="line"><span class="lineno"> 7830</span>            <span class="comment">/*</span></div>
<div class="line"><span class="lineno"> 7831</span><span class="comment">         1. get the cut-mesh polygon using the halfedge</span></div>
<div class="line"><span class="lineno"> 7832</span><span class="comment">         2. save polygon and halfedge index</span></div>
<div class="line"><span class="lineno"> 7833</span><span class="comment">        */</span></div>
<div class="line"><span class="lineno"> 7834</span> </div>
<div class="line"><span class="lineno"> 7835</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, h).<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a809275ccd755fb7b88661d952134b14d">size</a>() &gt; 0 <span class="comment">/*m0_h_to_ply.find(h) != m0_h_to_ply.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 7836</span>            <span class="keyword">const</span> std::vector&lt;int&gt;&amp; h_polygons = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, h);</div>
<div class="line"><span class="lineno"> 7837</span> </div>
<div class="line"><span class="lineno"> 7838</span>            <span class="comment">// get the cut-mesh polygon using h0</span></div>
<div class="line"><span class="lineno"> 7839</span>            std::vector&lt;int&gt;::const_iterator h_cutmesh_polygon_find_iter = std::find_if(</div>
<div class="line"><span class="lineno"> 7840</span>                h_polygons.cbegin(),</div>
<div class="line"><span class="lineno"> 7841</span>                h_polygons.cend(),</div>
<div class="line"><span class="lineno"> 7842</span>                [&amp;](<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; e) {</div>
<div class="line"><span class="lineno"> 7843</span>                    return e &gt;= traced_sm_polygon_count; <span class="comment">// match cutmesh polygon!</span></div>
<div class="line"><span class="lineno"> 7844</span>                });</div>
<div class="line"><span class="lineno"> 7845</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(h_cutmesh_polygon_find_iter != h_polygons.cend()); <span class="comment">// cut path halfedge are always used by 2 polygons (for tracing)</span></div>
<div class="line"><span class="lineno"> 7846</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> h_polygon_idx = *h_cutmesh_polygon_find_iter;</div>
<div class="line"><span class="lineno"> 7847</span>            <span class="comment">// the actual polygon</span></div>
<div class="line"><span class="lineno"> 7848</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(h_polygon_idx &lt; (<span class="keywordtype">int</span>)m0_polygons.size());</div>
<div class="line"><span class="lineno"> 7849</span> </div>
<div class="line"><span class="lineno"> 7850</span>            <span class="keyword">const</span> std::vector&lt;hd_t&gt;&amp; h_polygon = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_polygons, h_polygon_idx);</div>
<div class="line"><span class="lineno"> 7851</span>            <span class="comment">// find the index of h0 in the polygon</span></div>
<div class="line"><span class="lineno"> 7852</span>            std::vector&lt;hd_t&gt;::const_iterator h_polygon_find_iter = std::find_if(</div>
<div class="line"><span class="lineno"> 7853</span>                h_polygon.cbegin(), h_polygon.cend(),</div>
<div class="line"><span class="lineno"> 7854</span>                [&amp;](<span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; e) {</div>
<div class="line"><span class="lineno"> 7855</span>                    return e == h;</div>
<div class="line"><span class="lineno"> 7856</span>                });</div>
<div class="line"><span class="lineno"> 7857</span> </div>
<div class="line"><span class="lineno"> 7858</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(h_polygon_find_iter != h_polygon.cend());</div>
<div class="line"><span class="lineno"> 7859</span> </div>
<div class="line"><span class="lineno"> 7860</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> h_idx = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)<a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(h_polygon.cbegin(), h_polygon_find_iter);</div>
<div class="line"><span class="lineno"> 7861</span> </div>
<div class="line"><span class="lineno"> 7862</span>            patch_discovery_seeds.emplace_back(h_polygon_idx, h_idx); <span class="comment">// save</span></div>
<div class="line"><span class="lineno"> 7863</span>        }</div>
<div class="line"><span class="lineno"> 7864</span>    }</div>
<div class="line"><span class="lineno"> 7865</span> </div>
<div class="line"><span class="lineno"> 7866</span>    std::vector&lt;std::pair&lt;int, int&gt;&gt; primary_interior_ihalfedge_pool = patch_discovery_seeds; <span class="comment">// copy because it gets modify</span></div>
<div class="line"><span class="lineno"> 7867</span> </div>
<div class="line"><span class="lineno"> 7868</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 7869</span> </div>
<div class="line"><span class="lineno"> 7870</span>    m0_cutpath_sequences.clear(); <span class="comment">// free, no longer needed.</span></div>
<div class="line"><span class="lineno"> 7871</span> </div>
<div class="line"><span class="lineno"> 7874</span>    <span class="comment">// Find graph(s) and build patches</span></div>
<div class="line"><span class="lineno"> 7877</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 7878</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Build patch graphs&quot;</span>); <span class="comment">// &amp;&amp;&amp;&amp;&amp;</span></div>
<div class="line"><span class="lineno"> 7879</span> </div>
<div class="line"><span class="lineno"> 7880</span>    <span class="comment">// Note that the built patches in this stage will have the same winding</span></div>
<div class="line"><span class="lineno"> 7881</span>    <span class="comment">// order (e.g. counter-clock-wise ) as the input cut-mesh. The patches with</span></div>
<div class="line"><span class="lineno"> 7882</span>    <span class="comment">// reversed winding order will be created later (once all patches are</span></div>
<div class="line"><span class="lineno"> 7883</span>    <span class="comment">// identified).</span></div>
<div class="line"><span class="lineno"> 7884</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7885</span>    <span class="comment">// There is one graph which arises from the intersection of the</span></div>
<div class="line"><span class="lineno"> 7886</span>    <span class="comment">// source-mesh with the cut-mesh. This graph is planar</span></div>
<div class="line"><span class="lineno"> 7887</span>    <span class="comment">// and there is exactly one node with e.g. color &quot;A&quot; and the rest are &quot;B&quot;.</span></div>
<div class="line"><span class="lineno"> 7888</span>    <span class="comment">// When visualised, it looks like a star, and this graph topology</span></div>
<div class="line"><span class="lineno"> 7889</span>    <span class="comment">// is bipartite. We call this a &quot;strongly-connected set&quot; (SCS) because there</span></div>
<div class="line"><span class="lineno"> 7890</span>    <span class="comment">// is a path from one graph node to another.</span></div>
<div class="line"><span class="lineno"> 7891</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7892</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7893</span>    std::map&lt;</div>
<div class="line"><span class="lineno"> 7894</span>        <a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>, <span class="comment">// patch index</span></div>
<div class="line"><span class="lineno"> 7895</span>        std::vector&lt;int&gt; <span class="comment">// patch polygon-indices</span></div>
<div class="line"><span class="lineno"> 7896</span>        &gt;</div>
<div class="line"><span class="lineno"> 7897</span>        patches;</div>
<div class="line"><span class="lineno"> 7898</span> </div>
<div class="line"><span class="lineno"> 7899</span>    std::unordered_map&lt;</div>
<div class="line"><span class="lineno"> 7900</span>        <a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>, <span class="comment">// traced cut-mesh polygon index</span></div>
<div class="line"><span class="lineno"> 7901</span>        <span class="keywordtype">int</span> <span class="comment">// patch index</span></div>
<div class="line"><span class="lineno"> 7902</span>        &gt;</div>
<div class="line"><span class="lineno"> 7903</span>        m0_cm_poly_to_patch_idx;</div>
<div class="line"><span class="lineno"> 7904</span>    m0_cm_poly_to_patch_idx.reserve(cs_face_count);</div>
<div class="line"><span class="lineno"> 7905</span> </div>
<div class="line"><span class="lineno"> 7906</span>    <span class="comment">// This map stores an interior intersection-halfedge for each patch. This</span></div>
<div class="line"><span class="lineno"> 7907</span>    <span class="comment">// halfedge also represents the traced cut-mesh polygon from which we will</span></div>
<div class="line"><span class="lineno"> 7908</span>    <span class="comment">// start stitching/glueing the correspnding patch to a fragment connected</span></div>
<div class="line"><span class="lineno"> 7909</span>    <span class="comment">// component of the source mesh.</span></div>
<div class="line"><span class="lineno"> 7910</span>    <span class="comment">// This connected component will be one which has the same winding  as the</span></div>
<div class="line"><span class="lineno"> 7911</span>    <span class="comment">// patch</span></div>
<div class="line"><span class="lineno"> 7912</span>    std::map&lt;</div>
<div class="line"><span class="lineno"> 7913</span>        <a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>, <span class="comment">// patch index</span></div>
<div class="line"><span class="lineno"> 7914</span>        <span class="keywordtype">int</span> <span class="comment">// interior intersection-halfedge from which patch-stitching into a connected component will start from</span></div>
<div class="line"><span class="lineno"> 7915</span>        &gt;</div>
<div class="line"><span class="lineno"> 7916</span>        patch_to_seed_interior_ihalfedge_idx;</div>
<div class="line"><span class="lineno"> 7917</span> </div>
<div class="line"><span class="lineno"> 7918</span>    std::map&lt;</div>
<div class="line"><span class="lineno"> 7919</span>        <a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>, <span class="comment">// patch index</span></div>
<div class="line"><span class="lineno"> 7920</span>        <span class="keywordtype">int</span>&gt; <span class="comment">// index of patch-polygon that will be stitched first (from &quot;patch_to_seed_interior_ihalfedge_idx[patch index]&quot;)</span></div>
<div class="line"><span class="lineno"> 7921</span>        patch_to_seed_poly_idx;</div>
<div class="line"><span class="lineno"> 7922</span> </div>
<div class="line"><span class="lineno"> 7923</span>    <span class="comment">// Interior/inside patches must be stitched into separate connected component</span></div>
<div class="line"><span class="lineno"> 7924</span>    <span class="comment">// as exterior/outside patches so we create two versions of &quot;m1&quot; for that.</span></div>
<div class="line"><span class="lineno"> 7925</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7926</span>    std::map&lt;</div>
<div class="line"><span class="lineno"> 7927</span>        char, <span class="comment">// color value (representing the notion of &quot;interior&quot;/&quot;exterior&quot;)</span></div>
<div class="line"><span class="lineno"> 7928</span>        <a class="code hl_class" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> <span class="comment">// the mesh (copy of &quot;m1&quot;) to which corresponding patch(es) will be stitched</span></div>
<div class="line"><span class="lineno"> 7929</span>        &gt;</div>
<div class="line"><span class="lineno"> 7930</span>        color_to_m1; <span class="comment">// = { { &#39;A&#39; /*e.g. &quot;red&quot;*/, m1 }, { &#39;B&#39; /*e.g. &quot;blue&quot;*/, m1 } };</span></div>
<div class="line"><span class="lineno"> 7931</span>    color_to_m1.insert(std::make_pair(<span class="charliteral">&#39;A&#39;</span> <span class="comment">/*e.g. &quot;red&quot;*/</span>, m1));</div>
<div class="line"><span class="lineno"> 7932</span>    color_to_m1.insert(std::make_pair(<span class="charliteral">&#39;B&#39;</span> <span class="comment">/*e.g. &quot;red&quot;*/</span>, std::move(m1))); <span class="comment">// &quot;m1&quot; becomes NULL after this</span></div>
<div class="line"><span class="lineno"> 7933</span> </div>
<div class="line"><span class="lineno"> 7934</span>    <span class="comment">// m1.reset(); // clear data</span></div>
<div class="line"><span class="lineno"> 7935</span> </div>
<div class="line"><span class="lineno"> 7936</span>    <span class="comment">// Patch (node) colors</span></div>
<div class="line"><span class="lineno"> 7937</span>    <span class="comment">// NOTE: we use the letters &#39;A&#39; and &#39;B&#39; just to ensure lexicographical order</span></div>
<div class="line"><span class="lineno"> 7938</span>    <span class="comment">// when we iterate over color_to_patch</span></div>
<div class="line"><span class="lineno"> 7939</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7940</span>    std::map&lt;</div>
<div class="line"><span class="lineno"> 7941</span>        char, <span class="comment">// color value</span></div>
<div class="line"><span class="lineno"> 7942</span>        std::vector&lt;int&gt; <span class="comment">// list of patches of that color</span></div>
<div class="line"><span class="lineno"> 7943</span>        &gt;</div>
<div class="line"><span class="lineno"> 7944</span>        color_to_patch = { { <span class="charliteral">&#39;A&#39;</span>, std::vector&lt;int&gt;() }, { <span class="charliteral">&#39;B&#39;</span>, std::vector&lt;int&gt;() } };</div>
<div class="line"><span class="lineno"> 7945</span> </div>
<div class="line"><span class="lineno"> 7946</span>    <span class="comment">// We also tag each patch, identifying whether is it a floating patch or not.</span></div>
<div class="line"><span class="lineno"> 7947</span>    <span class="comment">// All patches have an entry, including the reversed patches that are created</span></div>
<div class="line"><span class="lineno"> 7948</span>    <span class="comment">// later.</span></div>
<div class="line"><span class="lineno"> 7949</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7950</span>    <span class="comment">// std::map&lt;</span></div>
<div class="line"><span class="lineno"> 7951</span>    <span class="comment">//    int, // patch id</span></div>
<div class="line"><span class="lineno"> 7952</span>    <span class="comment">//    bool // flag to indicate of patch is a floating patch.</span></div>
<div class="line"><span class="lineno"> 7953</span>    <span class="comment">//    &gt;</span></div>
<div class="line"><span class="lineno"> 7954</span>    <span class="comment">//    patch_to_floating_flag;</span></div>
<div class="line"><span class="lineno"> 7955</span> </div>
<div class="line"><span class="lineno"> 7956</span>    <span class="comment">// tracks how many cut-mesh polygons have been stitched. Used only for naming damped meshes</span></div>
<div class="line"><span class="lineno"> 7957</span>    <span class="keywordtype">int</span> global_cm_poly_stitch_counter = 0;</div>
<div class="line"><span class="lineno"> 7958</span> </div>
<div class="line"><span class="lineno"> 7959</span>    <span class="comment">// keeps track of the total number of default-winding-order (e.g. CCW) patches which has been identified</span></div>
<div class="line"><span class="lineno"> 7960</span>    <span class="comment">// NOTE: not all will be CCW if we have floating patches (in this case winding could be flipped)</span></div>
<div class="line"><span class="lineno"> 7961</span>    <span class="keywordtype">int</span> total_ccw_patch_count = 0;</div>
<div class="line"><span class="lineno"> 7962</span>    std::vector&lt;bool&gt; patch_poly_enqueued(m0_polygons.size(), <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno"> 7963</span>    std::queue&lt;int&gt; flood_fill_queue; <span class="comment">// for building patch using BFS</span></div>
<div class="line"><span class="lineno"> 7964</span> </div>
<div class="line"><span class="lineno"> 7965</span>    <span class="keywordflow">do</span> {</div>
<div class="line"><span class="lineno"> 7967</span>        <span class="comment">// Associate cut-mesh polygons with patches of the graph</span></div>
<div class="line"><span class="lineno"> 7969</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 7970</span>        <span class="keywordtype">int</span> graph_cur_patch_idx = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)patches.size();</div>
<div class="line"><span class="lineno"> 7971</span> </div>
<div class="line"><span class="lineno"> 7972</span>        <span class="comment">// counter to keep track of the number of patches discovered for</span></div>
<div class="line"><span class="lineno"> 7973</span>        <span class="comment">// the current SCS</span></div>
<div class="line"><span class="lineno"> 7974</span> </div>
<div class="line"><span class="lineno"> 7975</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 7976</span>        <span class="comment">// Here, we will pick an interior intersection halfedge (and its polygon) from</span></div>
<div class="line"><span class="lineno"> 7977</span>        <span class="comment">// which we can identify the [first patch] of the graph</span></div>
<div class="line"><span class="lineno"> 7978</span>        std::tuple&lt;int, int, int&gt; graph_interior_ihalfedge_pool;</div>
<div class="line"><span class="lineno"> 7979</span>        std::get&lt;0&gt;(graph_interior_ihalfedge_pool) = -1;</div>
<div class="line"><span class="lineno"> 7980</span> </div>
<div class="line"><span class="lineno"> 7981</span>        <span class="comment">// find the [first] interior intersection-halfedge of a cut-mesh polygon</span></div>
<div class="line"><span class="lineno"> 7982</span>        <span class="comment">// which has not already been associated with a patch</span></div>
<div class="line"><span class="lineno"> 7983</span>        <span class="keywordflow">while</span> (!primary_interior_ihalfedge_pool.empty()) { <span class="comment">// while seeds are not found</span></div>
<div class="line"><span class="lineno"> 7984</span> </div>
<div class="line"><span class="lineno"> 7985</span>            <span class="comment">// pull an interior intersection-halfedge from the queue</span></div>
<div class="line"><span class="lineno"> 7986</span>            std::vector&lt;std::pair&lt;int, int&gt;&gt;::iterator primary_interior_ihalfedge_pool_citer = primary_interior_ihalfedge_pool.end() - 1; <span class="comment">// last element</span></div>
<div class="line"><span class="lineno"> 7987</span>            <span class="comment">// halfedge polygon index</span></div>
<div class="line"><span class="lineno"> 7988</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> potential_seed_poly_idx = primary_interior_ihalfedge_pool_citer-&gt;first;</div>
<div class="line"><span class="lineno"> 7989</span>            <span class="comment">// halfedge index in polygon</span></div>
<div class="line"><span class="lineno"> 7990</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> potential_seed_poly_he_idx = primary_interior_ihalfedge_pool_citer-&gt;second;</div>
<div class="line"><span class="lineno"> 7991</span><span class="preprocessor">#if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 7992</span>            <span class="keyword">const</span> <span class="keywordtype">bool</span> poly_patch_is_known = <a class="code hl_function" href="../../df/d05/tpool_8h.html#ae3cfa32999d5b05486b216557bab41d3">parallel_find_in_map_by_key</a>(</div>
<div class="line"><span class="lineno"> 7993</span>                                                 *input.scheduler,</div>
<div class="line"><span class="lineno"> 7994</span>                                                 m0_cm_poly_to_patch_idx.cbegin(),</div>
<div class="line"><span class="lineno"> 7995</span>                                                 m0_cm_poly_to_patch_idx.cend(), potential_seed_poly_idx)</div>
<div class="line"><span class="lineno"> 7996</span>                != m0_cm_poly_to_patch_idx.cend();</div>
<div class="line"><span class="lineno"> 7997</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno"> 7998</span>            <span class="comment">// check if the polygon has already been associated with a patch</span></div>
<div class="line"><span class="lineno"> 7999</span>            <span class="keyword">const</span> <span class="keywordtype">bool</span> poly_patch_is_known = m0_cm_poly_to_patch_idx.find(potential_seed_poly_idx) != m0_cm_poly_to_patch_idx.cend();</div>
<div class="line"><span class="lineno"> 8000</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 8001</span>            primary_interior_ihalfedge_pool_citer = primary_interior_ihalfedge_pool.erase(primary_interior_ihalfedge_pool_citer);</div>
<div class="line"><span class="lineno"> 8002</span> </div>
<div class="line"><span class="lineno"> 8003</span>            <span class="keywordflow">if</span> (!poly_patch_is_known) {</div>
<div class="line"><span class="lineno"> 8004</span>                <span class="comment">// we can use the halfedge as a seed from which to starting point to build [a] patch</span></div>
<div class="line"><span class="lineno"> 8005</span>                std::get&lt;0&gt;(graph_interior_ihalfedge_pool) = graph_cur_patch_idx;</div>
<div class="line"><span class="lineno"> 8006</span>                std::get&lt;1&gt;(graph_interior_ihalfedge_pool) = potential_seed_poly_idx;</div>
<div class="line"><span class="lineno"> 8007</span>                std::get&lt;2&gt;(graph_interior_ihalfedge_pool) = potential_seed_poly_he_idx;</div>
<div class="line"><span class="lineno"> 8008</span>                <span class="keywordflow">break</span>; <span class="comment">// start patch discovery with the current seed</span></div>
<div class="line"><span class="lineno"> 8009</span>            }</div>
<div class="line"><span class="lineno"> 8010</span>        }</div>
<div class="line"><span class="lineno"> 8011</span> </div>
<div class="line"><span class="lineno"> 8012</span>        <span class="keywordflow">if</span> (std::get&lt;0&gt;(graph_interior_ihalfedge_pool) == -1) {</div>
<div class="line"><span class="lineno"> 8013</span>            <span class="keywordflow">break</span>; <span class="comment">// done</span></div>
<div class="line"><span class="lineno"> 8014</span>        }</div>
<div class="line"><span class="lineno"> 8015</span> </div>
<div class="line"><span class="lineno"> 8017</span>        <span class="comment">// build the patch by flood-fill (BFS)</span></div>
<div class="line"><span class="lineno"> 8019</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 8020</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(patch_to_seed_interior_ihalfedge_idx.count(graph_cur_patch_idx) == 0);</div>
<div class="line"><span class="lineno"> 8021</span>        patch_to_seed_interior_ihalfedge_idx[graph_cur_patch_idx] = std::get&lt;2&gt;(graph_interior_ihalfedge_pool);</div>
<div class="line"><span class="lineno"> 8022</span> </div>
<div class="line"><span class="lineno"> 8023</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(patch_to_seed_poly_idx.count(graph_cur_patch_idx) == 0);</div>
<div class="line"><span class="lineno"> 8024</span>        patch_to_seed_poly_idx[graph_cur_patch_idx] = std::get&lt;1&gt;(graph_interior_ihalfedge_pool);</div>
<div class="line"><span class="lineno"> 8025</span> </div>
<div class="line"><span class="lineno"> 8026</span>        std::vector&lt;int&gt;&amp; patch = patches[graph_cur_patch_idx]; <span class="comment">// patch_insertion.first-&gt;second; // polygons of patch</span></div>
<div class="line"><span class="lineno"> 8027</span>        patch.reserve(cs_face_count);</div>
<div class="line"><span class="lineno"> 8028</span> </div>
<div class="line"><span class="lineno"> 8029</span>        flood_fill_queue.push(std::get&lt;1&gt;(graph_interior_ihalfedge_pool)); <span class="comment">// first polygon</span></div>
<div class="line"><span class="lineno"> 8030</span>        patch_poly_enqueued[std::get&lt;1&gt;(graph_interior_ihalfedge_pool)] = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 8031</span> </div>
<div class="line"><span class="lineno"> 8032</span>        <span class="keywordflow">do</span> { <span class="comment">// each interation adds a polygon to the patch</span></div>
<div class="line"><span class="lineno"> 8033</span> </div>
<div class="line"><span class="lineno"> 8034</span>            <span class="comment">// get the polygon at the front of the queue</span></div>
<div class="line"><span class="lineno"> 8035</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> graph_patch_poly_idx = flood_fill_queue.front();</div>
<div class="line"><span class="lineno"> 8036</span>            flood_fill_queue.pop(); <span class="comment">// graph_patch_poly_idx</span></div>
<div class="line"><span class="lineno"> 8037</span> </div>
<div class="line"><span class="lineno"> 8038</span>            <span class="comment">// add polygon to patch</span></div>
<div class="line"><span class="lineno"> 8039</span>            patch.push_back(graph_patch_poly_idx);</div>
<div class="line"><span class="lineno"> 8040</span> </div>
<div class="line"><span class="lineno"> 8041</span>            <span class="comment">// relate polygon to patch</span></div>
<div class="line"><span class="lineno"> 8042</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_cm_poly_to_patch_idx.count(graph_patch_poly_idx) == 0);</div>
<div class="line"><span class="lineno"> 8043</span>            m0_cm_poly_to_patch_idx[graph_patch_poly_idx] = graph_cur_patch_idx;</div>
<div class="line"><span class="lineno"> 8044</span>            <span class="comment">// std::pair&lt;std::map&lt;int, int&gt;::const_iterator, bool&gt; pair = m0_cm_poly_to_patch_idx.insert(std::make_pair(graph_patch_poly_idx, graph_cur_patch_idx)); // signifies that polygon has been associated with a patch</span></div>
<div class="line"><span class="lineno"> 8045</span>            <span class="comment">// MCUT_ASSERT(pair.second == true);</span></div>
<div class="line"><span class="lineno"> 8046</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_cm_poly_to_patch_idx.count(graph_patch_poly_idx) == 1);</div>
<div class="line"><span class="lineno"> 8047</span> </div>
<div class="line"><span class="lineno"> 8048</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8049</span>            <span class="comment">// find adjacent polygons which share class 0,1,2 (o--&gt;o, o--&gt;x, x--&gt;o) halfedges, and</span></div>
<div class="line"><span class="lineno"> 8050</span>            <span class="comment">// the class 3 (x--&gt;x) halfedges which are [exterior/boundary] intersection-halfedges.</span></div>
<div class="line"><span class="lineno"> 8051</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8052</span> </div>
<div class="line"><span class="lineno"> 8053</span>            <span class="comment">// the current polygon</span></div>
<div class="line"><span class="lineno"> 8054</span>            <span class="keyword">const</span> <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a>&amp; graph_patch_poly = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_polygons, graph_patch_poly_idx);</div>
<div class="line"><span class="lineno"> 8055</span> </div>
<div class="line"><span class="lineno"> 8056</span>            <span class="comment">// for each halfedge of the current polygon</span></div>
<div class="line"><span class="lineno"> 8057</span>            <span class="keywordflow">for</span> (traced_polygon_t::const_iterator poly_he_iter = graph_patch_poly.cbegin();</div>
<div class="line"><span class="lineno"> 8058</span>                 poly_he_iter != graph_patch_poly.cend();</div>
<div class="line"><span class="lineno"> 8059</span>                 ++poly_he_iter) {</div>
<div class="line"><span class="lineno"> 8060</span> </div>
<div class="line"><span class="lineno"> 8061</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 8062</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> src_vertex = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(*poly_he_iter);</div>
<div class="line"><span class="lineno"> 8063</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> tgt_vertex = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(*poly_he_iter);</div>
<div class="line"><span class="lineno"> 8064</span>                    <span class="keywordtype">bool</span> is_ambiguious_boundary_edge_case = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(src_vertex, ps_vtx_cnt) &amp;&amp; <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(tgt_vertex, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 8065</span>                    <span class="keywordtype">bool</span> is_valid_ambiguious_boundary_edge = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 8066</span> </div>
<div class="line"><span class="lineno"> 8067</span>                    <span class="keywordflow">if</span> (is_ambiguious_boundary_edge_case)</div>
<div class="line"><span class="lineno"> 8068</span>                    { <span class="comment">// exterior edge with two intersection vertices (ambigious case arising from concave polyhedron cut)</span></div>
<div class="line"><span class="lineno"> 8069</span> </div>
<div class="line"><span class="lineno"> 8070</span>                        <span class="comment">//const hd_t src_coincident_ps_halfedge = SAFE_ACCESS(m0_ivtx_to_ps_edge, src_vertex);</span></div>
<div class="line"><span class="lineno"> 8071</span>                        <span class="comment">//const hd_t tgt_ps_h = SAFE_ACCESS(m0_ivtx_to_ps_edge, tgt_vertex);</span></div>
<div class="line"><span class="lineno"> 8072</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)src_vertex - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(src_vertex) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 8073</span>                        <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt; &amp;src_vertex_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, src_vertex - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 8074</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> src_ps_edge = src_vertex_ipair.first; <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_edge, src_vertex); //ps.edge(src_coincident_ps_halfedge);</span></div>
<div class="line"><span class="lineno"> 8075</span> </div>
<div class="line"><span class="lineno"> 8076</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)tgt_vertex - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(tgt_vertex) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 8077</span>                        <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt; &amp;tgt_vertex_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, tgt_vertex - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 8078</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> tgt_ps_edge = tgt_vertex_ipair.first; <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_edge, tgt_vertex); //ps.edge(tgt_ps_h);</span></div>
<div class="line"><span class="lineno"> 8079</span> </div>
<div class="line"><span class="lineno"> 8080</span>                        is_valid_ambiguious_boundary_edge = (src_ps_edge == tgt_ps_edge);</div>
<div class="line"><span class="lineno"> 8081</span>                    }</div>
<div class="line"><span class="lineno"> 8082</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 8083</span>                <span class="keyword">const</span> <span class="keywordtype">bool</span> is_boundary_halfedge = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#ad0e7884ca4d03bad54f0f83d198676e5">m0_is_polygon_boundary_halfedge</a>((*poly_he_iter), m0_num_cutpath_halfedges);</div>
<div class="line"><span class="lineno"> 8084</span> </div>
<div class="line"><span class="lineno"> 8085</span>                <span class="comment">// &quot;is the halfdge not along the cut-path&quot;</span></div>
<div class="line"><span class="lineno"> 8086</span>                <span class="keywordflow">if</span> (is_boundary_halfedge ) {</div>
<div class="line"><span class="lineno"> 8087</span>                    <span class="comment">// get the opposite halfedge which is used to trace the adjacent polygon</span></div>
<div class="line"><span class="lineno"> 8088</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> poly_he_opp = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(*poly_he_iter);</div>
<div class="line"><span class="lineno"> 8089</span>                    <span class="comment">// get the coincident polygons (if any)</span></div>
<div class="line"><span class="lineno"> 8090</span>                    std::vector&lt;std::vector&lt;int&gt;&gt;::const_iterator find_iter = m0_h_to_ply.cbegin() + poly_he_opp; <span class="comment">// m0_h_to_ply.find(poly_he_opp);</span></div>
<div class="line"><span class="lineno"> 8091</span> </div>
<div class="line"><span class="lineno"> 8092</span>                    <span class="comment">// check if &quot;poly_he_opp&quot; is used to trace a polygon i.e its not a border halfedge</span></div>
<div class="line"><span class="lineno"> 8093</span>                    <span class="keywordflow">if</span> (find_iter-&gt;size() &gt; 0 <span class="comment">/*find_iter != m0_h_to_ply.cend()*/</span>) {</div>
<div class="line"><span class="lineno"> 8094</span> </div>
<div class="line"><span class="lineno"> 8095</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(find_iter-&gt;size() == 1); <span class="comment">// only used to trace a CCW cut-mesh polygon</span></div>
<div class="line"><span class="lineno"> 8096</span> </div>
<div class="line"><span class="lineno"> 8097</span>                        <span class="comment">// get the polygon which is traced with &quot;poly_he_opp&quot; i.e. the adjacent polygon we are looking for!</span></div>
<div class="line"><span class="lineno"> 8098</span>                        <span class="keyword">const</span> <span class="keywordtype">int</span> incident_poly = find_iter-&gt;front();</div>
<div class="line"><span class="lineno"> 8099</span> </div>
<div class="line"><span class="lineno"> 8100</span>                        <span class="comment">// mustbe  cut-mesh polygon since we are only dealing with such polygons when building patches</span></div>
<div class="line"><span class="lineno"> 8101</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(incident_poly &gt;= traced_sm_polygon_count);</div>
<div class="line"><span class="lineno"> 8102</span> </div>
<div class="line"><span class="lineno"> 8103</span>                        <span class="comment">// if (!poly_already_in_patch)</span></div>
<div class="line"><span class="lineno"> 8104</span>                        {</div>
<div class="line"><span class="lineno"> 8105</span>                            <span class="comment">// std::unordered_map&lt;int, bool&gt;::const_iterator qmap_fiter = patch_poly_enqueued.find(incident_poly);</span></div>
<div class="line"><span class="lineno"> 8106</span>                            <span class="keyword">const</span> <span class="keywordtype">bool</span> poly_already_queued = patch_poly_enqueued[incident_poly]; <span class="comment">// qmap_fiter != patch_poly_enqueued.cend(); //std::find(flood_fill_queue.crbegin(), flood_fill_queue.crend(), incident_poly) != flood_fill_queue.crend();</span></div>
<div class="line"><span class="lineno"> 8107</span>                            <span class="keywordflow">if</span> (!poly_already_queued) {</div>
<div class="line"><span class="lineno"> 8108</span>                                flood_fill_queue.push(incident_poly); <span class="comment">// add adjacent polygon to bfs-queue</span></div>
<div class="line"><span class="lineno"> 8109</span>                                patch_poly_enqueued[incident_poly] = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 8110</span>                            }</div>
<div class="line"><span class="lineno"> 8111</span>                        }</div>
<div class="line"><span class="lineno"> 8112</span>                    }</div>
<div class="line"><span class="lineno"> 8113</span>                }</div>
<div class="line"><span class="lineno"> 8114</span>            }</div>
<div class="line"><span class="lineno"> 8115</span> </div>
<div class="line"><span class="lineno"> 8116</span>        } <span class="keywordflow">while</span> (!flood_fill_queue.empty()); <span class="comment">// while there are more adjacent polygons for building current patch</span></div>
<div class="line"><span class="lineno"> 8117</span> </div>
<div class="line"><span class="lineno"> 8118</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(!patch.empty()); <span class="comment">// there has to be at least one polygon</span></div>
<div class="line"><span class="lineno"> 8119</span> </div>
<div class="line"><span class="lineno"> 8120</span>        <span class="comment">// NOTE: at this stage, all patches/nodes of the current graph have been coloured i.e. we have bipartite graph of the patches (except if there is only one patch i.e. a floating patch).</span></div>
<div class="line"><span class="lineno"> 8121</span>    } <span class="keywordflow">while</span> (!primary_interior_ihalfedge_pool.empty()); <span class="comment">// while there are more interior ihalfedges coincident to polygons which have not been associated with a patch (hence, there are remaining graphs of patches to be stitched)</span></div>
<div class="line"><span class="lineno"> 8122</span> </div>
<div class="line"><span class="lineno"> 8123</span>    patch_poly_enqueued.clear();</div>
<div class="line"><span class="lineno"> 8124</span> </div>
<div class="line"><span class="lineno"> 8125</span>    <span class="comment">// NOTE: At this stage, we have identified all patches of the current graph</span></div>
<div class="line"><span class="lineno"> 8126</span> </div>
<div class="line"><span class="lineno"> 8127</span>    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(patches.size() &gt;= 1);</div>
<div class="line"><span class="lineno"> 8128</span> </div>
<div class="line"><span class="lineno"> 8129</span>    total_ccw_patch_count = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)patches.size();</div>
<div class="line"><span class="lineno"> 8130</span> </div>
<div class="line"><span class="lineno"> 8131</span>    std::unordered_map&lt;</div>
<div class="line"><span class="lineno"> 8132</span>        <a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>, <span class="comment">// patch index</span></div>
<div class="line"><span class="lineno"> 8133</span>        std::vector&lt;int&gt; <span class="comment">// adjacent patches (i.e. sharing a cut-path)</span></div>
<div class="line"><span class="lineno"> 8134</span>        &gt;</div>
<div class="line"><span class="lineno"> 8135</span>        graph_patch_to_adj_list;</div>
<div class="line"><span class="lineno"> 8136</span> </div>
<div class="line"><span class="lineno"> 8137</span>    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(patch_discovery_seeds.size() % 2 == 0);</div>
<div class="line"><span class="lineno"> 8138</span> </div>
<div class="line"><span class="lineno"> 8139</span>    <span class="comment">// To understand this loop see how &quot;patch_discovery_seeds&quot; is define above.</span></div>
<div class="line"><span class="lineno"> 8140</span>    <span class="comment">// We are effetcively using the seed polygon for each patch, to determing adjacency.</span></div>
<div class="line"><span class="lineno"> 8141</span>    <span class="comment">// &quot;patch_discovery_seeds&quot; is populated with two polygons are any one time,</span></div>
<div class="line"><span class="lineno"> 8142</span>    <span class="comment">// where these polygons shared a cutpath edge, and hence belong to the boundaries</span></div>
<div class="line"><span class="lineno"> 8143</span>    <span class="comment">// of their respective patches</span></div>
<div class="line"><span class="lineno"> 8144</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)patch_discovery_seeds.size(); i += 2) {</div>
<div class="line"><span class="lineno"> 8145</span>        <span class="keyword">const</span> std::pair&lt;int, int&gt;&amp; cur = patch_discovery_seeds[i];</div>
<div class="line"><span class="lineno"> 8146</span>        <span class="keyword">const</span> <span class="keywordtype">int</span> cur_cm_traced_poly = cur.first;</div>
<div class="line"><span class="lineno"> 8147</span>        <span class="keyword">const</span> <span class="keywordtype">int</span> cur_patch_idx = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_cm_poly_to_patch_idx, cur_cm_traced_poly);</div>
<div class="line"><span class="lineno"> 8148</span> </div>
<div class="line"><span class="lineno"> 8149</span>        <span class="keyword">const</span> std::pair&lt;int, int&gt;&amp; nxt = patch_discovery_seeds[(std::size_t)i + 1];</div>
<div class="line"><span class="lineno"> 8150</span>        <span class="keyword">const</span> <span class="keywordtype">int</span> nxt_cm_traced_poly = nxt.first;</div>
<div class="line"><span class="lineno"> 8151</span>        <span class="keyword">const</span> <span class="keywordtype">int</span> nxt_patch_idx = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_cm_poly_to_patch_idx, nxt_cm_traced_poly);</div>
<div class="line"><span class="lineno"> 8152</span> </div>
<div class="line"><span class="lineno"> 8153</span>        graph_patch_to_adj_list[cur_patch_idx].push_back(nxt_patch_idx);</div>
<div class="line"><span class="lineno"> 8154</span>        graph_patch_to_adj_list[nxt_patch_idx].push_back(cur_patch_idx);</div>
<div class="line"><span class="lineno"> 8155</span>    }</div>
<div class="line"><span class="lineno"> 8156</span> </div>
<div class="line"><span class="lineno"> 8158</span>    <span class="comment">// Identify which patches are interior and which are exterior (coloring)</span></div>
<div class="line"><span class="lineno"> 8160</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 8161</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8162</span>    <span class="comment">// We will now sort the patches into two sets - interior and exterior.</span></div>
<div class="line"><span class="lineno"> 8163</span>    <span class="comment">// We do this by building an adjacency matrix and its square (^2) to produce</span></div>
<div class="line"><span class="lineno"> 8164</span>    <span class="comment">// a bipartite graph via coloring. The adjacency matrix represents the</span></div>
<div class="line"><span class="lineno"> 8165</span>    <span class="comment">// adjacency between patches (sharing a cut path).</span></div>
<div class="line"><span class="lineno"> 8166</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8167</span> </div>
<div class="line"><span class="lineno"> 8168</span>    <a class="code hl_class" href="../../df/d20/classmatrix__t.html">matrix_t&lt;&gt;</a> scs_adj_matrix((<span class="keywordtype">int</span>)patches.size(), (<span class="keywordtype">int</span>)patches.size()); <span class="comment">// square</span></div>
<div class="line"><span class="lineno"> 8169</span> </div>
<div class="line"><span class="lineno"> 8170</span>    <span class="keywordflow">for</span> (std::unordered_map&lt;<span class="keywordtype">int</span>, std::vector&lt;int&gt;&gt;::const_iterator patch_iter = graph_patch_to_adj_list.cbegin();</div>
<div class="line"><span class="lineno"> 8171</span>         patch_iter != graph_patch_to_adj_list.cend();</div>
<div class="line"><span class="lineno"> 8172</span>         ++patch_iter) {</div>
<div class="line"><span class="lineno"> 8173</span> </div>
<div class="line"><span class="lineno"> 8174</span>        <span class="keyword">const</span> <span class="keywordtype">int</span> row_id = patch_iter-&gt;first; <span class="comment">// same as patch index</span></div>
<div class="line"><span class="lineno"> 8175</span> </div>
<div class="line"><span class="lineno"> 8176</span>        <span class="keywordflow">for</span> (std::vector&lt;int&gt;::const_iterator adj_patch_iter = patch_iter-&gt;second.cbegin();</div>
<div class="line"><span class="lineno"> 8177</span>             adj_patch_iter != patch_iter-&gt;second.cend();</div>
<div class="line"><span class="lineno"> 8178</span>             ++adj_patch_iter) {</div>
<div class="line"><span class="lineno"> 8179</span> </div>
<div class="line"><span class="lineno"> 8180</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> col_id = *adj_patch_iter;</div>
<div class="line"><span class="lineno"> 8181</span> </div>
<div class="line"><span class="lineno"> 8182</span>            <span class="keywordflow">if</span> (row_id == col_id) {</div>
<div class="line"><span class="lineno"> 8183</span>                <span class="comment">// our adjacency matrix is no self referent because patches</span></div>
<div class="line"><span class="lineno"> 8184</span>                <span class="comment">// do not connect to themselves!</span></div>
<div class="line"><span class="lineno"> 8185</span>                <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 8186</span>            }</div>
<div class="line"><span class="lineno"> 8187</span> </div>
<div class="line"><span class="lineno"> 8188</span>            scs_adj_matrix(row_id, col_id) = 1; <span class="comment">// mark adjacent</span></div>
<div class="line"><span class="lineno"> 8189</span>        }</div>
<div class="line"><span class="lineno"> 8190</span>    }</div>
<div class="line"><span class="lineno"> 8191</span> </div>
<div class="line"><span class="lineno"> 8192</span>    <span class="keyword">const</span> <a class="code hl_class" href="../../df/d20/classmatrix__t.html">matrix_t&lt;&gt;</a> scs_adj_matrix_sqrd = scs_adj_matrix * scs_adj_matrix;</div>
<div class="line"><span class="lineno"> 8193</span> </div>
<div class="line"><span class="lineno"> 8194</span>    <span class="comment">// Here we do graph coloring using BFS</span></div>
<div class="line"><span class="lineno"> 8195</span>    <span class="comment">// NOTE: coloring is used to mark patches as either interior or exterior.</span></div>
<div class="line"><span class="lineno"> 8196</span>    <span class="comment">// Be aware that since we work only with the topology (connectivity), the</span></div>
<div class="line"><span class="lineno"> 8197</span>    <span class="comment">// notion color itself will not tell us whether a patch is interior or</span></div>
<div class="line"><span class="lineno"> 8198</span>    <span class="comment">// exterior. The coloring simply tells us that a patch belongs to one</span></div>
<div class="line"><span class="lineno"> 8199</span>    <span class="comment">// group or the other. One exception is when we have a floating-patch</span></div>
<div class="line"><span class="lineno"> 8200</span>    <span class="comment">// in which case it is possible to infer that the patch is interior.</span></div>
<div class="line"><span class="lineno"> 8201</span>    <span class="comment">// This is because floating patches are always defined by interior</span></div>
<div class="line"><span class="lineno"> 8202</span>    <span class="comment">// intersection-halfedges.</span></div>
<div class="line"><span class="lineno"> 8203</span> </div>
<div class="line"><span class="lineno"> 8204</span>    std::deque&lt;int&gt; graph_patch_coloring_queue;</div>
<div class="line"><span class="lineno"> 8205</span>    <span class="comment">// start coloring with the first patch</span></div>
<div class="line"><span class="lineno"> 8206</span>    graph_patch_coloring_queue.push_back(0);</div>
<div class="line"><span class="lineno"> 8207</span>    <span class="comment">// &quot;red&quot; chosen arbitrarilly</span></div>
<div class="line"><span class="lineno"> 8208</span>    std::vector&lt;int&gt;&amp; red_nodes = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(color_to_patch, <span class="charliteral">&#39;A&#39;</span>);</div>
<div class="line"><span class="lineno"> 8209</span> </div>
<div class="line"><span class="lineno"> 8210</span>    <span class="keywordflow">do</span> { <span class="comment">// color the current node/patch of the red set</span></div>
<div class="line"><span class="lineno"> 8211</span>        <span class="keyword">const</span> <span class="keywordtype">int</span> graph_cur_colored_patch_idx = graph_patch_coloring_queue.front();</div>
<div class="line"><span class="lineno"> 8212</span>        red_nodes.push_back(graph_cur_colored_patch_idx);</div>
<div class="line"><span class="lineno"> 8213</span> </div>
<div class="line"><span class="lineno"> 8214</span>        <span class="keyword">const</span> <span class="keywordtype">int</span> row_id = graph_cur_colored_patch_idx; <span class="comment">// NOTE: no need to account for the fact that the number of patches accumulates since graph_1st_patch_idx == 0</span></div>
<div class="line"><span class="lineno"> 8215</span> </div>
<div class="line"><span class="lineno"> 8216</span>        <span class="comment">// find adjacent patch using A^2 and push adj patch onto queue (if not already colored)</span></div>
<div class="line"><span class="lineno"> 8217</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> col_id = 0; col_id &lt; scs_adj_matrix_sqrd.<a class="code hl_function" href="../../df/d20/classmatrix__t.html#a5e16fcbd07f878c4efebe9d54fe37c49">cols</a>(); ++col_id) {</div>
<div class="line"><span class="lineno"> 8218</span> </div>
<div class="line"><span class="lineno"> 8219</span>            <span class="keywordflow">if</span> (row_id == col_id) {</div>
<div class="line"><span class="lineno"> 8220</span>                <span class="keywordflow">continue</span>; <span class="comment">// we dont care about two-walks from a node back to itself</span></div>
<div class="line"><span class="lineno"> 8221</span>            }</div>
<div class="line"><span class="lineno"> 8222</span> </div>
<div class="line"><span class="lineno"> 8223</span>            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> entry = scs_adj_matrix_sqrd(row_id, col_id);</div>
<div class="line"><span class="lineno"> 8224</span> </div>
<div class="line"><span class="lineno"> 8225</span>            <span class="keywordflow">if</span> (entry &gt; 0) <span class="comment">// two-walk exists</span></div>
<div class="line"><span class="lineno"> 8226</span>            {</div>
<div class="line"><span class="lineno"> 8227</span>                <span class="keyword">const</span> <span class="keywordtype">int</span> graph_next_colored_patch_idx = col_id;</div>
<div class="line"><span class="lineno"> 8228</span> </div>
<div class="line"><span class="lineno"> 8229</span>                <span class="keywordflow">if</span> ( <span class="comment">// not already colored</span></div>
<div class="line"><span class="lineno"> 8230</span>                    std::find(red_nodes.cbegin(), red_nodes.cend(), graph_next_colored_patch_idx) == red_nodes.cend() &amp;&amp;</div>
<div class="line"><span class="lineno"> 8231</span>                    <span class="comment">// not in queue</span></div>
<div class="line"><span class="lineno"> 8232</span>                    std::find(graph_patch_coloring_queue.cbegin(), graph_patch_coloring_queue.cend(), graph_next_colored_patch_idx) == graph_patch_coloring_queue.cend()) {</div>
<div class="line"><span class="lineno"> 8233</span>                    graph_patch_coloring_queue.push_back(graph_next_colored_patch_idx);</div>
<div class="line"><span class="lineno"> 8234</span>                }</div>
<div class="line"><span class="lineno"> 8235</span>            }</div>
<div class="line"><span class="lineno"> 8236</span>        }</div>
<div class="line"><span class="lineno"> 8237</span> </div>
<div class="line"><span class="lineno"> 8238</span>        graph_patch_coloring_queue.pop_front(); <span class="comment">// rm graph_cur_colored_patch_idx</span></div>
<div class="line"><span class="lineno"> 8239</span> </div>
<div class="line"><span class="lineno"> 8240</span>    } <span class="keywordflow">while</span> (!graph_patch_coloring_queue.empty());</div>
<div class="line"><span class="lineno"> 8241</span> </div>
<div class="line"><span class="lineno"> 8242</span>    <span class="comment">// color the remaining uncolored nodes</span></div>
<div class="line"><span class="lineno"> 8243</span>    std::vector&lt;int&gt;&amp; blue_nodes = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(color_to_patch, <span class="charliteral">&#39;B&#39;</span>); <span class="comment">// i.e. blue patches</span></div>
<div class="line"><span class="lineno"> 8244</span> </div>
<div class="line"><span class="lineno"> 8245</span>    <span class="keywordflow">for</span> (std::unordered_map&lt;<span class="keywordtype">int</span>, std::vector&lt;int&gt;&gt;::const_iterator patch_iter = graph_patch_to_adj_list.cbegin();</div>
<div class="line"><span class="lineno"> 8246</span>         patch_iter != graph_patch_to_adj_list.cend();</div>
<div class="line"><span class="lineno"> 8247</span>         ++patch_iter) {</div>
<div class="line"><span class="lineno"> 8248</span> </div>
<div class="line"><span class="lineno"> 8249</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> is_red = std::find(red_nodes.cbegin(), red_nodes.cend(), patch_iter-&gt;first) != red_nodes.cend();</div>
<div class="line"><span class="lineno"> 8250</span> </div>
<div class="line"><span class="lineno"> 8251</span>        <span class="keywordflow">if</span> (!is_red) {</div>
<div class="line"><span class="lineno"> 8252</span>            blue_nodes.push_back(patch_iter-&gt;first);</div>
<div class="line"><span class="lineno"> 8253</span>        }</div>
<div class="line"><span class="lineno"> 8254</span>    }</div>
<div class="line"><span class="lineno"> 8255</span> </div>
<div class="line"><span class="lineno"> 8256</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>(); <span class="comment">// &amp;&amp;&amp;&amp;&amp;</span></div>
<div class="line"><span class="lineno"> 8257</span> </div>
<div class="line"><span class="lineno"> 8258</span>    <span class="comment">// NOTE: at this stage, all strongly-connected-sets have been identified and colored (i.e via coloring, all nodes/patches have been associated with a side : interior or exterior)</span></div>
<div class="line"><span class="lineno"> 8259</span> </div>
<div class="line"><span class="lineno"> 8260</span>    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(!patches.empty());</div>
<div class="line"><span class="lineno"> 8261</span> </div>
<div class="line"><span class="lineno"> 8262</span>    primary_interior_ihalfedge_pool.clear();</div>
<div class="line"><span class="lineno"> 8263</span> </div>
<div class="line"><span class="lineno"> 8265</span>    <span class="comment">// Find the cut-mesh vertices that must not be duplicated</span></div>
<div class="line"><span class="lineno"> 8267</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 8268</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Find non-duplicated cut-mesh vertices&quot;</span>);</div>
<div class="line"><span class="lineno"> 8269</span>    <span class="comment">// In the case of a partial cut, the o-vertices of the cut-mesh are not duplicated</span></div>
<div class="line"><span class="lineno"> 8270</span>    <span class="comment">// e.g. those which reside interior to the sm</span></div>
<div class="line"><span class="lineno"> 8271</span>    std::vector&lt;vd_t&gt; sm_interior_cs_border_vertices;</div>
<div class="line"><span class="lineno"> 8272</span> </div>
<div class="line"><span class="lineno"> 8273</span>    <span class="keywordflow">if</span> (partial_cut_detected) {</div>
<div class="line"><span class="lineno"> 8274</span> </div>
<div class="line"><span class="lineno"> 8275</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8276</span>        <span class="comment">// Here we save the cut-mesh border vertices (non-intersection points) which</span></div>
<div class="line"><span class="lineno"> 8277</span>        <span class="comment">// are on the interior (inside) of the src-mesh.</span></div>
<div class="line"><span class="lineno"> 8278</span>        <span class="comment">// These are needed for calculating properly-sealed connected components which</span></div>
<div class="line"><span class="lineno"> 8279</span>        <span class="comment">// have been partially cut. We use this informaion determine which vertices of</span></div>
<div class="line"><span class="lineno"> 8280</span>        <span class="comment">// the cut-mesh to not duplicate while allowing for the openings in the sealed</span></div>
<div class="line"><span class="lineno"> 8281</span>        <span class="comment">// the connected components.</span></div>
<div class="line"><span class="lineno"> 8282</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8283</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(!cm_is_watertight);</div>
<div class="line"><span class="lineno"> 8284</span> </div>
<div class="line"><span class="lineno"> 8285</span>        <span class="comment">/*</span></div>
<div class="line"><span class="lineno"> 8286</span><span class="comment">        1. do while there exists a re-entrant vertex which has not been used to find an interior cut-mesh border vertices</span></div>
<div class="line"><span class="lineno"> 8287</span><span class="comment">            a. get the ihalfedge whose source is &lt;1&gt; and it is used for tracing</span></div>
<div class="line"><span class="lineno"> 8288</span><span class="comment">            b.  do while target of next halfedge along border is not an intersection point</span></div>
<div class="line"><span class="lineno"> 8289</span><span class="comment">                c. save target of current halfedge as one which we will not duplicate</span></div>
<div class="line"><span class="lineno"> 8290</span><span class="comment">                d. go to next halfedge along border</span></div>
<div class="line"><span class="lineno"> 8291</span><span class="comment">    */</span></div>
<div class="line"><span class="lineno"> 8292</span> </div>
<div class="line"><span class="lineno"> 8293</span>        <span class="comment">// populate the queue with all cut-mesh tip re-entrant vertices</span></div>
<div class="line"><span class="lineno"> 8294</span>        std::deque&lt;vd_t&gt; reentrant_ivertex_queue(cm_border_reentrant_ivtx_list.cbegin(), cm_border_reentrant_ivtx_list.cend());</div>
<div class="line"><span class="lineno"> 8295</span> </div>
<div class="line"><span class="lineno"> 8296</span>        <span class="keywordflow">do</span> {</div>
<div class="line"><span class="lineno"> 8297</span> </div>
<div class="line"><span class="lineno"> 8298</span>            <span class="comment">// pull any re-entrant vertex from queue</span></div>
<div class="line"><span class="lineno"> 8299</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> current_reentrant_ivertex = reentrant_ivertex_queue.front();</div>
<div class="line"><span class="lineno"> 8300</span> </div>
<div class="line"><span class="lineno"> 8301</span>            <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> current_cs_border_he = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno"> 8302</span>            <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> next_cs_border_he = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno"> 8303</span>            <span class="keywordtype">int</span> current_cs_border_he_idx = -1;</div>
<div class="line"><span class="lineno"> 8304</span>            <span class="keywordtype">int</span> next_cs_border_he_idx = -1;</div>
<div class="line"><span class="lineno"> 8305</span> </div>
<div class="line"><span class="lineno"> 8306</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8307</span>            <span class="comment">// find polygon, and its halfedge whose src vertex is the current re-entrant vertex</span></div>
<div class="line"><span class="lineno"> 8308</span>            <span class="comment">// &quot;current_reentrant_ivertex&quot;, and the target is not an intersection point</span></div>
<div class="line"><span class="lineno"> 8309</span>            <span class="comment">// keep in mind that we are looking for the non-intersection points that lie</span></div>
<div class="line"><span class="lineno"> 8310</span>            <span class="comment">// inside the src-mesh - so that we dont duplicate them.</span></div>
<div class="line"><span class="lineno"> 8311</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8312</span>            std::vector&lt;traced_polygon_t&gt;::const_iterator next_cs_border_he_poly_find_iter = std::find_if(</div>
<div class="line"><span class="lineno"> 8313</span>                m0_polygons.cbegin() + traced_sm_polygon_count, <span class="comment">// offset to start of traced cut-mesh polygons</span></div>
<div class="line"><span class="lineno"> 8314</span>                m0_polygons.cend(),</div>
<div class="line"><span class="lineno"> 8315</span>                [&amp;](<span class="keyword">const</span> <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a>&amp; cs_poly) {</div>
<div class="line"><span class="lineno"> 8316</span>                    <span class="comment">// for each halfedge of cut-mesh polygon</span></div>
<div class="line"><span class="lineno"> 8317</span>                    for (traced_polygon_t::const_iterator cs_poly_he_iter = cs_poly.cbegin();</div>
<div class="line"><span class="lineno"> 8318</span>                         cs_poly_he_iter != cs_poly.cend();</div>
<div class="line"><span class="lineno"> 8319</span>                         ++cs_poly_he_iter) {</div>
<div class="line"><span class="lineno"> 8320</span> </div>
<div class="line"><span class="lineno"> 8321</span>                        <span class="comment">// check if the target is an intersection point</span></div>
<div class="line"><span class="lineno"> 8322</span>                        const vd_t tgt = m0.target(*cs_poly_he_iter);</div>
<div class="line"><span class="lineno"> 8323</span>                        const bool tgt_is_ivertex = m0_is_intersection_point(tgt, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 8324</span> </div>
<div class="line"><span class="lineno"> 8325</span>                        if (tgt_is_ivertex) { <span class="comment">//..--&gt;x</span></div>
<div class="line"><span class="lineno"> 8326</span>                            continue;</div>
<div class="line"><span class="lineno"> 8327</span>                        }</div>
<div class="line"><span class="lineno"> 8328</span> </div>
<div class="line"><span class="lineno"> 8329</span>                        <span class="comment">// is the halfedge on the border of the cut-mesh i.e. its opposite halfedge is not</span></div>
<div class="line"><span class="lineno"> 8330</span>                        <span class="comment">// used to trace a polygon</span></div>
<div class="line"><span class="lineno"> 8331</span>                        const bool is_on_cs_border = SAFE_ACCESS(m0_h_to_ply, m0.opposite(*cs_poly_he_iter)).size() == 0; <span class="comment">// m0_h_to_ply.find(m0.opposite(*cs_poly_he_iter)) == m0_h_to_ply.cend(); // opposite is used to traced a polygon</span></div>
<div class="line"><span class="lineno"> 8332</span> </div>
<div class="line"><span class="lineno"> 8333</span>                        if (is_on_cs_border) {</div>
<div class="line"><span class="lineno"> 8334</span> </div>
<div class="line"><span class="lineno"> 8335</span>                            <span class="comment">// check if the src vertex of the current halfedge is a re-entrant vertex</span></div>
<div class="line"><span class="lineno"> 8336</span>                            <span class="comment">// we search through the queue because it contains the tip re-entrant vertices</span></div>
<div class="line"><span class="lineno"> 8337</span>                            <span class="comment">// that have not yet been visited (valid set).</span></div>
<div class="line"><span class="lineno"> 8338</span>                            <span class="comment">// Note that this implies that src is also an intersection point</span></div>
<div class="line"><span class="lineno"> 8339</span>                            const vd_t src = m0.source(*cs_poly_he_iter);</div>
<div class="line"><span class="lineno"> 8340</span>                            const bool src_is_reentrant = std::find(reentrant_ivertex_queue.cbegin(), reentrant_ivertex_queue.cend(), src) != reentrant_ivertex_queue.cend();</div>
<div class="line"><span class="lineno"> 8341</span> </div>
<div class="line"><span class="lineno"> 8342</span>                            if (src_is_reentrant) {</div>
<div class="line"><span class="lineno"> 8343</span> </div>
<div class="line"><span class="lineno"> 8344</span>                                <span class="comment">// we have found that first halfedge from which the remaining one(s)</span></div>
<div class="line"><span class="lineno"> 8345</span>                                <span class="comment">// inside the src-mesh can be found</span></div>
<div class="line"><span class="lineno"> 8346</span>                                next_cs_border_he = *cs_poly_he_iter;</div>
<div class="line"><span class="lineno"> 8347</span>                                next_cs_border_he_idx = (int)std::distance(cs_poly.cbegin(), cs_poly_he_iter);</div>
<div class="line"><span class="lineno"> 8348</span>                                break;</div>
<div class="line"><span class="lineno"> 8349</span>                            } else {</div>
<div class="line"><span class="lineno"> 8350</span>                                continue;</div>
<div class="line"><span class="lineno"> 8351</span>                            }</div>
<div class="line"><span class="lineno"> 8352</span>                        } else {</div>
<div class="line"><span class="lineno"> 8353</span>                            continue;</div>
<div class="line"><span class="lineno"> 8354</span>                        }</div>
<div class="line"><span class="lineno"> 8355</span>                    }</div>
<div class="line"><span class="lineno"> 8356</span> </div>
<div class="line"><span class="lineno"> 8357</span>                    <a class="code hl_variable" href="../../d2/d86/xmltok__impl_8inc.html#a0daef2d817750da6dd6df041157e8aba">return</a> (next_cs_border_he != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>());</div>
<div class="line"><span class="lineno"> 8358</span>                });</div>
<div class="line"><span class="lineno"> 8359</span> </div>
<div class="line"><span class="lineno"> 8360</span>            reentrant_ivertex_queue.pop_front(); <span class="comment">// rm current_reentrant_ivertex</span></div>
<div class="line"><span class="lineno"> 8361</span> </div>
<div class="line"><span class="lineno"> 8362</span>            <span class="comment">// we could not find a halfedge whose src vertex is the current re-entrant vertex</span></div>
<div class="line"><span class="lineno"> 8363</span>            <span class="keywordflow">if</span> (next_cs_border_he_poly_find_iter == m0_polygons.cend()) {</div>
<div class="line"><span class="lineno"> 8364</span>                <span class="comment">// happens when a single cut-mesh partially cuts the src-mesh whereby</span></div>
<div class="line"><span class="lineno"> 8365</span>                <span class="comment">// a single edge passes through 2 or more src-mesh faces e.g.</span></div>
<div class="line"><span class="lineno"> 8366</span>                <span class="comment">// tet vs triangle partial cut</span></div>
<div class="line"><span class="lineno"> 8367</span>                <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 8368</span>            }</div>
<div class="line"><span class="lineno"> 8369</span> </div>
<div class="line"><span class="lineno"> 8370</span>            <span class="comment">// a reference to the polygon which is traced with the halfedge we found</span></div>
<div class="line"><span class="lineno"> 8371</span>            std::vector&lt;traced_polygon_t&gt;::const_iterator current_cs_border_he_poly_find_iter = m0_polygons.cend();</div>
<div class="line"><span class="lineno"> 8372</span> </div>
<div class="line"><span class="lineno"> 8373</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8374</span>            <span class="comment">// we will now walk along the border of the cut-mesh saving all non</span></div>
<div class="line"><span class="lineno"> 8375</span>            <span class="comment">// intersection points which must not be duplicated later</span></div>
<div class="line"><span class="lineno"> 8376</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8377</span>            <span class="keywordflow">while</span> (next_cs_border_he != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>()) {</div>
<div class="line"><span class="lineno"> 8378</span> </div>
<div class="line"><span class="lineno"> 8379</span>                <span class="comment">// current border halfedge</span></div>
<div class="line"><span class="lineno"> 8380</span>                current_cs_border_he = next_cs_border_he;</div>
<div class="line"><span class="lineno"> 8381</span>                <span class="comment">// polygon of current border halfedge</span></div>
<div class="line"><span class="lineno"> 8382</span>                current_cs_border_he_poly_find_iter = next_cs_border_he_poly_find_iter;</div>
<div class="line"><span class="lineno"> 8383</span>                <span class="comment">// index of current border halfedge</span></div>
<div class="line"><span class="lineno"> 8384</span>                current_cs_border_he_idx = next_cs_border_he_idx;</div>
<div class="line"><span class="lineno"> 8385</span> </div>
<div class="line"><span class="lineno"> 8386</span>                <span class="comment">// reset</span></div>
<div class="line"><span class="lineno"> 8387</span>                next_cs_border_he = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno"> 8388</span>                next_cs_border_he_idx = -1;</div>
<div class="line"><span class="lineno"> 8389</span>                next_cs_border_he_poly_find_iter = m0_polygons.cend();</div>
<div class="line"><span class="lineno"> 8390</span> </div>
<div class="line"><span class="lineno"> 8391</span>                <span class="comment">// save the non-intersection point on the border</span></div>
<div class="line"><span class="lineno"> 8392</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> current_cs_border_he_tgt = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(current_cs_border_he);</div>
<div class="line"><span class="lineno"> 8393</span>                sm_interior_cs_border_vertices.push_back(current_cs_border_he_tgt);</div>
<div class="line"><span class="lineno"> 8394</span> </div>
<div class="line"><span class="lineno"> 8395</span>                <span class="keywordflow">if</span> (<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(current_cs_border_he_tgt, ps_vtx_cnt)) {</div>
<div class="line"><span class="lineno"> 8396</span>                    <span class="keywordflow">break</span>; <span class="comment">// done (finished walking along cut-mesh interior border)</span></div>
<div class="line"><span class="lineno"> 8397</span>                }</div>
<div class="line"><span class="lineno"> 8398</span> </div>
<div class="line"><span class="lineno"> 8399</span>                <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8400</span>                <span class="comment">// find next halfedge along the border</span></div>
<div class="line"><span class="lineno"> 8401</span>                <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8402</span> </div>
<div class="line"><span class="lineno"> 8403</span>                <span class="comment">// const int&amp; current_cs_border_he_poly_idx = SAFE_ACCESS(m0_h_to_ply, current_cs_border_he).front(); // NOTE: class-2 or class-1 ihalfedges are incident to only one polygon</span></div>
<div class="line"><span class="lineno"> 8404</span> </div>
<div class="line"><span class="lineno"> 8405</span>                <span class="comment">// the current polygon</span></div>
<div class="line"><span class="lineno"> 8406</span>                <span class="comment">// const traced_polygon_t&amp; current_cs_border_he_poly = *current_cs_border_he_poly_find_iter;</span></div>
<div class="line"><span class="lineno"> 8407</span>                <span class="comment">// get reference to the current border halfedge in the polygon</span></div>
<div class="line"><span class="lineno"> 8408</span>                <span class="comment">// const traced_polygon_t::const_iterator current_cs_border_he_find_iter = std::find(</span></div>
<div class="line"><span class="lineno"> 8409</span>                <span class="comment">//    current_cs_border_he_poly.cbegin(), current_cs_border_he_poly.cend(), current_cs_border_he);</span></div>
<div class="line"><span class="lineno"> 8410</span> </div>
<div class="line"><span class="lineno"> 8411</span>                <span class="comment">// halfedge must exist in the polygon because it is used for tracing</span></div>
<div class="line"><span class="lineno"> 8412</span>                <span class="comment">// MCUT_ASSERT(current_cs_border_he_find_iter != current_cs_border_he_poly.cend());</span></div>
<div class="line"><span class="lineno"> 8413</span> </div>
<div class="line"><span class="lineno"> 8414</span>                <span class="comment">// const int current_cs_border_he_idx = std::distance(current_cs_border_he_poly.cbegin(), current_cs_border_he_find_iter);</span></div>
<div class="line"><span class="lineno"> 8415</span> </div>
<div class="line"><span class="lineno"> 8416</span>                <span class="comment">// Here we now find the next border halfedge</span></div>
<div class="line"><span class="lineno"> 8417</span>                <span class="comment">// -----------------------------------------</span></div>
<div class="line"><span class="lineno"> 8418</span> </div>
<div class="line"><span class="lineno"> 8419</span>                <span class="comment">// We do this by circulating around &quot;current_cs_border_he_tgt&quot; to find the next border halfedge</span></div>
<div class="line"><span class="lineno"> 8420</span>                <span class="comment">// starting from the next after the current halfedge (around the vertex)</span></div>
<div class="line"><span class="lineno"> 8421</span>                std::vector&lt;traced_polygon_t&gt;::const_iterator next_he_poly_iter = current_cs_border_he_poly_find_iter;</div>
<div class="line"><span class="lineno"> 8422</span>                std::vector&lt;traced_polygon_t&gt;::const_iterator cur_he_poly_iter = m0_polygons.cend();</div>
<div class="line"><span class="lineno"> 8423</span>                <span class="keywordtype">int</span> next_he_idx = <a class="code hl_function" href="../../d5/d60/utils_8h.html#ad42d4789f60996516823b4b4cfb9c04d">wrap_integer</a>(current_cs_border_he_idx + 1, 0, (<span class="keywordtype">int</span>)next_he_poly_iter-&gt;size() - 1);</div>
<div class="line"><span class="lineno"> 8424</span>                <span class="keywordtype">int</span> cur_he_idx = -1;</div>
<div class="line"><span class="lineno"> 8425</span>                <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> next_he = next_he_poly_iter-&gt;at(next_he_idx);</div>
<div class="line"><span class="lineno"> 8426</span>                <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> cur_he = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno"> 8427</span> </div>
<div class="line"><span class="lineno"> 8428</span>                <span class="keywordflow">do</span> {</div>
<div class="line"><span class="lineno"> 8429</span>                    cur_he = next_he;</div>
<div class="line"><span class="lineno"> 8430</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(cur_he != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>());</div>
<div class="line"><span class="lineno"> 8431</span>                    next_he = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno"> 8432</span> </div>
<div class="line"><span class="lineno"> 8433</span>                    cur_he_idx = next_he_idx;</div>
<div class="line"><span class="lineno"> 8434</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(cur_he_idx != -1);</div>
<div class="line"><span class="lineno"> 8435</span>                    next_he_idx = -1;</div>
<div class="line"><span class="lineno"> 8436</span> </div>
<div class="line"><span class="lineno"> 8437</span>                    cur_he_poly_iter = next_he_poly_iter;</div>
<div class="line"><span class="lineno"> 8438</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(cur_he_poly_iter != m0_polygons.cend());</div>
<div class="line"><span class="lineno"> 8439</span>                    next_he_poly_iter = m0_polygons.cend();</div>
<div class="line"><span class="lineno"> 8440</span> </div>
<div class="line"><span class="lineno"> 8441</span>                    <span class="comment">// the next halfedge descriptor itself</span></div>
<div class="line"><span class="lineno"> 8442</span>                    <span class="comment">// const hd_t&amp; cur_he = SAFE_ACCESS(current_cs_border_he_poly, cur_he_idx); // in the polygon of current_cs_border_he</span></div>
<div class="line"><span class="lineno"> 8443</span> </div>
<div class="line"><span class="lineno"> 8444</span>                    <span class="comment">// get the opposite of the next halfedge in order to enter the neighbouring</span></div>
<div class="line"><span class="lineno"> 8445</span>                    <span class="comment">// polygon which has a border halfedge</span></div>
<div class="line"><span class="lineno"> 8446</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> opp_of_cur_he = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(cur_he);</div>
<div class="line"><span class="lineno"> 8447</span> </div>
<div class="line"><span class="lineno"> 8448</span>                    <span class="keywordtype">bool</span> opp_of_cur_he_is_border = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, opp_of_cur_he).size() == 0; <span class="comment">// m0_h_to_ply.find(opp_of_cur_he) == m0_h_to_ply.cend(); // opposite is used to traced a polygon</span></div>
<div class="line"><span class="lineno"> 8449</span> </div>
<div class="line"><span class="lineno"> 8450</span>                    <span class="keywordflow">if</span> (opp_of_cur_he_is_border) { <span class="comment">// found!</span></div>
<div class="line"><span class="lineno"> 8451</span>                        next_cs_border_he = cur_he;</div>
<div class="line"><span class="lineno"> 8452</span>                        next_cs_border_he_idx = cur_he_idx;</div>
<div class="line"><span class="lineno"> 8453</span>                        next_cs_border_he_poly_find_iter = cur_he_poly_iter;</div>
<div class="line"><span class="lineno"> 8454</span>                    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 8455</span> </div>
<div class="line"><span class="lineno"> 8456</span>                        <span class="comment">// get index of this neighouring polygon</span></div>
<div class="line"><span class="lineno"> 8457</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, opp_of_cur_he).<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a809275ccd755fb7b88661d952134b14d">size</a>() &gt; 0 <span class="comment">/*m0_h_to_ply.find(opp_of_cur_he) != m0_h_to_ply.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 8458</span>                        <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; opp_of_cur_he_poly_idx = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, opp_of_cur_he).front(); <span class="comment">// NOTE: class-2 or class-1 ihalfedges are incident to only one polygon</span></div>
<div class="line"><span class="lineno"> 8459</span>                        <span class="comment">// reference to the neighbour/adjacent polygon</span></div>
<div class="line"><span class="lineno"> 8460</span>                        std::vector&lt;traced_polygon_t&gt;::const_iterator opp_of_cur_he_poly_iter = m0_polygons.cbegin() + (opp_of_cur_he_poly_idx);</div>
<div class="line"><span class="lineno"> 8461</span> </div>
<div class="line"><span class="lineno"> 8462</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(opp_of_cur_he_poly_iter != m0_polygons.cend());</div>
<div class="line"><span class="lineno"> 8463</span> </div>
<div class="line"><span class="lineno"> 8464</span>                        <span class="comment">// get the neighbouring polygon itself</span></div>
<div class="line"><span class="lineno"> 8465</span>                        <span class="keyword">const</span> <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a>&amp; opp_of_cur_he_poly = *opp_of_cur_he_poly_iter;</div>
<div class="line"><span class="lineno"> 8466</span>                        <span class="comment">// get the reference to the next of opposite of current halfedge</span></div>
<div class="line"><span class="lineno"> 8467</span>                        <span class="keyword">const</span> traced_polygon_t::const_iterator opp_of_cur_he_find_iter = std::find(</div>
<div class="line"><span class="lineno"> 8468</span>                            opp_of_cur_he_poly.cbegin(), opp_of_cur_he_poly.cend(), opp_of_cur_he);</div>
<div class="line"><span class="lineno"> 8469</span> </div>
<div class="line"><span class="lineno"> 8470</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(opp_of_cur_he_find_iter != opp_of_cur_he_poly.cend());</div>
<div class="line"><span class="lineno"> 8471</span> </div>
<div class="line"><span class="lineno"> 8472</span>                        <span class="comment">// index of &quot;next of opposite of current halfedge&quot; in the neighbour polygon</span></div>
<div class="line"><span class="lineno"> 8473</span>                        <span class="keyword">const</span> <span class="keywordtype">int</span> opp_of_cur_he_idx = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)<a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(opp_of_cur_he_poly.cbegin(), opp_of_cur_he_find_iter);</div>
<div class="line"><span class="lineno"> 8474</span>                        <span class="comment">// get the next halfedge, which will be on the border</span></div>
<div class="line"><span class="lineno"> 8475</span>                        <span class="keyword">const</span> <span class="keywordtype">int</span> next_of_opp_of_cur_he_idx = <a class="code hl_function" href="../../d5/d60/utils_8h.html#ad42d4789f60996516823b4b4cfb9c04d">wrap_integer</a>(opp_of_cur_he_idx + 1, 0, (<span class="keywordtype">int</span>)opp_of_cur_he_poly.size() - 1);</div>
<div class="line"><span class="lineno"> 8476</span> </div>
<div class="line"><span class="lineno"> 8477</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(next_of_opp_of_cur_he_idx &lt; (<span class="keywordtype">int</span>)opp_of_cur_he_poly.size());</div>
<div class="line"><span class="lineno"> 8478</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; next_of_opp_of_cur_he = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(opp_of_cur_he_poly, next_of_opp_of_cur_he_idx); <span class="comment">// in the polygon of opp_of_next_he_poly</span></div>
<div class="line"><span class="lineno"> 8479</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> opp_of_next_of_opp_of_cur_he = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(next_of_opp_of_cur_he);</div>
<div class="line"><span class="lineno"> 8480</span>                        <span class="keywordtype">bool</span> opp_of_next_of_opp_of_cur_he_is_border = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, opp_of_next_of_opp_of_cur_he).size() == 0; <span class="comment">// m0_h_to_ply.find(opp_of_next_of_opp_of_cur_he) == m0_h_to_ply.cend(); // opposite is used to traced a polygon</span></div>
<div class="line"><span class="lineno"> 8481</span> </div>
<div class="line"><span class="lineno"> 8482</span>                        <span class="comment">// bool opp_of_next_of_opp_of_cur_he_is_border = m0_h_to_ply.find(opp_of_next_of_opp_of_cur_he) == m0_h_to_ply.cend(); // opposite is used to traced a polygon</span></div>
<div class="line"><span class="lineno"> 8483</span> </div>
<div class="line"><span class="lineno"> 8484</span>                        <span class="keywordflow">if</span> (opp_of_next_of_opp_of_cur_he_is_border) { <span class="comment">// found!</span></div>
<div class="line"><span class="lineno"> 8485</span>                            next_cs_border_he = next_of_opp_of_cur_he;</div>
<div class="line"><span class="lineno"> 8486</span>                            next_cs_border_he_idx = next_of_opp_of_cur_he_idx;</div>
<div class="line"><span class="lineno"> 8487</span>                            next_cs_border_he_poly_find_iter = opp_of_cur_he_poly_iter;</div>
<div class="line"><span class="lineno"> 8488</span>                        } <span class="comment">// else if (opp_of_next_of_opp_of_cur_he_is_border) {</span></div>
<div class="line"><span class="lineno"> 8489</span> </div>
<div class="line"><span class="lineno"> 8490</span>                        <span class="comment">// this is an edge-case:</span></div>
<div class="line"><span class="lineno"> 8491</span>                        <span class="comment">// simple partial-cut intersection where an edge (of the cut-mesh) intersects two faces of the src-mesh</span></div>
<div class="line"><span class="lineno"> 8492</span> </div>
<div class="line"><span class="lineno"> 8493</span>                        <span class="comment">// get the target of the halfedge along the border of the adjacent polygon</span></div>
<div class="line"><span class="lineno"> 8494</span>                        <span class="comment">//    const vd_t next_of_opp_of_cur_he_tgt = m0.target(next_of_opp_of_cur_he);</span></div>
<div class="line"><span class="lineno"> 8495</span> </div>
<div class="line"><span class="lineno"> 8496</span>                        <span class="comment">//     MCUT_ASSERT(m0_is_intersection_point(next_of_opp_of_cur_he_tgt, ps_vtx_cnt));</span></div>
<div class="line"><span class="lineno"> 8497</span> </div>
<div class="line"><span class="lineno"> 8498</span>                        <span class="comment">//    break;</span></div>
<div class="line"><span class="lineno"> 8499</span>                        <span class="comment">//}</span></div>
<div class="line"><span class="lineno"> 8500</span>                        <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 8501</span> </div>
<div class="line"><span class="lineno"> 8502</span>                            <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; poly_idx = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, opp_of_next_of_opp_of_cur_he).front(); <span class="comment">// NOTE: class-2 or class-1 ihalfedges are incident to only one polygon</span></div>
<div class="line"><span class="lineno"> 8503</span>                            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8504</span>                            next_he_poly_iter = m0_polygons.cbegin() + (poly_idx);</div>
<div class="line"><span class="lineno"> 8505</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(next_he_poly_iter != m0_polygons.cend());</div>
<div class="line"><span class="lineno"> 8506</span>                            <span class="keyword">const</span> <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a>&amp; poly = *next_he_poly_iter;</div>
<div class="line"><span class="lineno"> 8507</span>                            <span class="keyword">const</span> traced_polygon_t::const_iterator he_find_iter = std::find(poly.cbegin(), poly.cend(), opp_of_next_of_opp_of_cur_he);</div>
<div class="line"><span class="lineno"> 8508</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(he_find_iter != poly.cend());</div>
<div class="line"><span class="lineno"> 8509</span>                            <span class="keyword">const</span> <span class="keywordtype">int</span> idx = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)<a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(poly.cbegin(), he_find_iter);</div>
<div class="line"><span class="lineno"> 8510</span>                            <span class="comment">// .. need to start from next-after, otherwise we end up in an infinite loop!</span></div>
<div class="line"><span class="lineno"> 8511</span>                            <span class="comment">// see top of current do-while loop: i.e. this -&gt; &quot;opp_of_cur_he = m0.opposite(cur_he);&quot; would</span></div>
<div class="line"><span class="lineno"> 8512</span>                            <span class="comment">// bring us back into the current polygon</span></div>
<div class="line"><span class="lineno"> 8513</span>                            next_he_idx = <a class="code hl_function" href="../../d5/d60/utils_8h.html#ad42d4789f60996516823b4b4cfb9c04d">wrap_integer</a>(idx + 1, 0, (<span class="keywordtype">int</span>)poly.size() - 1);</div>
<div class="line"><span class="lineno"> 8514</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(next_he_idx &lt; (<span class="keywordtype">int</span>)poly.size());</div>
<div class="line"><span class="lineno"> 8515</span>                            <span class="comment">// set next</span></div>
<div class="line"><span class="lineno"> 8516</span>                            <span class="comment">// --------</span></div>
<div class="line"><span class="lineno"> 8517</span>                            next_he = poly[next_he_idx];</div>
<div class="line"><span class="lineno"> 8518</span>                        }</div>
<div class="line"><span class="lineno"> 8519</span>                    }</div>
<div class="line"><span class="lineno"> 8520</span> </div>
<div class="line"><span class="lineno"> 8521</span>                    <span class="comment">// while the next border halfedge has not been found OR</span></div>
<div class="line"><span class="lineno"> 8522</span>                    <span class="comment">// if the next border he which is found is not actually equal to the current he</span></div>
<div class="line"><span class="lineno"> 8523</span>                } <span class="keywordflow">while</span> (next_cs_border_he == <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>());</div>
<div class="line"><span class="lineno"> 8524</span>            } <span class="comment">// while (...)</span></div>
<div class="line"><span class="lineno"> 8525</span> </div>
<div class="line"><span class="lineno"> 8526</span>        } <span class="keywordflow">while</span> (!reentrant_ivertex_queue.empty());</div>
<div class="line"><span class="lineno"> 8527</span>    } <span class="comment">// if (partial_cut_detected) {</span></div>
<div class="line"><span class="lineno"> 8528</span> </div>
<div class="line"><span class="lineno"> 8529</span>    cm_border_reentrant_ivtx_list.clear(); <span class="comment">// free</span></div>
<div class="line"><span class="lineno"> 8530</span> </div>
<div class="line"><span class="lineno"> 8531</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 8532</span> </div>
<div class="line"><span class="lineno"> 8534</span>    <span class="comment">// Infer patch location (inside/outside) based on graph coloring</span></div>
<div class="line"><span class="lineno"> 8536</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 8537</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8538</span>    <span class="comment">// Here we will now explicitly association location information to the graph</span></div>
<div class="line"><span class="lineno"> 8539</span>    <span class="comment">// color. Thus for each color &#39;A&#39;, or &#39;B&#39; we find out if it means &quot;interior&quot; or</span></div>
<div class="line"><span class="lineno"> 8540</span>    <span class="comment">// &quot;exterior&quot; - in the geometric sense. Bare in mind that till this point the</span></div>
<div class="line"><span class="lineno"> 8541</span>    <span class="comment">// notion graph node color was only used to classify patches into two sets.</span></div>
<div class="line"><span class="lineno"> 8542</span>    <span class="comment">// The intuition behind this classification was that &quot;there is two types&quot; of</span></div>
<div class="line"><span class="lineno"> 8543</span>    <span class="comment">// cut-mesh patches, 1) those which are used to seal the interior of the source-mesh</span></div>
<div class="line"><span class="lineno"> 8544</span>    <span class="comment">// and 2) those used to seal the exterior&quot;. So here, we find out whether &#39;A&#39; means</span></div>
<div class="line"><span class="lineno"> 8545</span>    <span class="comment">// &quot;interior&quot; or &quot;exterior&quot;, and vice versa for &#39;B&#39;.</span></div>
<div class="line"><span class="lineno"> 8546</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8547</span>    <span class="comment">// DETAIL: Relying on topological alone to infer patch location is insufficient to</span></div>
<div class="line"><span class="lineno"> 8548</span>    <span class="comment">// determine whether a patch lies inside or outside the source-mesh (with the exception</span></div>
<div class="line"><span class="lineno"> 8549</span>    <span class="comment">// of floating patches). There is ambiguity which prevents us from knowing exactly</span></div>
<div class="line"><span class="lineno"> 8550</span>    <span class="comment">// what location each color &#39;A&#39; or &#39;B&#39; pertains to.</span></div>
<div class="line"><span class="lineno"> 8551</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8552</span> </div>
<div class="line"><span class="lineno"> 8553</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Infer patch color to location&quot;</span>);</div>
<div class="line"><span class="lineno"> 8554</span> </div>
<div class="line"><span class="lineno"> 8555</span>    std::map&lt;char, cm_patch_location_t&gt; patch_color_label_to_location;</div>
<div class="line"><span class="lineno"> 8556</span> </div>
<div class="line"><span class="lineno"> 8557</span>    <span class="comment">// if no exterior cut-mesh polygons where found using re-entrant vertices</span></div>
<div class="line"><span class="lineno"> 8558</span>    <span class="keywordflow">if</span> (known_exterior_cm_polygons.empty()) {</div>
<div class="line"><span class="lineno"> 8559</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8560</span>        <span class="comment">// entering this scope means that we have a floating patch.</span></div>
<div class="line"><span class="lineno"> 8561</span>        <span class="comment">// Failing to find any exterior patch(es) occurs only due the fact the</span></div>
<div class="line"><span class="lineno"> 8562</span>        <span class="comment">// the cut-mesh intersectioned the src-mesh, but no edge in the cut-mesh</span></div>
<div class="line"><span class="lineno"> 8563</span>        <span class="comment">// intersected a face of the source-mesh</span></div>
<div class="line"><span class="lineno"> 8564</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8565</span>        <span class="comment">// MCUT_ASSERT(patches.size() == 1);</span></div>
<div class="line"><span class="lineno"> 8566</span> </div>
<div class="line"><span class="lineno"> 8567</span>        <span class="comment">// What we will do then is assign cut-mesh polygons a value of</span></div>
<div class="line"><span class="lineno"> 8568</span>        <span class="comment">// cm_patch_location_t::INSIDE since floating patches</span></div>
<div class="line"><span class="lineno"> 8569</span>        <span class="comment">// are always interior</span></div>
<div class="line"><span class="lineno"> 8570</span> </div>
<div class="line"><span class="lineno"> 8571</span>        <span class="keyword">const</span> <span class="keywordtype">int</span> patch_idx = patches.cbegin()-&gt;first;</div>
<div class="line"><span class="lineno"> 8572</span> </div>
<div class="line"><span class="lineno"> 8573</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(patches.cbegin()-&gt;second.size() == 1); <span class="comment">// should only be one polygon due to fact of having floating patch</span></div>
<div class="line"><span class="lineno"> 8574</span> </div>
<div class="line"><span class="lineno"> 8575</span>        <span class="comment">// find the colored entry containing the patch</span></div>
<div class="line"><span class="lineno"> 8576</span>        std::map&lt;char, std::vector&lt;int&gt;&gt;::const_iterator color_to_ccw_patches_find_iter = std::find_if(</div>
<div class="line"><span class="lineno"> 8577</span>            color_to_patch.cbegin(),</div>
<div class="line"><span class="lineno"> 8578</span>            color_to_patch.cend(),</div>
<div class="line"><span class="lineno"> 8579</span>            [&amp;](<span class="keyword">const</span> std::pair&lt;<span class="keywordtype">char</span>, std::vector&lt;int&gt;&gt;&amp; e) {</div>
<div class="line"><span class="lineno"> 8580</span>                return std::find(e.second.cbegin(), e.second.cend(), patch_idx) != e.second.cend();</div>
<div class="line"><span class="lineno"> 8581</span>            });</div>
<div class="line"><span class="lineno"> 8582</span> </div>
<div class="line"><span class="lineno"> 8583</span>        <span class="comment">// all patches must be associated with a patch by this point</span></div>
<div class="line"><span class="lineno"> 8584</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(color_to_ccw_patches_find_iter != color_to_patch.cend());</div>
<div class="line"><span class="lineno"> 8585</span> </div>
<div class="line"><span class="lineno"> 8586</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8587</span>        <span class="comment">// We have successively inferred that the color label (&#39;A&#39; or &#39;B&#39;)</span></div>
<div class="line"><span class="lineno"> 8588</span>        <span class="comment">// associated with the floating patch corresponds to &quot;interior&quot;</span></div>
<div class="line"><span class="lineno"> 8589</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8590</span>        <span class="keyword">const</span> <span class="keywordtype">char</span> color_label = color_to_ccw_patches_find_iter-&gt;first;</div>
<div class="line"><span class="lineno"> 8591</span>        patch_color_label_to_location.insert(std::make_pair(color_label, <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956a554a7418c4c0dafd902ebd377b87c80c">cm_patch_location_t::INSIDE</a>));</div>
<div class="line"><span class="lineno"> 8592</span> </div>
<div class="line"><span class="lineno"> 8593</span>        <span class="comment">// So, given that we know what the other color label is, we can infer</span></div>
<div class="line"><span class="lineno"> 8594</span>        <span class="comment">// the location associaed with the remaining color</span></div>
<div class="line"><span class="lineno"> 8595</span>        patch_color_label_to_location.insert(std::make_pair(color_label == <span class="charliteral">&#39;A&#39;</span> ? <span class="charliteral">&#39;B&#39;</span> : <span class="stringliteral">&#39;A&#39;</span>, <a class="code hl_enumeration" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956">cm_patch_location_t</a>::<a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956a93da25bafef6761717afc6b25c17ea16">OUTSIDE</a>));</div>
<div class="line"><span class="lineno"> 8596</span>    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 8597</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8598</span>        <span class="comment">// Here, we know the at least one polygon which lies on the exterior of the</span></div>
<div class="line"><span class="lineno"> 8599</span>        <span class="comment">// source-mesh.</span></div>
<div class="line"><span class="lineno"> 8600</span>        <span class="comment">// So lets find the patch which contains any such polygon and label this patch</span></div>
<div class="line"><span class="lineno"> 8601</span>        <span class="comment">// as being &quot;exterior&quot;.</span></div>
<div class="line"><span class="lineno"> 8602</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8603</span> </div>
<div class="line"><span class="lineno"> 8604</span><span class="preprocessor">#if 1</span></div>
<div class="line"><span class="lineno"> 8605</span>        <span class="comment">// std::vector&lt;std::pair&lt;int /*poly*/, int /*he idx*/&gt;&gt; known_exterior_cm_polygons;</span></div>
<div class="line"><span class="lineno"> 8606</span>        <span class="keyword">const</span> std::unordered_map&lt;<span class="keywordtype">int</span> <span class="comment">/*poly*/</span>, <span class="keywordtype">int</span> <span class="comment">/*he idx*/</span>&gt;::const_iterator known_exterior_cm_polygon = known_exterior_cm_polygons.cbegin();</div>
<div class="line"><span class="lineno"> 8607</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_cm_poly_to_patch_idx.find(known_exterior_cm_polygon-&gt;first) != m0_cm_poly_to_patch_idx.cend());</div>
<div class="line"><span class="lineno"> 8608</span> </div>
<div class="line"><span class="lineno"> 8609</span>        <span class="comment">// get the patch containing the polygon</span></div>
<div class="line"><span class="lineno"> 8610</span>        <span class="keyword">const</span> <span class="keywordtype">int</span> patch_idx = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_cm_poly_to_patch_idx, known_exterior_cm_polygon-&gt;first);</div>
<div class="line"><span class="lineno"> 8611</span> </div>
<div class="line"><span class="lineno"> 8612</span>        <span class="comment">// get the color of the patch</span></div>
<div class="line"><span class="lineno"> 8613</span>        std::map&lt;char, std::vector&lt;int&gt;&gt;::const_iterator color_to_ccw_patches_find_iter = std::find_if(</div>
<div class="line"><span class="lineno"> 8614</span>            color_to_patch.cbegin(),</div>
<div class="line"><span class="lineno"> 8615</span>            color_to_patch.cend(),</div>
<div class="line"><span class="lineno"> 8616</span>            [&amp;](<span class="keyword">const</span> std::pair&lt;<span class="keywordtype">char</span>, std::vector&lt;int&gt;&gt;&amp; e) {</div>
<div class="line"><span class="lineno"> 8617</span>                return std::find(e.second.cbegin(), e.second.cend(), patch_idx) != e.second.cend();</div>
<div class="line"><span class="lineno"> 8618</span>            });</div>
<div class="line"><span class="lineno"> 8619</span> </div>
<div class="line"><span class="lineno"> 8620</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(color_to_ccw_patches_find_iter != color_to_patch.cend());</div>
<div class="line"><span class="lineno"> 8621</span> </div>
<div class="line"><span class="lineno"> 8622</span>        <span class="comment">// thus, the color of the patch means it is an &quot;exterior&quot; patch because it contains an exterior</span></div>
<div class="line"><span class="lineno"> 8623</span>        <span class="comment">// polygon</span></div>
<div class="line"><span class="lineno"> 8624</span>        <span class="keyword">const</span> <span class="keywordtype">char</span> color_label = color_to_ccw_patches_find_iter-&gt;first;</div>
<div class="line"><span class="lineno"> 8625</span>        patch_color_label_to_location.insert(std::make_pair(color_label, <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956a93da25bafef6761717afc6b25c17ea16">cm_patch_location_t::OUTSIDE</a>));</div>
<div class="line"><span class="lineno"> 8626</span> </div>
<div class="line"><span class="lineno"> 8627</span>        <span class="comment">// infer the opposite color label&#39;s meaning</span></div>
<div class="line"><span class="lineno"> 8628</span>        patch_color_label_to_location.insert(std::make_pair(color_label == <span class="charliteral">&#39;A&#39;</span> ? <span class="charliteral">&#39;B&#39;</span> : <span class="stringliteral">&#39;A&#39;</span>, <a class="code hl_enumeration" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956">cm_patch_location_t</a>::<a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956a554a7418c4c0dafd902ebd377b87c80c">INSIDE</a>));</div>
<div class="line"><span class="lineno"> 8629</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno"> 8630</span>        <span class="comment">// for each cut-mesh polygon</span></div>
<div class="line"><span class="lineno"> 8631</span>        <span class="keywordflow">for</span> (std::map&lt;int, int&gt;::const_iterator cs_poly_to_patch_idx_iter = m0_cm_poly_to_patch_idx.cbegin();</div>
<div class="line"><span class="lineno"> 8632</span>             cs_poly_to_patch_idx_iter != m0_cm_poly_to_patch_idx.cend();</div>
<div class="line"><span class="lineno"> 8633</span>             ++cs_poly_to_patch_idx_iter) {</div>
<div class="line"><span class="lineno"> 8634</span> </div>
<div class="line"><span class="lineno"> 8635</span>            <span class="comment">// get index of polygon</span></div>
<div class="line"><span class="lineno"> 8636</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> cs_poly_idx = cs_poly_to_patch_idx_iter-&gt;first;</div>
<div class="line"><span class="lineno"> 8637</span> </div>
<div class="line"><span class="lineno"> 8638</span>            <span class="comment">// check if polygon is an exterior cut-mesh polygon</span></div>
<div class="line"><span class="lineno"> 8639</span>            <span class="keyword">const</span> std::vector&lt;std::pair&lt;int, int&gt;&gt;::const_iterator known_exterior_cs_polygons_find_iter = std::find_if(</div>
<div class="line"><span class="lineno"> 8640</span>                known_exterior_cm_polygons.cbegin(),</div>
<div class="line"><span class="lineno"> 8641</span>                known_exterior_cm_polygons.cend(),</div>
<div class="line"><span class="lineno"> 8642</span>                [&amp;](<span class="keyword">const</span> std::pair&lt;int, int&gt;&amp; e) { return e.first == cs_poly_idx; });</div>
<div class="line"><span class="lineno"> 8643</span>            <span class="keyword">const</span> <span class="keywordtype">bool</span> poly_is_known_exterior_cs_polygon = (known_exterior_cs_polygons_find_iter != known_exterior_cm_polygons.cend());</div>
<div class="line"><span class="lineno"> 8644</span> </div>
<div class="line"><span class="lineno"> 8645</span>            <span class="keywordflow">if</span> (poly_is_known_exterior_cs_polygon) {</div>
<div class="line"><span class="lineno"> 8646</span>                <span class="comment">// get the patch containing the polygon</span></div>
<div class="line"><span class="lineno"> 8647</span>                <span class="keyword">const</span> <span class="keywordtype">int</span> patch_idx = cs_poly_to_patch_idx_iter-&gt;second;</div>
<div class="line"><span class="lineno"> 8648</span> </div>
<div class="line"><span class="lineno"> 8649</span>                <span class="comment">// get the color of the patch</span></div>
<div class="line"><span class="lineno"> 8650</span>                std::map&lt;char, std::vector&lt;int&gt;&gt;::const_iterator color_to_ccw_patches_find_iter = std::find_if(</div>
<div class="line"><span class="lineno"> 8651</span>                    color_to_patch.cbegin(),</div>
<div class="line"><span class="lineno"> 8652</span>                    color_to_patch.cend(),</div>
<div class="line"><span class="lineno"> 8653</span>                    [&amp;](<span class="keyword">const</span> std::pair&lt;<span class="keywordtype">char</span>, std::vector&lt;int&gt;&gt;&amp; e) {</div>
<div class="line"><span class="lineno"> 8654</span>                        return std::find(e.second.cbegin(), e.second.cend(), patch_idx) != e.second.cend();</div>
<div class="line"><span class="lineno"> 8655</span>                    });</div>
<div class="line"><span class="lineno"> 8656</span> </div>
<div class="line"><span class="lineno"> 8657</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(color_to_ccw_patches_find_iter != color_to_patch.cend());</div>
<div class="line"><span class="lineno"> 8658</span> </div>
<div class="line"><span class="lineno"> 8659</span>                <span class="comment">// thus, the color of the patch means it is an &quot;exterior&quot; patch because it contains an exterior</span></div>
<div class="line"><span class="lineno"> 8660</span>                <span class="comment">// polygon</span></div>
<div class="line"><span class="lineno"> 8661</span>                <span class="keyword">const</span> <span class="keywordtype">char</span> color_label = color_to_ccw_patches_find_iter-&gt;first;</div>
<div class="line"><span class="lineno"> 8662</span>                patch_color_label_to_location.insert(std::make_pair(color_label, <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956a93da25bafef6761717afc6b25c17ea16">cm_patch_location_t::OUTSIDE</a>));</div>
<div class="line"><span class="lineno"> 8663</span> </div>
<div class="line"><span class="lineno"> 8664</span>                <span class="comment">// infer the opposite color label&#39;s meaning</span></div>
<div class="line"><span class="lineno"> 8665</span>                patch_color_label_to_location.insert(std::make_pair(color_label == <span class="charliteral">&#39;A&#39;</span> ? <span class="charliteral">&#39;B&#39;</span> : <span class="stringliteral">&#39;A&#39;</span>, <a class="code hl_enumeration" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956">cm_patch_location_t</a>::<a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956a554a7418c4c0dafd902ebd377b87c80c">INSIDE</a>));</div>
<div class="line"><span class="lineno"> 8666</span> </div>
<div class="line"><span class="lineno"> 8667</span>                <span class="keywordflow">break</span>; <span class="comment">// done (only need to find the first exterior polygon for use to know everything else)</span></div>
<div class="line"><span class="lineno"> 8668</span>            }</div>
<div class="line"><span class="lineno"> 8669</span>        }</div>
<div class="line"><span class="lineno"> 8670</span> </div>
<div class="line"><span class="lineno"> 8671</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 8672</span>    }</div>
<div class="line"><span class="lineno"> 8673</span>    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(!patch_color_label_to_location.empty());</div>
<div class="line"><span class="lineno"> 8674</span> </div>
<div class="line"><span class="lineno"> 8675</span>    known_exterior_cm_polygons.clear();</div>
<div class="line"><span class="lineno"> 8676</span>    <span class="comment">// m0_cm_poly_to_patch_idx.clear();</span></div>
<div class="line"><span class="lineno"> 8677</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 8678</span>        <span class="comment">// dump</span></div>
<div class="line"><span class="lineno"> 8679</span>        </div>
<div class="line"><span class="lineno"> 8680</span>        </div>
<div class="line"><span class="lineno"> 8681</span>        <span class="keywordflow">for</span> (std::map&lt;<span class="keywordtype">char</span>, std::vector&lt;int&gt;&gt;::const_iterator color_to_ccw_patches_iter = color_to_patch.cbegin(); color_to_ccw_patches_iter != color_to_patch.cend(); ++color_to_ccw_patches_iter)</div>
<div class="line"><span class="lineno"> 8682</span>        {</div>
<div class="line"><span class="lineno"> 8683</span>            <span class="keyword">const</span> <span class="keywordtype">char</span> color_label = color_to_ccw_patches_iter-&gt;first;</div>
<div class="line"><span class="lineno"> 8684</span>            <span class="comment">//const cm_patch_location_t color_label_dye = SAFE_ACCESS(patch_color_label_to_location, color_label);</span></div>
<div class="line"><span class="lineno"> 8685</span> </div>
<div class="line"><span class="lineno"> 8686</span>            </div>
<div class="line"><span class="lineno"> 8687</span>        }</div>
<div class="line"><span class="lineno"> 8688</span> </div>
<div class="line"><span class="lineno"> 8689</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 8690</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 8691</span> </div>
<div class="line"><span class="lineno"> 8693</span>    <span class="comment">// Create reverse patches</span></div>
<div class="line"><span class="lineno"> 8695</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 8696</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Create reversed patches&quot;</span>);</div>
<div class="line"><span class="lineno"> 8697</span> </div>
<div class="line"><span class="lineno"> 8698</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> traced_polygon_count = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)m0_polygons.size(); <span class="comment">// does not include the reversed cut-mesh polygons</span></div>
<div class="line"><span class="lineno"> 8699</span> </div>
<div class="line"><span class="lineno"> 8700</span>    <span class="comment">// note: reversed patches are called &quot;cw&quot; patches (for assumed clockwise based on input meshes)</span></div>
<div class="line"><span class="lineno"> 8701</span> </div>
<div class="line"><span class="lineno"> 8702</span>    std::map&lt;</div>
<div class="line"><span class="lineno"> 8703</span>        char, <span class="comment">// color tag</span></div>
<div class="line"><span class="lineno"> 8704</span>        std::vector&lt;int&gt; <span class="comment">// reversed patch index</span></div>
<div class="line"><span class="lineno"> 8705</span>        &gt;</div>
<div class="line"><span class="lineno"> 8706</span>        color_to_cw_patch;</div>
<div class="line"><span class="lineno"> 8707</span> </div>
<div class="line"><span class="lineno"> 8708</span>    std::map&lt;</div>
<div class="line"><span class="lineno"> 8709</span>        <a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>, <span class="comment">// patch index</span></div>
<div class="line"><span class="lineno"> 8710</span>        <span class="keywordtype">int</span> <span class="comment">// opposite patch index</span></div>
<div class="line"><span class="lineno"> 8711</span>        &gt;</div>
<div class="line"><span class="lineno"> 8712</span>        patch_to_opposite;</div>
<div class="line"><span class="lineno"> 8713</span> </div>
<div class="line"><span class="lineno"> 8714</span>    <span class="comment">// for each color</span></div>
<div class="line"><span class="lineno"> 8715</span>    <span class="keywordflow">for</span> (std::map&lt;<span class="keywordtype">char</span>, std::vector&lt;int&gt;&gt;::const_iterator color_to_ccw_patches_iter = color_to_patch.cbegin();</div>
<div class="line"><span class="lineno"> 8716</span>         color_to_ccw_patches_iter != color_to_patch.cend();</div>
<div class="line"><span class="lineno"> 8717</span>         ++color_to_ccw_patches_iter) {</div>
<div class="line"><span class="lineno"> 8718</span> </div>
<div class="line"><span class="lineno"> 8719</span>        <span class="comment">// const char color_id = color_to_ccw_patches_iter-&gt;first;</span></div>
<div class="line"><span class="lineno"> 8720</span> </div>
<div class="line"><span class="lineno"> 8721</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8722</span> </div>
<div class="line"><span class="lineno"> 8723</span>        <span class="comment">// add entry</span></div>
<div class="line"><span class="lineno"> 8724</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(color_to_cw_patch.count(color_to_ccw_patches_iter-&gt;first) == 0);</div>
<div class="line"><span class="lineno"> 8725</span>        color_to_cw_patch[color_to_ccw_patches_iter-&gt;first] = std::vector&lt;int&gt;();</div>
<div class="line"><span class="lineno"> 8726</span>        <span class="comment">// std::pair&lt;std::map&lt;char, std::vector&lt;int&gt;&gt;::iterator, bool&gt; color_to_cw_patch_insertion = color_to_cw_patch.insert(std::make_pair(color_to_ccw_patches_iter-&gt;first, std::vector&lt;int&gt;()));</span></div>
<div class="line"><span class="lineno"> 8727</span>        <span class="comment">// MCUT_ASSERT(color_to_cw_patch_insertion.second == true);</span></div>
<div class="line"><span class="lineno"> 8728</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(color_to_cw_patch.count(color_to_ccw_patches_iter-&gt;first) == 1);</div>
<div class="line"><span class="lineno"> 8729</span> </div>
<div class="line"><span class="lineno"> 8730</span>        <span class="comment">// list of reversed patches with current color</span></div>
<div class="line"><span class="lineno"> 8731</span>        std::vector&lt;int&gt;&amp; cw_patch_color = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(color_to_cw_patch, color_to_ccw_patches_iter-&gt;first);</div>
<div class="line"><span class="lineno"> 8732</span> </div>
<div class="line"><span class="lineno"> 8733</span>        <span class="comment">// for each patch with current color</span></div>
<div class="line"><span class="lineno"> 8734</span>        <span class="keywordflow">for</span> (std::vector&lt;int&gt;::const_iterator patch_iter = color_to_ccw_patches_iter-&gt;second.cbegin();</div>
<div class="line"><span class="lineno"> 8735</span>             patch_iter != color_to_ccw_patches_iter-&gt;second.cend();</div>
<div class="line"><span class="lineno"> 8736</span>             ++patch_iter) {</div>
<div class="line"><span class="lineno"> 8737</span> </div>
<div class="line"><span class="lineno"> 8738</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> patch_idx = *patch_iter;</div>
<div class="line"><span class="lineno"> 8739</span> </div>
<div class="line"><span class="lineno"> 8740</span>            <span class="keyword">const</span> std::vector&lt;int&gt;&amp; patch = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patches, patch_idx);</div>
<div class="line"><span class="lineno"> 8741</span> </div>
<div class="line"><span class="lineno"> 8742</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8743</span>            <span class="comment">// create reversed patch</span></div>
<div class="line"><span class="lineno"> 8744</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8745</span> </div>
<div class="line"><span class="lineno"> 8746</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> cw_patch_idx = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)patches.size(); <span class="comment">// index of reversed version</span></div>
<div class="line"><span class="lineno"> 8747</span> </div>
<div class="line"><span class="lineno"> 8748</span>            <span class="comment">// relate patch to opposite</span></div>
<div class="line"><span class="lineno"> 8749</span>            patch_to_opposite[patch_idx] = cw_patch_idx;</div>
<div class="line"><span class="lineno"> 8750</span>            patch_to_opposite[cw_patch_idx] = patch_idx;</div>
<div class="line"><span class="lineno"> 8751</span> </div>
<div class="line"><span class="lineno"> 8752</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(patches.count(cw_patch_idx) == 0);</div>
<div class="line"><span class="lineno"> 8753</span>            patches[cw_patch_idx] = std::vector&lt;int&gt;();</div>
<div class="line"><span class="lineno"> 8754</span>            <span class="comment">// std::pair&lt;std::map&lt;int, std::vector&lt;int&gt;&gt;::iterator, bool&gt; patch_insertion = patches.insert(std::make_pair(cw_patch_idx, std::vector&lt;int&gt;()));</span></div>
<div class="line"><span class="lineno"> 8755</span>            <span class="comment">// MCUT_ASSERT(patch_insertion.second == true);</span></div>
<div class="line"><span class="lineno"> 8756</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(patches.count(cw_patch_idx) == 1);</div>
<div class="line"><span class="lineno"> 8757</span> </div>
<div class="line"><span class="lineno"> 8758</span>            std::vector&lt;int&gt;&amp; cw_patch = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patches, cw_patch_idx);</div>
<div class="line"><span class="lineno"> 8759</span> </div>
<div class="line"><span class="lineno"> 8760</span>            <span class="comment">// add to list of patches with current color</span></div>
<div class="line"><span class="lineno"> 8761</span>            cw_patch_color.push_back(cw_patch_idx);</div>
<div class="line"><span class="lineno"> 8762</span> </div>
<div class="line"><span class="lineno"> 8763</span>            <span class="comment">/*</span></div>
<div class="line"><span class="lineno"> 8764</span><span class="comment">            for each polygon in patch</span></div>
<div class="line"><span class="lineno"> 8765</span><span class="comment">                if is floating-patch polygon</span></div>
<div class="line"><span class="lineno"> 8766</span><span class="comment">                    find the opposite polygon (which already exists)</span></div>
<div class="line"><span class="lineno"> 8767</span><span class="comment">                    add opposite polygon into patch</span></div>
<div class="line"><span class="lineno"> 8768</span><span class="comment">                else</span></div>
<div class="line"><span class="lineno"> 8769</span><span class="comment">                    create reversed version and update data structures</span></div>
<div class="line"><span class="lineno"> 8770</span><span class="comment">        */</span></div>
<div class="line"><span class="lineno"> 8771</span> </div>
<div class="line"><span class="lineno"> 8772</span>            <span class="comment">// number of polygons in the ccw patch</span></div>
<div class="line"><span class="lineno"> 8773</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> initial_patch_size = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)patch.size();</div>
<div class="line"><span class="lineno"> 8774</span> </div>
<div class="line"><span class="lineno"> 8775</span>            <span class="comment">// for each polygon in the ccw patch</span></div>
<div class="line"><span class="lineno"> 8776</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ccw_patch_iter = 0; ccw_patch_iter &lt; initial_patch_size; ++ccw_patch_iter) {</div>
<div class="line"><span class="lineno"> 8777</span> </div>
<div class="line"><span class="lineno"> 8778</span>                <span class="comment">// get the polygon index</span></div>
<div class="line"><span class="lineno"> 8779</span>                <span class="keyword">const</span> <span class="keywordtype">int</span> ccw_patch_poly_idx = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patch, ccw_patch_iter);</div>
<div class="line"><span class="lineno"> 8780</span> </div>
<div class="line"><span class="lineno"> 8781</span>                <span class="comment">// all polygon are stored in the same array so we can use that to deduce</span></div>
<div class="line"><span class="lineno"> 8782</span>                <span class="comment">// index of new reversed polygon</span></div>
<div class="line"><span class="lineno"> 8783</span>                <span class="keywordtype">int</span> cw_poly_idx = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)m0_polygons.size();</div>
<div class="line"><span class="lineno"> 8784</span> </div>
<div class="line"><span class="lineno"> 8785</span>                <span class="comment">// get the normal polygon</span></div>
<div class="line"><span class="lineno"> 8786</span>                <span class="keyword">const</span> <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a>&amp; patch_poly = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_polygons, ccw_patch_poly_idx);</div>
<div class="line"><span class="lineno"> 8787</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 8788</span>                    <span class="keyword">const</span> <span class="keywordtype">bool</span> is_floating_patch = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patch_to_floating_flag, patch_idx);</div>
<div class="line"><span class="lineno"> 8789</span> </div>
<div class="line"><span class="lineno"> 8790</span>                    <span class="keywordflow">if</span> (is_floating_patch)</div>
<div class="line"><span class="lineno"> 8791</span>                    {</div>
<div class="line"><span class="lineno"> 8792</span>                        <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8793</span>                        <span class="comment">// the reversed polygon of the current normal polygon already exists.</span></div>
<div class="line"><span class="lineno"> 8794</span>                        <span class="comment">// So we can just use that. Note: this is because the polygon tracing</span></div>
<div class="line"><span class="lineno"> 8795</span>                        <span class="comment">// that we did earlier (in &quot;m0&quot;) always traces two versions of a polygon</span></div>
<div class="line"><span class="lineno"> 8796</span>                        <span class="comment">// whose halfedges are all interior intersection-halfedges (x--&gt;x)</span></div>
<div class="line"><span class="lineno"> 8797</span>                        <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8798</span> </div>
<div class="line"><span class="lineno"> 8799</span>                        <span class="comment">// find opposite polygon</span></div>
<div class="line"><span class="lineno"> 8800</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> &amp;coincident_halfedge = patch_poly.front(); <span class="comment">// can be any</span></div>
<div class="line"><span class="lineno"> 8801</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> coincident_halfedge_opp = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(coincident_halfedge);</div>
<div class="line"><span class="lineno"> 8802</span>                        <span class="keyword">const</span> std::vector&lt;int&gt; &amp;coincident_polys = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, coincident_halfedge_opp);</div>
<div class="line"><span class="lineno"> 8803</span>                        <span class="comment">// find coincident cut-mesh polygon</span></div>
<div class="line"><span class="lineno"> 8804</span>                        <span class="keyword">const</span> std::vector&lt;int&gt;::const_iterator coincident_polys_find_iter = std::find_if(</div>
<div class="line"><span class="lineno"> 8805</span>                            coincident_polys.cbegin(),</div>
<div class="line"><span class="lineno"> 8806</span>                            coincident_polys.cend(),</div>
<div class="line"><span class="lineno"> 8807</span>                            [&amp;](<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;e)</div>
<div class="line"><span class="lineno"> 8808</span>                            { return e &gt;= traced_sm_polygon_count &amp;&amp; e &lt; traced_polygon_count; });</div>
<div class="line"><span class="lineno"> 8809</span> </div>
<div class="line"><span class="lineno"> 8810</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(coincident_polys_find_iter != coincident_polys.cend());</div>
<div class="line"><span class="lineno"> 8811</span> </div>
<div class="line"><span class="lineno"> 8812</span>                        <span class="keyword">const</span> <span class="keywordtype">int</span> patch_poly_opp = *coincident_polys_find_iter;</div>
<div class="line"><span class="lineno"> 8813</span>                        cw_poly_idx = patch_poly_opp; <span class="comment">// found opposite polygon</span></div>
<div class="line"><span class="lineno"> 8814</span>                    }</div>
<div class="line"><span class="lineno"> 8815</span>                    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno"> 8816</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 8817</span>                {</div>
<div class="line"><span class="lineno"> 8818</span> </div>
<div class="line"><span class="lineno"> 8819</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8820</span>                    <span class="comment">// the current ccw polygon does not form a floating patch,</span></div>
<div class="line"><span class="lineno"> 8821</span>                    <span class="comment">// so we calculate the reversed version by retracing the</span></div>
<div class="line"><span class="lineno"> 8822</span>                    <span class="comment">// connectivity in reverse order</span></div>
<div class="line"><span class="lineno"> 8823</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8824</span> </div>
<div class="line"><span class="lineno"> 8825</span>                    <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a> cw_poly;</div>
<div class="line"><span class="lineno"> 8826</span>                    cw_poly.reserve(patch_poly.size());</div>
<div class="line"><span class="lineno"> 8827</span>                    <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a> tmp;</div>
<div class="line"><span class="lineno"> 8828</span>                    tmp.reserve(patch_poly.size());</div>
<div class="line"><span class="lineno"> 8829</span> </div>
<div class="line"><span class="lineno"> 8830</span>                    <span class="comment">// for each halfedge of the ccw polygon</span></div>
<div class="line"><span class="lineno"> 8831</span>                    <span class="keywordflow">for</span> (traced_polygon_t::const_iterator patch_poly_he_iter = patch_poly.cbegin();</div>
<div class="line"><span class="lineno"> 8832</span>                         patch_poly_he_iter != patch_poly.cend();</div>
<div class="line"><span class="lineno"> 8833</span>                         ++patch_poly_he_iter) {</div>
<div class="line"><span class="lineno"> 8834</span> </div>
<div class="line"><span class="lineno"> 8835</span>                        <span class="comment">// get halfedge descriptor</span></div>
<div class="line"><span class="lineno"> 8836</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; patch_poly_he = *patch_poly_he_iter;</div>
<div class="line"><span class="lineno"> 8837</span>                        <span class="comment">// get the opposite halfedge</span></div>
<div class="line"><span class="lineno"> 8838</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> patch_poly_he_opp = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(patch_poly_he);</div>
<div class="line"><span class="lineno"> 8839</span>                        <span class="comment">// add into list defining reversed polygon</span></div>
<div class="line"><span class="lineno"> 8840</span>                        tmp.push_back(patch_poly_he_opp);</div>
<div class="line"><span class="lineno"> 8841</span>                        <span class="comment">// check if another cut-mesh polygon is traced with this opposite halfedge.</span></div>
<div class="line"><span class="lineno"> 8842</span>                        std::vector&lt;std::vector&lt;int&gt;&gt;::iterator find_iter = m0_h_to_ply.begin() + patch_poly_he_opp; <span class="comment">// m0_h_to_ply.find(patch_poly_he_opp);</span></div>
<div class="line"><span class="lineno"> 8843</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 8844</span>                            <span class="keywordflow">if</span> (find_iter == m0_h_to_ply.end())</div>
<div class="line"><span class="lineno"> 8845</span>                            { <span class="comment">// &quot;patch_poly_he_opp&quot; not used to trace any polygon</span></div>
<div class="line"><span class="lineno"> 8846</span>                                <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8847</span>                                <span class="comment">// we only enter this scope of the halfedge &quot;patch_poly_he_opp&quot; is a</span></div>
<div class="line"><span class="lineno"> 8848</span>                                <span class="comment">// border halfedge which is not used to trace a cut-mesh polygon.</span></div>
<div class="line"><span class="lineno"> 8849</span> </div>
<div class="line"><span class="lineno"> 8850</span>                                <span class="comment">// add entry for the halfedge</span></div>
<div class="line"><span class="lineno"> 8851</span>                                std::pair&lt;std::map&lt;hd_t, std::vector&lt;int&gt;&gt;::iterator, <span class="keywordtype">bool</span>&gt; m0_he_to_poly_idx_insertion = m0_h_to_ply.insert(std::make_pair(patch_poly_he_opp, std::vector&lt;int&gt;()));</div>
<div class="line"><span class="lineno"> 8852</span> </div>
<div class="line"><span class="lineno"> 8853</span>                                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_he_to_poly_idx_insertion.second == <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 8854</span> </div>
<div class="line"><span class="lineno"> 8855</span>                                find_iter = m0_he_to_poly_idx_insertion.first;</div>
<div class="line"><span class="lineno"> 8856</span>                            }</div>
<div class="line"><span class="lineno"> 8857</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 8858</span>                        <span class="comment">// associate &quot;patch_poly_he_opp&quot; with the new reversed polygon</span></div>
<div class="line"><span class="lineno"> 8859</span>                        find_iter-&gt;push_back(cw_poly_idx);</div>
<div class="line"><span class="lineno"> 8860</span>                    }</div>
<div class="line"><span class="lineno"> 8861</span> </div>
<div class="line"><span class="lineno"> 8862</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(tmp.size() == patch_poly.size());</div>
<div class="line"><span class="lineno"> 8863</span> </div>
<div class="line"><span class="lineno"> 8864</span>                    <span class="comment">// reverse the order to ensure correct winding, last halfedge for goes to beginning, and so on...</span></div>
<div class="line"><span class="lineno"> 8865</span>                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> h = 0; h &lt; (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)tmp.size(); ++h) {</div>
<div class="line"><span class="lineno"> 8866</span>                        <span class="keyword">const</span> <span class="keywordtype">int</span> index = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)tmp.size() - 1 - h;</div>
<div class="line"><span class="lineno"> 8867</span>                        cw_poly.push_back(<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(tmp, index));</div>
<div class="line"><span class="lineno"> 8868</span>                    }</div>
<div class="line"><span class="lineno"> 8869</span> </div>
<div class="line"><span class="lineno"> 8870</span>                    <span class="comment">//{</span></div>
<div class="line"><span class="lineno"> 8871</span>                    <span class="comment">//    for (traced_polygon_t::const_iterator cw_poly_he_iter = cw_poly.cbegin(); cw_poly_he_iter != cw_poly.cend(); ++cw_poly_he_iter) {</span></div>
<div class="line"><span class="lineno"> 8873</span><span class="comment"></span>                    <span class="comment">//}</span></div>
<div class="line"><span class="lineno"> 8874</span> </div>
<div class="line"><span class="lineno"> 8875</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(cw_poly.front()) == m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(cw_poly.back())); <span class="comment">// must form loop</span></div>
<div class="line"><span class="lineno"> 8876</span> </div>
<div class="line"><span class="lineno"> 8877</span>                    m0_polygons.push_back(cw_poly); <span class="comment">// save the new polygon!</span></div>
<div class="line"><span class="lineno"> 8878</span>                }</div>
<div class="line"><span class="lineno"> 8879</span> </div>
<div class="line"><span class="lineno"> 8880</span>                <span class="comment">// the new polygon&#39;s index as being part of the patch</span></div>
<div class="line"><span class="lineno"> 8881</span>                cw_patch.push_back(cw_poly_idx);</div>
<div class="line"><span class="lineno"> 8882</span> </div>
<div class="line"><span class="lineno"> 8883</span>                <span class="comment">// map the reversed polygon to its patch</span></div>
<div class="line"><span class="lineno"> 8884</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_cm_poly_to_patch_idx.count(cw_poly_idx) == 0);</div>
<div class="line"><span class="lineno"> 8885</span>                m0_cm_poly_to_patch_idx[cw_poly_idx] = cw_patch_idx;</div>
<div class="line"><span class="lineno"> 8886</span> </div>
<div class="line"><span class="lineno"> 8887</span>                <span class="comment">// map the reversed polygon to the same ps-face as its ccw counterpart!</span></div>
<div class="line"><span class="lineno"> 8888</span>                <span class="keywordflow">if</span> (m0_to_ps_face.count(cw_poly_idx) == 0) {</div>
<div class="line"><span class="lineno"> 8889</span>                    <span class="comment">// must not be a floating patch because such ccw and cw patch polygons are created and mapped during &quot;m0&quot; tracing stage</span></div>
<div class="line"><span class="lineno"> 8890</span>                    <span class="comment">// MCUT_ASSERT(patch_to_floating_flag.count(cw_poly_idx) == false);</span></div>
<div class="line"><span class="lineno"> 8891</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_to_ps_face.count(ccw_patch_poly_idx) == 1);</div>
<div class="line"><span class="lineno"> 8892</span>                    <span class="comment">// both polygon will have originated from the same ps-face!</span></div>
<div class="line"><span class="lineno"> 8893</span>                    m0_to_ps_face[cw_poly_idx] = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_ps_face, ccw_patch_poly_idx);</div>
<div class="line"><span class="lineno"> 8894</span>                }</div>
<div class="line"><span class="lineno"> 8895</span>            }</div>
<div class="line"><span class="lineno"> 8896</span>        }</div>
<div class="line"><span class="lineno"> 8897</span>    }</div>
<div class="line"><span class="lineno"> 8898</span> </div>
<div class="line"><span class="lineno"> 8899</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 8900</span> </div>
<div class="line"><span class="lineno"> 8901</span>    <span class="comment">// number of reversed cut-mesh polygons</span></div>
<div class="line"><span class="lineno"> 8902</span>    <span class="comment">// const int cw_cs_poly_count = ((int)m0_polygons.size() - traced_polygon_count);</span></div>
<div class="line"><span class="lineno"> 8903</span> </div>
<div class="line"><span class="lineno"> 8904</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8905</span> </div>
<div class="line"><span class="lineno"> 8906</span>    <span class="comment">// NOTE: at this stage, all patch polygons (ccw/normal) also have an opposite (cw/reversed)</span></div>
<div class="line"><span class="lineno"> 8907</span> </div>
<div class="line"><span class="lineno"> 8908</span>    <span class="comment">// merge the opposite color_to_patch data structure</span></div>
<div class="line"><span class="lineno"> 8909</span> </div>
<div class="line"><span class="lineno"> 8910</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;merge opposite color to path data structures&quot;</span>);</div>
<div class="line"><span class="lineno"> 8911</span> </div>
<div class="line"><span class="lineno"> 8912</span>    <span class="comment">// for each color</span></div>
<div class="line"><span class="lineno"> 8913</span>    <span class="keywordflow">for</span> (std::map&lt;<span class="keywordtype">char</span>, std::vector&lt;int&gt;&gt;::const_iterator color_to_cw_patch_iter = color_to_cw_patch.cbegin();</div>
<div class="line"><span class="lineno"> 8914</span>         color_to_cw_patch_iter != color_to_cw_patch.cend();</div>
<div class="line"><span class="lineno"> 8915</span>         ++color_to_cw_patch_iter) {</div>
<div class="line"><span class="lineno"> 8916</span> </div>
<div class="line"><span class="lineno"> 8917</span>        <span class="keyword">const</span> <span class="keywordtype">char</span> color_value = color_to_cw_patch_iter-&gt;first;</div>
<div class="line"><span class="lineno"> 8918</span> </div>
<div class="line"><span class="lineno"> 8919</span>        <span class="comment">// get reversed patches</span></div>
<div class="line"><span class="lineno"> 8920</span>        <span class="keyword">const</span> std::vector&lt;int&gt;&amp; colored_cw_patches = color_to_cw_patch_iter-&gt;second;</div>
<div class="line"><span class="lineno"> 8921</span>        <span class="comment">// get normal patches</span></div>
<div class="line"><span class="lineno"> 8922</span>        std::vector&lt;int&gt;&amp; colored_patches = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(color_to_patch, color_value);</div>
<div class="line"><span class="lineno"> 8923</span>        <span class="comment">// merge</span></div>
<div class="line"><span class="lineno"> 8924</span>        colored_patches.insert(colored_patches.end(), colored_cw_patches.cbegin(), colored_cw_patches.cend()); <span class="comment">// merge</span></div>
<div class="line"><span class="lineno"> 8925</span> </div>
<div class="line"><span class="lineno"> 8926</span>        <span class="comment">// dump</span></div>
<div class="line"><span class="lineno"> 8927</span>        <span class="keywordflow">if</span> (input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#acbacc55f2163529291e5a45671fed3d1">verbose</a>) {</div>
<div class="line"><span class="lineno"> 8928</span> </div>
<div class="line"><span class="lineno"> 8929</span>            <span class="keywordflow">for</span> (std::vector&lt;int&gt;::const_iterator colored_patch_iter = colored_patches.cbegin();</div>
<div class="line"><span class="lineno"> 8930</span>                 colored_patch_iter != colored_patches.cend();</div>
<div class="line"><span class="lineno"> 8931</span>                 ++colored_patch_iter) {</div>
<div class="line"><span class="lineno"> 8932</span> </div>
<div class="line"><span class="lineno"> 8933</span>                <span class="keyword">const</span> <span class="keywordtype">int</span> patch_idx = *colored_patch_iter;</div>
<div class="line"><span class="lineno"> 8934</span>                <span class="keyword">const</span> std::vector&lt;int&gt;&amp; patch = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patches, patch_idx);</div>
<div class="line"><span class="lineno"> 8935</span>                <span class="comment">// const int is_ccw = (int)(std::distance(colored_patches.cbegin(), colored_patch_iter) &lt; (int)(patch.size() / 2));</span></div>
<div class="line"><span class="lineno"> 8936</span> </div>
<div class="line"><span class="lineno"> 8937</span>                <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8938</span> </div>
<div class="line"><span class="lineno"> 8939</span>                <span class="keywordflow">for</span> (std::vector&lt;int&gt;::const_iterator patch_poly_iter = patch.cbegin(); patch_poly_iter != patch.cend(); ++patch_poly_iter) {</div>
<div class="line"><span class="lineno"> 8940</span>                }</div>
<div class="line"><span class="lineno"> 8941</span>            }</div>
<div class="line"><span class="lineno"> 8942</span>        }</div>
<div class="line"><span class="lineno"> 8943</span>    }</div>
<div class="line"><span class="lineno"> 8944</span> </div>
<div class="line"><span class="lineno"> 8945</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 8946</span> </div>
<div class="line"><span class="lineno"> 8948</span>    <span class="comment">// save the patches into the output</span></div>
<div class="line"><span class="lineno"> 8950</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 8951</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Save patches&quot;</span>);</div>
<div class="line"><span class="lineno"> 8952</span> </div>
<div class="line"><span class="lineno"> 8953</span>    <span class="comment">// for each color</span></div>
<div class="line"><span class="lineno"> 8954</span>    <span class="keywordflow">for</span> (std::map&lt;<span class="keywordtype">char</span>, std::vector&lt;int&gt;&gt;::const_iterator color_to_patches_iter = color_to_patch.cbegin();</div>
<div class="line"><span class="lineno"> 8955</span>         color_to_patches_iter != color_to_patch.cend();</div>
<div class="line"><span class="lineno"> 8956</span>         ++color_to_patches_iter) {</div>
<div class="line"><span class="lineno"> 8957</span> </div>
<div class="line"><span class="lineno"> 8958</span>        <span class="keyword">const</span> <span class="keywordtype">char</span> color_id = color_to_patches_iter-&gt;first;</div>
<div class="line"><span class="lineno"> 8959</span> </div>
<div class="line"><span class="lineno"> 8960</span>        <span class="comment">// for each patch with current color</span></div>
<div class="line"><span class="lineno"> 8961</span>        <span class="keywordflow">for</span> (std::vector&lt;int&gt;::const_iterator patch_iter = color_to_patches_iter-&gt;second.cbegin();</div>
<div class="line"><span class="lineno"> 8962</span>             patch_iter != color_to_patches_iter-&gt;second.cend();</div>
<div class="line"><span class="lineno"> 8963</span>             ++patch_iter) {</div>
<div class="line"><span class="lineno"> 8964</span> </div>
<div class="line"><span class="lineno"> 8965</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> cur_patch_idx = *patch_iter;</div>
<div class="line"><span class="lineno"> 8966</span> </div>
<div class="line"><span class="lineno"> 8967</span>            <span class="keyword">const</span> <a class="code hl_enumeration" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956">cm_patch_location_t</a>&amp; patch_location = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patch_color_label_to_location, color_id);</div>
<div class="line"><span class="lineno"> 8968</span>            <span class="keywordflow">if</span> ((patch_location == <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956a554a7418c4c0dafd902ebd377b87c80c">cm_patch_location_t::INSIDE</a> &amp;&amp; !input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a69d05b5eabcaa02ad142e51104f16502">keep_inside_patches</a>) || <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8969</span>                (patch_location == <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956a93da25bafef6761717afc6b25c17ea16">cm_patch_location_t::OUTSIDE</a> &amp;&amp; !input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af5ee3a08c24f72b6d9f88a2a651159d1">keep_outside_patches</a>)) {</div>
<div class="line"><span class="lineno"> 8970</span>                <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 8971</span>            }</div>
<div class="line"><span class="lineno"> 8972</span> </div>
<div class="line"><span class="lineno"> 8973</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8974</span>            <span class="comment">// create mesh for patch</span></div>
<div class="line"><span class="lineno"> 8975</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8976</span>            std::shared_ptr&lt;hmesh_t&gt; patch_mesh = std::shared_ptr&lt;hmesh_t&gt;(<span class="keyword">new</span> <a class="code hl_class" href="../../d7/d63/classhmesh__t.html">hmesh_t</a>);</div>
<div class="line"><span class="lineno"> 8977</span>            patch_mesh-&gt;reserve_for_additional_elements(cs_face_count);</div>
<div class="line"><span class="lineno"> 8978</span> </div>
<div class="line"><span class="lineno"> 8979</span>            std::unordered_map&lt;</div>
<div class="line"><span class="lineno"> 8980</span>                <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a>, <span class="comment">// vertex descriptor in &quot;m0&quot;</span></div>
<div class="line"><span class="lineno"> 8981</span>                <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> <span class="comment">// vertex descriptor in &quot;patch_mesh&quot;</span></div>
<div class="line"><span class="lineno"> 8982</span>                &gt;</div>
<div class="line"><span class="lineno"> 8983</span>                m0_to_patch_mesh_vertex;</div>
<div class="line"><span class="lineno"> 8984</span> </div>
<div class="line"><span class="lineno"> 8985</span>            m0_to_patch_mesh_vertex.reserve(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a35ce6de1cc36d41e9eb48edb3e23e795">number_of_vertices</a>());</div>
<div class="line"><span class="lineno"> 8986</span> </div>
<div class="line"><span class="lineno"> 8987</span>            <span class="comment">// NOTE: ccw/normal patches are created before their reversed counterparts (hence the modulo Operator trick)</span></div>
<div class="line"><span class="lineno"> 8988</span> </div>
<div class="line"><span class="lineno"> 8989</span>            <span class="comment">// is the a normal patch</span></div>
<div class="line"><span class="lineno"> 8990</span>            <span class="keyword">const</span> <span class="keywordtype">bool</span> is_ccw_patch = ((cur_patch_idx % total_ccw_patch_count) == cur_patch_idx);</div>
<div class="line"><span class="lineno"> 8991</span>            <span class="keyword">const</span> <a class="code hl_enumeration" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#afff2632fef27a069a33f81a0b51400f3">cm_patch_winding_order_t</a> patch_descriptor = is_ccw_patch ? <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#afff2632fef27a069a33f81a0b51400f3a5b39c8b553c821e7cddc6da64b5bd2ee">cm_patch_winding_order_t::DEFAULT</a> : <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#afff2632fef27a069a33f81a0b51400f3a642e0b6684e6165e142c074f1cd8d55c">cm_patch_winding_order_t::REVERSE</a>;</div>
<div class="line"><span class="lineno"> 8992</span>            <span class="keyword">const</span> std::string cs_patch_descriptor_str = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#ac170ee95cd3318133c47c23a4a4412b8">to_string</a>(patch_descriptor);</div>
<div class="line"><span class="lineno"> 8993</span> </div>
<div class="line"><span class="lineno"> 8994</span>            <span class="comment">// get the patch&#39;s polygons</span></div>
<div class="line"><span class="lineno"> 8995</span>            <span class="keyword">const</span> std::vector&lt;int&gt;&amp; patch = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patches, cur_patch_idx);</div>
<div class="line"><span class="lineno"> 8996</span> </div>
<div class="line"><span class="lineno"> 8997</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 8998</span>            <span class="comment">// add vertices into patch mesh</span></div>
<div class="line"><span class="lineno"> 8999</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9000</span> </div>
<div class="line"><span class="lineno"> 9001</span>            std::vector&lt;vd_t&gt; seam_vertices; <span class="comment">// vertices along cutpath</span></div>
<div class="line"><span class="lineno"> 9002</span> </div>
<div class="line"><span class="lineno"> 9003</span>            std::unordered_map&lt;vd_t, vd_t&gt; patch_to_m0_vertex;</div>
<div class="line"><span class="lineno"> 9004</span>            patch_to_m0_vertex.reserve(cs_face_count);</div>
<div class="line"><span class="lineno"> 9005</span> </div>
<div class="line"><span class="lineno"> 9006</span>            <span class="comment">// for each polygon in the patch</span></div>
<div class="line"><span class="lineno"> 9007</span>            <span class="keywordflow">for</span> (std::vector&lt;int&gt;::const_iterator patch_poly_iter = patch.cbegin(); patch_poly_iter != patch.cend(); ++patch_poly_iter) {</div>
<div class="line"><span class="lineno"> 9008</span> </div>
<div class="line"><span class="lineno"> 9009</span>                <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; patch_poly_idx = *patch_poly_iter;</div>
<div class="line"><span class="lineno"> 9010</span>                <span class="keyword">const</span> <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a>&amp; patch_poly = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_polygons, patch_poly_idx);</div>
<div class="line"><span class="lineno"> 9011</span> </div>
<div class="line"><span class="lineno"> 9012</span>                <span class="comment">// for each halfedge of polygon</span></div>
<div class="line"><span class="lineno"> 9013</span>                <span class="keywordflow">for</span> (traced_polygon_t::const_iterator patch_poly_he_iter = patch_poly.cbegin();</div>
<div class="line"><span class="lineno"> 9014</span>                     patch_poly_he_iter != patch_poly.cend();</div>
<div class="line"><span class="lineno"> 9015</span>                     ++patch_poly_he_iter) {</div>
<div class="line"><span class="lineno"> 9016</span> </div>
<div class="line"><span class="lineno"> 9017</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_vertex = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(*patch_poly_he_iter);</div>
<div class="line"><span class="lineno"> 9018</span>                    <span class="keyword">const</span> <span class="keywordtype">bool</span> vertex_already_mapped = m0_to_patch_mesh_vertex.find(m0_vertex) != m0_to_patch_mesh_vertex.cend();</div>
<div class="line"><span class="lineno"> 9019</span> </div>
<div class="line"><span class="lineno"> 9020</span>                    <span class="keywordflow">if</span> (!vertex_already_mapped) {</div>
<div class="line"><span class="lineno"> 9021</span>                        <span class="comment">// map from &quot;m0&quot; to &quot;patch_mesh&quot; descriptor</span></div>
<div class="line"><span class="lineno"> 9022</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a>&amp; patch_mesh_vertex = patch_mesh-&gt;add_vertex(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(m0_vertex));</div>
<div class="line"><span class="lineno"> 9023</span> </div>
<div class="line"><span class="lineno"> 9024</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(patch_mesh_vertex != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>());</div>
<div class="line"><span class="lineno"> 9025</span> </div>
<div class="line"><span class="lineno"> 9026</span>                        m0_to_patch_mesh_vertex.insert(std::make_pair(m0_vertex, patch_mesh_vertex));</div>
<div class="line"><span class="lineno"> 9027</span>                        patch_to_m0_vertex.insert(std::make_pair(patch_mesh_vertex, m0_vertex));</div>
<div class="line"><span class="lineno"> 9028</span> </div>
<div class="line"><span class="lineno"> 9029</span>                        <span class="comment">// mark if is seam vertex</span></div>
<div class="line"><span class="lineno"> 9030</span>                        <span class="keywordflow">if</span> (<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0_vertex, ps_vtx_cnt)) {</div>
<div class="line"><span class="lineno"> 9031</span>                            seam_vertices.push_back(patch_mesh_vertex); <span class="comment">// seam vertices are intersection points</span></div>
<div class="line"><span class="lineno"> 9032</span>                        }</div>
<div class="line"><span class="lineno"> 9033</span>                    }</div>
<div class="line"><span class="lineno"> 9034</span>                }</div>
<div class="line"><span class="lineno"> 9035</span>            }</div>
<div class="line"><span class="lineno"> 9036</span> </div>
<div class="line"><span class="lineno"> 9037</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(!seam_vertices.empty());</div>
<div class="line"><span class="lineno"> 9038</span> </div>
<div class="line"><span class="lineno"> 9039</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9040</span>            <span class="comment">// add faces into patch mesh</span></div>
<div class="line"><span class="lineno"> 9041</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9042</span> </div>
<div class="line"><span class="lineno"> 9043</span>            std::unordered_map&lt;fd_t, int&gt; patch_to_m0_face;</div>
<div class="line"><span class="lineno"> 9044</span>            patch_to_m0_face.reserve(patch.size());</div>
<div class="line"><span class="lineno"> 9045</span> </div>
<div class="line"><span class="lineno"> 9046</span><span class="preprocessor">#if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 9047</span>            <span class="keyword">auto</span> fn_remap_face_vertices = [&amp;](std::vector&lt;int&gt;::const_iterator block_start_, std::vector&lt;int&gt;::const_iterator block_end_) {</div>
<div class="line"><span class="lineno"> 9048</span>                std::vector&lt;std::pair&lt;int, std::vector&lt;vd_t&gt;&gt;&gt; result;</div>
<div class="line"><span class="lineno"> 9049</span>                result.resize(<a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(block_start_, block_end_));</div>
<div class="line"><span class="lineno"> 9050</span> </div>
<div class="line"><span class="lineno"> 9051</span>                <a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> counter = 0;</div>
<div class="line"><span class="lineno"> 9052</span>                <span class="comment">// for each polygon</span></div>
<div class="line"><span class="lineno"> 9053</span>                <span class="keywordflow">for</span> (std::vector&lt;int&gt;::const_iterator patch_poly_iter = block_start_; patch_poly_iter != block_end_; ++patch_poly_iter) {</div>
<div class="line"><span class="lineno"> 9054</span>                    std::vector&lt;vd_t&gt;&amp; remapped_poly_vertices = result[counter].second; <span class="comment">// redefined face using &quot;patch_mesh&quot; descriptors</span></div>
<div class="line"><span class="lineno"> 9055</span>                    <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; patch_poly_idx = *patch_poly_iter;</div>
<div class="line"><span class="lineno"> 9056</span>                    result[counter].first = patch_poly_idx;</div>
<div class="line"><span class="lineno"> 9057</span>                    <span class="keyword">const</span> <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a>&amp; patch_poly = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_polygons, patch_poly_idx);</div>
<div class="line"><span class="lineno"> 9058</span> </div>
<div class="line"><span class="lineno"> 9059</span>                    remapped_poly_vertices.reserve(patch_poly.size());</div>
<div class="line"><span class="lineno"> 9060</span> </div>
<div class="line"><span class="lineno"> 9061</span>                    <span class="comment">// for each halfedge</span></div>
<div class="line"><span class="lineno"> 9062</span>                    <span class="keywordflow">for</span> (traced_polygon_t::const_iterator patch_poly_he_iter = patch_poly.cbegin();</div>
<div class="line"><span class="lineno"> 9063</span>                         patch_poly_he_iter != patch_poly.cend();</div>
<div class="line"><span class="lineno"> 9064</span>                         ++patch_poly_he_iter) {</div>
<div class="line"><span class="lineno"> 9065</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_vertex = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(*patch_poly_he_iter);</div>
<div class="line"><span class="lineno"> 9066</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> patch_mesh_vertex = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_patch_mesh_vertex, m0_vertex);</div>
<div class="line"><span class="lineno"> 9067</span>                        remapped_poly_vertices.push_back(patch_mesh_vertex);</div>
<div class="line"><span class="lineno"> 9068</span>                    }</div>
<div class="line"><span class="lineno"> 9069</span> </div>
<div class="line"><span class="lineno"> 9070</span>                    counter++;</div>
<div class="line"><span class="lineno"> 9071</span>                }</div>
<div class="line"><span class="lineno"> 9072</span> </div>
<div class="line"><span class="lineno"> 9073</span>                <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno"> 9074</span>            };</div>
<div class="line"><span class="lineno"> 9075</span> </div>
<div class="line"><span class="lineno"> 9076</span>            std::vector&lt;std::future&lt;std::vector&lt;std::pair&lt;int, std::vector&lt;vd_t&gt;&gt;&gt;&gt;&gt; futures;</div>
<div class="line"><span class="lineno"> 9077</span>            std::vector&lt;std::pair&lt;int, std::vector&lt;vd_t&gt;&gt;&gt; partial_res;</div>
<div class="line"><span class="lineno"> 9078</span> </div>
<div class="line"><span class="lineno"> 9079</span>            <a class="code hl_function" href="../../df/d05/tpool_8h.html#a48d2e68725f7691f1422697f4c359827">parallel_for</a>(</div>
<div class="line"><span class="lineno"> 9080</span>                *input.scheduler,</div>
<div class="line"><span class="lineno"> 9081</span>                patch.cbegin(),</div>
<div class="line"><span class="lineno"> 9082</span>                patch.cend(),</div>
<div class="line"><span class="lineno"> 9083</span>                fn_remap_face_vertices,</div>
<div class="line"><span class="lineno"> 9084</span>                partial_res, <span class="comment">// output computed by master thread</span></div>
<div class="line"><span class="lineno"> 9085</span>                futures);</div>
<div class="line"><span class="lineno"> 9086</span> </div>
<div class="line"><span class="lineno"> 9087</span>            <span class="keyword">auto</span> add_face_and_save_mapping = [&amp;](<span class="keyword">const</span> std::pair&lt;int, std::vector&lt;vd_t&gt;&gt;&amp; remapped_poly_info) {</div>
<div class="line"><span class="lineno"> 9088</span>                <span class="keyword">const</span> std::vector&lt;vd_t&gt;&amp; remapped_poly_vertices = remapped_poly_info.second;</div>
<div class="line"><span class="lineno"> 9089</span>                <span class="keyword">const</span> <span class="keywordtype">int</span> patch_poly_idx = remapped_poly_info.first;</div>
<div class="line"><span class="lineno"> 9090</span> </div>
<div class="line"><span class="lineno"> 9091</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> f = patch_mesh-&gt;add_face(remapped_poly_vertices);</div>
<div class="line"><span class="lineno"> 9092</span> </div>
<div class="line"><span class="lineno"> 9093</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(f != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>());</div>
<div class="line"><span class="lineno"> 9094</span> </div>
<div class="line"><span class="lineno"> 9095</span>                patch_to_m0_face.insert(std::make_pair(f, patch_poly_idx));</div>
<div class="line"><span class="lineno"> 9096</span>            };</div>
<div class="line"><span class="lineno"> 9097</span> </div>
<div class="line"><span class="lineno"> 9098</span>            <span class="comment">// to maintain face insertion order, we add according to the scheduling</span></div>
<div class="line"><span class="lineno"> 9099</span> </div>
<div class="line"><span class="lineno"> 9100</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)futures.size(); ++i) {</div>
<div class="line"><span class="lineno"> 9101</span>                std::future&lt;std::vector&lt;std::pair&lt;int, std::vector&lt;vd_t&gt;&gt;&gt;&gt;&amp; f = futures[i];</div>
<div class="line"><span class="lineno"> 9102</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(f.valid());</div>
<div class="line"><span class="lineno"> 9103</span>                std::vector&lt;std::pair&lt;int, std::vector&lt;vd_t&gt;&gt;&gt; future_result = f.get(); <span class="comment">// &quot;get()&quot; is a blocking function</span></div>
<div class="line"><span class="lineno"> 9104</span> </div>
<div class="line"><span class="lineno"> 9105</span>                <span class="comment">// for each polygon</span></div>
<div class="line"><span class="lineno"> 9106</span>                <span class="keywordflow">for</span> (<a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> j = 0; j &lt; (<a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>)future_result.size(); ++j) {</div>
<div class="line"><span class="lineno"> 9107</span>                    <span class="keyword">const</span> std::pair&lt;int, std::vector&lt;vd_t&gt;&gt;&amp; remapped_poly_info = future_result[j];</div>
<div class="line"><span class="lineno"> 9108</span>                    add_face_and_save_mapping(remapped_poly_info);</div>
<div class="line"><span class="lineno"> 9109</span>                }</div>
<div class="line"><span class="lineno"> 9110</span>            }</div>
<div class="line"><span class="lineno"> 9111</span> </div>
<div class="line"><span class="lineno"> 9112</span>            <span class="comment">// for each polygon</span></div>
<div class="line"><span class="lineno"> 9113</span>            <span class="keywordflow">for</span> (<a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> j = 0; j &lt; (<a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>)partial_res.size(); ++j) {</div>
<div class="line"><span class="lineno"> 9114</span>                <span class="keyword">const</span> std::pair&lt;int, std::vector&lt;vd_t&gt;&gt;&amp; remapped_poly_info = partial_res[j];</div>
<div class="line"><span class="lineno"> 9115</span>                add_face_and_save_mapping(remapped_poly_info);</div>
<div class="line"><span class="lineno"> 9116</span>            }</div>
<div class="line"><span class="lineno"> 9117</span> </div>
<div class="line"><span class="lineno"> 9118</span><span class="preprocessor">#else </span><span class="comment">// #if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 9119</span>            std::vector&lt;vd_t&gt; remapped_poly_vertices; <span class="comment">// redefined face using &quot;patch_mesh&quot; descriptors</span></div>
<div class="line"><span class="lineno"> 9120</span>            <span class="comment">// for each polygon</span></div>
<div class="line"><span class="lineno"> 9121</span>            <span class="keywordflow">for</span> (std::vector&lt;int&gt;::const_iterator patch_poly_iter = patch.cbegin(); patch_poly_iter != patch.cend(); ++patch_poly_iter) {</div>
<div class="line"><span class="lineno"> 9122</span> </div>
<div class="line"><span class="lineno"> 9123</span>                <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; patch_poly_idx = *patch_poly_iter;</div>
<div class="line"><span class="lineno"> 9124</span>                <span class="keyword">const</span> <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a>&amp; patch_poly = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_polygons, patch_poly_idx);</div>
<div class="line"><span class="lineno"> 9125</span> </div>
<div class="line"><span class="lineno"> 9126</span>                remapped_poly_vertices.clear();</div>
<div class="line"><span class="lineno"> 9127</span>                remapped_poly_vertices.reserve(patch_poly.size());</div>
<div class="line"><span class="lineno"> 9128</span> </div>
<div class="line"><span class="lineno"> 9129</span>                <span class="comment">// for each halfedge</span></div>
<div class="line"><span class="lineno"> 9130</span>                <span class="keywordflow">for</span> (traced_polygon_t::const_iterator patch_poly_he_iter = patch_poly.cbegin();</div>
<div class="line"><span class="lineno"> 9131</span>                     patch_poly_he_iter != patch_poly.cend();</div>
<div class="line"><span class="lineno"> 9132</span>                     ++patch_poly_he_iter) {</div>
<div class="line"><span class="lineno"> 9133</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_vertex = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(*patch_poly_he_iter);</div>
<div class="line"><span class="lineno"> 9134</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> patch_mesh_vertex = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_patch_mesh_vertex, m0_vertex);</div>
<div class="line"><span class="lineno"> 9135</span>                    remapped_poly_vertices.push_back(patch_mesh_vertex);</div>
<div class="line"><span class="lineno"> 9136</span>                }</div>
<div class="line"><span class="lineno"> 9137</span> </div>
<div class="line"><span class="lineno"> 9138</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> f = patch_mesh-&gt;add_face(remapped_poly_vertices);</div>
<div class="line"><span class="lineno"> 9139</span> </div>
<div class="line"><span class="lineno"> 9140</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(f != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>());</div>
<div class="line"><span class="lineno"> 9141</span> </div>
<div class="line"><span class="lineno"> 9142</span>                patch_to_m0_face.insert(std::make_pair(f, patch_poly_idx));</div>
<div class="line"><span class="lineno"> 9143</span>            }</div>
<div class="line"><span class="lineno"> 9144</span> </div>
<div class="line"><span class="lineno"> 9145</span><span class="preprocessor">#endif </span><span class="comment">// #if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 9146</span> </div>
<div class="line"><span class="lineno"> 9147</span>            <span class="keywordflow">if</span> (input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#acbacc55f2163529291e5a45671fed3d1">verbose</a>) {</div>
<div class="line"><span class="lineno"> 9148</span>                <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a9bb440c35b34b7ecd91a6ce4eca6941e">dump_mesh</a>(patch_mesh.get()[0], (<span class="stringliteral">&quot;patch&quot;</span> + std::to_string(cur_patch_idx) + <span class="stringliteral">&quot;.&quot;</span> + <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#ac170ee95cd3318133c47c23a4a4412b8">to_string</a>(patch_location) + <span class="stringliteral">&quot;.&quot;</span> + cs_patch_descriptor_str).c_str());</div>
<div class="line"><span class="lineno"> 9149</span>            }</div>
<div class="line"><span class="lineno"> 9150</span> </div>
<div class="line"><span class="lineno"> 9151</span>            std::shared_ptr&lt;output_mesh_info_t&gt; omi = std::shared_ptr&lt;output_mesh_info_t&gt;(<span class="keyword">new</span> <a class="code hl_struct" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#de/de4/structoutput__mesh__info__t">output_mesh_info_t</a>);</div>
<div class="line"><span class="lineno"> 9152</span>            omi-&gt;mesh = patch_mesh;</div>
<div class="line"><span class="lineno"> 9153</span>            omi-&gt;seam_vertices = std::move(seam_vertices);</div>
<div class="line"><span class="lineno"> 9154</span> </div>
<div class="line"><span class="lineno"> 9155</span>            <span class="keywordflow">if</span> (input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a0b23c3ae4df4369125ff8b489a42260b">populate_vertex_maps</a>) {</div>
<div class="line"><span class="lineno"> 9156</span>                <span class="comment">// compute vertex mapping</span></div>
<div class="line"><span class="lineno"> 9157</span>                <span class="comment">// ----------------------</span></div>
<div class="line"><span class="lineno"> 9158</span> </div>
<div class="line"><span class="lineno"> 9159</span>                omi-&gt;data_maps.vertex_map.resize(patch_mesh-&gt;number_of_vertices());</div>
<div class="line"><span class="lineno"> 9160</span> </div>
<div class="line"><span class="lineno"> 9161</span><span class="preprocessor">#if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 9162</span>                {</div>
<div class="line"><span class="lineno"> 9163</span>                    <span class="keyword">auto</span> fn_fill_vertex_map = [&amp;](<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">vertex_array_iterator_t</a> block_start_, <a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">vertex_array_iterator_t</a> block_end_) {</div>
<div class="line"><span class="lineno"> 9164</span>                        <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">vertex_array_iterator_t</a> v = block_start_; v != block_end_; ++v) {</div>
<div class="line"><span class="lineno"> 9165</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(patch_to_m0_vertex.count(*v) == 1);</div>
<div class="line"><span class="lineno"> 9166</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> as_m0_descr = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patch_to_m0_vertex, *v);</div>
<div class="line"><span class="lineno"> 9167</span>                            <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> as_cm_descr = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ab448d0b9684fd2f648195b2e5edb83f2">hmesh_t::null_vertex</a>();</div>
<div class="line"><span class="lineno"> 9168</span> </div>
<div class="line"><span class="lineno"> 9169</span>                            <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>)as_m0_descr &lt; (<span class="keywordtype">int</span>)m0_to_ps_vtx.size() <span class="comment">/*m0_to_ps_vtx.count(as_m0_descr) == 1*/</span>) {</div>
<div class="line"><span class="lineno"> 9170</span>                                <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> as_ps_descr = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patch_to_m0_vertex, *v);</div>
<div class="line"><span class="lineno"> 9171</span> </div>
<div class="line"><span class="lineno"> 9172</span>                                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">int</span>)as_ps_descr &lt; (<span class="keywordtype">int</span>)ps_to_cm_vtx.size() <span class="comment">/*ps_to_cm_vtx.count(as_ps_descr) == 1*/</span>);</div>
<div class="line"><span class="lineno"> 9173</span>                                as_cm_descr = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_to_cm_vtx, as_ps_descr);</div>
<div class="line"><span class="lineno"> 9174</span> </div>
<div class="line"><span class="lineno"> 9175</span>                                <span class="comment">// add an offset which allows users to deduce which birth/origin mesh (source or cut mesh) a face (map value) belongs to.</span></div>
<div class="line"><span class="lineno"> 9176</span>                                as_cm_descr = <span class="keyword">static_cast&lt;</span><a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a><span class="keyword">&gt;</span>(as_cm_descr + sm_vtx_cnt);</div>
<div class="line"><span class="lineno"> 9177</span>                            }</div>
<div class="line"><span class="lineno"> 9178</span> </div>
<div class="line"><span class="lineno"> 9179</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(omi-&gt;data_maps.vertex_map, *v) == <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ab448d0b9684fd2f648195b2e5edb83f2">hmesh_t::null_vertex</a>() <span class="comment">/*omi-&gt;data_maps.vertex_map.count(*v) == 0*/</span>);</div>
<div class="line"><span class="lineno"> 9180</span>                            omi-&gt;data_maps.vertex_map[*v] = as_cm_descr;</div>
<div class="line"><span class="lineno"> 9181</span>                        }</div>
<div class="line"><span class="lineno"> 9182</span>                    };</div>
<div class="line"><span class="lineno"> 9183</span> </div>
<div class="line"><span class="lineno"> 9184</span>                    <a class="code hl_function" href="../../df/d05/tpool_8h.html#a48d2e68725f7691f1422697f4c359827">parallel_for</a>(</div>
<div class="line"><span class="lineno"> 9185</span>                        *input.scheduler,</div>
<div class="line"><span class="lineno"> 9186</span>                        patch_mesh-&gt;vertices_begin(),</div>
<div class="line"><span class="lineno"> 9187</span>                        patch_mesh-&gt;vertices_end(),</div>
<div class="line"><span class="lineno"> 9188</span>                        fn_fill_vertex_map);</div>
<div class="line"><span class="lineno"> 9189</span>                }</div>
<div class="line"><span class="lineno"> 9190</span><span class="preprocessor">#else </span><span class="comment">// #if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 9191</span>                <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">vertex_array_iterator_t</a> v = patch_mesh-&gt;vertices_begin(); v != patch_mesh-&gt;vertices_end(); ++v) {</div>
<div class="line"><span class="lineno"> 9192</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(patch_to_m0_vertex.count(*v) == 1);</div>
<div class="line"><span class="lineno"> 9193</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> as_m0_descr = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patch_to_m0_vertex, *v);</div>
<div class="line"><span class="lineno"> 9194</span>                    <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> as_cm_descr = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ab448d0b9684fd2f648195b2e5edb83f2">hmesh_t::null_vertex</a>();</div>
<div class="line"><span class="lineno"> 9195</span> </div>
<div class="line"><span class="lineno"> 9196</span>                    <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>)as_m0_descr &lt; (<span class="keywordtype">int</span>)m0_to_ps_vtx.size() <span class="comment">/*m0_to_ps_vtx.count(as_m0_descr) == 1*/</span>) {</div>
<div class="line"><span class="lineno"> 9197</span>                        <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> as_ps_descr = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patch_to_m0_vertex, *v);</div>
<div class="line"><span class="lineno"> 9198</span> </div>
<div class="line"><span class="lineno"> 9199</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">int</span>)as_ps_descr &lt; (<span class="keywordtype">int</span>)ps_to_cm_vtx.size() <span class="comment">/*ps_to_cm_vtx.count(as_ps_descr) == 1*/</span>);</div>
<div class="line"><span class="lineno"> 9200</span>                        as_cm_descr = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_to_cm_vtx, as_ps_descr);</div>
<div class="line"><span class="lineno"> 9201</span> </div>
<div class="line"><span class="lineno"> 9202</span>                        <span class="comment">// add an offset which allows users to deduce which birth/origin mesh (source or cut mesh) a face (map value) belongs to.</span></div>
<div class="line"><span class="lineno"> 9203</span>                        as_cm_descr = <span class="keyword">static_cast&lt;</span><a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a><span class="keyword">&gt;</span>(as_cm_descr + sm_vtx_cnt);</div>
<div class="line"><span class="lineno"> 9204</span>                    }</div>
<div class="line"><span class="lineno"> 9205</span> </div>
<div class="line"><span class="lineno"> 9206</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(omi-&gt;data_maps.vertex_map, *v) == <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ab448d0b9684fd2f648195b2e5edb83f2">hmesh_t::null_vertex</a>() <span class="comment">/*omi-&gt;data_maps.vertex_map.count(*v) == 0*/</span>);</div>
<div class="line"><span class="lineno"> 9207</span>                    omi-&gt;data_maps.vertex_map[*v] = as_cm_descr;</div>
<div class="line"><span class="lineno"> 9208</span>                }</div>
<div class="line"><span class="lineno"> 9209</span><span class="preprocessor">#endif </span><span class="comment">// #if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 9210</span>            }</div>
<div class="line"><span class="lineno"> 9211</span> </div>
<div class="line"><span class="lineno"> 9212</span>            <span class="keywordflow">if</span> (input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8307155337693cbe5ebf0f61ea8ffd81">populate_face_maps</a>) {</div>
<div class="line"><span class="lineno"> 9213</span>                <span class="comment">// compute face mapping</span></div>
<div class="line"><span class="lineno"> 9214</span>                <span class="comment">// ----------------------</span></div>
<div class="line"><span class="lineno"> 9215</span> </div>
<div class="line"><span class="lineno"> 9216</span>                omi-&gt;data_maps.face_map.resize(patch_mesh-&gt;number_of_faces());</div>
<div class="line"><span class="lineno"> 9217</span><span class="preprocessor">#if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 9218</span>                {</div>
<div class="line"><span class="lineno"> 9219</span>                    <span class="keyword">auto</span> fn_fill_face_map = [&amp;](<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">face_array_iterator_t</a> block_start_, <a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">face_array_iterator_t</a> block_end_) {</div>
<div class="line"><span class="lineno"> 9220</span>                        <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">face_array_iterator_t</a> f = block_start_; f != block_end_; ++f) {</div>
<div class="line"><span class="lineno"> 9221</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(patch_to_m0_face.count(*f) == 1);</div>
<div class="line"><span class="lineno"> 9222</span>                            <span class="keyword">const</span> <span class="keywordtype">int</span> as_m0_descr = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patch_to_m0_face, *f);</div>
<div class="line"><span class="lineno"> 9223</span> </div>
<div class="line"><span class="lineno"> 9224</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_to_ps_face.count(as_m0_descr) == 1);</div>
<div class="line"><span class="lineno"> 9225</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> as_ps_descr = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_ps_face, as_m0_descr);</div>
<div class="line"><span class="lineno"> 9226</span> </div>
<div class="line"><span class="lineno"> 9227</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">int</span>)as_ps_descr &lt; (<span class="keywordtype">int</span>)ps_to_cm_face.size() <span class="comment">/*ps_to_cm_face.count(as_ps_descr) == 1*/</span>);</div>
<div class="line"><span class="lineno"> 9228</span>                            <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> as_cm_descr = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_to_cm_face, as_ps_descr);</div>
<div class="line"><span class="lineno"> 9229</span> </div>
<div class="line"><span class="lineno"> 9230</span>                            <span class="comment">// add an offset which allows users to deduce which birth/origin mesh (source or cut mesh) a face (map value) belongs to.</span></div>
<div class="line"><span class="lineno"> 9231</span>                            as_cm_descr = <span class="keyword">static_cast&lt;</span><a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a><span class="keyword">&gt;</span>(as_cm_descr + sm_face_count);</div>
<div class="line"><span class="lineno"> 9232</span> </div>
<div class="line"><span class="lineno"> 9233</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(omi-&gt;data_maps.face_map, *f) == <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>() <span class="comment">/*omi-&gt;data_maps.face_map.count(*f) == 0*/</span>);</div>
<div class="line"><span class="lineno"> 9234</span>                            omi-&gt;data_maps.face_map[*f] = as_cm_descr;</div>
<div class="line"><span class="lineno"> 9235</span>                        }</div>
<div class="line"><span class="lineno"> 9236</span>                    };</div>
<div class="line"><span class="lineno"> 9237</span> </div>
<div class="line"><span class="lineno"> 9238</span>                    <a class="code hl_function" href="../../df/d05/tpool_8h.html#a48d2e68725f7691f1422697f4c359827">parallel_for</a>(</div>
<div class="line"><span class="lineno"> 9239</span>                        *input.scheduler,</div>
<div class="line"><span class="lineno"> 9240</span>                        patch_mesh-&gt;faces_begin(),</div>
<div class="line"><span class="lineno"> 9241</span>                        patch_mesh-&gt;faces_end(),</div>
<div class="line"><span class="lineno"> 9242</span>                        fn_fill_face_map);</div>
<div class="line"><span class="lineno"> 9243</span>                }</div>
<div class="line"><span class="lineno"> 9244</span><span class="preprocessor">#else </span><span class="comment">// #if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 9245</span>                <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">face_array_iterator_t</a> f = patch_mesh-&gt;faces_begin(); f != patch_mesh-&gt;faces_end(); ++f) {</div>
<div class="line"><span class="lineno"> 9246</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(patch_to_m0_face.count(*f) == 1);</div>
<div class="line"><span class="lineno"> 9247</span>                    <span class="keyword">const</span> <span class="keywordtype">int</span> as_m0_descr = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patch_to_m0_face, *f);</div>
<div class="line"><span class="lineno"> 9248</span> </div>
<div class="line"><span class="lineno"> 9249</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_to_ps_face.count(as_m0_descr) == 1);</div>
<div class="line"><span class="lineno"> 9250</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> as_ps_descr = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_ps_face, as_m0_descr);</div>
<div class="line"><span class="lineno"> 9251</span> </div>
<div class="line"><span class="lineno"> 9252</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">int</span>)as_ps_descr &lt; (<span class="keywordtype">int</span>)ps_to_cm_face.size() <span class="comment">/*ps_to_cm_face.count(as_ps_descr) == 1*/</span>);</div>
<div class="line"><span class="lineno"> 9253</span>                    <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> as_cm_descr = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_to_cm_face, as_ps_descr);</div>
<div class="line"><span class="lineno"> 9254</span> </div>
<div class="line"><span class="lineno"> 9255</span>                    <span class="comment">// add an offset which allows users to deduce which birth/origin mesh (source or cut mesh) a face (map value) belongs to.</span></div>
<div class="line"><span class="lineno"> 9256</span>                    as_cm_descr = <span class="keyword">static_cast&lt;</span><a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a><span class="keyword">&gt;</span>(as_cm_descr + sm_face_count);</div>
<div class="line"><span class="lineno"> 9257</span> </div>
<div class="line"><span class="lineno"> 9258</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(omi-&gt;data_maps.face_map, *f) == <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>() <span class="comment">/*omi-&gt;data_maps.face_map.count(*f) == 0*/</span>);</div>
<div class="line"><span class="lineno"> 9259</span>                    omi-&gt;data_maps.face_map[*f] = as_cm_descr;</div>
<div class="line"><span class="lineno"> 9260</span>                }</div>
<div class="line"><span class="lineno"> 9261</span><span class="preprocessor">#endif </span><span class="comment">// #if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 9262</span>            }</div>
<div class="line"><span class="lineno"> 9263</span> </div>
<div class="line"><span class="lineno"> 9264</span>            <span class="keywordflow">if</span> (patch_location == <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956a554a7418c4c0dafd902ebd377b87c80c">cm_patch_location_t::INSIDE</a>) {</div>
<div class="line"><span class="lineno"> 9265</span>                output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a212140a3fcc6fafadaf91ec04e4840c7">inside_patches</a>[patch_descriptor].emplace_back((omi));</div>
<div class="line"><span class="lineno"> 9266</span>            } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 9267</span>                output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a058fa7a2d90c7ead6282f1810cebb731">outside_patches</a>[patch_descriptor].emplace_back((omi));</div>
<div class="line"><span class="lineno"> 9268</span>            }</div>
<div class="line"><span class="lineno"> 9269</span>        }</div>
<div class="line"><span class="lineno"> 9270</span>    }</div>
<div class="line"><span class="lineno"> 9271</span> </div>
<div class="line"><span class="lineno"> 9272</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 9273</span> </div>
<div class="line"><span class="lineno"> 9274</span>    <span class="keywordflow">if</span> (<span class="keyword">false</span> == (input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a07e9992982b4f9497d1499f1cfb2826d">keep_fragments_below_cutmesh</a> || <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9275</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#ababb18b60ba667267d374ba263e889af">keep_fragments_above_cutmesh</a> || <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9276</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a6558e59317164c8e7d141f2f8fce00b5">keep_fragments_partially_cut</a> || <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9277</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a4d23d907262b78c2d865f4d52bb65757">keep_fragments_sealed_inside</a> || <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9278</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#aff3651e310bd220d4f65bd450af94f16">keep_fragments_sealed_outside</a> || input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a18ab3e0c7ed366d45a0c1aaccddc4eee">keep_fragments_sealed_inside_exhaustive</a> || <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9279</span>            input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a719e59e63d8bf7d7c665f69d3213327b">keep_fragments_sealed_outside_exhaustive</a>)) {</div>
<div class="line"><span class="lineno"> 9280</span>        <span class="comment">// if the user simply wants [patches], then we should not have to proceed further.</span></div>
<div class="line"><span class="lineno"> 9281</span>        <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno"> 9282</span>    }</div>
<div class="line"><span class="lineno"> 9283</span> </div>
<div class="line"><span class="lineno"> 9285</span>    <span class="comment">// calculate the reversed patch seeds</span></div>
<div class="line"><span class="lineno"> 9287</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 9288</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9289</span>    <span class="comment">// Here, we will infer the seed [interior intersection-halfedges] and polygons</span></div>
<div class="line"><span class="lineno"> 9290</span>    <span class="comment">// for the newly create reversed polygons. We will also save information telling</span></div>
<div class="line"><span class="lineno"> 9291</span>    <span class="comment">// whether each reversed patch is a floating patch or not. We will use this</span></div>
<div class="line"><span class="lineno"> 9292</span>    <span class="comment">// information during stitching</span></div>
<div class="line"><span class="lineno"> 9293</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9294</span> </div>
<div class="line"><span class="lineno"> 9295</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Create reversed-patch seed variables&quot;</span>);</div>
<div class="line"><span class="lineno"> 9296</span> </div>
<div class="line"><span class="lineno"> 9297</span>    <span class="comment">// for each color</span></div>
<div class="line"><span class="lineno"> 9298</span>    <span class="keywordflow">for</span> (std::map&lt;<span class="keywordtype">char</span>, std::vector&lt;int&gt;&gt;::const_iterator color_to_cw_patch_iter = color_to_cw_patch.cbegin();</div>
<div class="line"><span class="lineno"> 9299</span>         color_to_cw_patch_iter != color_to_cw_patch.cend();</div>
<div class="line"><span class="lineno"> 9300</span>         ++color_to_cw_patch_iter) {</div>
<div class="line"><span class="lineno"> 9301</span> </div>
<div class="line"><span class="lineno"> 9302</span>        <span class="comment">// const char color_value = color_to_cw_patch_iter-&gt;first;</span></div>
<div class="line"><span class="lineno"> 9303</span> </div>
<div class="line"><span class="lineno"> 9304</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9305</span> </div>
<div class="line"><span class="lineno"> 9306</span>        <span class="comment">// get the reversed patch of the current color</span></div>
<div class="line"><span class="lineno"> 9307</span>        <span class="keyword">const</span> std::vector&lt;int&gt;&amp; colored_cw_patches = color_to_cw_patch_iter-&gt;second;</div>
<div class="line"><span class="lineno"> 9308</span> </div>
<div class="line"><span class="lineno"> 9309</span>        <span class="comment">// for each patch</span></div>
<div class="line"><span class="lineno"> 9310</span>        <span class="keywordflow">for</span> (std::vector&lt;int&gt;::const_iterator colored_cw_patch_iter = colored_cw_patches.cbegin();</div>
<div class="line"><span class="lineno"> 9311</span>             colored_cw_patch_iter != colored_cw_patches.cend();</div>
<div class="line"><span class="lineno"> 9312</span>             ++colored_cw_patch_iter) {</div>
<div class="line"><span class="lineno"> 9313</span> </div>
<div class="line"><span class="lineno"> 9314</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> cw_patch_idx = *colored_cw_patch_iter;</div>
<div class="line"><span class="lineno"> 9315</span> </div>
<div class="line"><span class="lineno"> 9316</span>            <span class="comment">// get patch polygons</span></div>
<div class="line"><span class="lineno"> 9317</span>            <span class="comment">// const std::vector&lt;int&gt;&amp; cw_patch = SAFE_ACCESS(patches, cw_patch_idx);</span></div>
<div class="line"><span class="lineno"> 9318</span>            <span class="comment">// get the opposite patch</span></div>
<div class="line"><span class="lineno"> 9319</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> ccw_patch_idx = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patch_to_opposite, cw_patch_idx); <span class="comment">// opposite patch</span></div>
<div class="line"><span class="lineno"> 9320</span> </div>
<div class="line"><span class="lineno"> 9321</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9322</span>            <span class="comment">// copy information from opposite (ccw/normal) patch</span></div>
<div class="line"><span class="lineno"> 9323</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9324</span>            <span class="comment">// std::pair&lt;std::map&lt;int, bool&gt;::const_iterator, bool&gt; patch_to_floating_flag_insertion = patch_to_floating_flag.insert(</span></div>
<div class="line"><span class="lineno"> 9325</span>            <span class="comment">//    std::make_pair(cw_patch_idx, SAFE_ACCESS(patch_to_floating_flag, ccw_patch_idx)));</span></div>
<div class="line"><span class="lineno"> 9326</span> </div>
<div class="line"><span class="lineno"> 9327</span>            <span class="comment">// MCUT_ASSERT(patch_to_floating_flag_insertion.second == true);</span></div>
<div class="line"><span class="lineno"> 9328</span> </div>
<div class="line"><span class="lineno"> 9329</span>            <span class="comment">// was the opposite patch determined to be a floating patch</span></div>
<div class="line"><span class="lineno"> 9330</span>            <span class="comment">// const bool is_floating_patch = patch_to_floating_flag_insertion.first-&gt;second;</span></div>
<div class="line"><span class="lineno"> 9331</span>            <span class="comment">// get the index of seed interior intersection halfedge of the opposite ccw/normal patch</span></div>
<div class="line"><span class="lineno"> 9332</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> ccw_patch_seed_interior_ihalfedge_idx = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patch_to_seed_interior_ihalfedge_idx, ccw_patch_idx);</div>
<div class="line"><span class="lineno"> 9333</span>            <span class="comment">// get the index of seed polygon of the opposite ccw/normal patch</span></div>
<div class="line"><span class="lineno"> 9334</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> ccw_patch_seed_poly_idx = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patch_to_seed_poly_idx, ccw_patch_idx);</div>
<div class="line"><span class="lineno"> 9335</span>            <span class="comment">// get the seed polygon of the opposite ccw/normal patch</span></div>
<div class="line"><span class="lineno"> 9336</span>            <span class="keyword">const</span> <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a>&amp; ccw_patch_seed_poly = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_polygons, ccw_patch_seed_poly_idx);</div>
<div class="line"><span class="lineno"> 9337</span>            <span class="comment">// get the seed interior intersection halfedge of the opposite ccw/normal patch</span></div>
<div class="line"><span class="lineno"> 9338</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; ccw_patch_seed_interior_ihalfedge = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ccw_patch_seed_poly, ccw_patch_seed_interior_ihalfedge_idx);</div>
<div class="line"><span class="lineno"> 9339</span>            <span class="comment">// opposite halfedge of the seed interior intersection halfedge of the opposite ccw/normal patch</span></div>
<div class="line"><span class="lineno"> 9340</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> ccw_patch_seed_interior_ihalfedge_opp = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(ccw_patch_seed_interior_ihalfedge);</div>
<div class="line"><span class="lineno"> 9341</span> </div>
<div class="line"><span class="lineno"> 9342</span>            <span class="comment">// find the reversed polygon which uses &quot;ccw_patch_seed_interior_ihalfedge_opp&quot;</span></div>
<div class="line"><span class="lineno"> 9343</span>            <span class="comment">// this will be the seed polygon of the current reversed patch</span></div>
<div class="line"><span class="lineno"> 9344</span>            <span class="keyword">const</span> std::vector&lt;int&gt;&amp; coincident_polys = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, ccw_patch_seed_interior_ihalfedge_opp);</div>
<div class="line"><span class="lineno"> 9345</span> </div>
<div class="line"><span class="lineno"> 9346</span>            std::vector&lt;int&gt;::const_iterator find_iter = std::find_if(coincident_polys.cbegin(), coincident_polys.cend(),</div>
<div class="line"><span class="lineno"> 9347</span>                [&amp;](<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; e) {</div>
<div class="line"><span class="lineno"> 9348</span>#if 0</div>
<div class="line"><span class="lineno"> 9349</span>                                                                              if (is_floating_patch)</div>
<div class="line"><span class="lineno"> 9350</span>                                                                              {</div>
<div class="line"><span class="lineno"> 9351</span>                                                                                  return e &gt;= traced_sm_polygon_count &amp;&amp; e &lt; traced_polygon_count; <span class="comment">// interior ihalfedges of floating patches are already coincident to two polygons due to polygon tracing</span></div>
<div class="line"><span class="lineno"> 9352</span>                                                                              }</div>
<div class="line"><span class="lineno"> 9353</span>                                                                              <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno"> 9354</span>#endif</div>
<div class="line"><span class="lineno"> 9355</span>                    {</div>
<div class="line"><span class="lineno"> 9356</span>                        return e &gt;= traced_polygon_count;</div>
<div class="line"><span class="lineno"> 9357</span>                    }</div>
<div class="line"><span class="lineno"> 9358</span>                });</div>
<div class="line"><span class="lineno"> 9359</span> </div>
<div class="line"><span class="lineno"> 9360</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(find_iter != coincident_polys.cend());</div>
<div class="line"><span class="lineno"> 9361</span> </div>
<div class="line"><span class="lineno"> 9362</span>            <span class="comment">// the index of the seed polygon of the current reversed patch</span></div>
<div class="line"><span class="lineno"> 9363</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> cw_patch_seed_poly_idx = *find_iter;</div>
<div class="line"><span class="lineno"> 9364</span> </div>
<div class="line"><span class="lineno"> 9365</span>            <span class="comment">// the patch must contain the polygon</span></div>
<div class="line"><span class="lineno"> 9366</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(std::find(<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patches, cw_patch_idx).<a class="code hl_function" href="../../dd/d66/namespacelibnest2d_1_1shapelike.html#ae20480bfb433b47626e2e0e9188f8bb8">cbegin</a>(), <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patches, cw_patch_idx).<a class="code hl_function" href="../../dd/d66/namespacelibnest2d_1_1shapelike.html#ab0e9f75b95a950d0262d29654d15e123">cend</a>(), cw_patch_seed_poly_idx) != <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patches, cw_patch_idx).<a class="code hl_function" href="../../dd/d66/namespacelibnest2d_1_1shapelike.html#ab0e9f75b95a950d0262d29654d15e123">cend</a>());</div>
<div class="line"><span class="lineno"> 9367</span> </div>
<div class="line"><span class="lineno"> 9368</span>            <span class="keyword">const</span> <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a>&amp; cw_patch_seed_poly = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_polygons, cw_patch_seed_poly_idx);</div>
<div class="line"><span class="lineno"> 9369</span>            traced_polygon_t::const_iterator he_find_iter = std::find(cw_patch_seed_poly.cbegin(), cw_patch_seed_poly.cend(), ccw_patch_seed_interior_ihalfedge_opp);</div>
<div class="line"><span class="lineno"> 9370</span> </div>
<div class="line"><span class="lineno"> 9371</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(he_find_iter != cw_patch_seed_poly.cend());</div>
<div class="line"><span class="lineno"> 9372</span> </div>
<div class="line"><span class="lineno"> 9373</span>            <span class="comment">// the index of the interior intersection halfedge of the current reversed patch</span></div>
<div class="line"><span class="lineno"> 9374</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> opposite_patch_seed_interior_ihalfedge_idx = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)<a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(cw_patch_seed_poly.cbegin(), he_find_iter);</div>
<div class="line"><span class="lineno"> 9375</span> </div>
<div class="line"><span class="lineno"> 9376</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(patch_to_seed_interior_ihalfedge_idx.count(cw_patch_idx) == 0);</div>
<div class="line"><span class="lineno"> 9377</span>            patch_to_seed_interior_ihalfedge_idx[cw_patch_idx] = opposite_patch_seed_interior_ihalfedge_idx;</div>
<div class="line"><span class="lineno"> 9378</span>            <span class="comment">// std::pair&lt;std::map&lt;int, int&gt;::const_iterator, bool&gt; seed_interior_ihalfedge_idx_insertion = patch_to_seed_interior_ihalfedge_idx.insert(std::make_pair(cw_patch_idx, opposite_patch_seed_interior_ihalfedge_idx));</span></div>
<div class="line"><span class="lineno"> 9379</span>            <span class="comment">//  MCUT_ASSERT(seed_interior_ihalfedge_idx_insertion.second == true);</span></div>
<div class="line"><span class="lineno"> 9380</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(patch_to_seed_interior_ihalfedge_idx.count(cw_patch_idx) == 1);</div>
<div class="line"><span class="lineno"> 9381</span> </div>
<div class="line"><span class="lineno"> 9382</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(patch_to_seed_poly_idx.count(cw_patch_idx) == 0);</div>
<div class="line"><span class="lineno"> 9383</span>            patch_to_seed_poly_idx[cw_patch_idx] = cw_patch_seed_poly_idx;</div>
<div class="line"><span class="lineno"> 9384</span>            <span class="comment">// std::pair&lt;std::map&lt;int, int&gt;::const_iterator, bool&gt; seed_poly_idx_insertion = patch_to_seed_poly_idx.insert(std::make_pair(cw_patch_idx, cw_patch_seed_poly_idx));</span></div>
<div class="line"><span class="lineno"> 9385</span>            <span class="comment">// MCUT_ASSERT(seed_poly_idx_insertion.second == true);</span></div>
<div class="line"><span class="lineno"> 9386</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(patch_to_seed_poly_idx.count(cw_patch_idx) == 1);</div>
<div class="line"><span class="lineno"> 9387</span>        }</div>
<div class="line"><span class="lineno"> 9388</span>    }</div>
<div class="line"><span class="lineno"> 9389</span> </div>
<div class="line"><span class="lineno"> 9390</span>    <span class="comment">// patch_to_floating_flag.clear(); // free</span></div>
<div class="line"><span class="lineno"> 9391</span>    color_to_cw_patch.clear(); <span class="comment">// free</span></div>
<div class="line"><span class="lineno"> 9392</span>    patch_to_opposite.clear(); <span class="comment">// free</span></div>
<div class="line"><span class="lineno"> 9393</span> </div>
<div class="line"><span class="lineno"> 9394</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 9395</span> </div>
<div class="line"><span class="lineno"> 9397</span>    <span class="comment">// Stitch cut-mesh patches into connected components (fragments) of the source-mesh</span></div>
<div class="line"><span class="lineno"> 9399</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 9400</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9401</span>    <span class="comment">// We are now going to &quot;fill the holes&quot;</span></div>
<div class="line"><span class="lineno"> 9402</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9403</span>    <span class="comment">// For each color tag, we have a halfdge data structure (which is a copy of &quot;m1&quot;).</span></div>
<div class="line"><span class="lineno"> 9404</span>    <span class="comment">// We do this to make sure that the exterior/outside patches will be stitched to</span></div>
<div class="line"><span class="lineno"> 9405</span>    <span class="comment">// separate copies of the connected components in &quot;m1&quot;, compared to interior patches.</span></div>
<div class="line"><span class="lineno"> 9406</span>    <span class="comment">// This helps us to distinguish between stitching the interior of the source-mesh</span></div>
<div class="line"><span class="lineno"> 9407</span>    <span class="comment">// (hole-filling), and stitching the exterior (i.e. boolean merge operation</span></div>
<div class="line"><span class="lineno"> 9408</span>    <span class="comment">// if the cut-mesh is water-tight)</span></div>
<div class="line"><span class="lineno"> 9409</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9410</span> </div>
<div class="line"><span class="lineno"> 9411</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Stitching&quot;</span>); <span class="comment">// &amp;&amp;&amp;&amp;&amp;</span></div>
<div class="line"><span class="lineno"> 9412</span> </div>
<div class="line"><span class="lineno"> 9413</span>    std::map&lt;</div>
<div class="line"><span class="lineno"> 9414</span>        char, <span class="comment">// color tag</span></div>
<div class="line"><span class="lineno"> 9415</span>        std::map&lt;</div>
<div class="line"><span class="lineno"> 9416</span>            std::size_t, <span class="comment">// cc-id</span></div>
<div class="line"><span class="lineno"> 9417</span>            std::vector&lt; <span class="comment">// list of partially sealed connected components (first elem has 1 stitched polygon and the last has all cut-mesh polygons stitched to fill holes)</span></div>
<div class="line"><span class="lineno"> 9418</span>                std::pair&lt; <span class="comment">// mesh instance</span></div>
<div class="line"><span class="lineno"> 9419</span>                    std::shared_ptr&lt;hmesh_t&gt;, <span class="comment">// actual mesh data structure</span></div>
<div class="line"><span class="lineno"> 9420</span>                    <a class="code hl_struct" href="../../dd/d24/kernel_8cpp.html#d7/dd7/structconnected__component__info__t">connected_component_info_t</a> <span class="comment">// information about mesh</span></div>
<div class="line"><span class="lineno"> 9421</span>                    &gt;&gt;&gt;&gt;</div>
<div class="line"><span class="lineno"> 9422</span>        color_to_separated_connected_ccsponents;</div>
<div class="line"><span class="lineno"> 9423</span> </div>
<div class="line"><span class="lineno"> 9424</span>    std::map&lt;</div>
<div class="line"><span class="lineno"> 9425</span>        char, <span class="comment">// color tag</span></div>
<div class="line"><span class="lineno"> 9426</span>        std::vector&lt;traced_polygon_t&gt; <span class="comment">// traced polygons in colored &quot;m1&quot; mesh</span></div>
<div class="line"><span class="lineno"> 9427</span>        &gt;</div>
<div class="line"><span class="lineno"> 9428</span>        color_to_m1_polygons;</div>
<div class="line"><span class="lineno"> 9429</span> </div>
<div class="line"><span class="lineno"> 9430</span>    <span class="comment">// A halfedge in &quot;m0&quot; that is used to trace a cut-mesh polygon will have</span></div>
<div class="line"><span class="lineno"> 9431</span>    <span class="comment">// two &quot;m1&quot; versions - one for the ccw/normal patch and the other for the</span></div>
<div class="line"><span class="lineno"> 9432</span>    <span class="comment">// cw/reversed patch.</span></div>
<div class="line"><span class="lineno"> 9433</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9434</span>    std::map&lt;</div>
<div class="line"><span class="lineno"> 9435</span>        char, <span class="comment">// color tag</span></div>
<div class="line"><span class="lineno"> 9436</span>        std::unordered_map&lt;</div>
<div class="line"><span class="lineno"> 9437</span>            <a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a>, <span class="comment">// &quot;m0&quot; cut-mesh halfedge instance</span></div>
<div class="line"><span class="lineno"> 9438</span>            std::map&lt;</div>
<div class="line"><span class="lineno"> 9439</span>                <a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>, <span class="comment">// patch idx</span></div>
<div class="line"><span class="lineno"> 9440</span>                <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> <span class="comment">// &quot;m1&quot; cut-mesh halfedge instance</span></div>
<div class="line"><span class="lineno"> 9441</span>                &gt;&gt;&gt;</div>
<div class="line"><span class="lineno"> 9442</span>        color_to_m0_to_m1_he_instances;</div>
<div class="line"><span class="lineno"> 9443</span> </div>
<div class="line"><span class="lineno"> 9444</span>    std::map&lt;</div>
<div class="line"><span class="lineno"> 9445</span>        char, <span class="comment">// color value</span></div>
<div class="line"><span class="lineno"> 9446</span>        std::unordered_map&lt;int, int&gt; <span class="comment">// copy of m0_to_m1_face (initially containing mappings just for traced source-mesh polygon)</span></div>
<div class="line"><span class="lineno"> 9447</span>        &gt;</div>
<div class="line"><span class="lineno"> 9448</span>        color_to_m0_to_m1_face; <span class="comment">//  = { { &#39;A&#39;, m0_to_m1_face }, { &#39;B&#39;, m0_to_m1_face } };</span></div>
<div class="line"><span class="lineno"> 9449</span> </div>
<div class="line"><span class="lineno"> 9450</span>    color_to_m0_to_m1_face.emplace(std::make_pair(<span class="charliteral">&#39;A&#39;</span>, m0_to_m1_face));</div>
<div class="line"><span class="lineno"> 9451</span>    color_to_m0_to_m1_face.emplace(std::make_pair(<span class="charliteral">&#39;B&#39;</span>, std::move(m0_to_m1_face)));</div>
<div class="line"><span class="lineno"> 9452</span>    <span class="comment">// m0_to_m1_face.clear();</span></div>
<div class="line"><span class="lineno"> 9453</span> </div>
<div class="line"><span class="lineno"> 9454</span>    std::map&lt;</div>
<div class="line"><span class="lineno"> 9455</span>        char, <span class="comment">// color value</span></div>
<div class="line"><span class="lineno"> 9456</span>        std::unordered_map&lt;int, int&gt; <span class="comment">// copy of m1_to_m0_face (initially containing mappings just for traced source-mesh polygon)</span></div>
<div class="line"><span class="lineno"> 9457</span>        &gt;</div>
<div class="line"><span class="lineno"> 9458</span>        color_to_m1_to_m0_face; <span class="comment">// = { { &#39;A&#39;, m1_to_m0_face }, { &#39;B&#39;, m1_to_m0_face } };</span></div>
<div class="line"><span class="lineno"> 9459</span>    color_to_m1_to_m0_face.emplace(std::make_pair(<span class="charliteral">&#39;A&#39;</span>, m1_to_m0_face));</div>
<div class="line"><span class="lineno"> 9460</span>    color_to_m1_to_m0_face.emplace(std::make_pair(<span class="charliteral">&#39;B&#39;</span>, std::move(m1_to_m0_face)));</div>
<div class="line"><span class="lineno"> 9461</span>    <span class="comment">// m1_to_m0_face.clear();</span></div>
<div class="line"><span class="lineno"> 9462</span> </div>
<div class="line"><span class="lineno"> 9463</span>    std::map&lt;char, std::unordered_map&lt;<a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a>, <span class="comment">// &quot;m1&quot; cut-mesh vtx instance</span></div>
<div class="line"><span class="lineno"> 9464</span>                       <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> <span class="comment">// &quot;m0&quot; cut-mesh ovtx instance</span></div>
<div class="line"><span class="lineno"> 9465</span>                       &gt;&gt;</div>
<div class="line"><span class="lineno"> 9466</span>        colour_to_m1_to_m0_cm_ovtx;</div>
<div class="line"><span class="lineno"> 9467</span> </div>
<div class="line"><span class="lineno"> 9468</span>    std::map&lt;</div>
<div class="line"><span class="lineno"> 9469</span>        char, <span class="comment">// color value</span></div>
<div class="line"><span class="lineno"> 9470</span>        std::vector&lt;vd_t&gt; <span class="comment">// copy of &quot;m0_to_m1_ovtx&quot; (initially containing mappings just for original source-mesh &amp; cut-mesh vertices i.e. no ivertices included!)</span></div>
<div class="line"><span class="lineno"> 9471</span>        &gt;</div>
<div class="line"><span class="lineno"> 9472</span>        color_to_m1_to_m0_sm_ovtx; <span class="comment">// = { { &#39;A&#39;, m1_to_m0_ovtx }, { &#39;B&#39;, m1_to_m0_ovtx } };</span></div>
<div class="line"><span class="lineno"> 9473</span>    color_to_m1_to_m0_sm_ovtx.emplace(std::make_pair(<span class="charliteral">&#39;A&#39;</span>, m1_to_m0_ovtx));</div>
<div class="line"><span class="lineno"> 9474</span>    color_to_m1_to_m0_sm_ovtx.emplace(std::make_pair(<span class="charliteral">&#39;B&#39;</span>, std::move(m1_to_m0_ovtx)));</div>
<div class="line"><span class="lineno"> 9475</span>    <span class="comment">// m1_to_m0_ovtx.clear();</span></div>
<div class="line"><span class="lineno"> 9476</span> </div>
<div class="line"><span class="lineno"> 9477</span>    <span class="comment">// this queue contains information identifying the patch polygons next-in-queue</span></div>
<div class="line"><span class="lineno"> 9478</span>    <span class="comment">// to be stitched into the inferred connected component</span></div>
<div class="line"><span class="lineno"> 9479</span>    std::deque&lt;std::tuple&lt;<a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> <span class="comment">/*m1*/</span>, <span class="keywordtype">int</span> <span class="comment">/*m0 poly*/</span>, <span class="keywordtype">int</span> <span class="comment">/*m0 he*/</span>&gt;&gt; patch_poly_stitching_queue;</div>
<div class="line"><span class="lineno"> 9480</span> </div>
<div class="line"><span class="lineno"> 9481</span>    <span class="comment">// enough space for cut-mesh polygons</span></div>
<div class="line"><span class="lineno"> 9482</span>    std::vector&lt;bool&gt; m0_poly_already_enqueued(m0_polygons.size() - traced_sm_polygon_count, <span class="keyword">false</span>); <span class="comment">// i.e. in &quot;patch_poly_stitching_queue&quot;</span></div>
<div class="line"><span class="lineno"> 9483</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> m0_poly_already_enqueued_size = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)m0_poly_already_enqueued.size();</div>
<div class="line"><span class="lineno"> 9484</span> </div>
<div class="line"><span class="lineno"> 9485</span>    <span class="comment">// for each color  (&quot;interior&quot; / &quot;exterior&quot;)</span></div>
<div class="line"><span class="lineno"> 9486</span>    <span class="keywordflow">for</span> (std::map&lt;<span class="keywordtype">char</span>, std::vector&lt;int&gt;&gt;::const_iterator color_to_patches_iter = color_to_patch.cbegin();</div>
<div class="line"><span class="lineno"> 9487</span>         color_to_patches_iter != color_to_patch.cend();</div>
<div class="line"><span class="lineno"> 9488</span>         ++color_to_patches_iter) {</div>
<div class="line"><span class="lineno"> 9489</span> </div>
<div class="line"><span class="lineno"> 9490</span>        <span class="keyword">const</span> <span class="keywordtype">char</span> color_id = color_to_patches_iter-&gt;first;</div>
<div class="line"><span class="lineno"> 9491</span> </div>
<div class="line"><span class="lineno"> 9492</span>        <span class="keyword">const</span> <a class="code hl_enumeration" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956">cm_patch_location_t</a>&amp; location = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patch_color_label_to_location, color_id);</div>
<div class="line"><span class="lineno"> 9493</span> </div>
<div class="line"><span class="lineno"> 9494</span>        <span class="keywordflow">if</span> ((location == <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956a554a7418c4c0dafd902ebd377b87c80c">cm_patch_location_t::INSIDE</a> &amp;&amp; !(input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a4d23d907262b78c2d865f4d52bb65757">keep_fragments_sealed_inside</a> || input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a18ab3e0c7ed366d45a0c1aaccddc4eee">keep_fragments_sealed_inside_exhaustive</a>)) || <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9495</span>            (location == <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956a93da25bafef6761717afc6b25c17ea16">cm_patch_location_t::OUTSIDE</a> &amp;&amp; !(input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#aff3651e310bd220d4f65bd450af94f16">keep_fragments_sealed_outside</a> || input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a719e59e63d8bf7d7c665f69d3213327b">keep_fragments_sealed_outside_exhaustive</a>))) {</div>
<div class="line"><span class="lineno"> 9496</span>            <span class="keywordflow">continue</span>; <span class="comment">// skip stitching of exterior/ interior patches as user desires.</span></div>
<div class="line"><span class="lineno"> 9497</span>        }</div>
<div class="line"><span class="lineno"> 9498</span> </div>
<div class="line"><span class="lineno"> 9499</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(color_to_m1.count(color_id) == 1);</div>
<div class="line"><span class="lineno"> 9500</span>        <span class="comment">// get the reference to the copy of &quot;m1&quot; to which patches of the current color will be stitched</span></div>
<div class="line"><span class="lineno"> 9501</span>        <a class="code hl_class" href="../../d7/d63/classhmesh__t.html">hmesh_t</a>&amp; m1_colored = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(color_to_m1, color_id);</div>
<div class="line"><span class="lineno"> 9502</span> </div>
<div class="line"><span class="lineno"> 9503</span>        m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a0c71c904363d4a3932bd674812f8478e">reserve_for_additional_elements</a>(cs_vtx_count);</div>
<div class="line"><span class="lineno"> 9504</span> </div>
<div class="line"><span class="lineno"> 9505</span>        <span class="comment">// create entry</span></div>
<div class="line"><span class="lineno"> 9506</span>        color_to_m0_to_m1_he_instances.insert(std::make_pair(color_id, std::unordered_map&lt;<a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>, std::map&lt;int, hd_t&gt;&gt;()));</div>
<div class="line"><span class="lineno"> 9507</span>        <span class="comment">// ref to entry</span></div>
<div class="line"><span class="lineno"> 9508</span>        std::unordered_map&lt;hd_t, std::map&lt;int, hd_t&gt;&gt;&amp; m0_to_m1_he_instances = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(color_to_m0_to_m1_he_instances, color_id);</div>
<div class="line"><span class="lineno"> 9509</span>        m0_to_m1_he_instances.reserve(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a38154c743bff113eea931e14eaea6ddd">number_of_halfedges</a>());</div>
<div class="line"><span class="lineno"> 9510</span>        <span class="comment">// copy all of the &quot;m1_polygons&quot; that were created before we got to the stitching stage</span></div>
<div class="line"><span class="lineno"> 9511</span>        <span class="comment">// Note: Before stitching has began, &quot;m1_polygons&quot; contains only source-mesh polygons,</span></div>
<div class="line"><span class="lineno"> 9512</span>        <span class="comment">// which have been partition to allow separation of unsealed connected components</span></div>
<div class="line"><span class="lineno"> 9513</span>        std::pair&lt;std::map&lt;char, std::vector&lt;traced_polygon_t&gt;&gt;::iterator, <span class="keywordtype">bool</span>&gt; color_to_m1_polygons_insertion = color_to_m1_polygons.insert(std::make_pair(color_id, m1_polygons)); <span class="comment">// copy!</span></div>
<div class="line"><span class="lineno"> 9514</span> </div>
<div class="line"><span class="lineno"> 9515</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(color_to_m1_polygons_insertion.second == <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 9516</span> </div>
<div class="line"><span class="lineno"> 9517</span>        <span class="comment">// ref to &quot;m1_polygons&quot; i.e. the source-mesh polygons with partitioning</span></div>
<div class="line"><span class="lineno"> 9518</span>        std::vector&lt;traced_polygon_t&gt;&amp; m1_polygons_colored = color_to_m1_polygons_insertion.first-&gt;second;</div>
<div class="line"><span class="lineno"> 9519</span>        m1_polygons_colored.reserve(m1_polygons_colored.size() + cs_face_count);</div>
<div class="line"><span class="lineno"> 9520</span> </div>
<div class="line"><span class="lineno"> 9521</span>        <span class="comment">// reference to the list connected components (see declaration for details)</span></div>
<div class="line"><span class="lineno"> 9522</span>        std::map&lt;std::size_t, std::vector&lt;std::pair&lt;std::shared_ptr&lt;hmesh_t&gt;, <a class="code hl_struct" href="../../dd/d24/kernel_8cpp.html#d7/dd7/structconnected__component__info__t">connected_component_info_t</a>&gt;&gt;&gt;&amp; separated_stitching_CCs = color_to_separated_connected_ccsponents[color_id]; <span class="comment">// insert</span></div>
<div class="line"><span class="lineno"> 9523</span> </div>
<div class="line"><span class="lineno"> 9524</span>        std::unordered_map&lt;int, int&gt;&amp; m0_to_m1_face_colored = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(color_to_m0_to_m1_face, color_id); <span class="comment">// note: containing mappings only for traced source mesh polygons initially!</span></div>
<div class="line"><span class="lineno"> 9525</span>        m0_to_m1_face_colored.reserve(m0_polygons.size());</div>
<div class="line"><span class="lineno"> 9526</span>        std::unordered_map&lt;int, int&gt;&amp; m1_to_m0_face_colored = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(color_to_m1_to_m0_face, color_id);</div>
<div class="line"><span class="lineno"> 9527</span>        m1_to_m0_face_colored.reserve(m0_polygons.size());</div>
<div class="line"><span class="lineno"> 9528</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(!m0_to_m1_face_colored.empty());</div>
<div class="line"><span class="lineno"> 9529</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(!m1_to_m0_face_colored.empty());</div>
<div class="line"><span class="lineno"> 9530</span> </div>
<div class="line"><span class="lineno"> 9531</span>        std::vector&lt;vd_t&gt;&amp; m1_to_m0_sm_ovtx_colored = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(color_to_m1_to_m0_sm_ovtx, color_id);</div>
<div class="line"><span class="lineno"> 9532</span>        <span class="comment">// MCUT_ASSERT(!m0_to_m1_sm_ovtx_colored.empty());</span></div>
<div class="line"><span class="lineno"> 9533</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(!m1_to_m0_sm_ovtx_colored.empty());</div>
<div class="line"><span class="lineno"> 9534</span>        m1_to_m0_sm_ovtx_colored.reserve(sm_vtx_cnt);</div>
<div class="line"><span class="lineno"> 9535</span> </div>
<div class="line"><span class="lineno"> 9536</span>        <span class="comment">// An original in &quot;m0&quot; that is used to trace a cut-mesh polygon will have</span></div>
<div class="line"><span class="lineno"> 9537</span>        <span class="comment">// two &quot;m1&quot; versions - one for the ccw/normal patch and the other for the</span></div>
<div class="line"><span class="lineno"> 9538</span>        <span class="comment">// cw/reversed patch.</span></div>
<div class="line"><span class="lineno"> 9539</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9540</span>        <span class="comment">// This map works like &quot;color_to_m0_to_m1_sm_ovtx&quot; but the difference is that each</span></div>
<div class="line"><span class="lineno"> 9541</span>        <span class="comment">// &quot;m0&quot; vertex has two &quot;m1&quot; copies because we generate ccw &amp; cw patches.</span></div>
<div class="line"><span class="lineno"> 9542</span> </div>
<div class="line"><span class="lineno"> 9543</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(colour_to_m1_to_m0_cm_ovtx.count(color_id) == 0);</div>
<div class="line"><span class="lineno"> 9544</span>        std::unordered_map&lt;<a class="code hl_typedef" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a>, <span class="comment">// &quot;m1&quot; cut-mesh vtx instance</span></div>
<div class="line"><span class="lineno"> 9545</span>            <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> <span class="comment">// &quot;m0&quot; cut-mesh ovtx instance</span></div>
<div class="line"><span class="lineno"> 9546</span>            &gt;&amp; m1_to_m0_cm_ovtx_colored</div>
<div class="line"><span class="lineno"> 9547</span>            = colour_to_m1_to_m0_cm_ovtx[color_id];</div>
<div class="line"><span class="lineno"> 9548</span> </div>
<div class="line"><span class="lineno"> 9549</span>        <span class="comment">// keeps track of the total number of cut-mesh polygons for the current color tag (interior/ext)</span></div>
<div class="line"><span class="lineno"> 9550</span>        <span class="keywordtype">int</span> stitched_poly_counter = 0;</div>
<div class="line"><span class="lineno"> 9551</span> </div>
<div class="line"><span class="lineno"> 9552</span>        <span class="comment">// for each patch with current color</span></div>
<div class="line"><span class="lineno"> 9553</span>        <span class="keywordflow">for</span> (std::vector&lt;int&gt;::const_iterator patch_iter = color_to_patches_iter-&gt;second.cbegin();</div>
<div class="line"><span class="lineno"> 9554</span>             patch_iter != color_to_patches_iter-&gt;second.cend();</div>
<div class="line"><span class="lineno"> 9555</span>             ++patch_iter) {</div>
<div class="line"><span class="lineno"> 9556</span> </div>
<div class="line"><span class="lineno"> 9557</span>            <span class="comment">// get patch index</span></div>
<div class="line"><span class="lineno"> 9558</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> cur_patch_idx = *patch_iter;</div>
<div class="line"><span class="lineno"> 9559</span> </div>
<div class="line"><span class="lineno"> 9560</span>            <span class="comment">// is it a ccw/normal patch i.e. not the cw/reversed version</span></div>
<div class="line"><span class="lineno"> 9561</span>            <span class="comment">// NOTE: ccw/normal patches are created/traced before reversed counterparts (hence the modulo trick)</span></div>
<div class="line"><span class="lineno"> 9562</span>            <span class="keyword">const</span> <span class="keywordtype">bool</span> is_ccw_patch = ((cur_patch_idx % total_ccw_patch_count) == cur_patch_idx);</div>
<div class="line"><span class="lineno"> 9563</span> </div>
<div class="line"><span class="lineno"> 9564</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(patches.find(cur_patch_idx) != patches.cend());</div>
<div class="line"><span class="lineno"> 9566</span>            <span class="comment">// stitch patch into a connected component stored in &quot;m1_colored&quot;</span></div>
<div class="line"><span class="lineno"> 9568</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 9569</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9570</span>            <span class="comment">// We are basically going to search for the connected component (in &quot;m1_colored&quot;) to which</span></div>
<div class="line"><span class="lineno"> 9571</span>            <span class="comment">// the current patch will be stitched/glued.</span></div>
<div class="line"><span class="lineno"> 9572</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9573</span>            <span class="comment">// PERSONAL NOTE REGARDING `NORMAL` PATCHES:</span></div>
<div class="line"><span class="lineno"> 9574</span>            <span class="comment">// Interior patches are stitched to the connected components which &quot;naturally&quot;</span></div>
<div class="line"><span class="lineno"> 9575</span>            <span class="comment">// match their winding order (i.e. they are stitched to the connected component</span></div>
<div class="line"><span class="lineno"> 9576</span>            <span class="comment">// &quot;below&quot; the patch).</span></div>
<div class="line"><span class="lineno"> 9577</span>            <span class="comment">// Exterior patches are stitched to connected components which DO NOT share</span></div>
<div class="line"><span class="lineno"> 9578</span>            <span class="comment">// the &quot;natural&quot; winding order (i.e. they are stitched to the connected component</span></div>
<div class="line"><span class="lineno"> 9579</span>            <span class="comment">// &quot;above&quot; the patch).</span></div>
<div class="line"><span class="lineno"> 9580</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9581</span> </div>
<div class="line"><span class="lineno"> 9582</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(patch_to_seed_poly_idx.find(cur_patch_idx) != patch_to_seed_poly_idx.cend());</div>
<div class="line"><span class="lineno"> 9583</span> </div>
<div class="line"><span class="lineno"> 9584</span>            <span class="comment">// get the seed polygon from which to begin the stitching</span></div>
<div class="line"><span class="lineno"> 9585</span>            <span class="comment">// this polygon will be on the patch boundary/border</span></div>
<div class="line"><span class="lineno"> 9586</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> m0_patch_seed_poly_idx = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patch_to_seed_poly_idx, cur_patch_idx);</div>
<div class="line"><span class="lineno"> 9587</span> </div>
<div class="line"><span class="lineno"> 9588</span>            <span class="comment">// patch must contain the polygon</span></div>
<div class="line"><span class="lineno"> 9589</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(std::find(<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patches, cur_patch_idx).<a class="code hl_function" href="../../dd/d66/namespacelibnest2d_1_1shapelike.html#ae20480bfb433b47626e2e0e9188f8bb8">cbegin</a>(), <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patches, cur_patch_idx).<a class="code hl_function" href="../../dd/d66/namespacelibnest2d_1_1shapelike.html#ab0e9f75b95a950d0262d29654d15e123">cend</a>(), m0_patch_seed_poly_idx) != <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patches, cur_patch_idx).<a class="code hl_function" href="../../dd/d66/namespacelibnest2d_1_1shapelike.html#ab0e9f75b95a950d0262d29654d15e123">cend</a>());</div>
<div class="line"><span class="lineno"> 9590</span>            <span class="comment">// the seed polygon must be from the ones that were traced in &quot;m0&quot; (see graph discovery stage above)</span></div>
<div class="line"><span class="lineno"> 9591</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_patch_seed_poly_idx &lt; (<span class="keywordtype">int</span>)m0_polygons.size());</div>
<div class="line"><span class="lineno"> 9592</span> </div>
<div class="line"><span class="lineno"> 9593</span>            <span class="comment">// get the seed polygon of the patch</span></div>
<div class="line"><span class="lineno"> 9594</span>            <span class="keyword">const</span> <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a>&amp; m0_patch_seed_poly = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_polygons, m0_patch_seed_poly_idx);</div>
<div class="line"><span class="lineno"> 9595</span> </div>
<div class="line"><span class="lineno"> 9596</span>            <span class="comment">// patch must have a seed halfedge (the one used to traced the seed polygon)</span></div>
<div class="line"><span class="lineno"> 9597</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(patch_to_seed_interior_ihalfedge_idx.find(cur_patch_idx) != patch_to_seed_interior_ihalfedge_idx.cend());</div>
<div class="line"><span class="lineno"> 9598</span> </div>
<div class="line"><span class="lineno"> 9599</span>            <span class="comment">// get the index of the seed interior intersection halfedge of the patch</span></div>
<div class="line"><span class="lineno"> 9600</span>            <span class="comment">// this is a halfedge defining the border of the patch and is used to trace</span></div>
<div class="line"><span class="lineno"> 9601</span>            <span class="comment">// the seed polygon</span></div>
<div class="line"><span class="lineno"> 9602</span>            <span class="keyword">const</span> <span class="keywordtype">int</span> m0_patch_seed_poly_he_idx = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patch_to_seed_interior_ihalfedge_idx, cur_patch_idx);</div>
<div class="line"><span class="lineno"> 9603</span> </div>
<div class="line"><span class="lineno"> 9604</span>            <span class="comment">// must be within the range of the number of halfedge defining the seed polygon</span></div>
<div class="line"><span class="lineno"> 9605</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_patch_seed_poly_he_idx &lt; (<span class="keywordtype">int</span>)m0_patch_seed_poly.size());</div>
<div class="line"><span class="lineno"> 9606</span> </div>
<div class="line"><span class="lineno"> 9607</span>            <span class="comment">// get the seed halfedge descriptor</span></div>
<div class="line"><span class="lineno"> 9608</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; m0_patch_seed_poly_he = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_patch_seed_poly, m0_patch_seed_poly_he_idx);</div>
<div class="line"><span class="lineno"> 9609</span> </div>
<div class="line"><span class="lineno"> 9610</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9611</span>            <span class="comment">// Here, we now deduce the connected component to which the current patch will be stitched.</span></div>
<div class="line"><span class="lineno"> 9612</span>            <span class="comment">// To do this we can use the opposite halfedge of the seed halfedge. This opposite halfedge</span></div>
<div class="line"><span class="lineno"> 9613</span>            <span class="comment">// is used to trace a source-mesh polygon next to the cut-path.</span></div>
<div class="line"><span class="lineno"> 9614</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9615</span> </div>
<div class="line"><span class="lineno"> 9616</span>            <span class="comment">// get opposite halfedge of the seed halfedge of the current patch</span></div>
<div class="line"><span class="lineno"> 9617</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m0_patch_seed_poly_he_opp = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(m0_patch_seed_poly_he);</div>
<div class="line"><span class="lineno"> 9618</span> </div>
<div class="line"><span class="lineno"> 9619</span>            <span class="comment">// an &quot;m1&quot; version of this opposite halfedge must exist from the halfedge</span></div>
<div class="line"><span class="lineno"> 9620</span>            <span class="comment">// partitioning problem we solved when duplicating intersection points to</span></div>
<div class="line"><span class="lineno"> 9621</span>            <span class="comment">// partition the source-mesh</span></div>
<div class="line"><span class="lineno"> 9622</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_to_m1_ihe.find(m0_patch_seed_poly_he_opp) != m0_to_m1_ihe.cend());</div>
<div class="line"><span class="lineno"> 9623</span> </div>
<div class="line"><span class="lineno"> 9624</span>            <span class="comment">// get the &quot;m1&quot; version of the opposite-halfedge of the seed-halfedge.</span></div>
<div class="line"><span class="lineno"> 9625</span>            <span class="comment">// Note that this halfedge has already been used to trace a source-mesh polygon</span></div>
<div class="line"><span class="lineno"> 9626</span>            <span class="comment">// in &quot;m1&quot;....</span></div>
<div class="line"><span class="lineno"> 9627</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m1_seed_interior_ihe_opp = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_m1_ihe, m0_patch_seed_poly_he_opp);</div>
<div class="line"><span class="lineno"> 9628</span>            <span class="comment">// .... thus, we have to use its opposite, which will be the &quot;m1&quot; version of the</span></div>
<div class="line"><span class="lineno"> 9629</span>            <span class="comment">// seed halfedge of the current patch.</span></div>
<div class="line"><span class="lineno"> 9630</span>            <span class="comment">// PERSONAL NOTE: this probably requires a visual example to properly understand</span></div>
<div class="line"><span class="lineno"> 9631</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m1_seed_interior_ihe_opp_opp = m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(m1_seed_interior_ihe_opp); <span class="comment">// i.e. m1 instance of m0_patch_seed_poly_he_opp</span></div>
<div class="line"><span class="lineno"> 9632</span> </div>
<div class="line"><span class="lineno"> 9633</span>            patch_poly_stitching_queue.clear();</div>
<div class="line"><span class="lineno"> 9634</span> </div>
<div class="line"><span class="lineno"> 9635</span>            <span class="comment">// reset</span></div>
<div class="line"><span class="lineno"> 9636</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m0_poly_already_enqueued_size; ++i) {</div>
<div class="line"><span class="lineno"> 9637</span>                m0_poly_already_enqueued[i] = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 9638</span>            }</div>
<div class="line"><span class="lineno"> 9639</span> </div>
<div class="line"><span class="lineno"> 9640</span>            <span class="comment">// thus, the first element is the seed polygon and the seed halfedge</span></div>
<div class="line"><span class="lineno"> 9641</span>            patch_poly_stitching_queue.push_back(</div>
<div class="line"><span class="lineno"> 9642</span>                std::make_tuple(</div>
<div class="line"><span class="lineno"> 9643</span>                    m1_seed_interior_ihe_opp_opp,</div>
<div class="line"><span class="lineno"> 9644</span>                    m0_patch_seed_poly_idx,</div>
<div class="line"><span class="lineno"> 9645</span>                    m0_patch_seed_poly_he_idx));</div>
<div class="line"><span class="lineno"> 9646</span> </div>
<div class="line"><span class="lineno"> 9647</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9648</span>            <span class="comment">// In the following loop, we will stitch patch polygons iteratively as we</span></div>
<div class="line"><span class="lineno"> 9649</span>            <span class="comment">// discover adjacent ones starting from the seed polygon. In each interation,</span></div>
<div class="line"><span class="lineno"> 9650</span>            <span class="comment">// we process halfedges of the current polygon so that they reference the</span></div>
<div class="line"><span class="lineno"> 9651</span>            <span class="comment">// correct vertex descriptors (src and tgt) in order to fill holes.</span></div>
<div class="line"><span class="lineno"> 9652</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9653</span>            <span class="keywordflow">do</span> {</div>
<div class="line"><span class="lineno"> 9654</span> </div>
<div class="line"><span class="lineno"> 9655</span>                <span class="comment">// the first processed/stitched of halfedge the current polygon (our starting point)</span></div>
<div class="line"><span class="lineno"> 9656</span>                <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m1_cur_patch_cur_poly_1st_he = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno"> 9657</span>                <span class="keywordtype">int</span> m0_cur_patch_cur_poly_idx = -1; <span class="comment">// index into m0_polygons</span></div>
<div class="line"><span class="lineno"> 9658</span>                <span class="keywordtype">int</span> m0_cur_patch_cur_poly_1st_he_idx = -1; <span class="comment">// index into m0_polygon</span></div>
<div class="line"><span class="lineno"> 9659</span> </div>
<div class="line"><span class="lineno"> 9660</span>                <span class="comment">// pop element from queue (the next polygon to stitch)</span></div>
<div class="line"><span class="lineno"> 9661</span>                std::tie(</div>
<div class="line"><span class="lineno"> 9662</span>                    m1_cur_patch_cur_poly_1st_he,</div>
<div class="line"><span class="lineno"> 9663</span>                    m0_cur_patch_cur_poly_idx,</div>
<div class="line"><span class="lineno"> 9664</span>                    m0_cur_patch_cur_poly_1st_he_idx)</div>
<div class="line"><span class="lineno"> 9665</span>                    = patch_poly_stitching_queue.front();</div>
<div class="line"><span class="lineno"> 9666</span> </div>
<div class="line"><span class="lineno"> 9667</span>                m0_poly_already_enqueued[(std::size_t)m0_cur_patch_cur_poly_idx - traced_sm_polygon_count] = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 9668</span> </div>
<div class="line"><span class="lineno"> 9669</span>                <span class="comment">// must be within the range of the traced polygons (include the reversed ones)</span></div>
<div class="line"><span class="lineno"> 9670</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_cur_patch_cur_poly_idx &lt; (<span class="keywordtype">int</span>)m0_polygons.size());</div>
<div class="line"><span class="lineno"> 9671</span> </div>
<div class="line"><span class="lineno"> 9672</span>                <span class="comment">// get the current polygon of the patch</span></div>
<div class="line"><span class="lineno"> 9673</span>                <span class="keyword">const</span> <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a>&amp; m0_cur_patch_cur_poly = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_polygons, m0_cur_patch_cur_poly_idx);</div>
<div class="line"><span class="lineno"> 9674</span> </div>
<div class="line"><span class="lineno"> 9675</span>                <span class="comment">// the index of the starting halfedge must be within range of the polygon</span></div>
<div class="line"><span class="lineno"> 9676</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_cur_patch_cur_poly_1st_he_idx &lt; (<span class="keywordtype">int</span>)m0_cur_patch_cur_poly.size());</div>
<div class="line"><span class="lineno"> 9677</span> </div>
<div class="line"><span class="lineno"> 9678</span>                <span class="comment">// get the descriptor of the starting halfedge</span></div>
<div class="line"><span class="lineno"> 9679</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; m0_cur_patch_cur_poly_1st_he = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_cur_patch_cur_poly, m0_cur_patch_cur_poly_1st_he_idx);</div>
<div class="line"><span class="lineno"> 9680</span> </div>
<div class="line"><span class="lineno"> 9681</span>                <span class="comment">// the processed/stitched version of the current polygon</span></div>
<div class="line"><span class="lineno"> 9682</span>                m1_polygons_colored.emplace_back(<a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a>());</div>
<div class="line"><span class="lineno"> 9683</span>                <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a>&amp; m1_poly = m1_polygons_colored.back(); <span class="comment">// stitched/&quot;m1&quot; version of polygon</span></div>
<div class="line"><span class="lineno"> 9684</span>                m1_poly.reserve(m0_cur_patch_cur_poly.size());</div>
<div class="line"><span class="lineno"> 9685</span>                m1_poly.push_back(m1_cur_patch_cur_poly_1st_he);</div>
<div class="line"><span class="lineno"> 9686</span> </div>
<div class="line"><span class="lineno"> 9687</span>                <span class="comment">// save mapping</span></div>
<div class="line"><span class="lineno"> 9688</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_to_m1_face_colored.count(m0_cur_patch_cur_poly_idx) == 0);</div>
<div class="line"><span class="lineno"> 9689</span>                <span class="keyword">const</span> <span class="keywordtype">int</span> m1_cur_patch_cur_poly_idx = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)(m1_polygons_colored.size() - 1);</div>
<div class="line"><span class="lineno"> 9690</span>                m0_to_m1_face_colored[m0_cur_patch_cur_poly_idx] = m1_cur_patch_cur_poly_idx;</div>
<div class="line"><span class="lineno"> 9691</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m1_to_m0_face_colored.count(m1_cur_patch_cur_poly_idx) == 0);</div>
<div class="line"><span class="lineno"> 9692</span>                m1_to_m0_face_colored[m1_cur_patch_cur_poly_idx] = m0_cur_patch_cur_poly_idx;</div>
<div class="line"><span class="lineno"> 9693</span> </div>
<div class="line"><span class="lineno"> 9694</span>                <span class="comment">// the number of halfedges in the current polygon that have been processed</span></div>
<div class="line"><span class="lineno"> 9695</span>                <span class="comment">// Note: we start from &quot;1&quot; because the initial halfedge (m0_cur_patch_cur_poly_1st_he) has already been processed.</span></div>
<div class="line"><span class="lineno"> 9696</span>                <span class="comment">// That is, we already have an &quot;m1&quot; version of it thanks to the halfedge transformation step (intersection point</span></div>
<div class="line"><span class="lineno"> 9697</span>                <span class="comment">// dupication step) which occurs along the cutpath.</span></div>
<div class="line"><span class="lineno"> 9698</span>                <span class="keywordtype">int</span> transformed_he_counter = 1; <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9699</span> </div>
<div class="line"><span class="lineno"> 9700</span>                <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9701</span>                <span class="comment">// In the following loop, we will process polygon-halfedges iteratively as we</span></div>
<div class="line"><span class="lineno"> 9702</span>                <span class="comment">// advance onto the &quot;next&quot; ones in the sequence starting from the initial. In each interation,</span></div>
<div class="line"><span class="lineno"> 9703</span>                <span class="comment">// we create an &quot;m1&quot; version of the of the current &quot;m0&quot; halfedge so that it references the</span></div>
<div class="line"><span class="lineno"> 9704</span>                <span class="comment">// correct vertex descriptors (src and tgt). The next iteration moves onto the</span></div>
<div class="line"><span class="lineno"> 9705</span>                <span class="comment">// next halfedge, and so on...</span></div>
<div class="line"><span class="lineno"> 9706</span>                <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9707</span> </div>
<div class="line"><span class="lineno"> 9708</span>                <span class="keywordflow">do</span> { <span class="comment">// for each remaining halfedge of current polygon being stitched</span></div>
<div class="line"><span class="lineno"> 9709</span> </div>
<div class="line"><span class="lineno"> 9710</span>                    <span class="comment">// if (transformed_he_counter == 1) { // are we processing the second halfedge?</span></div>
<div class="line"><span class="lineno"> 9711</span>                    <span class="comment">//  log</span></div>
<div class="line"><span class="lineno"> 9712</span>                    <span class="comment">//  TODO: proper printing functions</span></div>
<div class="line"><span class="lineno"> 9713</span> </div>
<div class="line"><span class="lineno"> 9714</span>                    <span class="comment">//  &lt;&lt; m1_colored.source(m1_cur_patch_cur_poly_1st_he) &lt;&lt; &quot; &quot; &lt;&lt; m1_colored.target(m1_cur_patch_cur_poly_1st_he) &lt;&lt; &quot;&gt;&quot; &lt;&lt; std::endl;);</span></div>
<div class="line"><span class="lineno"> 9715</span>                    <span class="comment">//}</span></div>
<div class="line"><span class="lineno"> 9716</span> </div>
<div class="line"><span class="lineno"> 9717</span>                    <span class="comment">// index of current halfedge index to be processed</span></div>
<div class="line"><span class="lineno"> 9718</span>                    <span class="keyword">const</span> <span class="keywordtype">int</span> m0_cur_patch_cur_poly_cur_he_idx = <a class="code hl_function" href="../../d5/d60/utils_8h.html#ad42d4789f60996516823b4b4cfb9c04d">wrap_integer</a>(m0_cur_patch_cur_poly_1st_he_idx + transformed_he_counter, 0, (<span class="keywordtype">int</span>)m0_cur_patch_cur_poly.size() - 1);</div>
<div class="line"><span class="lineno"> 9719</span> </div>
<div class="line"><span class="lineno"> 9720</span>                    <span class="comment">// must be in range of polygon size</span></div>
<div class="line"><span class="lineno"> 9721</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_cur_patch_cur_poly_cur_he_idx &lt; (<span class="keywordtype">int</span>)m0_cur_patch_cur_poly.size());</div>
<div class="line"><span class="lineno"> 9722</span> </div>
<div class="line"><span class="lineno"> 9723</span>                    <span class="comment">// descriptor of current halfedge</span></div>
<div class="line"><span class="lineno"> 9724</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m0_cur_patch_cur_poly_cur_he = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_cur_patch_cur_poly, m0_cur_patch_cur_poly_cur_he_idx); <span class="comment">// current untransformed</span></div>
<div class="line"><span class="lineno"> 9725</span>                    <span class="comment">// opposite of current halfedge</span></div>
<div class="line"><span class="lineno"> 9726</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m0_cur_patch_cur_poly_cur_he_opp = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(m0_cur_patch_cur_poly_cur_he);</div>
<div class="line"><span class="lineno"> 9727</span>                    <span class="comment">// target of the current halfedge</span></div>
<div class="line"><span class="lineno"> 9728</span>                    <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_cur_patch_cur_poly_cur_he_tgt = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m0_cur_patch_cur_poly_cur_he);</div>
<div class="line"><span class="lineno"> 9729</span>                    <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_cur_patch_cur_poly_cur_he_src = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(m0_cur_patch_cur_poly_cur_he);</div>
<div class="line"><span class="lineno"> 9730</span>                    <span class="keyword">const</span> <span class="keywordtype">bool</span> src_is_ivertex = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0_cur_patch_cur_poly_cur_he_src, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 9731</span>                    <span class="keyword">const</span> <span class="keywordtype">bool</span> tgt_is_ivertex = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0_cur_patch_cur_poly_cur_he_tgt, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 9732</span> </div>
<div class="line"><span class="lineno"> 9733</span>                    <span class="comment">// is the current halfedge the last to be processed in the current polygon?</span></div>
<div class="line"><span class="lineno"> 9734</span>                    <span class="keyword">const</span> <span class="keywordtype">bool</span> cur_is_last_to_be_transformed = ((transformed_he_counter + 1) == (<span class="keywordtype">int</span>)m0_cur_patch_cur_poly.size()); <span class="comment">// i.e. current he is last one to be transform</span></div>
<div class="line"><span class="lineno"> 9735</span>                    <span class="comment">// enumerator of previously processed halfedge</span></div>
<div class="line"><span class="lineno"> 9736</span>                    <span class="keyword">const</span> <span class="keywordtype">int</span> m1_cur_patch_cur_poly_prev_he_idx = transformed_he_counter - 1; <span class="comment">// note: transformed_he_counter is init to 1</span></div>
<div class="line"><span class="lineno"> 9737</span> </div>
<div class="line"><span class="lineno"> 9738</span>                    <span class="comment">// must be in current polygon&#39;s range</span></div>
<div class="line"><span class="lineno"> 9739</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m1_cur_patch_cur_poly_prev_he_idx &gt;= 0 &amp;&amp; m1_cur_patch_cur_poly_prev_he_idx &lt; (<span class="keywordtype">int</span>)m1_poly.size());</div>
<div class="line"><span class="lineno"> 9740</span> </div>
<div class="line"><span class="lineno"> 9741</span>                    <span class="comment">// get descriptor of the processed copy of the preceeding halfedge in the current polygon</span></div>
<div class="line"><span class="lineno"> 9742</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m1_cur_patch_cur_poly_prev_he = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m1_poly, m1_cur_patch_cur_poly_prev_he_idx); <span class="comment">// previously transformed</span></div>
<div class="line"><span class="lineno"> 9743</span>                    <span class="comment">// get target of transformed previous</span></div>
<div class="line"><span class="lineno"> 9744</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m1_cur_patch_cur_poly_prev_he_tgt = m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m1_cur_patch_cur_poly_prev_he); <span class="comment">// transformed target of previous</span></div>
<div class="line"><span class="lineno"> 9745</span> </div>
<div class="line"><span class="lineno"> 9747</span>                    <span class="comment">// create &quot;m1&quot; version of current halfedge</span></div>
<div class="line"><span class="lineno"> 9749</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 9750</span>                    <span class="comment">// Note that the source of the processed/&quot;m1&quot; version of the current halfedge is the same as</span></div>
<div class="line"><span class="lineno"> 9751</span>                    <span class="comment">// the target of the processed/&quot;m1&quot; version of the previous halfedge in the current polygon</span></div>
<div class="line"><span class="lineno"> 9752</span>                    <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m1_cs_cur_patch_polygon_he_src = m1_cur_patch_cur_poly_prev_he_tgt; <span class="comment">// known from previous halfedge</span></div>
<div class="line"><span class="lineno"> 9753</span>                    <span class="comment">// This initialization assumes the target of the processed/&quot;m1&quot; version of the current halfedge</span></div>
<div class="line"><span class="lineno"> 9754</span>                    <span class="comment">// is the same descriptor as the unprocessed/&quot;m0&quot; version (this is generally true</span></div>
<div class="line"><span class="lineno"> 9755</span>                    <span class="comment">// when processing non-boundary/border halfedges and the current patch is a normal patch).</span></div>
<div class="line"><span class="lineno"> 9756</span>                    <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m1_cs_cur_patch_polygon_he_tgt = m0_cur_patch_cur_poly_cur_he_tgt;</div>
<div class="line"><span class="lineno"> 9757</span> </div>
<div class="line"><span class="lineno"> 9758</span>                    <span class="comment">// flag whether to insert new edge into &quot;m1_colored&quot;</span></div>
<div class="line"><span class="lineno"> 9759</span>                    <span class="comment">// bool create_new_edge = false;</span></div>
<div class="line"><span class="lineno"> 9760</span> </div>
<div class="line"><span class="lineno"> 9761</span>                    <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m1_cur_patch_cur_poly_cur_he = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno"> 9762</span> </div>
<div class="line"><span class="lineno"> 9763</span>                    <span class="comment">// is the current halfedge the last one to be process in the current polygon?</span></div>
<div class="line"><span class="lineno"> 9764</span>                    <span class="keywordflow">if</span> (cur_is_last_to_be_transformed) {</div>
<div class="line"><span class="lineno"> 9765</span> </div>
<div class="line"><span class="lineno"> 9766</span>                        <span class="comment">// we can infer the updated version of the target vertex from the halfedge</span></div>
<div class="line"><span class="lineno"> 9767</span>                        <span class="comment">// which is already updated. Update tgt will be the source of the first</span></div>
<div class="line"><span class="lineno"> 9768</span>                        <span class="comment">// updated halfedge of the current polygon.</span></div>
<div class="line"><span class="lineno"> 9769</span>                        m1_cs_cur_patch_polygon_he_tgt = m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(m1_poly[0]);</div>
<div class="line"><span class="lineno"> 9770</span> </div>
<div class="line"><span class="lineno"> 9771</span>                        <span class="keywordflow">if</span> (src_is_ivertex &amp;&amp; tgt_is_ivertex) { <span class="comment">// class 3 : // x--&gt;x</span></div>
<div class="line"><span class="lineno"> 9772</span> </div>
<div class="line"><span class="lineno"> 9773</span>                            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9774</span>                            <span class="comment">// we now want to check if the current halfedge is interior or exterior</span></div>
<div class="line"><span class="lineno"> 9775</span>                            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9776</span> </div>
<div class="line"><span class="lineno"> 9777</span>                            <span class="comment">// MCUT_ASSERT(m0_ivtx_to_ps_edge.find(m0.source(m0_cur_patch_cur_poly_cur_he)) != m0_ivtx_to_ps_edge.cend());</span></div>
<div class="line"><span class="lineno"> 9778</span> </div>
<div class="line"><span class="lineno"> 9779</span>                            <span class="comment">// get the ps-halfedge in the intersection-registry entry of src</span></div>
<div class="line"><span class="lineno"> 9780</span>                            <span class="comment">// const hd_t src_coincident_ps_halfedge = SAFE_ACCESS(m0_ivtx_to_ps_edge, m0.source(m0_cur_patch_cur_poly_cur_he));</span></div>
<div class="line"><span class="lineno"> 9781</span> </div>
<div class="line"><span class="lineno"> 9782</span>                            <span class="comment">// MCUT_ASSERT(m0_ivtx_to_ps_edge.find(m0.target(m0_cur_patch_cur_poly_cur_he)) != m0_ivtx_to_ps_edge.cend());</span></div>
<div class="line"><span class="lineno"> 9783</span> </div>
<div class="line"><span class="lineno"> 9784</span>                            <span class="comment">// get the ps-halfedge in the intersection-registry entry of src</span></div>
<div class="line"><span class="lineno"> 9785</span>                            <span class="comment">// const hd_t tgt_ps_h = SAFE_ACCESS(m0_ivtx_to_ps_edge, m0.target(m0_cur_patch_cur_poly_cur_he));</span></div>
<div class="line"><span class="lineno"> 9786</span>                            <span class="comment">// get the ps-edges corresponding to the ps-halfedges</span></div>
<div class="line"><span class="lineno"> 9787</span>                            <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> src_vertex = m0_cur_patch_cur_poly_cur_he_src; <span class="comment">// m0.source(m0_cur_patch_cur_poly_cur_he); // TODO: no need to query m0 [again] (see above)</span></div>
<div class="line"><span class="lineno"> 9788</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)src_vertex - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(src_vertex) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 9789</span>                            <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt;&amp; src_vertex_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, (std::size_t)src_vertex - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 9790</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> src_ps_edge = src_vertex_ipair.first; <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_edge, m0.source(m0_cur_patch_cur_poly_cur_he)); // ps.edge(src_coincident_ps_halfedge);</span></div>
<div class="line"><span class="lineno"> 9791</span> </div>
<div class="line"><span class="lineno"> 9792</span>                            <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> tgt_vertex = m0_cur_patch_cur_poly_cur_he_tgt; <span class="comment">// m0.target(m0_cur_patch_cur_poly_cur_he);</span></div>
<div class="line"><span class="lineno"> 9793</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)tgt_vertex - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(tgt_vertex) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 9794</span>                            <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt;&amp; tgt_vertex_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, (std::size_t)tgt_vertex - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 9795</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> tgt_ps_edge = tgt_vertex_ipair.first; <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_edge, m0.target(m0_cur_patch_cur_poly_cur_he)); // ps.edge(tgt_ps_h);</span></div>
<div class="line"><span class="lineno"> 9796</span> </div>
<div class="line"><span class="lineno"> 9797</span>                            <span class="comment">// is it an interior halfedge</span></div>
<div class="line"><span class="lineno"> 9798</span>                            <span class="keywordtype">bool</span> is_valid_ambiguious_interior_edge = (src_ps_edge != tgt_ps_edge);</div>
<div class="line"><span class="lineno"> 9799</span> </div>
<div class="line"><span class="lineno"> 9800</span>                            <span class="keywordflow">if</span> (is_valid_ambiguious_interior_edge) { <span class="comment">// check is interior ihalfedge (due ambiguity with exterior-interior halfedges x--&gt;x)</span></div>
<div class="line"><span class="lineno"> 9801</span> </div>
<div class="line"><span class="lineno"> 9802</span>                                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_to_m1_ihe.find(m0_cur_patch_cur_poly_cur_he_opp) != m0_to_m1_ihe.cend());</div>
<div class="line"><span class="lineno"> 9803</span> </div>
<div class="line"><span class="lineno"> 9804</span>                                <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m1_cur_patch_cur_poly_cur_he_opp = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_m1_ihe, m0_cur_patch_cur_poly_cur_he_opp);</div>
<div class="line"><span class="lineno"> 9805</span>                                <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m1_cur_patch_cur_poly_cur_he_opp_opp = m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(m1_cur_patch_cur_poly_cur_he_opp);</div>
<div class="line"><span class="lineno"> 9806</span> </div>
<div class="line"><span class="lineno"> 9807</span>                                <span class="comment">// halfedge already exists. it was created during source-mesh partitioning stage earlier</span></div>
<div class="line"><span class="lineno"> 9808</span>                                m1_cur_patch_cur_poly_cur_he = m1_cur_patch_cur_poly_cur_he_opp_opp;</div>
<div class="line"><span class="lineno"> 9809</span> </div>
<div class="line"><span class="lineno"> 9810</span>                                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m1_cur_patch_cur_poly_cur_he) == m1_cs_cur_patch_polygon_he_tgt);</div>
<div class="line"><span class="lineno"> 9811</span>                            }</div>
<div class="line"><span class="lineno"> 9812</span>                        }</div>
<div class="line"><span class="lineno"> 9813</span>                    } <span class="comment">// if (cur_is_last_to_be_transformed) {</span></div>
<div class="line"><span class="lineno"> 9814</span>                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!src_is_ivertex &amp;&amp; tgt_is_ivertex) { <span class="comment">// class 1 : o--&gt;x : this type of halfedge can only be &quot;coming in&quot; i.e. pointing torward source mesh</span></div>
<div class="line"><span class="lineno"> 9815</span>                        <span class="comment">// o--&gt;x</span></div>
<div class="line"><span class="lineno"> 9816</span> </div>
<div class="line"><span class="lineno"> 9817</span>                        <span class="comment">/*</span></div>
<div class="line"><span class="lineno"> 9818</span><span class="comment">                        Steps:</span></div>
<div class="line"><span class="lineno"> 9819</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 9820</span><span class="comment">                        transformed_src = transformed_prev_tgt // always available since cut-mesh polygon updating always starts from a halfedge whose opposite is already updated</span></div>
<div class="line"><span class="lineno"> 9821</span><span class="comment">                        transformed_tgt = untransformed_tgt // assume descriptor will not be updated</span></div>
<div class="line"><span class="lineno"> 9822</span><span class="comment">                        create_new_edge = FALSE // to insert a new edge into halfedge data structure or not</span></div>
<div class="line"><span class="lineno"> 9823</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 9824</span><span class="comment">                        IF &quot;opp&quot; has been transformed // note: if opp is transformed, then polygon coincident to that opp halfedge has been fully updated too since all halfedges of a cut-mesh polygon are transformed before moving onto others.</span></div>
<div class="line"><span class="lineno"> 9825</span><span class="comment">                            transformed_tgt = source of transformed &quot;opp&quot;</span></div>
<div class="line"><span class="lineno"> 9826</span><span class="comment">                        ELSE</span></div>
<div class="line"><span class="lineno"> 9827</span><span class="comment">                            transformed_tgt = source of transformed &quot;next&quot; // note: &quot;next&quot; will always be an interior intersection-halfedge since o--&gt;x ihalfedges are always &quot;incoming&quot; i.e. torward the src-mesh</span></div>
<div class="line"><span class="lineno"> 9828</span><span class="comment">                            create_new_edge = TRUE // because opposite does not exist (in &quot;m1&quot;)</span></div>
<div class="line"><span class="lineno"> 9829</span><span class="comment"></span> </div>
<div class="line"><span class="lineno"> 9830</span><span class="comment">                        IF create_new_edge</span></div>
<div class="line"><span class="lineno"> 9831</span><span class="comment">                            create new edge and use halfedge defined by transformed_src and transformed_tgt</span></div>
<div class="line"><span class="lineno"> 9832</span><span class="comment">                        ELSE</span></div>
<div class="line"><span class="lineno"> 9833</span><span class="comment">                            use halfedge defined by computed transformed_src and transformed_tgt</span></div>
<div class="line"><span class="lineno"> 9834</span><span class="comment">                    */</span></div>
<div class="line"><span class="lineno"> 9835</span> </div>
<div class="line"><span class="lineno"> 9836</span>                        <span class="comment">// check if opposite halfedge of current is updated. (NOTE: searching only through</span></div>
<div class="line"><span class="lineno"> 9837</span>                        <span class="comment">// the polygons of the current patch)</span></div>
<div class="line"><span class="lineno"> 9838</span> </div>
<div class="line"><span class="lineno"> 9839</span>                        <span class="comment">// the updated opposite halfedge in the current patch</span></div>
<div class="line"><span class="lineno"> 9840</span>                        <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m1_cs_cur_patch_polygon_he_opp = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno"> 9841</span>                        <span class="comment">// query instances of the &quot;m1&quot; version of the opposite halfedge</span></div>
<div class="line"><span class="lineno"> 9842</span>                        std::unordered_map&lt;<a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> <span class="comment">/*m0*/</span>, std::map&lt;<span class="keywordtype">int</span> <span class="comment">/*patch idx*/</span>, <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> <span class="comment">/*m1*/</span>&gt;&gt;::const_iterator m0_to_m1_he_instances_find_iter = m0_to_m1_he_instances.find(m0_cur_patch_cur_poly_cur_he_opp);</div>
<div class="line"><span class="lineno"> 9843</span> </div>
<div class="line"><span class="lineno"> 9844</span>                        <span class="comment">// do we have at least one updated copy of the opposite, irrespective of which patch it</span></div>
<div class="line"><span class="lineno"> 9845</span>                        <span class="comment">// belongs to.</span></div>
<div class="line"><span class="lineno"> 9846</span>                        <span class="keywordflow">if</span> (m0_to_m1_he_instances_find_iter != m0_to_m1_he_instances.cend()) {</div>
<div class="line"><span class="lineno"> 9847</span>                            <span class="comment">// now check if there is an updated instance corresponding to the current patch</span></div>
<div class="line"><span class="lineno"> 9848</span>                            std::map&lt;<span class="keywordtype">int</span> <span class="comment">/*initial patch polygon*/</span>, <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> <span class="comment">/*m1*/</span>&gt;::const_iterator m1_he_instances_find_iter = m0_to_m1_he_instances_find_iter-&gt;second.find(cur_patch_idx);</div>
<div class="line"><span class="lineno"> 9849</span>                            <span class="keywordflow">if</span> (m1_he_instances_find_iter != m0_to_m1_he_instances_find_iter-&gt;second.cend()) {</div>
<div class="line"><span class="lineno"> 9850</span>                                <span class="comment">// we have found the already-updated instance of the opposite halfedge</span></div>
<div class="line"><span class="lineno"> 9851</span>                                m1_cs_cur_patch_polygon_he_opp = m1_he_instances_find_iter-&gt;second;</div>
<div class="line"><span class="lineno"> 9852</span>                            }</div>
<div class="line"><span class="lineno"> 9853</span>                        }</div>
<div class="line"><span class="lineno"> 9854</span> </div>
<div class="line"><span class="lineno"> 9855</span>                        <span class="comment">// check if opposite halfedge is transformed</span></div>
<div class="line"><span class="lineno"> 9856</span>                        <span class="keyword">const</span> <span class="keywordtype">bool</span> opp_is_transformed = m1_cs_cur_patch_polygon_he_opp != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno"> 9857</span> </div>
<div class="line"><span class="lineno"> 9858</span>                        <span class="keywordflow">if</span> (opp_is_transformed) {</div>
<div class="line"><span class="lineno"> 9859</span>                            <span class="comment">// infer tgt from opposite</span></div>
<div class="line"><span class="lineno"> 9860</span>                            m1_cs_cur_patch_polygon_he_tgt = m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(m1_cs_cur_patch_polygon_he_opp);</div>
<div class="line"><span class="lineno"> 9861</span>                        } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 9862</span> </div>
<div class="line"><span class="lineno"> 9863</span>                            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9864</span>                            <span class="comment">// the opposite halfedge has not been transformed.</span></div>
<div class="line"><span class="lineno"> 9865</span>                            <span class="comment">// We will deduce the target from the updated &quot;next&quot; halfedge, and</span></div>
<div class="line"><span class="lineno"> 9866</span>                            <span class="comment">// we have to create a new edge</span></div>
<div class="line"><span class="lineno"> 9867</span>                            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9868</span> </div>
<div class="line"><span class="lineno"> 9869</span>                            <span class="comment">// look up the updated &quot;next&quot; by looking forward and finding the coincident source-mesh polygon</span></div>
<div class="line"><span class="lineno"> 9870</span>                            <span class="comment">// and then getting the updated instance of &quot;next&quot;.</span></div>
<div class="line"><span class="lineno"> 9871</span>                            <span class="keyword">const</span> <span class="keywordtype">int</span> m0_next_cs_polygon_he_index = <a class="code hl_function" href="../../d5/d60/utils_8h.html#ad42d4789f60996516823b4b4cfb9c04d">wrap_integer</a>(m0_cur_patch_cur_poly_cur_he_idx + 1, 0, (<span class="keywordtype">int</span>)m0_cur_patch_cur_poly.size() - 1);</div>
<div class="line"><span class="lineno"> 9872</span> </div>
<div class="line"><span class="lineno"> 9873</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_next_cs_polygon_he_index &lt; (<span class="keywordtype">int</span>)m0_cur_patch_cur_poly.size());</div>
<div class="line"><span class="lineno"> 9874</span> </div>
<div class="line"><span class="lineno"> 9875</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m0_cs_next_patch_polygon_he = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_cur_patch_cur_poly, m0_next_cs_polygon_he_index); <span class="comment">// next untransformed</span></div>
<div class="line"><span class="lineno"> 9876</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_cs_next_patch_polygon_he_src = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(m0_cs_next_patch_polygon_he);</div>
<div class="line"><span class="lineno"> 9877</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_cs_next_patch_polygon_he_tgt = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m0_cs_next_patch_polygon_he);</div>
<div class="line"><span class="lineno"> 9878</span> </div>
<div class="line"><span class="lineno"> 9879</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0_cs_next_patch_polygon_he_src, ps_vtx_cnt) &amp;&amp; <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0_cs_next_patch_polygon_he_tgt, ps_vtx_cnt)); <span class="comment">// .. because the current halfedge is &quot;incoming&quot;</span></div>
<div class="line"><span class="lineno"> 9880</span> </div>
<div class="line"><span class="lineno"> 9881</span>                            <span class="comment">// get the &quot;m0&quot; polygons which are traced with the &quot;next&quot; halfedge</span></div>
<div class="line"><span class="lineno"> 9882</span>                            <span class="comment">// const std::vector&lt;int&gt;&amp; m0_poly_he_coincident_polys = SAFE_ACCESS(m0_h_to_ply, m0_cs_next_patch_polygon_he);</span></div>
<div class="line"><span class="lineno"> 9883</span>                            <span class="comment">// get reference to src-mesn polygon which is traced with &quot;next&quot; halfedge</span></div>
<div class="line"><span class="lineno"> 9884</span>                            <span class="comment">// const std::vector&lt;int&gt;::const_iterator find_iter = std::find_if(</span></div>
<div class="line"><span class="lineno"> 9885</span>                            <span class="comment">//    m0_poly_he_coincident_polys.cbegin(),</span></div>
<div class="line"><span class="lineno"> 9886</span>                            <span class="comment">//    m0_poly_he_coincident_polys.cend(),</span></div>
<div class="line"><span class="lineno"> 9887</span>                            <span class="comment">//    [&amp;](const int&amp; e) {</span></div>
<div class="line"><span class="lineno"> 9888</span>                            <span class="comment">//        return (e &lt; traced_sm_polygon_count); // match with src-mesn polygon</span></div>
<div class="line"><span class="lineno"> 9889</span>                            <span class="comment">//    });</span></div>
<div class="line"><span class="lineno"> 9890</span> </div>
<div class="line"><span class="lineno"> 9891</span>                            <span class="comment">// &quot;next&quot; is always incident to a source-mesh polygon</span></div>
<div class="line"><span class="lineno"> 9892</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(std::find_if(</div>
<div class="line"><span class="lineno"> 9893</span>                                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, m0_cs_next_patch_polygon_he).<a class="code hl_function" href="../../dd/d66/namespacelibnest2d_1_1shapelike.html#ae20480bfb433b47626e2e0e9188f8bb8">cbegin</a>(),</div>
<div class="line"><span class="lineno"> 9894</span>                                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, m0_cs_next_patch_polygon_he).<a class="code hl_function" href="../../dd/d66/namespacelibnest2d_1_1shapelike.html#ab0e9f75b95a950d0262d29654d15e123">cend</a>(),</div>
<div class="line"><span class="lineno"> 9895</span>                                            [&amp;](<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; e) {</div>
<div class="line"><span class="lineno"> 9896</span>                                                <span class="keywordflow">return</span> (e &lt; traced_sm_polygon_count); <span class="comment">// match with src-mesn polygon</span></div>
<div class="line"><span class="lineno"> 9897</span>                                            })</div>
<div class="line"><span class="lineno"> 9898</span>                                != <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, m0_cs_next_patch_polygon_he).<a class="code hl_function" href="../../dd/d66/namespacelibnest2d_1_1shapelike.html#ab0e9f75b95a950d0262d29654d15e123">cend</a>());</div>
<div class="line"><span class="lineno"> 9899</span> </div>
<div class="line"><span class="lineno"> 9900</span>                            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9901</span>                            <span class="comment">// At this point, we have found the adjacent connected component which is</span></div>
<div class="line"><span class="lineno"> 9902</span>                            <span class="comment">// the one using m0_cs_next_patch_polygon_he. Therefore, we can directly</span></div>
<div class="line"><span class="lineno"> 9903</span>                            <span class="comment">// determine the connected component by looking up the updated instance</span></div>
<div class="line"><span class="lineno"> 9904</span>                            <span class="comment">// of m0_cs_next_patch_polygon_he_opp since m0_cs_next_patch_polygon_he_opp</span></div>
<div class="line"><span class="lineno"> 9905</span>                            <span class="comment">// is guarranteed to have been updated because it is an interior intersection</span></div>
<div class="line"><span class="lineno"> 9906</span>                            <span class="comment">// halfedge (i.e. its on the cut path).</span></div>
<div class="line"><span class="lineno"> 9907</span>                            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 9908</span>                            <span class="comment">// REMEMBER: exterior patches are stitched to the &quot;upper&quot; source-mesh fragment</span></div>
<div class="line"><span class="lineno"> 9909</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m0_cs_next_patch_polygon_he_opp = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(m0_cs_next_patch_polygon_he);</div>
<div class="line"><span class="lineno"> 9910</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m1_cs_next_patch_polygon_he_opp = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_m1_ihe, m0_cs_next_patch_polygon_he_opp);</div>
<div class="line"><span class="lineno"> 9911</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m1_cs_next_patch_polygon_he_opp_opp = m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(m1_cs_next_patch_polygon_he_opp);</div>
<div class="line"><span class="lineno"> 9912</span> </div>
<div class="line"><span class="lineno"> 9913</span>                            m1_cs_cur_patch_polygon_he_tgt = m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(m1_cs_next_patch_polygon_he_opp_opp);</div>
<div class="line"><span class="lineno"> 9914</span> </div>
<div class="line"><span class="lineno"> 9915</span>                            <span class="comment">// create_new_edge = true; // because opposite has not yet been created</span></div>
<div class="line"><span class="lineno"> 9916</span>                        }</div>
<div class="line"><span class="lineno"> 9917</span>                    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (src_is_ivertex &amp;&amp; tgt_is_ivertex) { <span class="comment">// class 3 : // x--&gt;x</span></div>
<div class="line"><span class="lineno"> 9918</span> </div>
<div class="line"><span class="lineno"> 9919</span>                        <span class="comment">// the current halfedge will either be interior or exterior.</span></div>
<div class="line"><span class="lineno"> 9920</span> </div>
<div class="line"><span class="lineno"> 9921</span>                        <span class="comment">// MCUT_ASSERT(m0_ivtx_to_ps_edge.find(m0.source(m0_cur_patch_cur_poly_cur_he)) != m0_ivtx_to_ps_edge.cend());</span></div>
<div class="line"><span class="lineno"> 9922</span> </div>
<div class="line"><span class="lineno"> 9923</span>                        <span class="comment">// const hd_t src_coincident_ps_halfedge = SAFE_ACCESS(m0_ivtx_to_ps_edge, m0.source(m0_cur_patch_cur_poly_cur_he));</span></div>
<div class="line"><span class="lineno"> 9924</span> </div>
<div class="line"><span class="lineno"> 9925</span>                        <span class="comment">// MCUT_ASSERT(m0_ivtx_to_ps_edge.find(m0.target(m0_cur_patch_cur_poly_cur_he)) != m0_ivtx_to_ps_edge.cend());</span></div>
<div class="line"><span class="lineno"> 9926</span> </div>
<div class="line"><span class="lineno"> 9927</span>                        <span class="comment">// const hd_t tgt_ps_h = SAFE_ACCESS(m0_ivtx_to_ps_edge, m0.target(m0_cur_patch_cur_poly_cur_he));</span></div>
<div class="line"><span class="lineno"> 9928</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> src_vertex = m0_cur_patch_cur_poly_cur_he_src; <span class="comment">// m0.source(m0_cur_patch_cur_poly_cur_he); // TODO: no need to query m0 [again] (see above)</span></div>
<div class="line"><span class="lineno"> 9929</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)src_vertex - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(src_vertex) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 9930</span>                        <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt;&amp; src_vertex_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, (std::size_t)src_vertex - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 9931</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> src_ps_edge = src_vertex_ipair.first; <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_edge, m0.source(m0_cur_patch_cur_poly_cur_he)); // ps.edge(src_coincident_ps_halfedge);</span></div>
<div class="line"><span class="lineno"> 9932</span> </div>
<div class="line"><span class="lineno"> 9933</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> tgt_vertex = m0_cur_patch_cur_poly_cur_he_tgt; <span class="comment">// m0.target(m0_cur_patch_cur_poly_cur_he);</span></div>
<div class="line"><span class="lineno"> 9934</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)tgt_vertex - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(tgt_vertex) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 9935</span>                        <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt;&amp; tgt_vertex_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, (std::size_t)tgt_vertex - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 9936</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> tgt_ps_edge = tgt_vertex_ipair.first;</div>
<div class="line"><span class="lineno"> 9937</span> </div>
<div class="line"><span class="lineno"> 9938</span>                        <span class="comment">// const ed_t src_ps_edge = SAFE_ACCESS(m0_ivtx_to_ps_edge, m0.source(m0_cur_patch_cur_poly_cur_he)); //ps.edge(src_coincident_ps_halfedge);</span></div>
<div class="line"><span class="lineno"> 9939</span>                        <span class="comment">// const ed_t tgt_ps_edge = SAFE_ACCESS(m0_ivtx_to_ps_edge, m0.target(m0_cur_patch_cur_poly_cur_he)); // ps.edge(tgt_ps_h);</span></div>
<div class="line"><span class="lineno"> 9940</span>                        <span class="keywordtype">bool</span> is_valid_ambiguious_interior_edge = (src_ps_edge != tgt_ps_edge);</div>
<div class="line"><span class="lineno"> 9941</span> </div>
<div class="line"><span class="lineno"> 9942</span>                        <span class="comment">// check if current halfedge is interior</span></div>
<div class="line"><span class="lineno"> 9943</span>                        <span class="keywordflow">if</span> (is_valid_ambiguious_interior_edge) {</div>
<div class="line"><span class="lineno"> 9944</span> </div>
<div class="line"><span class="lineno"> 9945</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_to_m1_ihe.find(m0_cur_patch_cur_poly_cur_he_opp) != m0_to_m1_ihe.cend());</div>
<div class="line"><span class="lineno"> 9946</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m1_cur_patch_cur_poly_cur_he_opp = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_m1_ihe, m0_cur_patch_cur_poly_cur_he_opp);</div>
<div class="line"><span class="lineno"> 9947</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m1_cur_patch_cur_poly_cur_he_opp_opp = m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(m1_cur_patch_cur_poly_cur_he_opp);</div>
<div class="line"><span class="lineno"> 9948</span> </div>
<div class="line"><span class="lineno"> 9949</span>                            <span class="comment">// halfedge already exists. it was created during src-mesh partitioning</span></div>
<div class="line"><span class="lineno"> 9950</span>                            m1_cur_patch_cur_poly_cur_he = m1_cur_patch_cur_poly_cur_he_opp_opp;</div>
<div class="line"><span class="lineno"> 9951</span>                            m1_cs_cur_patch_polygon_he_tgt = m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m1_cur_patch_cur_poly_cur_he_opp_opp);</div>
<div class="line"><span class="lineno"> 9952</span>                        } <span class="keywordflow">else</span> { <span class="comment">// its an exterior x--&gt;x halfedge</span></div>
<div class="line"><span class="lineno"> 9953</span> </div>
<div class="line"><span class="lineno"> 9954</span>                            <span class="comment">// look up the transformed &quot;next&quot; by looking finding the</span></div>
<div class="line"><span class="lineno"> 9955</span>                            <span class="comment">// coincident source-mesh polygon and then getting the transformed instance of &quot;next&quot;.</span></div>
<div class="line"><span class="lineno"> 9956</span>                            <span class="keyword">const</span> <span class="keywordtype">int</span> m0_next_cs_polygon_he_index = <a class="code hl_function" href="../../d5/d60/utils_8h.html#ad42d4789f60996516823b4b4cfb9c04d">wrap_integer</a>(m0_cur_patch_cur_poly_cur_he_idx + 1, 0, (<span class="keywordtype">int</span>)m0_cur_patch_cur_poly.size() - 1);</div>
<div class="line"><span class="lineno"> 9957</span> </div>
<div class="line"><span class="lineno"> 9958</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_next_cs_polygon_he_index &lt; (<span class="keywordtype">int</span>)m0_cur_patch_cur_poly.size());</div>
<div class="line"><span class="lineno"> 9959</span> </div>
<div class="line"><span class="lineno"> 9960</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m0_cs_next_patch_polygon_he = m0_cur_patch_cur_poly[m0_next_cs_polygon_he_index]; <span class="comment">// next untransformed</span></div>
<div class="line"><span class="lineno"> 9961</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_cs_next_patch_polygon_he_src = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(m0_cs_next_patch_polygon_he);</div>
<div class="line"><span class="lineno"> 9962</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_cs_next_patch_polygon_he_tgt = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m0_cs_next_patch_polygon_he);</div>
<div class="line"><span class="lineno"> 9963</span> </div>
<div class="line"><span class="lineno"> 9964</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0_cs_next_patch_polygon_he_src, ps_vtx_cnt) &amp;&amp; <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0_cs_next_patch_polygon_he_tgt, ps_vtx_cnt));</div>
<div class="line"><span class="lineno"> 9965</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, m0_cs_next_patch_polygon_he).<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a809275ccd755fb7b88661d952134b14d">size</a>() &gt; 0 <span class="comment">/*m0_h_to_ply.find(m0_cs_next_patch_polygon_he) != m0_h_to_ply.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 9966</span> </div>
<div class="line"><span class="lineno"> 9967</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><span class="lineno"> 9968</span>                            <span class="keyword">const</span> std::vector&lt;int&gt;&amp; m0_poly_he_coincident_polys = m0_h_to_ply[m0_cs_next_patch_polygon_he];</div>
<div class="line"><span class="lineno"> 9969</span>                            <span class="keyword">const</span> std::vector&lt;int&gt;::const_iterator find_iter = std::find_if( <span class="comment">// points to src-mesh polygon</span></div>
<div class="line"><span class="lineno"> 9970</span>                                m0_poly_he_coincident_polys.cbegin(),</div>
<div class="line"><span class="lineno"> 9971</span>                                m0_poly_he_coincident_polys.cend(),</div>
<div class="line"><span class="lineno"> 9972</span>                                [&amp;](<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; e) {</div>
<div class="line"><span class="lineno"> 9973</span>                                    return (e &lt; traced_sm_polygon_count); <span class="comment">// match with source-mesh polygon</span></div>
<div class="line"><span class="lineno"> 9974</span>                                });</div>
<div class="line"><span class="lineno"> 9975</span> </div>
<div class="line"><span class="lineno"> 9976</span>                            <span class="comment">// &quot;next&quot; is always incident to an source-mesh polygon</span></div>
<div class="line"><span class="lineno"> 9977</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(find_iter != m0_poly_he_coincident_polys.cend());</div>
<div class="line"><span class="lineno"> 9978</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 9979</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m0_cs_next_patch_polygon_he_opp = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(m0_cs_next_patch_polygon_he);</div>
<div class="line"><span class="lineno"> 9980</span> </div>
<div class="line"><span class="lineno"> 9981</span>                            <span class="comment">// Note: this is always true, even in the case of scoop cuts. This is because</span></div>
<div class="line"><span class="lineno"> 9982</span>                            <span class="comment">// halfedges along the cut-path are updated before stitching (during source-mesh partitioning)</span></div>
<div class="line"><span class="lineno"> 9983</span>                            <span class="comment">// so we can infer the tgt easily</span></div>
<div class="line"><span class="lineno"> 9984</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, m0_cs_next_patch_polygon_he_opp).<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a809275ccd755fb7b88661d952134b14d">size</a>() &gt; 0 <span class="comment">/*m0_h_to_ply.find(m0_cs_next_patch_polygon_he_opp) != m0_h_to_ply.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 9985</span> </div>
<div class="line"><span class="lineno"> 9986</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m1_cs_next_patch_polygon_he_opp = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_m1_ihe, m0_cs_next_patch_polygon_he_opp);</div>
<div class="line"><span class="lineno"> 9987</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m1_cs_next_patch_polygon_he_opp_opp = m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(m1_cs_next_patch_polygon_he_opp);</div>
<div class="line"><span class="lineno"> 9988</span> </div>
<div class="line"><span class="lineno"> 9989</span>                            m1_cs_cur_patch_polygon_he_tgt = m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(m1_cs_next_patch_polygon_he_opp_opp);</div>
<div class="line"><span class="lineno"> 9990</span>                        }</div>
<div class="line"><span class="lineno"> 9991</span>                    } <span class="keywordflow">else</span> { <span class="comment">// class 0 or 2 i.e. o--&gt;o or x--&gt;o</span></div>
<div class="line"><span class="lineno"> 9992</span> </div>
<div class="line"><span class="lineno"> 9993</span>                        <span class="comment">/*</span></div>
<div class="line"><span class="lineno"> 9994</span><span class="comment">                        In the following steps, our ability to deduce the correct target vertex instance</span></div>
<div class="line"><span class="lineno"> 9995</span><span class="comment">                        by simply checking whether &quot;opp&quot; or &quot;next&quot; is updated before</span></div>
<div class="line"><span class="lineno"> 9996</span><span class="comment">                        duplication is guarranteed to work. This is because we update polygons</span></div>
<div class="line"><span class="lineno"> 9997</span><span class="comment">                        of a patch using BFS (following adjacency) which guarrantees that when</span></div>
<div class="line"><span class="lineno"> 9998</span><span class="comment">                        the condition to create a duplicate vertex is reached, there will have</span></div>
<div class="line"><span class="lineno"> 9999</span><span class="comment">                        been no other halfedge referencing the same vertex that had reached the</span></div>
<div class="line"><span class="lineno">10000</span><span class="comment">                        same condition.</span></div>
<div class="line"><span class="lineno">10001</span><span class="comment"></span> </div>
<div class="line"><span class="lineno">10002</span><span class="comment">                        transformed_src = transformed_prev_tgt // always available because cut-mesh polygon update always starts from a halfedge whose opposite is already updated</span></div>
<div class="line"><span class="lineno">10003</span><span class="comment">                        transformed_tgt = untransformed_tgt</span></div>
<div class="line"><span class="lineno">10004</span><span class="comment">                        create_new_edge = FALSE</span></div>
<div class="line"><span class="lineno">10005</span><span class="comment"></span> </div>
<div class="line"><span class="lineno">10006</span><span class="comment">                        IF opposite patch is transformed</span></div>
<div class="line"><span class="lineno">10007</span><span class="comment">                            1. IF opposite halfedge is transformed</span></div>
<div class="line"><span class="lineno">10008</span><span class="comment">                            2.      infer from opposite halfedge</span></div>
<div class="line"><span class="lineno">10009</span><span class="comment">                            3. ELSE IF next halfedge is transformed</span></div>
<div class="line"><span class="lineno">10010</span><span class="comment">                            4.      infer from next</span></div>
<div class="line"><span class="lineno">10011</span><span class="comment">                            2. ELSE</span></div>
<div class="line"><span class="lineno">10012</span><span class="comment">                                IF an updated halfedge pointing to tgt already exists (i.e. using &quot;halfedges around vertex&quot;)</span></div>
<div class="line"><span class="lineno">10013</span><span class="comment">                                    infer from that halfedge</span></div>
<div class="line"><span class="lineno">10014</span><span class="comment">                                ELSE</span></div>
<div class="line"><span class="lineno">10015</span><span class="comment">                                    create duplicate of untransformed_tgt</span></div>
<div class="line"><span class="lineno">10016</span><span class="comment">                                    transformed_tgt = duplicate of untransformed_tgt</span></div>
<div class="line"><span class="lineno">10017</span><span class="comment">                                    create_new_edge = TRUE // because &quot;opposite&quot; AND &quot;next&quot; halfedge are not updated, so we have create a new connection between vertices</span></div>
<div class="line"><span class="lineno">10018</span><span class="comment">                        ELSE</span></div>
<div class="line"><span class="lineno">10019</span><span class="comment">                                // Do nothing (keep transformed_tgt as it is) because there</span></div>
<div class="line"><span class="lineno">10020</span><span class="comment">                                // is no adjacent halfedge which is updated, and the current</span></div>
<div class="line"><span class="lineno">10021</span><span class="comment">                                // patch gets precedence to use the first/original vertex instances</span></div>
<div class="line"><span class="lineno">10022</span><span class="comment">                    */</span></div>
<div class="line"><span class="lineno">10023</span>                        <span class="keywordflow">if</span> (cur_is_last_to_be_transformed) {</div>
<div class="line"><span class="lineno">10024</span>                            <span class="comment">// initial polygon halfedge which was transformed</span></div>
<div class="line"><span class="lineno">10025</span>                            m1_cs_cur_patch_polygon_he_tgt = m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(m1_poly.front());</div>
<div class="line"><span class="lineno">10026</span>                        } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">10027</span> </div>
<div class="line"><span class="lineno">10028</span>                            <span class="comment">// check opposite patch of current is transformed</span></div>
<div class="line"><span class="lineno">10029</span>                            <span class="keyword">const</span> <span class="keywordtype">bool</span> opposite_patch_is_transformed = !is_ccw_patch; <span class="comment">// ... since ccw patches are always transformed before their cw counterparts</span></div>
<div class="line"><span class="lineno">10030</span> </div>
<div class="line"><span class="lineno">10031</span>                            <span class="keywordflow">if</span> (opposite_patch_is_transformed) <span class="comment">// if true, the current patch is the cw one</span></div>
<div class="line"><span class="lineno">10032</span>                            {</div>
<div class="line"><span class="lineno">10033</span>                                <span class="comment">// check if opposite halfedge of current is transformed. (NOTE: searching</span></div>
<div class="line"><span class="lineno">10034</span>                                <span class="comment">// only through the polygons of the current patch)</span></div>
<div class="line"><span class="lineno">10035</span> </div>
<div class="line"><span class="lineno">10036</span>                                <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m1_cs_cur_patch_polygon_he_opp = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>(); <span class="comment">// transformed instance of opposite</span></div>
<div class="line"><span class="lineno">10037</span>                                std::unordered_map&lt;<a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> <span class="comment">/*m0*/</span>, std::map&lt;<span class="keywordtype">int</span> <span class="comment">/*patch idx*/</span>, <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> <span class="comment">/*m1*/</span>&gt;&gt;::const_iterator m0_to_m1_he_instances_find_iter = m0_to_m1_he_instances.find(m0_cur_patch_cur_poly_cur_he_opp);</div>
<div class="line"><span class="lineno">10038</span> </div>
<div class="line"><span class="lineno">10039</span>                                <span class="keywordflow">if</span> (m0_to_m1_he_instances_find_iter != m0_to_m1_he_instances.cend()) { <span class="comment">// must transformed at least once since opposite patch is transformed</span></div>
<div class="line"><span class="lineno">10040</span> </div>
<div class="line"><span class="lineno">10041</span>                                    std::map&lt;<span class="keywordtype">int</span> <span class="comment">/*initial patch polygon*/</span>, <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> <span class="comment">/*m1*/</span>&gt;::const_iterator m1_he_instances_find_iter = m0_to_m1_he_instances_find_iter-&gt;second.find(cur_patch_idx);</div>
<div class="line"><span class="lineno">10042</span> </div>
<div class="line"><span class="lineno">10043</span>                                    <span class="keywordflow">if</span> (m1_he_instances_find_iter != m0_to_m1_he_instances_find_iter-&gt;second.cend()) {</div>
<div class="line"><span class="lineno">10044</span>                                        m1_cs_cur_patch_polygon_he_opp = m1_he_instances_find_iter-&gt;second;</div>
<div class="line"><span class="lineno">10045</span>                                    }</div>
<div class="line"><span class="lineno">10046</span>                                }</div>
<div class="line"><span class="lineno">10047</span> </div>
<div class="line"><span class="lineno">10048</span>                                <span class="keyword">const</span> <span class="keywordtype">bool</span> opp_is_transformed = m1_cs_cur_patch_polygon_he_opp != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno">10049</span> </div>
<div class="line"><span class="lineno">10050</span>                                <span class="keywordflow">if</span> (opp_is_transformed) {</div>
<div class="line"><span class="lineno">10051</span>                                    m1_cs_cur_patch_polygon_he_tgt = m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(m1_cs_cur_patch_polygon_he_opp);</div>
<div class="line"><span class="lineno">10052</span>                                } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">10053</span> </div>
<div class="line"><span class="lineno">10054</span>                                    <span class="comment">// check if next halfedge of current is transformed.</span></div>
<div class="line"><span class="lineno">10055</span>                                    <span class="keyword">const</span> <span class="keywordtype">int</span> m0_next_cs_polygon_he_index = <a class="code hl_function" href="../../d5/d60/utils_8h.html#ad42d4789f60996516823b4b4cfb9c04d">wrap_integer</a>(m0_cur_patch_cur_poly_cur_he_idx + 1, 0, (<span class="keywordtype">int</span>)m0_cur_patch_cur_poly.size() - 1);</div>
<div class="line"><span class="lineno">10056</span>                                    <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m0_cs_next_patch_polygon_he = m0_cur_patch_cur_poly[m0_next_cs_polygon_he_index]; <span class="comment">// next untransformed</span></div>
<div class="line"><span class="lineno">10057</span>                                    m0_to_m1_he_instances_find_iter = m0_to_m1_he_instances.find(m0_cs_next_patch_polygon_he);</div>
<div class="line"><span class="lineno">10058</span>                                    <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m1_cs_next_patch_polygon_he = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno">10059</span> </div>
<div class="line"><span class="lineno">10060</span>                                    <span class="keywordflow">if</span> (m0_to_m1_he_instances_find_iter != m0_to_m1_he_instances.cend()) { <span class="comment">// must transformed at least once since opposite patch is transformed</span></div>
<div class="line"><span class="lineno">10061</span> </div>
<div class="line"><span class="lineno">10062</span>                                        std::map&lt;int, hd_t&gt;::const_iterator m1_he_instances_find_iter = m0_to_m1_he_instances_find_iter-&gt;second.find(cur_patch_idx);</div>
<div class="line"><span class="lineno">10063</span> </div>
<div class="line"><span class="lineno">10064</span>                                        <span class="keywordflow">if</span> (m1_he_instances_find_iter != m0_to_m1_he_instances_find_iter-&gt;second.cend()) {</div>
<div class="line"><span class="lineno">10065</span>                                            m1_cs_next_patch_polygon_he = m1_he_instances_find_iter-&gt;second;</div>
<div class="line"><span class="lineno">10066</span>                                        }</div>
<div class="line"><span class="lineno">10067</span>                                    }</div>
<div class="line"><span class="lineno">10068</span> </div>
<div class="line"><span class="lineno">10069</span>                                    <span class="keyword">const</span> <span class="keywordtype">bool</span> next_is_transformed = m1_cs_next_patch_polygon_he != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno">10070</span> </div>
<div class="line"><span class="lineno">10071</span>                                    <span class="keywordflow">if</span> (next_is_transformed) {</div>
<div class="line"><span class="lineno">10072</span>                                        m1_cs_cur_patch_polygon_he_tgt = m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(m1_cs_next_patch_polygon_he);</div>
<div class="line"><span class="lineno">10073</span>                                    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">10074</span> </div>
<div class="line"><span class="lineno">10075</span>                                        <span class="comment">//</span></div>
<div class="line"><span class="lineno">10076</span>                                        <span class="comment">// find all transformed halfedges which connect to m0_cur_patch_cur_poly_cur_he_tgt in the current patch</span></div>
<div class="line"><span class="lineno">10077</span>                                        <span class="comment">//</span></div>
<div class="line"><span class="lineno">10078</span> </div>
<div class="line"><span class="lineno">10079</span>                                        <span class="keywordtype">bool</span> found_transformed_neigh_he = <span class="keyword">false</span>; <span class="comment">// any updated halfedge whose m0 instance references m0_cur_patch_cur_poly_cur_he_tgt</span></div>
<div class="line"><span class="lineno">10080</span> </div>
<div class="line"><span class="lineno">10081</span>                                        <span class="comment">/*</span></div>
<div class="line"><span class="lineno">10082</span><span class="comment">                                      1. get &quot;m0&quot; halfedges around vertex</span></div>
<div class="line"><span class="lineno">10083</span><span class="comment">                                      2. for each halfedge around vertex, check if it has a transformed instance that belonging to the current patch</span></div>
<div class="line"><span class="lineno">10084</span><span class="comment">                                    */</span></div>
<div class="line"><span class="lineno">10085</span>                                        <span class="keyword">const</span> std::vector&lt;halfedge_descriptor_t&gt;&amp; m0_incoming_halfedges = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a3ea06ff1ab141d57223eb28cfba1bb26">get_halfedges_around_vertex</a>(m0_cur_patch_cur_poly_cur_he_tgt);</div>
<div class="line"><span class="lineno">10086</span> </div>
<div class="line"><span class="lineno">10087</span>                                        <span class="keywordflow">for</span> (std::vector&lt;halfedge_descriptor_t&gt;::const_iterator m0_incoming_halfedges_iter = m0_incoming_halfedges.cbegin();</div>
<div class="line"><span class="lineno">10088</span>                                             m0_incoming_halfedges_iter != m0_incoming_halfedges.cend();</div>
<div class="line"><span class="lineno">10089</span>                                             ++m0_incoming_halfedges_iter) {</div>
<div class="line"><span class="lineno">10090</span> </div>
<div class="line"><span class="lineno">10091</span>                                            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">halfedge_descriptor_t</a> m0_incoming_halfedge = *m0_incoming_halfedges_iter;</div>
<div class="line"><span class="lineno">10092</span>                                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_incoming_halfedge != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>());</div>
<div class="line"><span class="lineno">10093</span> </div>
<div class="line"><span class="lineno">10094</span>                                            <span class="comment">// is it transformed?</span></div>
<div class="line"><span class="lineno">10095</span>                                            m0_to_m1_he_instances_find_iter = m0_to_m1_he_instances.find(m0_incoming_halfedge);</div>
<div class="line"><span class="lineno">10096</span>                                            <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m1_incoming_halfedge = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno">10097</span> </div>
<div class="line"><span class="lineno">10098</span>                                            <span class="keywordflow">if</span> (m0_to_m1_he_instances_find_iter != m0_to_m1_he_instances.cend()) {</div>
<div class="line"><span class="lineno">10099</span> </div>
<div class="line"><span class="lineno">10100</span>                                                <span class="comment">// get the transformed instance belonging to the current patch</span></div>
<div class="line"><span class="lineno">10101</span>                                                std::map&lt;int, hd_t&gt;::const_iterator m1_he_instances_find_iter = m0_to_m1_he_instances_find_iter-&gt;second.find(cur_patch_idx);</div>
<div class="line"><span class="lineno">10102</span> </div>
<div class="line"><span class="lineno">10103</span>                                                <span class="keywordflow">if</span> (m1_he_instances_find_iter != m0_to_m1_he_instances_find_iter-&gt;second.cend()) {</div>
<div class="line"><span class="lineno">10104</span>                                                    m1_incoming_halfedge = m1_he_instances_find_iter-&gt;second;</div>
<div class="line"><span class="lineno">10105</span> </div>
<div class="line"><span class="lineno">10106</span>                                                    m1_cs_cur_patch_polygon_he_tgt = m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m1_incoming_halfedge);</div>
<div class="line"><span class="lineno">10107</span>                                                    found_transformed_neigh_he = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">10108</span>                                                }</div>
<div class="line"><span class="lineno">10109</span>                                            }</div>
<div class="line"><span class="lineno">10110</span> </div>
<div class="line"><span class="lineno">10111</span>                                            <span class="keywordflow">if</span> (!found_transformed_neigh_he) {</div>
<div class="line"><span class="lineno">10112</span>                                                <span class="comment">// We enter this scope if: &quot;m1_incoming_halfedge&quot; does not exist</span></div>
<div class="line"><span class="lineno">10113</span> </div>
<div class="line"><span class="lineno">10114</span>                                                <span class="comment">// What we are going to try to do now is check if the opposite of &quot;m0_incoming_halfedge&quot; has been transformed (w.r.t the current patch),</span></div>
<div class="line"><span class="lineno">10115</span>                                                <span class="comment">// and if so, we get it transformed instanced from which we deduce the correct value of &quot;m1_cs_cur_patch_polygon_he_tgt&quot;</span></div>
<div class="line"><span class="lineno">10116</span> </div>
<div class="line"><span class="lineno">10117</span>                                                <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">halfedge_descriptor_t</a> m0_incoming_halfedge_opp = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(m0_incoming_halfedge);</div>
<div class="line"><span class="lineno">10118</span>                                                m0_to_m1_he_instances_find_iter = m0_to_m1_he_instances.find(m0_incoming_halfedge);</div>
<div class="line"><span class="lineno">10119</span>                                                <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m1_incoming_halfedge_opp = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>();</div>
<div class="line"><span class="lineno">10120</span> </div>
<div class="line"><span class="lineno">10121</span>                                                <span class="keywordflow">if</span> (m0_to_m1_he_instances_find_iter != m0_to_m1_he_instances.cend()) {</div>
<div class="line"><span class="lineno">10122</span> </div>
<div class="line"><span class="lineno">10123</span>                                                    std::map&lt;int, hd_t&gt;::const_iterator m1_he_instances_find_iter = m0_to_m1_he_instances_find_iter-&gt;second.find(cur_patch_idx);</div>
<div class="line"><span class="lineno">10124</span> </div>
<div class="line"><span class="lineno">10125</span>                                                    <span class="keywordflow">if</span> (m1_he_instances_find_iter != m0_to_m1_he_instances_find_iter-&gt;second.cend()) {</div>
<div class="line"><span class="lineno">10126</span>                                                        m1_incoming_halfedge_opp = m1_he_instances_find_iter-&gt;second;</div>
<div class="line"><span class="lineno">10127</span>                                                        m1_cs_cur_patch_polygon_he_tgt = m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(m1_incoming_halfedge_opp); <span class="comment">// Note: using &quot;m1.source&quot; not &quot;m1.target&quot;</span></div>
<div class="line"><span class="lineno">10128</span>                                                        found_transformed_neigh_he = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">10129</span>                                                    }</div>
<div class="line"><span class="lineno">10130</span>                                                }</div>
<div class="line"><span class="lineno">10131</span>                                            }</div>
<div class="line"><span class="lineno">10132</span> </div>
<div class="line"><span class="lineno">10133</span>                                            <span class="keywordflow">if</span> (found_transformed_neigh_he) {</div>
<div class="line"><span class="lineno">10134</span>                                                <span class="keywordflow">break</span>; <span class="comment">// done</span></div>
<div class="line"><span class="lineno">10135</span>                                            }</div>
<div class="line"><span class="lineno">10136</span>                                        }</div>
<div class="line"><span class="lineno">10137</span> </div>
<div class="line"><span class="lineno">10138</span>                                        <span class="keywordflow">if</span> (!found_transformed_neigh_he) {</div>
<div class="line"><span class="lineno">10139</span>                                            <span class="comment">//</span></div>
<div class="line"><span class="lineno">10140</span>                                            <span class="comment">// none of the adjacent halfedges have been transformed, so we must duplicate m0_cur_patch_cur_poly_cur_he_tgt</span></div>
<div class="line"><span class="lineno">10141</span>                                            <span class="comment">//</span></div>
<div class="line"><span class="lineno">10142</span> </div>
<div class="line"><span class="lineno">10143</span>                                            <span class="comment">// is &quot;m1_cs_cur_patch_polygon_he_tgt&quot; a vertex we can duplicate? (partial cut, interior sealing)</span></div>
<div class="line"><span class="lineno">10144</span>                                            <span class="comment">// TODO: std::sort(sm_interior_cs_border_vertices) and then we can use binary search</span></div>
<div class="line"><span class="lineno">10145</span>                                            <span class="keyword">const</span> <span class="keywordtype">bool</span> is_sm_interior_cs_boundary_vertex = std::find(sm_interior_cs_border_vertices.cbegin(), sm_interior_cs_border_vertices.cend(), m0_cur_patch_cur_poly_cur_he_tgt) != sm_interior_cs_border_vertices.cend();</div>
<div class="line"><span class="lineno">10146</span> </div>
<div class="line"><span class="lineno">10147</span>                                            <span class="keywordflow">if</span> (!is_sm_interior_cs_boundary_vertex) {</div>
<div class="line"><span class="lineno">10148</span> </div>
<div class="line"><span class="lineno">10149</span>                                                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_poly_he_tgt_dupl = m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a0d2a1a79406b7352af07d4fc56707782">add_vertex</a>(m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(m0_cur_patch_cur_poly_cur_he_tgt));</div>
<div class="line"><span class="lineno">10150</span> </div>
<div class="line"><span class="lineno">10151</span>                                                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_poly_he_tgt_dupl != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>());</div>
<div class="line"><span class="lineno">10152</span> </div>
<div class="line"><span class="lineno">10153</span>                                                m1_cs_cur_patch_polygon_he_tgt = m0_poly_he_tgt_dupl;</div>
<div class="line"><span class="lineno">10154</span>                                                <span class="comment">// create_new_edge = true;</span></div>
<div class="line"><span class="lineno">10155</span>                                            }</div>
<div class="line"><span class="lineno">10156</span>                                        }</div>
<div class="line"><span class="lineno">10157</span>                                    } <span class="comment">// if (next_is_transformed) {</span></div>
<div class="line"><span class="lineno">10158</span>                                } <span class="comment">// if (opp_is_transformed) {</span></div>
<div class="line"><span class="lineno">10159</span>                            } <span class="comment">// if (opposite_patch_is_transformed)</span></div>
<div class="line"><span class="lineno">10160</span>                        } <span class="comment">// if (cur_is_last_to_be_transformed) {</span></div>
<div class="line"><span class="lineno">10161</span>                    } <span class="comment">// class 0 or 2 i.e. o--&gt;o or x--&gt;o</span></div>
<div class="line"><span class="lineno">10162</span> </div>
<div class="line"><span class="lineno">10163</span>                    <span class="comment">// if we could not infer from any pre-existing halfedge</span></div>
<div class="line"><span class="lineno">10164</span>                    <span class="keywordflow">if</span> (m1_cur_patch_cur_poly_cur_he == <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>()) {</div>
<div class="line"><span class="lineno">10165</span>                        <span class="comment">// check if edge exists</span></div>
<div class="line"><span class="lineno">10166</span>                        <span class="comment">// TODO: use mesh built &quot;halfedge(...)&quot; (may require minor update to function)</span></div>
<div class="line"><span class="lineno">10167</span>                        <span class="comment">// ed_t e = get_computed_edge(/*m1_colored, */ m1_cs_cur_patch_polygon_he_src, m1_cs_cur_patch_polygon_he_tgt);</span></div>
<div class="line"><span class="lineno">10168</span>                        <span class="comment">// hd_t h = m1_colored.halfedge(m1_cs_cur_patch_polygon_he_src, m1_cs_cur_patch_polygon_he_tgt);</span></div>
<div class="line"><span class="lineno">10169</span>                        <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> e = m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a96e9db918396b86f0b61f5445ef46b18">edge</a>(m1_cs_cur_patch_polygon_he_src, m1_cs_cur_patch_polygon_he_tgt, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno">10170</span> </div>
<div class="line"><span class="lineno">10171</span>                        <span class="keywordflow">if</span> (e != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aabb2a87d3b736883d381532fb871389e">hmesh_t::null_edge</a>()) { <span class="comment">// if edge already exists</span></div>
<div class="line"><span class="lineno">10172</span> </div>
<div class="line"><span class="lineno">10173</span>                            <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h0 = m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(e, 0);</div>
<div class="line"><span class="lineno">10174</span> </div>
<div class="line"><span class="lineno">10175</span>                            <span class="keywordflow">if</span> (m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(h0) == m1_cs_cur_patch_polygon_he_src) {</div>
<div class="line"><span class="lineno">10176</span>                                m1_cur_patch_cur_poly_cur_he = h0;</div>
<div class="line"><span class="lineno">10177</span>                            } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">10178</span>                                <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h1 = m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(e, 1);</div>
<div class="line"><span class="lineno">10179</span>                                m1_cur_patch_cur_poly_cur_he = h1;</div>
<div class="line"><span class="lineno">10180</span>                            }</div>
<div class="line"><span class="lineno">10181</span>                        } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">10182</span> </div>
<div class="line"><span class="lineno">10183</span>                            m1_cur_patch_cur_poly_cur_he = m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ae64649dd61e0c188c547c686abc8a19e">add_edge</a>(m1_cs_cur_patch_polygon_he_src, m1_cs_cur_patch_polygon_he_tgt);</div>
<div class="line"><span class="lineno">10184</span>                            <span class="comment">// TODO:replace with map (for O(Log N) searches)</span></div>
<div class="line"><span class="lineno">10185</span>                            <span class="comment">// m1_computed_edges.push_back(m1_colored.edge(m1_cur_patch_cur_poly_cur_he));</span></div>
<div class="line"><span class="lineno">10186</span>                            <span class="comment">// std::map&lt;vd_t, std::vector&lt;std::pair&lt;vd_t, ed_t&gt;&gt;&gt;</span></div>
<div class="line"><span class="lineno">10187</span> </div>
<div class="line"><span class="lineno">10188</span>                            <span class="comment">// ed_t new_edge = m1_colored.edge(m1_cur_patch_cur_poly_cur_he);</span></div>
<div class="line"><span class="lineno">10189</span>                            <span class="comment">// m1_computed_edges[m1_cs_cur_patch_polygon_he_src].push_back(std::make_pair(m1_cs_cur_patch_polygon_he_tgt, new_edge));</span></div>
<div class="line"><span class="lineno">10190</span>                            <span class="comment">// m1_computed_edges[m1_cs_cur_patch_polygon_he_tgt].push_back(std::make_pair(m1_cs_cur_patch_polygon_he_src, new_edge));</span></div>
<div class="line"><span class="lineno">10191</span>                        }</div>
<div class="line"><span class="lineno">10192</span>                    } <span class="comment">// if (m1_cur_patch_cur_poly_cur_he == hmesh_t::null_halfedge()) {</span></div>
<div class="line"><span class="lineno">10193</span> </div>
<div class="line"><span class="lineno">10194</span>                    <span class="comment">//  &lt;&lt; m1_colored.source(m1_cur_patch_cur_poly_cur_he) &lt;&lt; &quot; &quot; &lt;&lt; m1_colored.target(m1_cur_patch_cur_poly_cur_he) &lt;&lt; &quot;&gt;&quot; &lt;&lt; std::endl;);</span></div>
<div class="line"><span class="lineno">10195</span> </div>
<div class="line"><span class="lineno">10196</span>                    <span class="comment">// halfedge must have been found (created or inferred)</span></div>
<div class="line"><span class="lineno">10197</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m1_cur_patch_cur_poly_cur_he != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>());</div>
<div class="line"><span class="lineno">10198</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m1_poly.back()) == m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(m1_cur_patch_cur_poly_cur_he));</div>
<div class="line"><span class="lineno">10199</span> </div>
<div class="line"><span class="lineno">10200</span>                    <span class="comment">// add transformed halfedge to currently transformed polygon</span></div>
<div class="line"><span class="lineno">10201</span>                    m1_poly.push_back(m1_cur_patch_cur_poly_cur_he);</div>
<div class="line"><span class="lineno">10202</span> </div>
<div class="line"><span class="lineno">10203</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno">10204</span>                    <span class="comment">// map halfedge to transformed instance of current patch</span></div>
<div class="line"><span class="lineno">10205</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno">10206</span> </div>
<div class="line"><span class="lineno">10207</span>                    <span class="comment">// NOTE: m0_cur_patch_cur_poly_cur_he will not exist if current patch has CCW orientation</span></div>
<div class="line"><span class="lineno">10208</span>                    <span class="comment">// since such a patch will always be transformed first before its CW counterpart.</span></div>
<div class="line"><span class="lineno">10209</span>                    std::unordered_map&lt;hd_t, std::map&lt;int, hd_t&gt;&gt;::iterator m0_to_m1_he_instances_find_iter = m0_to_m1_he_instances.find(m0_cur_patch_cur_poly_cur_he);</div>
<div class="line"><span class="lineno">10210</span> </div>
<div class="line"><span class="lineno">10211</span>                    <span class="keywordflow">if</span> (m0_to_m1_he_instances_find_iter == m0_to_m1_he_instances.end()) { <span class="comment">// not yet transformed at all (i.e. m0_cur_patch_cur_poly_cur_he belongs to CCW polygon )</span></div>
<div class="line"><span class="lineno">10212</span> </div>
<div class="line"><span class="lineno">10213</span>                        std::pair&lt;std::unordered_map&lt;<a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> <span class="comment">/*m0*/</span>, std::map&lt;<span class="keywordtype">int</span> <span class="comment">/*initial patch polygon*/</span>, <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> <span class="comment">/*m1*/</span>&gt;&gt;::iterator, <span class="keywordtype">bool</span>&gt; <a class="code hl_struct" href="../../df/de8/structpair.html">pair</a> = m0_to_m1_he_instances.insert(std::make_pair(m0_cur_patch_cur_poly_cur_he, std::map&lt;int, hd_t&gt;()));</div>
<div class="line"><span class="lineno">10214</span> </div>
<div class="line"><span class="lineno">10215</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(<a class="code hl_struct" href="../../df/de8/structpair.html">pair</a>.second == <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno">10216</span> </div>
<div class="line"><span class="lineno">10217</span>                        m0_to_m1_he_instances_find_iter = <a class="code hl_struct" href="../../df/de8/structpair.html">pair</a>.first;</div>
<div class="line"><span class="lineno">10218</span>                    }</div>
<div class="line"><span class="lineno">10219</span> </div>
<div class="line"><span class="lineno">10220</span>                    <span class="comment">// stores the an &quot;m1&quot; instance of the current halfedge, for each patch</span></div>
<div class="line"><span class="lineno">10221</span>                    std::map&lt;<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>, <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> <span class="comment">/*m1*/</span>&gt;&amp; patch_to_m1_he = m0_to_m1_he_instances_find_iter-&gt;second;</div>
<div class="line"><span class="lineno">10222</span>                    <span class="comment">// const std::map&lt;int, hd_t /*m1*/&gt;::const_iterator patch_idx_to_m1_he = patch_to_m1_he.find(cur_patch_idx);</span></div>
<div class="line"><span class="lineno">10223</span> </div>
<div class="line"><span class="lineno">10224</span>                    <span class="comment">// In general, a halfedge may only be transformed once for each patch it is be associated</span></div>
<div class="line"><span class="lineno">10225</span>                    <span class="comment">// with (i.e it will have two copies with one for each opposing patch). Note however that</span></div>
<div class="line"><span class="lineno">10226</span>                    <span class="comment">// in the case that the current halfedge is a border halfedge (partial cut), its transformed</span></div>
<div class="line"><span class="lineno">10227</span>                    <span class="comment">// copy is the same as its untransformed copy for each patch</span></div>
<div class="line"><span class="lineno">10228</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(patch_to_m1_he.find(cur_patch_idx) == patch_to_m1_he.cend());</div>
<div class="line"><span class="lineno">10229</span> </div>
<div class="line"><span class="lineno">10230</span>                    patch_to_m1_he.insert(std::make_pair(cur_patch_idx, m1_cur_patch_cur_poly_cur_he));</div>
<div class="line"><span class="lineno">10231</span>                    transformed_he_counter += 1; <span class="comment">// next halfedge in m0_cur_patch_cur_poly</span></div>
<div class="line"><span class="lineno">10232</span> </div>
<div class="line"><span class="lineno">10233</span>                } <span class="keywordflow">while</span> (transformed_he_counter != (<span class="keywordtype">int</span>)m0_cur_patch_cur_poly.size()); <span class="comment">// while not all halfedges of the current polygon have been transformed.</span></div>
<div class="line"><span class="lineno">10234</span> </div>
<div class="line"><span class="lineno">10235</span>                <span class="comment">//</span></div>
<div class="line"><span class="lineno">10236</span>                <span class="comment">// at this stage, all halfedges of the current polygon have been transformed</span></div>
<div class="line"><span class="lineno">10237</span>                <span class="comment">//</span></div>
<div class="line"><span class="lineno">10238</span> </div>
<div class="line"><span class="lineno">10239</span>                <span class="comment">// ... remove the stitching-initialiation data of current polygon.</span></div>
<div class="line"><span class="lineno">10240</span>                patch_poly_stitching_queue.pop_front();</div>
<div class="line"><span class="lineno">10241</span> </div>
<div class="line"><span class="lineno">10243</span>                <span class="comment">// find untransformed neighbouring polygons and queue them</span></div>
<div class="line"><span class="lineno">10245</span><span class="comment"></span> </div>
<div class="line"><span class="lineno">10246</span>                <span class="comment">//</span></div>
<div class="line"><span class="lineno">10247</span>                <span class="comment">// We are basically adding all unstitched neighbours of the current polygon</span></div>
<div class="line"><span class="lineno">10248</span>                <span class="comment">// (that we just sticthed) to the queue so they can be stitched as well. These</span></div>
<div class="line"><span class="lineno">10249</span>                <span class="comment">// are polygons on the same patch as the current polygon and are adjacent to</span></div>
<div class="line"><span class="lineno">10250</span>                <span class="comment">// it i.e. they share an edge.</span></div>
<div class="line"><span class="lineno">10251</span>                <span class="comment">//</span></div>
<div class="line"><span class="lineno">10252</span> </div>
<div class="line"><span class="lineno">10253</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(patches.find(cur_patch_idx) != patches.cend());</div>
<div class="line"><span class="lineno">10254</span> </div>
<div class="line"><span class="lineno">10255</span>                <span class="comment">// polygons of current patch</span></div>
<div class="line"><span class="lineno">10256</span>                <span class="comment">// const std::vector&lt;int&gt;&amp; patch_polys = SAFE_ACCESS(patches, cur_patch_idx);</span></div>
<div class="line"><span class="lineno">10257</span> </div>
<div class="line"><span class="lineno">10258</span>                <span class="comment">// stores the queued adjacent polygon to be stitched that have just been discovered</span></div>
<div class="line"><span class="lineno">10259</span>                <span class="comment">// i.e. discovered while finding the next untransformed adjacent polygons of the</span></div>
<div class="line"><span class="lineno">10260</span>                <span class="comment">// current one that we just transformed</span></div>
<div class="line"><span class="lineno">10261</span>                std::deque&lt;std::tuple&lt;<a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> <span class="comment">/*m1*/</span>, <span class="keywordtype">int</span> <span class="comment">/*m0 poly*/</span>, <span class="keywordtype">int</span> <span class="comment">/*m0 he*/</span>&gt;&gt; patch_poly_stitching_queue_tmp;</div>
<div class="line"><span class="lineno">10262</span> </div>
<div class="line"><span class="lineno">10263</span>                <span class="comment">// for each halfedge of the polygon we just stitched</span></div>
<div class="line"><span class="lineno">10264</span>                <span class="keywordflow">for</span> (traced_polygon_t::const_iterator m0_poly_he_iter = m0_cur_patch_cur_poly.cbegin();</div>
<div class="line"><span class="lineno">10265</span>                     m0_poly_he_iter != m0_cur_patch_cur_poly.cend();</div>
<div class="line"><span class="lineno">10266</span>                     ++m0_poly_he_iter) {</div>
<div class="line"><span class="lineno">10267</span> </div>
<div class="line"><span class="lineno">10268</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m0_cur_patch_cur_poly_cur_he = *m0_poly_he_iter;</div>
<div class="line"><span class="lineno">10269</span> </div>
<div class="line"><span class="lineno">10270</span>                    <span class="comment">// Skip certain neighbours. The adjacent polygon has been processed (assuming</span></div>
<div class="line"><span class="lineno">10271</span>                    <span class="comment">// it exists) if the following conditions are true. Theses conditions are</span></div>
<div class="line"><span class="lineno">10272</span>                    <span class="comment">// evaluated on &quot;m0_cur_patch_cur_poly_cur_he&quot;</span></div>
<div class="line"><span class="lineno">10273</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno">10274</span>                    <span class="comment">// 1. is same as initial halfedge</span></div>
<div class="line"><span class="lineno">10275</span>                    <span class="comment">//      implies that opposite is already transformed (before the current polygon,</span></div>
<div class="line"><span class="lineno">10276</span>                    <span class="comment">//      we transformed the polygon which is traced by the opposite halfedge of</span></div>
<div class="line"><span class="lineno">10277</span>                    <span class="comment">//      m0_cur_patch_cur_poly_1st_he)</span></div>
<div class="line"><span class="lineno">10278</span>                    <span class="comment">// 2. is interior intersection-halfedge</span></div>
<div class="line"><span class="lineno">10279</span>                    <span class="comment">//      opposite is already transformed since interior intersection-halfedges</span></div>
<div class="line"><span class="lineno">10280</span>                    <span class="comment">//      are on cut-path (the opposite halfedge is incident to one of the</span></div>
<div class="line"><span class="lineno">10281</span>                    <span class="comment">//      src-mesh connected components)</span></div>
<div class="line"><span class="lineno">10282</span>                    <span class="comment">// 3. is a halfedge whose opposite has been transformed</span></div>
<div class="line"><span class="lineno">10283</span>                    <span class="comment">//      because that implies that its polygon has been transformed (so no need</span></div>
<div class="line"><span class="lineno">10284</span>                    <span class="comment">//      to add to queue).</span></div>
<div class="line"><span class="lineno">10285</span>                    <span class="comment">// 4. it is a border halfedge</span></div>
<div class="line"><span class="lineno">10286</span>                    <span class="comment">//      (i.e. the only face incident to the opposite halfedge is another which</span></div>
<div class="line"><span class="lineno">10287</span>                    <span class="comment">//      belong to the opposite patch)</span></div>
<div class="line"><span class="lineno">10288</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno">10289</span> </div>
<div class="line"><span class="lineno">10290</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno">10291</span>                    <span class="comment">// case 1</span></div>
<div class="line"><span class="lineno">10292</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno">10293</span>                    <span class="keywordflow">if</span> (m0_cur_patch_cur_poly_cur_he == m0_cur_patch_cur_poly_1st_he) {</div>
<div class="line"><span class="lineno">10294</span>                        <span class="keywordflow">continue</span>; <span class="comment">// 1</span></div>
<div class="line"><span class="lineno">10295</span>                    }</div>
<div class="line"><span class="lineno">10296</span> </div>
<div class="line"><span class="lineno">10297</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno">10298</span>                    <span class="comment">// case 2</span></div>
<div class="line"><span class="lineno">10299</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno">10300</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_cur_patch_cur_poly_cur_he_src = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(m0_cur_patch_cur_poly_cur_he);</div>
<div class="line"><span class="lineno">10301</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_cur_patch_cur_poly_cur_he_tgt = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m0_cur_patch_cur_poly_cur_he);</div>
<div class="line"><span class="lineno">10302</span>                    <span class="keywordtype">bool</span> is_ambiguious_interior_edge_case = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0_cur_patch_cur_poly_cur_he_src, ps_vtx_cnt) &amp;&amp; <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0_cur_patch_cur_poly_cur_he_tgt, ps_vtx_cnt);</div>
<div class="line"><span class="lineno">10303</span> </div>
<div class="line"><span class="lineno">10304</span>                    <span class="keywordflow">if</span> (is_ambiguious_interior_edge_case) {</div>
<div class="line"><span class="lineno">10305</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)m0_cur_patch_cur_poly_cur_he_src - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(m0_cur_patch_cur_poly_cur_he_src) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno">10306</span> </div>
<div class="line"><span class="lineno">10307</span>                        <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt;&amp; m0_cur_patch_cur_poly_cur_he_src_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, (std::size_t)m0_cur_patch_cur_poly_cur_he_src - ps_vtx_cnt);</div>
<div class="line"><span class="lineno">10308</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> src_ps_edge = m0_cur_patch_cur_poly_cur_he_src_ipair.first; <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_edge, m0_cur_patch_cur_poly_cur_he_src); //ps.edge(src_coincident_ps_halfedge);</span></div>
<div class="line"><span class="lineno">10309</span> </div>
<div class="line"><span class="lineno">10310</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)m0_cur_patch_cur_poly_cur_he_tgt - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(m0_cur_patch_cur_poly_cur_he_tgt) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno">10311</span>                        <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt;&amp; m0_cur_patch_cur_poly_cur_he_tgt_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, (std::size_t)m0_cur_patch_cur_poly_cur_he_tgt - ps_vtx_cnt);</div>
<div class="line"><span class="lineno">10312</span> </div>
<div class="line"><span class="lineno">10313</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> tgt_ps_edge = m0_cur_patch_cur_poly_cur_he_tgt_ipair.first; <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_edge, m0_cur_patch_cur_poly_cur_he_tgt); //ps.edge(tgt_ps_h);</span></div>
<div class="line"><span class="lineno">10314</span> </div>
<div class="line"><span class="lineno">10315</span>                        <span class="keywordtype">bool</span> is_valid_ambiguious_interior_edge = (src_ps_edge != tgt_ps_edge);</div>
<div class="line"><span class="lineno">10316</span> </div>
<div class="line"><span class="lineno">10317</span>                        <span class="keywordflow">if</span> (is_valid_ambiguious_interior_edge) {</div>
<div class="line"><span class="lineno">10318</span>                            <span class="keywordflow">continue</span>; <span class="comment">// 2</span></div>
<div class="line"><span class="lineno">10319</span>                        }</div>
<div class="line"><span class="lineno">10320</span>                    }</div>
<div class="line"><span class="lineno">10321</span> </div>
<div class="line"><span class="lineno">10322</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno">10323</span>                    <span class="comment">// case 3</span></div>
<div class="line"><span class="lineno">10324</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno">10325</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m0_cur_patch_cur_poly_cur_he_opp = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(m0_cur_patch_cur_poly_cur_he);</div>
<div class="line"><span class="lineno">10326</span>                    std::unordered_map&lt;hd_t, std::map&lt;int, hd_t&gt;&gt;::const_iterator m0_to_m1_he_instances_find_iter = m0_to_m1_he_instances.find(m0_cur_patch_cur_poly_cur_he_opp); <span class="comment">// value will not exist if current patch positive</span></div>
<div class="line"><span class="lineno">10327</span> </div>
<div class="line"><span class="lineno">10328</span>                    <span class="keywordflow">if</span> (m0_to_m1_he_instances_find_iter != m0_to_m1_he_instances.cend()) { <span class="comment">// check exists (i.e. m0_cur_patch_cur_poly_cur_he_opp has be transform but we dont know for which patch it has been transformed (CCW or CW)</span></div>
<div class="line"><span class="lineno">10329</span> </div>
<div class="line"><span class="lineno">10330</span>                        <span class="keyword">const</span> std::map&lt;int, hd_t&gt;&amp; patch_to_m1_he = m0_to_m1_he_instances_find_iter-&gt;second;</div>
<div class="line"><span class="lineno">10331</span>                        std::map&lt;int, hd_t&gt;::const_iterator patch_idx_to_m1_he = patch_to_m1_he.find(cur_patch_idx);</div>
<div class="line"><span class="lineno">10332</span> </div>
<div class="line"><span class="lineno">10333</span>                        <span class="keywordflow">if</span> (patch_idx_to_m1_he != patch_to_m1_he.cend()) { <span class="comment">// check is stitched</span></div>
<div class="line"><span class="lineno">10334</span>                            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(patch_idx_to_m1_he-&gt;second != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a>());</div>
<div class="line"><span class="lineno">10335</span>                            <span class="keywordflow">continue</span>; <span class="comment">// 3</span></div>
<div class="line"><span class="lineno">10336</span>                        }</div>
<div class="line"><span class="lineno">10337</span>                    }</div>
<div class="line"><span class="lineno">10338</span> </div>
<div class="line"><span class="lineno">10339</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno">10340</span>                    <span class="comment">// case 4</span></div>
<div class="line"><span class="lineno">10341</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno">10342</span> </div>
<div class="line"><span class="lineno">10343</span>                    <span class="comment">// must exist because m0_cur_patch_cur_poly_cur_he was just transformed</span></div>
<div class="line"><span class="lineno">10344</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_to_m1_he_instances.find(m0_cur_patch_cur_poly_cur_he) != m0_to_m1_he_instances.cend());</div>
<div class="line"><span class="lineno">10345</span> </div>
<div class="line"><span class="lineno">10346</span>                    <span class="comment">// find m1_cur_polygon_he which is the transformed instance of m0_cur_patch_cur_poly_cur_he</span></div>
<div class="line"><span class="lineno">10347</span>                    <span class="comment">/*const*/</span> std::map&lt;int, hd_t&gt;&amp; patch_to_m1_he = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_m1_he_instances, m0_cur_patch_cur_poly_cur_he);</div>
<div class="line"><span class="lineno">10348</span> </div>
<div class="line"><span class="lineno">10349</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(patch_to_m1_he.find(cur_patch_idx) != patch_to_m1_he.cend());</div>
<div class="line"><span class="lineno">10350</span> </div>
<div class="line"><span class="lineno">10351</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m1_cur_polygon_he = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patch_to_m1_he, cur_patch_idx);</div>
<div class="line"><span class="lineno">10352</span>                    <span class="comment">// transformed halfedge used by adjacent polygon</span></div>
<div class="line"><span class="lineno">10353</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> m1_next_poly_seed_he = m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(m1_cur_polygon_he);</div>
<div class="line"><span class="lineno">10354</span> </div>
<div class="line"><span class="lineno">10355</span>                    <span class="comment">// infer the index of the next stitched polygon which is traced with m0_cur_patch_cur_poly_cur_he_opp</span></div>
<div class="line"><span class="lineno">10356</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, m0_cur_patch_cur_poly_cur_he_opp).<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a809275ccd755fb7b88661d952134b14d">size</a>() &gt; 0 <span class="comment">/*m0_h_to_ply.find(m0_cur_patch_cur_poly_cur_he_opp) != m0_h_to_ply.cend()*/</span>);</div>
<div class="line"><span class="lineno">10357</span> </div>
<div class="line"><span class="lineno">10358</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno">10359</span>                    <span class="comment">// find the adjacent polygon in the current patch using the opposite of the</span></div>
<div class="line"><span class="lineno">10360</span>                    <span class="comment">// current halfedge</span></div>
<div class="line"><span class="lineno">10361</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno">10362</span> </div>
<div class="line"><span class="lineno">10363</span>                    <span class="comment">// get the polygons traced with the opposite halfedge</span></div>
<div class="line"><span class="lineno">10364</span>                    <span class="keyword">const</span> std::vector&lt;int&gt; m0_poly_he_opp_coincident_polys = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, m0_cur_patch_cur_poly_cur_he_opp);</div>
<div class="line"><span class="lineno">10365</span>                    <span class="keyword">const</span> std::vector&lt;int&gt;::const_iterator find_iter = std::find_if( <span class="comment">// find the current polygon of current patch</span></div>
<div class="line"><span class="lineno">10366</span>                        m0_poly_he_opp_coincident_polys.cbegin(),</div>
<div class="line"><span class="lineno">10367</span>                        m0_poly_he_opp_coincident_polys.cend(),</div>
<div class="line"><span class="lineno">10368</span>                        [&amp;](<span class="keyword">const</span> <span class="keywordtype">int</span> poly_idx) {</div>
<div class="line"><span class="lineno">10369</span>                            MCUT_ASSERT(m0_cm_poly_to_patch_idx.count(poly_idx) == 1);</div>
<div class="line"><span class="lineno">10370</span>                            <span class="comment">// return SAFE_ACCESS(m0_cm_poly_to_patch_idx, poly_idx) == cur_patch_idx;</span></div>
<div class="line"><span class="lineno">10371</span> </div>
<div class="line"><span class="lineno">10372</span>                            bool has_patch_winding_orientation = false;</div>
<div class="line"><span class="lineno">10373</span> </div>
<div class="line"><span class="lineno">10374</span>                            <span class="comment">// check if polygon has the same winding order as the current patch</span></div>
<div class="line"><span class="lineno">10375</span> </div>
<div class="line"><span class="lineno">10376</span>                            if (is_ccw_patch) { <span class="comment">// is the current patch a &quot;normal&quot; patch?</span></div>
<div class="line"><span class="lineno">10377</span>                                has_patch_winding_orientation = (poly_idx &lt; traced_polygon_count);</div>
<div class="line"><span class="lineno">10378</span>                            } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">10379</span>                                has_patch_winding_orientation = (poly_idx &gt;= traced_polygon_count);</div>
<div class="line"><span class="lineno">10380</span>                            }</div>
<div class="line"><span class="lineno">10381</span> </div>
<div class="line"><span class="lineno">10382</span>                            <span class="keywordflow">return</span> has_patch_winding_orientation &amp;&amp; <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_cm_poly_to_patch_idx, poly_idx) == cur_patch_idx; <span class="comment">// std::find(patch_polys.cbegin(), patch_polys.cend(), poly_idx) != patch_polys.cend(); // NOTE: only one polygon in the current patch will match</span></div>
<div class="line"><span class="lineno">10383</span>                        });</div>
<div class="line"><span class="lineno">10384</span> </div>
<div class="line"><span class="lineno">10385</span>                    <span class="comment">// note: if the current halfedge is on the border of the cut-mesh, then its opposite</span></div>
<div class="line"><span class="lineno">10386</span>                    <span class="comment">// halfedge can only trace one polygon, which is the opposite polygon to the</span></div>
<div class="line"><span class="lineno">10387</span>                    <span class="comment">// current (i.e. on the opposing patch). Hence, if find_iter is null then it means &quot;m0_cur_patch_cur_poly_cur_he&quot;</span></div>
<div class="line"><span class="lineno">10388</span>                    <span class="comment">// is on the border of the cut-mesh.</span></div>
<div class="line"><span class="lineno">10389</span>                    <span class="keyword">const</span> <span class="keywordtype">bool</span> opp_is_border_halfedge = (find_iter == m0_poly_he_opp_coincident_polys.cend()); <span class="comment">// current patch is reversed-patch and</span></div>
<div class="line"><span class="lineno">10390</span> </div>
<div class="line"><span class="lineno">10391</span>                    <span class="keywordflow">if</span> (opp_is_border_halfedge) {</div>
<div class="line"><span class="lineno">10392</span>                        <span class="comment">// 4 there is no neighbouring polygon which is coincident to</span></div>
<div class="line"><span class="lineno">10393</span>                        <span class="comment">// &quot;m0_cur_patch_cur_poly_cur_he_opp&quot;</span></div>
<div class="line"><span class="lineno">10394</span>                        <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">10395</span>                    }</div>
<div class="line"><span class="lineno">10396</span> </div>
<div class="line"><span class="lineno">10397</span>                    <span class="comment">// the adjacent polygon</span></div>
<div class="line"><span class="lineno">10398</span>                    <span class="keyword">const</span> <span class="keywordtype">int</span> m0_next_poly_idx = *find_iter;</div>
<div class="line"><span class="lineno">10399</span> </div>
<div class="line"><span class="lineno">10400</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno">10401</span>                    <span class="comment">// TODO: the following conditions below could also be speeded up if we</span></div>
<div class="line"><span class="lineno">10402</span>                    <span class="comment">// create a tmp vector/map which stores all of the adjacent polygons we have</span></div>
<div class="line"><span class="lineno">10403</span>                    <span class="comment">// already queued. Searching over this vector could be that bit faster.</span></div>
<div class="line"><span class="lineno">10404</span>                    <span class="comment">// We could do the right here now that &quot;m0_next_poly_idx&quot; is known.</span></div>
<div class="line"><span class="lineno">10405</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno">10406</span> </div>
<div class="line"><span class="lineno">10407</span>                    <span class="comment">// deduce the index of the next polygon&#39;s seed m0 halfedge</span></div>
<div class="line"><span class="lineno">10408</span>                    <span class="comment">// -------------------------------------------------------</span></div>
<div class="line"><span class="lineno">10409</span> </div>
<div class="line"><span class="lineno">10410</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_next_poly_idx &lt; (<span class="keywordtype">int</span>)m0_polygons.size());</div>
<div class="line"><span class="lineno">10411</span> </div>
<div class="line"><span class="lineno">10412</span>                    <span class="comment">// adjacent polygon</span></div>
<div class="line"><span class="lineno">10413</span>                    <span class="keyword">const</span> <a class="code hl_typedef" href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a>&amp; next_poly = m0_polygons[m0_next_poly_idx];</div>
<div class="line"><span class="lineno">10414</span>                    <span class="comment">// pointer to the first halfedge in the polygon from which its stitching will begin</span></div>
<div class="line"><span class="lineno">10415</span>                    <span class="keyword">const</span> traced_polygon_t::const_iterator he_find_iter = std::find(</div>
<div class="line"><span class="lineno">10416</span>                        next_poly.cbegin(),</div>
<div class="line"><span class="lineno">10417</span>                        next_poly.cend(),</div>
<div class="line"><span class="lineno">10418</span>                        m0_cur_patch_cur_poly_cur_he_opp);</div>
<div class="line"><span class="lineno">10419</span> </div>
<div class="line"><span class="lineno">10420</span>                    <span class="comment">// &quot;m0_cur_patch_cur_poly_cur_he_opp&quot; must exist in next_poly since we have</span></div>
<div class="line"><span class="lineno">10421</span>                    <span class="comment">// already established that &quot;m0_cur_patch_cur_poly_cur_he&quot; is not a border</span></div>
<div class="line"><span class="lineno">10422</span>                    <span class="comment">// halfedge. This is further supported by the fact that &quot;next_poly&quot; is in</span></div>
<div class="line"><span class="lineno">10423</span>                    <span class="comment">// current patch and coincident to &quot;m0_cur_patch_cur_poly_cur_he_opp&quot;</span></div>
<div class="line"><span class="lineno">10424</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(he_find_iter != next_poly.cend());</div>
<div class="line"><span class="lineno">10425</span> </div>
<div class="line"><span class="lineno">10426</span>                    <span class="comment">// index of halfedge from which stitching of the adjacent polygon will begin</span></div>
<div class="line"><span class="lineno">10427</span>                    <span class="keyword">const</span> <span class="keywordtype">int</span> m0_next_poly_he_idx = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)<a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(next_poly.cbegin(), he_find_iter);</div>
<div class="line"><span class="lineno">10428</span> </div>
<div class="line"><span class="lineno">10429</span>                    <span class="comment">// NOTE: there is no need to check if the next polygon is transformed here</span></div>
<div class="line"><span class="lineno">10430</span>                    <span class="comment">// because our 4 conditions above take care of this.</span></div>
<div class="line"><span class="lineno">10431</span>                    <span class="comment">// However, we do have to take care not to add the polygon to the queue more</span></div>
<div class="line"><span class="lineno">10432</span>                    <span class="comment">// than once (due to BFS nature of stitching), hence the following.</span></div>
<div class="line"><span class="lineno">10433</span> </div>
<div class="line"><span class="lineno">10434</span>                    <span class="keyword">const</span> <span class="keywordtype">bool</span> poly_is_already_in_tmp_queue = std::find_if(</div>
<div class="line"><span class="lineno">10435</span>                                                                  patch_poly_stitching_queue_tmp.crbegin(),</div>
<div class="line"><span class="lineno">10436</span>                                                                  patch_poly_stitching_queue_tmp.crend(),</div>
<div class="line"><span class="lineno">10437</span>                                                                  [&amp;](<span class="keyword">const</span> std::tuple&lt;hd_t, int, int&gt;&amp; elem) {</div>
<div class="line"><span class="lineno">10438</span>                                                                      return std::get&lt;1&gt;(elem) == m0_next_poly_idx;</div>
<div class="line"><span class="lineno">10439</span>                                                                  })</div>
<div class="line"><span class="lineno">10440</span>                        != patch_poly_stitching_queue_tmp.crend();</div>
<div class="line"><span class="lineno">10441</span> </div>
<div class="line"><span class="lineno">10442</span>                    <span class="keywordflow">if</span> (!poly_is_already_in_tmp_queue) {</div>
<div class="line"><span class="lineno">10443</span>                        <span class="comment">//                   if (!poly_is_already_stitched_wrt_cur_patch) { // TODO: the [if check] will have to go once &quot;poly_is_already_stitched_wrt_cur_patch&quot; is removed</span></div>
<div class="line"><span class="lineno">10444</span>                        <span class="comment">// check the main global queue to make sure poly has not already been added</span></div>
<div class="line"><span class="lineno">10445</span>                        <span class="comment">// std::unordered_map&lt;int, bool&gt;::const_iterator qmap_iter = m0_poly_already_enqueued.find(m0_next_poly_idx);</span></div>
<div class="line"><span class="lineno">10446</span>                        <span class="keyword">const</span> <span class="keywordtype">bool</span> poly_is_already_in_maqueued = m0_poly_already_enqueued[(std::size_t)m0_next_poly_idx - traced_sm_polygon_count]; <span class="comment">/*std::find_if(</span></div>
<div class="line"><span class="lineno">10447</span><span class="comment">                                                                     patch_poly_stitching_queue.crbegin(),</span></div>
<div class="line"><span class="lineno">10448</span><span class="comment">                                                                     patch_poly_stitching_queue.crend(),</span></div>
<div class="line"><span class="lineno">10449</span><span class="comment">                                                                     [&amp;](const std::tuple&lt;hd_t, int, int&gt; &amp;elem)</span></div>
<div class="line"><span class="lineno">10450</span><span class="comment">                                                                     {</span></div>
<div class="line"><span class="lineno">10451</span><span class="comment">                                                                         return std::get&lt;1&gt;(elem) == m0_next_poly_idx; // there is an element in the queue with the polygon&#39;s ID</span></div>
<div class="line"><span class="lineno">10452</span><span class="comment">                                                                     }) != patch_poly_stitching_queue.crend();*/</span></div>
<div class="line"><span class="lineno">10453</span> </div>
<div class="line"><span class="lineno">10454</span>                        <span class="keywordflow">if</span> (!poly_is_already_in_maqueued) {</div>
<div class="line"><span class="lineno">10455</span>                            patch_poly_stitching_queue_tmp.push_back(std::make_tuple(m1_next_poly_seed_he, m0_next_poly_idx, m0_next_poly_he_idx));</div>
<div class="line"><span class="lineno">10456</span>                            m0_poly_already_enqueued[(std::size_t)m0_next_poly_idx - traced_sm_polygon_count] = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">10457</span>                        }</div>
<div class="line"><span class="lineno">10458</span>                    }</div>
<div class="line"><span class="lineno">10459</span> </div>
<div class="line"><span class="lineno">10460</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno">10461</span>                    <span class="comment">// update vertex mapping for non-intersection points</span></div>
<div class="line"><span class="lineno">10462</span>                    <span class="comment">//</span></div>
<div class="line"><span class="lineno">10463</span> </div>
<div class="line"><span class="lineno">10464</span>                    <span class="comment">// since we loop round the whole current polygon, we can just use the target</span></div>
<div class="line"><span class="lineno">10465</span>                    <span class="comment">// NOTE: Possible optimization we could populate &quot;m1_to_m0_cm_ovtx_colored&quot; in the</span></div>
<div class="line"><span class="lineno">10466</span>                    <span class="comment">// do-while loop that stitches cut-mesh patches because the are specific if-cases which deal</span></div>
<div class="line"><span class="lineno">10467</span>                    <span class="comment">// with x--&gt;o and o--&gt;o halfedges, from which we can add elements to &quot;m1_to_m0_cm_ovtx_colored&quot;</span></div>
<div class="line"><span class="lineno">10468</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_cur_poly_cur_he_tgt = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m0_cur_patch_cur_poly_cur_he);</div>
<div class="line"><span class="lineno">10469</span>                    <span class="keyword">const</span> <span class="keywordtype">bool</span> tgt_is_original_vtx = !<a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(m0_cur_poly_cur_he_tgt, ps_vtx_cnt);</div>
<div class="line"><span class="lineno">10470</span> </div>
<div class="line"><span class="lineno">10471</span>                    <span class="keywordflow">if</span> (tgt_is_original_vtx) {</div>
<div class="line"><span class="lineno">10472</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m1_cur_poly_cur_he_tgt = m1_colored.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(m1_cur_polygon_he);</div>
<div class="line"><span class="lineno">10473</span>                        <span class="comment">// &quot;cur_poly_cur_he_tgt&quot; may already be mapped to its &quot;m1&quot; version w.r.t the current patch.</span></div>
<div class="line"><span class="lineno">10474</span>                        <span class="comment">// This is because of the BFS manner in which we stitch polygons of a patch.</span></div>
<div class="line"><span class="lineno">10475</span>                        <span class="keywordflow">if</span> (m1_to_m0_cm_ovtx_colored.count(m1_cur_poly_cur_he_tgt) == 0) {</div>
<div class="line"><span class="lineno">10476</span>                            m1_to_m0_cm_ovtx_colored[m1_cur_poly_cur_he_tgt] = m0_cur_poly_cur_he_tgt;</div>
<div class="line"><span class="lineno">10477</span>                        }</div>
<div class="line"><span class="lineno">10478</span>                    }</div>
<div class="line"><span class="lineno">10479</span>                }</div>
<div class="line"><span class="lineno">10480</span>                <span class="comment">//              } // for each m0 halfedge of current patch-polygon</span></div>
<div class="line"><span class="lineno">10481</span> </div>
<div class="line"><span class="lineno">10482</span>                <span class="comment">// add elements of tmp/local queue to global queue</span></div>
<div class="line"><span class="lineno">10483</span>                <span class="keywordflow">while</span> (!patch_poly_stitching_queue_tmp.empty()) {</div>
<div class="line"><span class="lineno">10484</span>                    <span class="keyword">const</span> std::tuple&lt;hd_t, int, int&gt;&amp; elem = patch_poly_stitching_queue_tmp.front();</div>
<div class="line"><span class="lineno">10485</span>                    patch_poly_stitching_queue.push_back(elem); <span class="comment">// add</span></div>
<div class="line"><span class="lineno">10486</span>                    patch_poly_stitching_queue_tmp.pop_front(); <span class="comment">// rm</span></div>
<div class="line"><span class="lineno">10487</span>                }</div>
<div class="line"><span class="lineno">10488</span> </div>
<div class="line"><span class="lineno">10489</span>                <span class="comment">//</span></div>
<div class="line"><span class="lineno">10490</span>                <span class="comment">// NOTE: At this stage, we have finished transforming all the halfedges of the current polygon</span></div>
<div class="line"><span class="lineno">10491</span>                <span class="comment">// and we have also added all its neighbouring polygons to the queue for stitching.</span></div>
<div class="line"><span class="lineno">10492</span>                <span class="comment">//</span></div>
<div class="line"><span class="lineno">10493</span> </div>
<div class="line"><span class="lineno">10494</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(patch_color_label_to_location.find(color_id) != patch_color_label_to_location.cend());</div>
<div class="line"><span class="lineno">10495</span> </div>
<div class="line"><span class="lineno">10497</span>                <span class="comment">// Update output (with the current polygon stitched into a cc)</span></div>
<div class="line"><span class="lineno">10499</span><span class="comment"></span> </div>
<div class="line"><span class="lineno">10500</span>                <span class="comment">// const std::string color_tag_stri = to_string(SAFE_ACCESS(patch_color_label_to_location, color_id)); // == cm_patch_location_t::OUTSIDE ? &quot;e&quot; : &quot;i&quot;);</span></div>
<div class="line"><span class="lineno">10501</span> </div>
<div class="line"><span class="lineno">10502</span>                <span class="comment">// save meshes and dump</span></div>
<div class="line"><span class="lineno">10503</span> </div>
<div class="line"><span class="lineno">10504</span>                <span class="keywordflow">if</span> (input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a18ab3e0c7ed366d45a0c1aaccddc4eee">keep_fragments_sealed_inside_exhaustive</a> || input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a719e59e63d8bf7d7c665f69d3213327b">keep_fragments_sealed_outside_exhaustive</a>) {</div>
<div class="line"><span class="lineno">10506</span>                    <span class="comment">// create the sealed meshes defined by the [current] set of traced polygons</span></div>
<div class="line"><span class="lineno">10508</span><span class="comment"></span> </div>
<div class="line"><span class="lineno">10509</span>                    <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a34276907046e706af5626787b2e2b05a">extract_connected_components</a>(</div>
<div class="line"><span class="lineno">10510</span>#<span class="keywordflow">if</span> defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</div>
<div class="line"><span class="lineno">10511</span>                        *input.scheduler,</div>
<div class="line"><span class="lineno">10512</span>#endif</div>
<div class="line"><span class="lineno">10513</span>                        separated_stitching_CCs,</div>
<div class="line"><span class="lineno">10514</span>                        m1_colored,</div>
<div class="line"><span class="lineno">10515</span>                        0,</div>
<div class="line"><span class="lineno">10516</span>                        m1_polygons_colored,</div>
<div class="line"><span class="lineno">10517</span>                        sm_polygons_below_cs,</div>
<div class="line"><span class="lineno">10518</span>                        sm_polygons_above_cs,</div>
<div class="line"><span class="lineno">10519</span>                        m1_vertex_to_seam_flag,</div>
<div class="line"><span class="lineno">10520</span>                        m1_to_m0_sm_ovtx_colored,</div>
<div class="line"><span class="lineno">10521</span>                        m1_to_m0_cm_ovtx_colored,</div>
<div class="line"><span class="lineno">10522</span>                        m1_to_m0_face_colored,</div>
<div class="line"><span class="lineno">10523</span>                        m0_to_ps_vtx,</div>
<div class="line"><span class="lineno">10524</span>                        m0_to_ps_face,</div>
<div class="line"><span class="lineno">10525</span>                        ps_to_sm_vtx,</div>
<div class="line"><span class="lineno">10526</span>                        ps_to_sm_face,</div>
<div class="line"><span class="lineno">10527</span>                        ps_to_cm_vtx,</div>
<div class="line"><span class="lineno">10528</span>                        ps_to_cm_face,</div>
<div class="line"><span class="lineno">10529</span>                        sm_vtx_cnt,</div>
<div class="line"><span class="lineno">10530</span>                        sm_face_count,</div>
<div class="line"><span class="lineno">10531</span>                        input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a0b23c3ae4df4369125ff8b489a42260b">populate_vertex_maps</a>,</div>
<div class="line"><span class="lineno">10532</span>                        input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8307155337693cbe5ebf0f61ea8ffd81">populate_face_maps</a>,</div>
<div class="line"><span class="lineno">10533</span>                        input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a07e9992982b4f9497d1499f1cfb2826d">keep_fragments_below_cutmesh</a>,</div>
<div class="line"><span class="lineno">10534</span>                        input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#ababb18b60ba667267d374ba263e889af">keep_fragments_above_cutmesh</a>,</div>
<div class="line"><span class="lineno">10535</span>                        input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a6558e59317164c8e7d141f2f8fce00b5">keep_fragments_partially_cut</a>);</div>
<div class="line"><span class="lineno">10536</span>                }</div>
<div class="line"><span class="lineno">10537</span> </div>
<div class="line"><span class="lineno">10538</span>                ++global_cm_poly_stitch_counter;</div>
<div class="line"><span class="lineno">10539</span>                stitched_poly_counter++;</div>
<div class="line"><span class="lineno">10540</span> </div>
<div class="line"><span class="lineno">10541</span>            } <span class="keywordflow">while</span> (!patch_poly_stitching_queue.empty()); <span class="comment">// for each polygon of patch</span></div>
<div class="line"><span class="lineno">10542</span> </div>
<div class="line"><span class="lineno">10543</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno">10544</span>            <span class="comment">// NOTE: At this stage we have finished stitching all polygons of the current patch.</span></div>
<div class="line"><span class="lineno">10545</span>            <span class="comment">// So, the current patch has been stitch to a src-mesh fragment</span></div>
<div class="line"><span class="lineno">10546</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno">10547</span> </div>
<div class="line"><span class="lineno">10548</span>        } <span class="comment">// for each patch</span></div>
<div class="line"><span class="lineno">10549</span> </div>
<div class="line"><span class="lineno">10550</span>    } <span class="comment">// for each color</span></div>
<div class="line"><span class="lineno">10551</span> </div>
<div class="line"><span class="lineno">10552</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>(); <span class="comment">// &amp;&amp;&amp;&amp;&amp;</span></div>
<div class="line"><span class="lineno">10553</span> </div>
<div class="line"><span class="lineno">10554</span>    patch_poly_stitching_queue.clear();</div>
<div class="line"><span class="lineno">10555</span>    m0_poly_already_enqueued.clear();</div>
<div class="line"><span class="lineno">10556</span> </div>
<div class="line"><span class="lineno">10557</span>    m0_cm_poly_to_patch_idx.clear();</div>
<div class="line"><span class="lineno">10558</span>    <span class="comment">// m0_ivtx_to_ps_edge.clear(); // free</span></div>
<div class="line"><span class="lineno">10559</span>    m0_polygons.clear();</div>
<div class="line"><span class="lineno">10560</span>    m0_h_to_ply.clear();</div>
<div class="line"><span class="lineno">10561</span>    m0_to_m1_ihe.clear();</div>
<div class="line"><span class="lineno">10562</span>    m1_polygons.clear();</div>
<div class="line"><span class="lineno">10563</span>    patches.clear();</div>
<div class="line"><span class="lineno">10564</span>    patch_to_seed_interior_ihalfedge_idx.clear();</div>
<div class="line"><span class="lineno">10565</span>    patch_to_seed_interior_ihalfedge_idx.clear();</div>
<div class="line"><span class="lineno">10566</span>    patch_to_seed_poly_idx.clear();</div>
<div class="line"><span class="lineno">10567</span>    color_to_patch.clear();</div>
<div class="line"><span class="lineno">10568</span>    sm_interior_cs_border_vertices.clear();</div>
<div class="line"><span class="lineno">10569</span>    color_to_m0_to_m1_he_instances.clear();</div>
<div class="line"><span class="lineno">10570</span> </div>
<div class="line"><span class="lineno">10571</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno">10572</span>    <span class="comment">// NOTE: At this stage, all patches of the current have been stitched</span></div>
<div class="line"><span class="lineno">10573</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno">10574</span> </div>
<div class="line"><span class="lineno">10575</span>    <span class="keywordtype">bool</span> userWantsFullySealedFragmentsANY = (input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a4d23d907262b78c2d865f4d52bb65757">keep_fragments_sealed_inside</a> || input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#aff3651e310bd220d4f65bd450af94f16">keep_fragments_sealed_outside</a>);</div>
<div class="line"><span class="lineno">10576</span>    <span class="keywordtype">bool</span> userWantsEvenPartiallySealedFragmentsANY = (input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a18ab3e0c7ed366d45a0c1aaccddc4eee">keep_fragments_sealed_inside_exhaustive</a> || input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a719e59e63d8bf7d7c665f69d3213327b">keep_fragments_sealed_outside_exhaustive</a>);</div>
<div class="line"><span class="lineno">10577</span> </div>
<div class="line"><span class="lineno">10578</span>    <span class="comment">// if the user wants [only] fully sealed fragment (not partially sealed)</span></div>
<div class="line"><span class="lineno">10579</span>    <span class="keywordflow">if</span> (userWantsFullySealedFragmentsANY &amp;&amp; <span class="comment">//</span></div>
<div class="line"><span class="lineno">10580</span>        !userWantsEvenPartiallySealedFragmentsANY) {</div>
<div class="line"><span class="lineno">10582</span>        <span class="comment">// create the [fully] sealed meshes defined by the final set of traced polygons</span></div>
<div class="line"><span class="lineno">10584</span><span class="comment"></span> </div>
<div class="line"><span class="lineno">10585</span>        <span class="keywordflow">for</span> (std::map&lt;<span class="keywordtype">char</span>, std::map&lt;std::size_t, std::vector&lt;std::pair&lt;std::shared_ptr&lt;hmesh_t&gt;, <a class="code hl_struct" href="../../dd/d24/kernel_8cpp.html#d7/dd7/structconnected__component__info__t">connected_component_info_t</a>&gt;&gt;&gt;&gt;::iterator color_to_separated_CCs_iter = color_to_separated_connected_ccsponents.begin();</div>
<div class="line"><span class="lineno">10586</span>             color_to_separated_CCs_iter != color_to_separated_connected_ccsponents.end();</div>
<div class="line"><span class="lineno">10587</span>             ++color_to_separated_CCs_iter) {</div>
<div class="line"><span class="lineno">10588</span> </div>
<div class="line"><span class="lineno">10589</span>            <span class="keyword">const</span> <span class="keywordtype">char</span> color_label = color_to_separated_CCs_iter-&gt;first;</div>
<div class="line"><span class="lineno">10590</span>            std::map&lt;std::size_t, std::vector&lt;std::pair&lt;std::shared_ptr&lt;hmesh_t&gt;, <a class="code hl_struct" href="../../dd/d24/kernel_8cpp.html#d7/dd7/structconnected__component__info__t">connected_component_info_t</a>&gt;&gt;&gt;&amp; separated_sealed_CCs = color_to_separated_CCs_iter-&gt;second;</div>
<div class="line"><span class="lineno">10591</span> </div>
<div class="line"><span class="lineno">10592</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d7/d63/classhmesh__t.html">hmesh_t</a>&amp; m1_colored = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(color_to_m1, color_label);</div>
<div class="line"><span class="lineno">10593</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(color_to_m1_polygons.count(color_label) == 1);</div>
<div class="line"><span class="lineno">10594</span>            <span class="keyword">const</span> std::vector&lt;traced_polygon_t&gt;&amp; m1_polygons_colored = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(color_to_m1_polygons, color_label);</div>
<div class="line"><span class="lineno">10595</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(color_to_m1_to_m0_sm_ovtx.count(color_label) == 1);</div>
<div class="line"><span class="lineno">10596</span>            <span class="keyword">const</span> std::vector&lt;vd_t&gt;&amp; m1_to_m0_sm_ovtx_colored = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(color_to_m1_to_m0_sm_ovtx, color_label);</div>
<div class="line"><span class="lineno">10597</span> </div>
<div class="line"><span class="lineno">10598</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(colour_to_m1_to_m0_cm_ovtx.count(color_label) == 1);</div>
<div class="line"><span class="lineno">10599</span>            <span class="keyword">const</span> std::unordered_map&lt;vd_t, vd_t&gt;&amp; m1_to_m0_cm_ovtx_colored = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(colour_to_m1_to_m0_cm_ovtx, color_label);</div>
<div class="line"><span class="lineno">10600</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(color_to_m1_to_m0_face.count(color_label) == 1);</div>
<div class="line"><span class="lineno">10601</span>            <span class="comment">/*const*/</span> std::unordered_map&lt;int, int&gt;&amp; m1_to_m0_face_colored = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(color_to_m1_to_m0_face, color_label);</div>
<div class="line"><span class="lineno">10602</span> </div>
<div class="line"><span class="lineno">10603</span>            <span class="comment">// extract the seam vertices</span></div>
<div class="line"><span class="lineno">10604</span>            <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a34276907046e706af5626787b2e2b05a">extract_connected_components</a>(</div>
<div class="line"><span class="lineno">10605</span>#<span class="keywordflow">if</span> defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</div>
<div class="line"><span class="lineno">10606</span>                *input.scheduler,</div>
<div class="line"><span class="lineno">10607</span>#endif</div>
<div class="line"><span class="lineno">10608</span>                separated_sealed_CCs,</div>
<div class="line"><span class="lineno">10609</span>                m1_colored,</div>
<div class="line"><span class="lineno">10610</span>                0,</div>
<div class="line"><span class="lineno">10611</span>                m1_polygons_colored,</div>
<div class="line"><span class="lineno">10612</span>                sm_polygons_below_cs,</div>
<div class="line"><span class="lineno">10613</span>                sm_polygons_above_cs,</div>
<div class="line"><span class="lineno">10614</span>                m1_vertex_to_seam_flag,</div>
<div class="line"><span class="lineno">10615</span>                m1_to_m0_sm_ovtx_colored,</div>
<div class="line"><span class="lineno">10616</span>                m1_to_m0_cm_ovtx_colored,</div>
<div class="line"><span class="lineno">10617</span>                m1_to_m0_face_colored,</div>
<div class="line"><span class="lineno">10618</span>                m0_to_ps_vtx,</div>
<div class="line"><span class="lineno">10619</span>                m0_to_ps_face,</div>
<div class="line"><span class="lineno">10620</span>                ps_to_sm_vtx,</div>
<div class="line"><span class="lineno">10621</span>                ps_to_sm_face,</div>
<div class="line"><span class="lineno">10622</span>                ps_to_cm_vtx,</div>
<div class="line"><span class="lineno">10623</span>                ps_to_cm_face,</div>
<div class="line"><span class="lineno">10624</span>                sm_vtx_cnt,</div>
<div class="line"><span class="lineno">10625</span>                sm_face_count,</div>
<div class="line"><span class="lineno">10626</span>                input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a0b23c3ae4df4369125ff8b489a42260b">populate_vertex_maps</a>,</div>
<div class="line"><span class="lineno">10627</span>                input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8307155337693cbe5ebf0f61ea8ffd81">populate_face_maps</a>,</div>
<div class="line"><span class="lineno">10628</span>                input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a07e9992982b4f9497d1499f1cfb2826d">keep_fragments_below_cutmesh</a>,</div>
<div class="line"><span class="lineno">10629</span>                input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#ababb18b60ba667267d374ba263e889af">keep_fragments_above_cutmesh</a>,</div>
<div class="line"><span class="lineno">10630</span>                input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a6558e59317164c8e7d141f2f8fce00b5">keep_fragments_partially_cut</a>);</div>
<div class="line"><span class="lineno">10631</span>        }</div>
<div class="line"><span class="lineno">10632</span>    }</div>
<div class="line"><span class="lineno">10633</span> </div>
<div class="line"><span class="lineno">10634</span>    sm_polygons_below_cs.clear(); <span class="comment">// free</span></div>
<div class="line"><span class="lineno">10635</span>    sm_polygons_above_cs.clear();</div>
<div class="line"><span class="lineno">10636</span>    m1_vertex_to_seam_flag.clear();</div>
<div class="line"><span class="lineno">10637</span>    color_to_m1.clear();</div>
<div class="line"><span class="lineno">10638</span>    color_to_m1_polygons.clear();</div>
<div class="line"><span class="lineno">10639</span> </div>
<div class="line"><span class="lineno">10641</span>    <span class="comment">// save output and finish</span></div>
<div class="line"><span class="lineno">10643</span><span class="comment"></span> </div>
<div class="line"><span class="lineno">10644</span>    std::map&lt;sm_frag_location_t, std::map&lt;cm_patch_location_t, std::vector&lt;std::shared_ptr&lt;output_mesh_info_t&gt;&gt;&gt;&gt;&amp; <a class="code hl_variable" href="../../d7/da4/testmini_8c.html#ad9e5eed42092079dea4d90550ff5fcf0">out</a> = output.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a08cabee26121d0fa4313c5960975b9d8">connected_components</a>;</div>
<div class="line"><span class="lineno">10645</span>    <span class="keywordtype">int</span> idx = 0;</div>
<div class="line"><span class="lineno">10646</span>    <span class="keywordflow">for</span> (std::map&lt;<span class="keywordtype">char</span>, std::map&lt;std::size_t, std::vector&lt;std::pair&lt;std::shared_ptr&lt;hmesh_t&gt;, <a class="code hl_struct" href="../../dd/d24/kernel_8cpp.html#d7/dd7/structconnected__component__info__t">connected_component_info_t</a>&gt;&gt;&gt;&gt;::iterator color_to_separated_CCs_iter = color_to_separated_connected_ccsponents.begin();</div>
<div class="line"><span class="lineno">10647</span>         color_to_separated_CCs_iter != color_to_separated_connected_ccsponents.end();</div>
<div class="line"><span class="lineno">10648</span>         ++color_to_separated_CCs_iter) {</div>
<div class="line"><span class="lineno">10649</span> </div>
<div class="line"><span class="lineno">10650</span>        <span class="keyword">const</span> <span class="keywordtype">char</span> color_label = color_to_separated_CCs_iter-&gt;first;</div>
<div class="line"><span class="lineno">10651</span>        <span class="comment">// inside or outside or undefined</span></div>
<div class="line"><span class="lineno">10652</span>        <span class="keyword">const</span> <a class="code hl_enumeration" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956">cm_patch_location_t</a> patchLocation = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(patch_color_label_to_location, color_label);</div>
<div class="line"><span class="lineno">10653</span>        std::map&lt;std::size_t, std::vector&lt;std::pair&lt;std::shared_ptr&lt;hmesh_t&gt;, <a class="code hl_struct" href="../../dd/d24/kernel_8cpp.html#d7/dd7/structconnected__component__info__t">connected_component_info_t</a>&gt;&gt;&gt;&amp; separated_sealed_CCs = color_to_separated_CCs_iter-&gt;second;</div>
<div class="line"><span class="lineno">10654</span> </div>
<div class="line"><span class="lineno">10655</span>        <span class="keywordflow">for</span> (std::map&lt;std::size_t, std::vector&lt;std::pair&lt;std::shared_ptr&lt;hmesh_t&gt;, <a class="code hl_struct" href="../../dd/d24/kernel_8cpp.html#d7/dd7/structconnected__component__info__t">connected_component_info_t</a>&gt;&gt;&gt;::iterator cc_iter = separated_sealed_CCs.begin();</div>
<div class="line"><span class="lineno">10656</span>             cc_iter != separated_sealed_CCs.end();</div>
<div class="line"><span class="lineno">10657</span>             ++cc_iter) {</div>
<div class="line"><span class="lineno">10658</span> </div>
<div class="line"><span class="lineno">10659</span>            <span class="comment">// all instances of current connected component (from 0-or-1 stitched cm-polygon to all stitched cm-polygons)</span></div>
<div class="line"><span class="lineno">10660</span>            <span class="comment">// NOTE TO SELF: the first instance may have one or [zero] cut-mesh polygons since stitching works on a per-patch-per-polygon basis.</span></div>
<div class="line"><span class="lineno">10661</span>            <span class="comment">// I.e. if the 1st stitched cm-polygon is into an &quot;above&quot; fragmetn (inside or outside), then the opposite</span></div>
<div class="line"><span class="lineno">10662</span>            <span class="comment">// fragment that is &quot;below&quot; will have zero cut-mesh polygons. Hence.</span></div>
<div class="line"><span class="lineno">10663</span>            std::vector&lt;std::pair&lt;std::shared_ptr&lt;hmesh_t&gt;, <a class="code hl_struct" href="../../dd/d24/kernel_8cpp.html#d7/dd7/structconnected__component__info__t">connected_component_info_t</a>&gt;&gt;&amp; cc_instances = cc_iter-&gt;second;</div>
<div class="line"><span class="lineno">10664</span> </div>
<div class="line"><span class="lineno">10665</span>            <span class="keywordflow">if</span> (!userWantsEvenPartiallySealedFragmentsANY) {</div>
<div class="line"><span class="lineno">10666</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(cc_instances.size() == 1); <span class="comment">// there is only one, fully sealed, copy</span></div>
<div class="line"><span class="lineno">10667</span>            }</div>
<div class="line"><span class="lineno">10668</span> </div>
<div class="line"><span class="lineno">10669</span>            <span class="comment">// For each instance of CC (each instance differs by one stitched polygon)</span></div>
<div class="line"><span class="lineno">10670</span>            <span class="keywordflow">for</span> (std::vector&lt;std::pair&lt;std::shared_ptr&lt;hmesh_t&gt;, <a class="code hl_struct" href="../../dd/d24/kernel_8cpp.html#d7/dd7/structconnected__component__info__t">connected_component_info_t</a>&gt;&gt;::iterator cc_instance_iter = cc_instances.begin();</div>
<div class="line"><span class="lineno">10671</span>                 cc_instance_iter != cc_instances.end();</div>
<div class="line"><span class="lineno">10672</span>                 ++cc_instance_iter) {</div>
<div class="line"><span class="lineno">10673</span> </div>
<div class="line"><span class="lineno">10674</span>                std::pair&lt;std::shared_ptr&lt;hmesh_t&gt;, <a class="code hl_struct" href="../../dd/d24/kernel_8cpp.html#d7/dd7/structconnected__component__info__t">connected_component_info_t</a>&gt;&amp; cc_instance = *cc_instance_iter;</div>
<div class="line"><span class="lineno">10675</span> </div>
<div class="line"><span class="lineno">10676</span>                <span class="keywordflow">if</span> (input.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#acbacc55f2163529291e5a45671fed3d1">verbose</a>) {</div>
<div class="line"><span class="lineno">10677</span>                    <span class="comment">// const int idx = (int)std::distance(cc_instances.begin(), cc_instance_iter);</span></div>
<div class="line"><span class="lineno">10678</span>                    <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a9bb440c35b34b7ecd91a6ce4eca6941e">dump_mesh</a>(cc_instance.first.get()[0], (std::string(<span class="stringliteral">&quot;cc&quot;</span>) + std::to_string(idx++) + <span class="stringliteral">&quot;.&quot;</span> + <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#ac170ee95cd3318133c47c23a4a4412b8">to_string</a>(cc_instance.second.location) + <span class="stringliteral">&quot;.&quot;</span> + <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#ac170ee95cd3318133c47c23a4a4412b8">to_string</a>(patchLocation)).c_str());</div>
<div class="line"><span class="lineno">10679</span>                }</div>
<div class="line"><span class="lineno">10680</span> </div>
<div class="line"><span class="lineno">10681</span>                std::shared_ptr&lt;output_mesh_info_t&gt; omi = std::shared_ptr&lt;output_mesh_info_t&gt;(<span class="keyword">new</span> <a class="code hl_struct" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#de/de4/structoutput__mesh__info__t">output_mesh_info_t</a>);</div>
<div class="line"><span class="lineno">10682</span>                omi-&gt;mesh = (cc_instance.first);</div>
<div class="line"><span class="lineno">10683</span>                omi-&gt;seam_vertices = std::move(cc_instance.second.seam_vertices);</div>
<div class="line"><span class="lineno">10684</span>                omi-&gt;data_maps = std::move(cc_instance.second.data_maps);</div>
<div class="line"><span class="lineno">10685</span>                <a class="code hl_variable" href="../../d7/da4/testmini_8c.html#ad9e5eed42092079dea4d90550ff5fcf0">out</a>[cc_instance.second.location][patchLocation].emplace_back(std::move(omi));</div>
<div class="line"><span class="lineno">10686</span>            }</div>
<div class="line"><span class="lineno">10687</span>        }</div>
<div class="line"><span class="lineno">10688</span>    }</div>
<div class="line"><span class="lineno">10689</span> </div>
<div class="line"><span class="lineno">10690</span>    patch_color_label_to_location.clear(); <span class="comment">// free</span></div>
<div class="line"><span class="lineno">10691</span>    color_to_separated_connected_ccsponents.clear();</div>
<div class="line"><span class="lineno">10692</span> </div>
<div class="line"><span class="lineno">10693</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno">10694</span> </div>
<div class="line"><span class="lineno">10695</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">10696</span>} <span class="comment">// dispatch</span></div>
<div class="ttc" id="a_array_cwise_unary_ops_8h_html_a281eccb624a3ff6dacbe305828e43a82"><div class="ttname"><a href="../../d4/df0/_array_cwise_unary_ops_8h.html#a281eccb624a3ff6dacbe305828e43a82">sign</a></div><div class="ttdeci">EIGEN_DEVICE_FUNC const SignReturnType sign() const</div><div class="ttdef"><b>Definition</b> ArrayCwiseUnaryOps.h:184</div></div>
<div class="ttc" id="a_shiny_prereqs_8h_html_a435d1572bf3f880d55459d9805097f62"><div class="ttname"><a href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a></div><div class="ttdeci">unsigned int uint32_t</div><div class="ttdef"><b>Definition</b> ShinyPrereqs.h:120</div></div>
<div class="ttc" id="aclassarray__iterator__t_html"><div class="ttname"><a href="../../d8/d9b/classarray__iterator__t.html">array_iterator_t</a></div><div class="ttdef"><b>Definition</b> hmesh.h:449</div></div>
<div class="ttc" id="aclassdescriptor__t___html_a80e181aa419b05d8c73a579815159df9"><div class="ttname"><a href="../../dd/dad/classdescriptor__t__.html#a80e181aa419b05d8c73a579815159df9">descriptor_t_&lt; vertex_descriptor_t &gt;::index_type</a></div><div class="ttdeci">unsigned int index_type</div><div class="ttdef"><b>Definition</b> hmesh.h:39</div></div>
<div class="ttc" id="aclassedge__descriptor__t_html"><div class="ttname"><a href="../../da/dd7/classedge__descriptor__t.html">edge_descriptor_t</a></div><div class="ttdef"><b>Definition</b> hmesh.h:137</div></div>
<div class="ttc" id="aclassface__descriptor__t_html"><div class="ttname"><a href="../../d1/dc7/classface__descriptor__t.html">face_descriptor_t</a></div><div class="ttdef"><b>Definition</b> hmesh.h:154</div></div>
<div class="ttc" id="aclasshalfedge__descriptor__t_html"><div class="ttname"><a href="../../d9/d0a/classhalfedge__descriptor__t.html">halfedge_descriptor_t</a></div><div class="ttdef"><b>Definition</b> hmesh.h:120</div></div>
<div class="ttc" id="aclasshmesh__t_html"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html">hmesh_t</a></div><div class="ttdef"><b>Definition</b> hmesh.h:252</div></div>
<div class="ttc" id="aclasshmesh__t_html_a08178cf3f846017dbec208b96c970ac7"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#a08178cf3f846017dbec208b96c970ac7">hmesh_t::number_of_faces</a></div><div class="ttdeci">int number_of_faces() const</div><div class="ttdef"><b>Definition</b> hmesh.cpp:130</div></div>
<div class="ttc" id="aclasshmesh__t_html_a0bf160ae73193f77064cc3d8f01e63a3"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#a0bf160ae73193f77064cc3d8f01e63a3">hmesh_t::vertices_begin</a></div><div class="ttdeci">vertex_array_iterator_t vertices_begin(bool account_for_removed_elems=true) const</div><div class="ttdef"><b>Definition</b> hmesh.cpp:838</div></div>
<div class="ttc" id="aclasshmesh__t_html_a0c71c904363d4a3932bd674812f8478e"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#a0c71c904363d4a3932bd674812f8478e">hmesh_t::reserve_for_additional_elements</a></div><div class="ttdeci">void reserve_for_additional_elements(std::uint32_t additional_vertices)</div><div class="ttdef"><b>Definition</b> hmesh.cpp:1174</div></div>
<div class="ttc" id="aclasshmesh__t_html_a0d2a1a79406b7352af07d4fc56707782"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#a0d2a1a79406b7352af07d4fc56707782">hmesh_t::add_vertex</a></div><div class="ttdeci">vertex_descriptor_t add_vertex(const vec3 &amp;point)</div><div class="ttdef"><b>Definition</b> hmesh.cpp:348</div></div>
<div class="ttc" id="aclasshmesh__t_html_a197264c917b7fb5ddc007909ae89d372"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#a197264c917b7fb5ddc007909ae89d372">hmesh_t::get_faces_around_face</a></div><div class="ttdeci">const std::vector&lt; face_descriptor_t &gt; get_faces_around_face(const face_descriptor_t f, const std::vector&lt; halfedge_descriptor_t &gt; *halfedges_around_face_=nullptr) const</div><div class="ttdef"><b>Definition</b> hmesh.cpp:748</div></div>
<div class="ttc" id="aclasshmesh__t_html_a2784844d96e3180300014869148d7577"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#a2784844d96e3180300014869148d7577">hmesh_t::add_face</a></div><div class="ttdeci">face_descriptor_t add_face(const std::vector&lt; vertex_descriptor_t &gt; &amp;vi)</div><div class="ttdef"><b>Definition</b> hmesh.cpp:507</div></div>
<div class="ttc" id="aclasshmesh__t_html_a323ceb33e1af67dc8ce0defc2774a3e6"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">hmesh_t::halfedge</a></div><div class="ttdeci">halfedge_descriptor_t halfedge(const edge_descriptor_t e, const int i) const</div><div class="ttdef"><b>Definition</b> hmesh.cpp:261</div></div>
<div class="ttc" id="aclasshmesh__t_html_a35ce6de1cc36d41e9eb48edb3e23e795"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#a35ce6de1cc36d41e9eb48edb3e23e795">hmesh_t::number_of_vertices</a></div><div class="ttdeci">int number_of_vertices() const</div><div class="ttdef"><b>Definition</b> hmesh.cpp:115</div></div>
<div class="ttc" id="aclasshmesh__t_html_a38154c743bff113eea931e14eaea6ddd"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#a38154c743bff113eea931e14eaea6ddd">hmesh_t::number_of_halfedges</a></div><div class="ttdeci">int number_of_halfedges() const</div><div class="ttdef"><b>Definition</b> hmesh.cpp:125</div></div>
<div class="ttc" id="aclasshmesh__t_html_a3d290168d74d3af8636faa881a9e3708"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#a3d290168d74d3af8636faa881a9e3708">hmesh_t::edges_end</a></div><div class="ttdeci">edge_array_iterator_t edges_end() const</div><div class="ttdef"><b>Definition</b> hmesh.cpp:867</div></div>
<div class="ttc" id="aclasshmesh__t_html_a3ea06ff1ab141d57223eb28cfba1bb26"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#a3ea06ff1ab141d57223eb28cfba1bb26">hmesh_t::get_halfedges_around_vertex</a></div><div class="ttdeci">const std::vector&lt; halfedge_descriptor_t &gt; &amp; get_halfedges_around_vertex(const vertex_descriptor_t v) const</div><div class="ttdef"><b>Definition</b> hmesh.cpp:829</div></div>
<div class="ttc" id="aclasshmesh__t_html_a49ab80e240a5f3555bde8db61739d685"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">hmesh_t::source</a></div><div class="ttdeci">vertex_descriptor_t source(const halfedge_descriptor_t &amp;h) const</div><div class="ttdef"><b>Definition</b> hmesh.cpp:135</div></div>
<div class="ttc" id="aclasshmesh__t_html_a56a93aa8ba1f69b11d91c8fb2a9b3913"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#a56a93aa8ba1f69b11d91c8fb2a9b3913">hmesh_t::is_border</a></div><div class="ttdeci">bool is_border(const halfedge_descriptor_t h)</div><div class="ttdef"><b>Definition</b> hmesh.cpp:244</div></div>
<div class="ttc" id="aclasshmesh__t_html_a64e5954a3578fded55d07fa8d5ec7bc0"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">hmesh_t::vertex</a></div><div class="ttdeci">vertex_descriptor_t vertex(const edge_descriptor_t e, const int v) const</div><div class="ttdef"><b>Definition</b> hmesh.cpp:219</div></div>
<div class="ttc" id="aclasshmesh__t_html_a682accc8af021cbd85eb03c91bc9fd0e"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#a682accc8af021cbd85eb03c91bc9fd0e">hmesh_t::null_halfedge</a></div><div class="ttdeci">static halfedge_descriptor_t null_halfedge()</div><div class="ttdef"><b>Definition</b> hmesh.cpp:97</div></div>
<div class="ttc" id="aclasshmesh__t_html_a7500af9f9f2d3b485dc144609ce25c2f"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">hmesh_t::target</a></div><div class="ttdeci">vertex_descriptor_t target(const halfedge_descriptor_t &amp;h) const</div><div class="ttdef"><b>Definition</b> hmesh.cpp:144</div></div>
<div class="ttc" id="aclasshmesh__t_html_a765a6f3b7249eb47135d246f6d301102"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#a765a6f3b7249eb47135d246f6d301102">hmesh_t::get_vertices_around_face</a></div><div class="ttdeci">std::vector&lt; vertex_descriptor_t &gt; get_vertices_around_face(const face_descriptor_t f, uint32_t prepend_offset=0) const</div><div class="ttdef"><b>Definition</b> hmesh.cpp:683</div></div>
<div class="ttc" id="aclasshmesh__t_html_a80ac49a03f1085744f5b121cc4acbf2c"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#a80ac49a03f1085744f5b121cc4acbf2c">hmesh_t::vertices_end</a></div><div class="ttdeci">vertex_array_iterator_t vertices_end() const</div><div class="ttdef"><b>Definition</b> hmesh.cpp:850</div></div>
<div class="ttc" id="aclasshmesh__t_html_a86f122fb5db56b6f79b21b657d3326f9"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#a86f122fb5db56b6f79b21b657d3326f9">hmesh_t::get_halfedges_around_face</a></div><div class="ttdeci">const std::vector&lt; halfedge_descriptor_t &gt; &amp; get_halfedges_around_face(const face_descriptor_t f) const</div><div class="ttdef"><b>Definition</b> hmesh.cpp:741</div></div>
<div class="ttc" id="aclasshmesh__t_html_a89e4f1f34dda0bdeced26bc71cb4a4fc"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#a89e4f1f34dda0bdeced26bc71cb4a4fc">hmesh_t::faces_end</a></div><div class="ttdeci">face_array_iterator_t faces_end() const</div><div class="ttdef"><b>Definition</b> hmesh.cpp:901</div></div>
<div class="ttc" id="aclasshmesh__t_html_a8d7c997988ef348807997c1b35d1ba62"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#a8d7c997988ef348807997c1b35d1ba62">hmesh_t::edges_begin</a></div><div class="ttdeci">edge_array_iterator_t edges_begin(bool account_for_removed_elems=true) const</div><div class="ttdef"><b>Definition</b> hmesh.cpp:855</div></div>
<div class="ttc" id="aclasshmesh__t_html_a913e50afe2e1dc220a379b1dbf8050d2"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#a913e50afe2e1dc220a379b1dbf8050d2">hmesh_t::faces_begin</a></div><div class="ttdeci">face_array_iterator_t faces_begin(bool account_for_removed_elems=true) const</div><div class="ttdef"><b>Definition</b> hmesh.cpp:889</div></div>
<div class="ttc" id="aclasshmesh__t_html_a96e9db918396b86f0b61f5445ef46b18"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#a96e9db918396b86f0b61f5445ef46b18">hmesh_t::edge</a></div><div class="ttdeci">edge_descriptor_t edge(const halfedge_descriptor_t &amp;h) const</div><div class="ttdef"><b>Definition</b> hmesh.cpp:199</div></div>
<div class="ttc" id="aclasshmesh__t_html_a9d7a7440367b78413f762626d2d7dd43"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#a9d7a7440367b78413f762626d2d7dd43">hmesh_t::next</a></div><div class="ttdeci">halfedge_descriptor_t next(const halfedge_descriptor_t &amp;h) const</div><div class="ttdef"><b>Definition</b> hmesh.cpp:172</div></div>
<div class="ttc" id="aclasshmesh__t_html_aa952ea0298d27de614e443c65ee15155"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">hmesh_t::face</a></div><div class="ttdeci">face_descriptor_t face(const halfedge_descriptor_t &amp;h) const</div><div class="ttdef"><b>Definition</b> hmesh.cpp:211</div></div>
<div class="ttc" id="aclasshmesh__t_html_aabb2a87d3b736883d381532fb871389e"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#aabb2a87d3b736883d381532fb871389e">hmesh_t::null_edge</a></div><div class="ttdeci">static edge_descriptor_t null_edge()</div><div class="ttdef"><b>Definition</b> hmesh.cpp:102</div></div>
<div class="ttc" id="aclasshmesh__t_html_ab448d0b9684fd2f648195b2e5edb83f2"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#ab448d0b9684fd2f648195b2e5edb83f2">hmesh_t::null_vertex</a></div><div class="ttdeci">static vertex_descriptor_t null_vertex()</div><div class="ttdef"><b>Definition</b> hmesh.cpp:92</div></div>
<div class="ttc" id="aclasshmesh__t_html_ab4bb1cdfa7306e352d20eb92417580ed"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#ab4bb1cdfa7306e352d20eb92417580ed">hmesh_t::prev</a></div><div class="ttdeci">halfedge_descriptor_t prev(const halfedge_descriptor_t &amp;h) const</div><div class="ttdef"><b>Definition</b> hmesh.cpp:164</div></div>
<div class="ttc" id="aclasshmesh__t_html_ac759578dea5f6dd7eebcef3f1a5af705"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#ac759578dea5f6dd7eebcef3f1a5af705">hmesh_t::number_of_edges</a></div><div class="ttdeci">int number_of_edges() const</div><div class="ttdef"><b>Definition</b> hmesh.cpp:120</div></div>
<div class="ttc" id="aclasshmesh__t_html_ae64649dd61e0c188c547c686abc8a19e"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#ae64649dd61e0c188c547c686abc8a19e">hmesh_t::add_edge</a></div><div class="ttdeci">halfedge_descriptor_t add_edge(const vertex_descriptor_t v0, const vertex_descriptor_t v1)</div><div class="ttdef"><b>Definition</b> hmesh.cpp:390</div></div>
<div class="ttc" id="aclasshmesh__t_html_af601050effa9292ffac4274918113712"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">hmesh_t::opposite</a></div><div class="ttdeci">halfedge_descriptor_t opposite(const halfedge_descriptor_t &amp;h) const</div><div class="ttdef"><b>Definition</b> hmesh.cpp:152</div></div>
<div class="ttc" id="aclasshmesh__t_html_af607b174b89bf1bf89c26672ef1647bb"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#af607b174b89bf1bf89c26672ef1647bb">hmesh_t::set_next</a></div><div class="ttdeci">void set_next(const halfedge_descriptor_t &amp;h, const halfedge_descriptor_t &amp;nxt)</div><div class="ttdef"><b>Definition</b> hmesh.cpp:180</div></div>
<div class="ttc" id="aclasshmesh__t_html_af78eb5785020a91476b847187b3b2b1a"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a></div><div class="ttdeci">static face_descriptor_t null_face()</div><div class="ttdef"><b>Definition</b> hmesh.cpp:107</div></div>
<div class="ttc" id="aclasslogger__t_html"><div class="ttname"><a href="../../d8/d0d/classlogger__t.html">logger_t</a></div><div class="ttdef"><b>Definition</b> utils.h:113</div></div>
<div class="ttc" id="aclasslogger__t_html_a03f98d9b0cd3e0fd02fcda7292f5f472"><div class="ttname"><a href="../../d8/d0d/classlogger__t.html#a03f98d9b0cd3e0fd02fcda7292f5f472">logger_t::verbose</a></div><div class="ttdeci">bool verbose()</div><div class="ttdef"><b>Definition</b> utils.h:155</div></div>
<div class="ttc" id="aclasslogger__t_html_a1722aff1cd74b1f30e9fdc4e07602fa2"><div class="ttname"><a href="../../d8/d0d/classlogger__t.html#a1722aff1cd74b1f30e9fdc4e07602fa2">logger_t::reset</a></div><div class="ttdeci">void reset()</div><div class="ttdef"><b>Definition</b> utils.h:165</div></div>
<div class="ttc" id="aclasslogger__t_html_a17b13679ad4d72b4b62c12e6083051ac"><div class="ttname"><a href="../../d8/d0d/classlogger__t.html#a17b13679ad4d72b4b62c12e6083051ac">logger_t::set_verbose</a></div><div class="ttdeci">void set_verbose(bool b)</div><div class="ttdef"><b>Definition</b> utils.h:160</div></div>
<div class="ttc" id="aclasslogger__t_html_aecaed21510eca7fa095e7176d9e36850"><div class="ttname"><a href="../../d8/d0d/classlogger__t.html#aecaed21510eca7fa095e7176d9e36850">logger_t::set_reason_for_failure</a></div><div class="ttdeci">void set_reason_for_failure(const std::string &amp;msg)</div><div class="ttdef"><b>Definition</b> utils.h:143</div></div>
<div class="ttc" id="aclassmatrix__t_html"><div class="ttname"><a href="../../df/d20/classmatrix__t.html">matrix_t</a></div><div class="ttdef"><b>Definition</b> math.h:241</div></div>
<div class="ttc" id="aclassmatrix__t_html_a5e16fcbd07f878c4efebe9d54fe37c49"><div class="ttname"><a href="../../df/d20/classmatrix__t.html#a5e16fcbd07f878c4efebe9d54fe37c49">matrix_t::cols</a></div><div class="ttdeci">int cols() const</div><div class="ttdef"><b>Definition</b> math.h:357</div></div>
<div class="ttc" id="aclassvec3___html"><div class="ttname"><a href="../../dd/d64/classvec3__.html">vec3_</a></div><div class="ttdef"><b>Definition</b> math.h:157</div></div>
<div class="ttc" id="aclassvertex__descriptor__t_html"><div class="ttname"><a href="../../de/dc8/classvertex__descriptor__t.html">vertex_descriptor_t</a></div><div class="ttdef"><b>Definition</b> hmesh.h:171</div></div>
<div class="ttc" id="ahmesh_8h_html_a4a483cf58ff6b716fbeba2dc8c76ffa1"><div class="ttname"><a href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a></div><div class="ttdeci">vertex_descriptor_t vd_t</div><div class="ttdef"><b>Definition</b> hmesh.h:440</div></div>
<div class="ttc" id="ahmesh_8h_html_a4b0f01185c259735e74598aa7cb52fc2"><div class="ttname"><a href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a></div><div class="ttdeci">halfedge_descriptor_t hd_t</div><div class="ttdef"><b>Definition</b> hmesh.h:441</div></div>
<div class="ttc" id="ahmesh_8h_html_a92abe1b30dc402b94e53318479d8b242"><div class="ttname"><a href="../../df/d77/hmesh_8h.html#a92abe1b30dc402b94e53318479d8b242">ed_t</a></div><div class="ttdeci">edge_descriptor_t ed_t</div><div class="ttdef"><b>Definition</b> hmesh.h:442</div></div>
<div class="ttc" id="ahmesh_8h_html_ac664ff0579ccea0a9ca27aaf2ffdcfcd"><div class="ttname"><a href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a></div><div class="ttdeci">face_descriptor_t fd_t</div><div class="ttdef"><b>Definition</b> hmesh.h:443</div></div>
<div class="ttc" id="akernel_8cpp_html_a0299dc00caf656e5713f528574c77a02"><div class="ttname"><a href="../../dd/d24/kernel_8cpp.html#a0299dc00caf656e5713f528574c77a02">resolve_intersection_point_descriptor</a></div><div class="ttdeci">vd_t resolve_intersection_point_descriptor(const hmesh_t &amp;ps, const hmesh_t &amp;m0, hmesh_t &amp;m1, const hd_t &amp;m0_h, const vd_t &amp;m0_h_tgt, const vd_t &amp;m1_h_tgt, const bool m0_h_is_ox, std::vector&lt; std::vector&lt; int &gt; &gt; &amp;m0_h_to_ply, std::unordered_map&lt; vd_t, std::vector&lt; hd_t &gt; &gt; &amp;ivtx_to_incoming_hlist, std::unordered_map&lt; hd_t, bool &gt; &amp;m0_sm_ihe_to_flag, const std::vector&lt; std::pair&lt; ed_t, fd_t &gt; &gt; &amp;m0_ivtx_to_intersection_registry_entry, std::unordered_map&lt; hd_t, hd_t &gt; &amp;m0_to_m1_ihe, const std::vector&lt; vd_t &gt; &amp;m0_to_ps_vtx, const int ps_vtx_cnt, const int sm_vtx_cnt, const int sm_face_count, const int m0_num_cutpath_halfedges)</div><div class="ttdef"><b>Definition</b> kernel.cpp:1184</div></div>
<div class="ttc" id="akernel_8cpp_html_a0a7bbc0e3b52fd64237a4e3525cbc09e"><div class="ttname"><a href="../../dd/d24/kernel_8cpp.html#a0a7bbc0e3b52fd64237a4e3525cbc09e">is_virtual_face</a></div><div class="ttdeci">bool is_virtual_face(const fd_t &amp;face)</div><div class="ttdef"><b>Definition</b> kernel.cpp:1127</div></div>
<div class="ttc" id="akernel_8cpp_html_a1b55223f27099f06cf4ef4442552eb3e"><div class="ttname"><a href="../../dd/d24/kernel_8cpp.html#a1b55223f27099f06cf4ef4442552eb3e">linear_projection_sort</a></div><div class="ttdeci">std::vector&lt; vd_t &gt; linear_projection_sort(const std::vector&lt; std::pair&lt; vd_t, vec3 &gt; &gt; &amp;points)</div><div class="ttdef"><b>Definition</b> kernel.cpp:1518</div></div>
<div class="ttc" id="akernel_8cpp_html_a22191ac3d02f34a43e21432ad2289f14"><div class="ttname"><a href="../../dd/d24/kernel_8cpp.html#a22191ac3d02f34a43e21432ad2289f14">logger_ptr</a></div><div class="ttdeci">logger_t * logger_ptr</div><div class="ttdef"><b>Definition</b> kernel.cpp:55</div></div>
<div class="ttc" id="akernel_8cpp_html_a263f562fbe3843b93d07f1b41eb4362e"><div class="ttname"><a href="../../dd/d24/kernel_8cpp.html#a263f562fbe3843b93d07f1b41eb4362e">update_neighouring_ps_iface_m0_edge_list</a></div><div class="ttdeci">void update_neighouring_ps_iface_m0_edge_list(const vd_t &amp;src_vertex, const vd_t &amp;tgt_vertex, const hmesh_t &amp;ps, const fd_t sm_face, const fd_t cs_face, const std::vector&lt; std::pair&lt; ed_t, fd_t &gt; &gt; &amp;m0_ivtx_to_intersection_registry_entry, std::unordered_map&lt; fd_t, std::vector&lt; ed_t &gt; &gt; &amp;ps_iface_to_m0_edge_list, const std::vector&lt; ed_t &gt; &amp;m0_cutpath_edges)</div><div class="ttdef"><b>Definition</b> kernel.cpp:1412</div></div>
<div class="ttc" id="akernel_8cpp_html_a34276907046e706af5626787b2e2b05a"><div class="ttname"><a href="../../dd/d24/kernel_8cpp.html#a34276907046e706af5626787b2e2b05a">extract_connected_components</a></div><div class="ttdeci">hmesh_t extract_connected_components(std::map&lt; std::size_t, std::vector&lt; std::pair&lt; std::shared_ptr&lt; hmesh_t &gt;, connected_component_info_t &gt; &gt; &gt; &amp;connected_components, const hmesh_t &amp;in, const int traced_polygons_base_offset, const std::vector&lt; std::vector&lt; hd_t &gt; &gt; &amp;mX_traced_polygons, const std::vector&lt; int &gt; &amp;sm_polygons_below_cs, const std::vector&lt; int &gt; &amp;sm_polygons_above_cs, const std::vector&lt; bool &gt; &amp;mesh_vertex_to_seam_flag, const std::vector&lt; vd_t &gt; &amp;m1_to_m0_sm_ovtx_colored, const std::unordered_map&lt; vd_t, vd_t &gt; &amp;m1_to_m0_cm_ovtx_colored, std::unordered_map&lt; int, int &gt; &amp;m1_to_m0_face_colored, const std::vector&lt; vd_t &gt; &amp;m0_to_ps_vtx, std::unordered_map&lt; int, fd_t &gt; &amp;m0_to_ps_face, const std::vector&lt; vd_t &gt; &amp;ps_to_sm_vtx, const std::vector&lt; fd_t &gt; &amp;ps_to_sm_face, const std::vector&lt; vd_t &gt; &amp;ps_to_cm_vtx, const std::vector&lt; fd_t &gt; &amp;ps_to_cm_face, const int sm_vtx_cnt, const int sm_face_count, bool popuplate_vertex_maps, bool popuplate_face_maps, bool keep_fragments_below_cutmesh, bool keep_fragments_above_cutmesh, bool keep_fragments_partially_cut)</div><div class="ttdef"><b>Definition</b> kernel.cpp:384</div></div>
<div class="ttc" id="akernel_8cpp_html_a426849b7f7105963c5e2767bdd31b155"><div class="ttname"><a href="../../dd/d24/kernel_8cpp.html#a426849b7f7105963c5e2767bdd31b155">ps_is_cutmesh_vertex</a></div><div class="ttdeci">bool ps_is_cutmesh_vertex(const vd_t &amp;ps_vd, const int sm_vtx_cnt)</div><div class="ttdef"><b>Definition</b> kernel.cpp:140</div></div>
<div class="ttc" id="akernel_8cpp_html_a7095d6c7279faa9121a2a2722a51a814"><div class="ttname"><a href="../../dd/d24/kernel_8cpp.html#a7095d6c7279faa9121a2a2722a51a814">mark_seam_vertices</a></div><div class="ttdeci">void mark_seam_vertices(std::vector&lt; bool &gt; &amp;mesh_seam_vertices, hmesh_t &amp;mesh, const int ps_num_vertices, const int m1_num_vertices_after_srcmesh_partitioning=std::numeric_limits&lt; int &gt;::max())</div><div class="ttdef"><b>Definition</b> kernel.cpp:368</div></div>
<div class="ttc" id="akernel_8cpp_html_a9bb440c35b34b7ecd91a6ce4eca6941e"><div class="ttname"><a href="../../dd/d24/kernel_8cpp.html#a9bb440c35b34b7ecd91a6ce4eca6941e">dump_mesh</a></div><div class="ttdeci">void dump_mesh(const hmesh_t &amp;mesh, const char *fbasename)</div><div class="ttdef"><b>Definition</b> kernel.cpp:150</div></div>
<div class="ttc" id="akernel_8cpp_html_a9c800ed2d7c13bb98e4f4fb2be59b53e"><div class="ttname"><a href="../../dd/d24/kernel_8cpp.html#a9c800ed2d7c13bb98e4f4fb2be59b53e">have_same_coordinate</a></div><div class="ttdeci">bool have_same_coordinate(const std::vector&lt; std::pair&lt; vd_t, vec3 &gt; &gt; &amp;bin_vertices_sorted, const int coordinate_index=0)</div><div class="ttdef"><b>Definition</b> kernel.cpp:1136</div></div>
<div class="ttc" id="akernel_8cpp_html_aa7de49b10bd8663a91f01e3beef776ff"><div class="ttname"><a href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a></div><div class="ttdeci">bool m0_is_intersection_point(const vd_t &amp;ps_vd, const int ps_vtx_cnt)</div><div class="ttdef"><b>Definition</b> kernel.cpp:134</div></div>
<div class="ttc" id="akernel_8cpp_html_aaf65fb11520f9cb197774e79efeddfbb"><div class="ttname"><a href="../../dd/d24/kernel_8cpp.html#aaf65fb11520f9cb197774e79efeddfbb">ps_is_cutmesh_face</a></div><div class="ttdeci">bool ps_is_cutmesh_face(const fd_t &amp;ps_fd, const int sm_face_count)</div><div class="ttdef"><b>Definition</b> kernel.cpp:145</div></div>
<div class="ttc" id="akernel_8cpp_html_abcaa230eb10486e26a5167bae360d451"><div class="ttname"><a href="../../dd/d24/kernel_8cpp.html#abcaa230eb10486e26a5167bae360d451">ps_get_ivtx_registry_entry_faces</a></div><div class="ttdeci">std::vector&lt; fd_t &gt; ps_get_ivtx_registry_entry_faces(const hmesh_t &amp;ps, const std::pair&lt; ed_t, fd_t &gt; &amp;ivtx_registry_entry)</div><div class="ttdef"><b>Definition</b> kernel.cpp:1399</div></div>
<div class="ttc" id="akernel_8cpp_html_ac170ee95cd3318133c47c23a4a4412b8"><div class="ttname"><a href="../../dd/d24/kernel_8cpp.html#ac170ee95cd3318133c47c23a4a4412b8">to_string</a></div><div class="ttdeci">std::string to_string(const sm_frag_location_t &amp;v)</div><div class="ttdef"><b>Definition</b> kernel.cpp:56</div></div>
<div class="ttc" id="akernel_8cpp_html_ad0e7884ca4d03bad54f0f83d198676e5"><div class="ttname"><a href="../../dd/d24/kernel_8cpp.html#ad0e7884ca4d03bad54f0f83d198676e5">m0_is_polygon_boundary_halfedge</a></div><div class="ttdeci">bool m0_is_polygon_boundary_halfedge(const hd_t &amp;h, uint32_t m0_num_cutpath_halfedges)</div><div class="ttdef"><b>Definition</b> kernel.cpp:1173</div></div>
<div class="ttc" id="akernel_8cpp_html_ad844a6457581698e69ccfa3e5199ebc9"><div class="ttname"><a href="../../dd/d24/kernel_8cpp.html#ad844a6457581698e69ccfa3e5199ebc9">traced_polygon_t</a></div><div class="ttdeci">std::vector&lt; hd_t &gt; traced_polygon_t</div><div class="ttdef"><b>Definition</b> kernel.cpp:1482</div></div>
<div class="ttc" id="akernel_8cpp_html_ae88bf8cfd20dbb5a5910da29eb700947"><div class="ttname"><a href="../../dd/d24/kernel_8cpp.html#ae88bf8cfd20dbb5a5910da29eb700947">mesh_is_closed</a></div><div class="ttdeci">bool mesh_is_closed(const hmesh_t &amp;mesh)</div><div class="ttdef"><b>Definition</b> kernel.cpp:1484</div></div>
<div class="ttc" id="akernel_8cpp_html_afee332fde04478605c5c0dc0105d50a9"><div class="ttname"><a href="../../dd/d24/kernel_8cpp.html#afee332fde04478605c5c0dc0105d50a9">lmsg</a></div><div class="ttdeci">#define lmsg()</div><div class="ttdef"><b>Definition</b> kernel.cpp:40</div></div>
<div class="ttc" id="akernel_8cpp_html_d7/dd7/structconnected__component__info__t"><div class="ttname"><a href="../../dd/d24/kernel_8cpp.html#d7/dd7/structconnected__component__info__t">connected_component_info_t</a></div><div class="ttdef"><b>Definition</b> kernel.cpp:358</div></div>
<div class="ttc" id="alzoconf_8h_html_a61569f2965b7a369eb10b6d75d410d11"><div class="ttname"><a href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a></div><div class="ttdeci">int</div><div class="ttdef"><b>Definition</b> lzoconf.h:340</div></div>
<div class="ttc" id="alzoconf_8h_html_a809275ccd755fb7b88661d952134b14d"><div class="ttname"><a href="../../de/d38/lzoconf_8h.html#a809275ccd755fb7b88661d952134b14d">size</a></div><div class="ttdeci">lzo_uint size</div><div class="ttdef"><b>Definition</b> lzoconf.h:378</div></div>
<div class="ttc" id="amath_8h_html_a0b6cff67f1f57a1096b42782cf5397da"><div class="ttname"><a href="../../df/db1/math_8h.html#a0b6cff67f1f57a1096b42782cf5397da">dot_product</a></div><div class="ttdeci">double dot_product(const vector_type &amp;a, const vector_type &amp;b)</div><div class="ttdef"><b>Definition</b> math.h:425</div></div>
<div class="ttc" id="amath_8h_html_a1d24f16459340cb796ff7bf6b7094108"><div class="ttname"><a href="../../df/db1/math_8h.html#a1d24f16459340cb796ff7bf6b7094108">normalize</a></div><div class="ttdeci">vector_type normalize(const vector_type &amp;v)</div><div class="ttdef"><b>Definition</b> math.h:480</div></div>
<div class="ttc" id="amath_8h_html_a2253a03334d0c9681225281db5a96928"><div class="ttname"><a href="../../df/db1/math_8h.html#a2253a03334d0c9681225281db5a96928">compute_segment_plane_intersection_type</a></div><div class="ttdeci">char compute_segment_plane_intersection_type(const vec3 &amp;q, const vec3 &amp;r, const std::vector&lt; vec3 &gt; &amp;polygon_vertices, const vec3 &amp;polygon_normal, const int polygon_normal_largest_component)</div><div class="ttdef"><b>Definition</b> math.cpp:257</div></div>
<div class="ttc" id="amath_8h_html_a35c50f5df223f546dec9cd74983abc38"><div class="ttname"><a href="../../df/db1/math_8h.html#a35c50f5df223f546dec9cd74983abc38">compute_segment_plane_intersection</a></div><div class="ttdeci">char compute_segment_plane_intersection(vec3 &amp;p, const vec3 &amp;normal, const double &amp;d_coeff, const vec3 &amp;q, const vec3 &amp;r)</div><div class="ttdef"><b>Definition</b> math.cpp:162</div></div>
<div class="ttc" id="amath_8h_html_a3a54064875b1b215da4904e90278a089"><div class="ttname"><a href="../../df/db1/math_8h.html#a3a54064875b1b215da4904e90278a089">length</a></div><div class="ttdeci">double length(const vector_type &amp;v)</div><div class="ttdef"><b>Definition</b> math.h:474</div></div>
<div class="ttc" id="amath_8h_html_a428603c304be386b3a1ce9cbc31cc328"><div class="ttname"><a href="../../df/db1/math_8h.html#a428603c304be386b3a1ce9cbc31cc328">intersect_bounding_boxes</a></div><div class="ttdeci">bool intersect_bounding_boxes(const bounding_box_t&lt; vec3_&lt; T &gt; &gt; &amp;a, const bounding_box_t&lt; vec3_&lt; T &gt; &gt; &amp;b)</div><div class="ttdef"><b>Definition</b> math.h:658</div></div>
<div class="ttc" id="amath_8h_html_a54f69876b05b83a7096e4bac9d0c3b13"><div class="ttname"><a href="../../df/db1/math_8h.html#a54f69876b05b83a7096e4bac9d0c3b13">compute_line_plane_intersection</a></div><div class="ttdeci">char compute_line_plane_intersection(vec3 &amp;p, const vec3 &amp;q, const vec3 &amp;r, const vec3 *polygon_vertices, const int polygon_vertex_count, const int polygon_normal_max_comp, const vec3 &amp;polygon_plane_normal)</div></div>
<div class="ttc" id="amath_8h_html_a5ac9a8399d477c88e7ab2e9e406015c6"><div class="ttname"><a href="../../df/db1/math_8h.html#a5ac9a8399d477c88e7ab2e9e406015c6">squared_length</a></div><div class="ttdeci">double squared_length(const vector_type &amp;v)</div><div class="ttdef"><b>Definition</b> math.h:468</div></div>
<div class="ttc" id="amath_8h_html_a6912657a051f0b1fc01a0d3095158b43a62d66a51fa7574c652597716f7709865"><div class="ttname"><a href="../../df/db1/math_8h.html#a6912657a051f0b1fc01a0d3095158b43a62d66a51fa7574c652597716f7709865">NEGATIVE</a></div><div class="ttdeci">@ NEGATIVE</div><div class="ttdef"><b>Definition</b> math.h:41</div></div>
<div class="ttc" id="amath_8h_html_a82a9c1f090b54dc1416ca1c3673ef5d7"><div class="ttname"><a href="../../df/db1/math_8h.html#a82a9c1f090b54dc1416ca1c3673ef5d7">compute_point_in_polygon_test</a></div><div class="ttdeci">char compute_point_in_polygon_test(const vec2 &amp;q, const std::vector&lt; vec2 &gt; &amp;polygon_vertices)</div><div class="ttdef"><b>Definition</b> math.cpp:415</div></div>
<div class="ttc" id="amath_8h_html_aadd997d85262028302f802864dea9f6c"><div class="ttname"><a href="../../df/db1/math_8h.html#aadd997d85262028302f802864dea9f6c">compute_polygon_plane_coefficients</a></div><div class="ttdeci">int compute_polygon_plane_coefficients(vec3 &amp;normal, double &amp;d_coeff, const vec3 *polygon_vertices, const int polygon_vertex_count)</div><div class="ttdef"><b>Definition</b> math.cpp:124</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a05468f8c497387b56c09f9b6105ec418"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a05468f8c497387b56c09f9b6105ec418">output_t::logger</a></div><div class="ttdeci">logger_t logger</div><div class="ttdef"><b>Definition</b> kernel.h:188</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a058fa7a2d90c7ead6282f1810cebb731"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a058fa7a2d90c7ead6282f1810cebb731">output_t::outside_patches</a></div><div class="ttdeci">std::map&lt; cm_patch_winding_order_t, std::vector&lt; std::shared_ptr&lt; output_mesh_info_t &gt; &gt; &gt; outside_patches</div><div class="ttdef"><b>Definition</b> kernel.h:194</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a07e9992982b4f9497d1499f1cfb2826d"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a07e9992982b4f9497d1499f1cfb2826d">input_t::keep_fragments_below_cutmesh</a></div><div class="ttdeci">bool keep_fragments_below_cutmesh</div><div class="ttdef"><b>Definition</b> kernel.h:146</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a08cabee26121d0fa4313c5960975b9d8"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a08cabee26121d0fa4313c5960975b9d8">output_t::connected_components</a></div><div class="ttdeci">std::map&lt; sm_frag_location_t, std::map&lt; cm_patch_location_t, std::vector&lt; std::shared_ptr&lt; output_mesh_info_t &gt; &gt; &gt; &gt; connected_components</div><div class="ttdef"><b>Definition</b> kernel.h:190</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a09475ec58d62ab7e47b2e880a6909956"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956">cm_patch_location_t</a></div><div class="ttdeci">cm_patch_location_t</div><div class="ttdef"><b>Definition</b> kernel.h:78</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a09475ec58d62ab7e47b2e880a6909956a554a7418c4c0dafd902ebd377b87c80c"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956a554a7418c4c0dafd902ebd377b87c80c">cm_patch_location_t::INSIDE</a></div><div class="ttdeci">@ INSIDE</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a09475ec58d62ab7e47b2e880a6909956a93da25bafef6761717afc6b25c17ea16"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956a93da25bafef6761717afc6b25c17ea16">cm_patch_location_t::OUTSIDE</a></div><div class="ttdeci">@ OUTSIDE</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a0b23c3ae4df4369125ff8b489a42260b"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a0b23c3ae4df4369125ff8b489a42260b">input_t::populate_vertex_maps</a></div><div class="ttdeci">bool populate_vertex_maps</div><div class="ttdef"><b>Definition</b> kernel.h:131</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a18ab3e0c7ed366d45a0c1aaccddc4eee"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a18ab3e0c7ed366d45a0c1aaccddc4eee">input_t::keep_fragments_sealed_inside_exhaustive</a></div><div class="ttdeci">bool keep_fragments_sealed_inside_exhaustive</div><div class="ttdef"><b>Definition</b> kernel.h:153</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a1e245a3c69ddc2f357fa5bbcb837dc8e"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a1e245a3c69ddc2f357fa5bbcb837dc8e">input_t::keep_srcmesh_seam</a></div><div class="ttdeci">bool keep_srcmesh_seam</div><div class="ttdef"><b>Definition</b> kernel.h:138</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a212140a3fcc6fafadaf91ec04e4840c7"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a212140a3fcc6fafadaf91ec04e4840c7">output_t::inside_patches</a></div><div class="ttdeci">std::map&lt; cm_patch_winding_order_t, std::vector&lt; std::shared_ptr&lt; output_mesh_info_t &gt; &gt; &gt; inside_patches</div><div class="ttdef"><b>Definition</b> kernel.h:193</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a2978b29712123e54d4098c4e83679f83"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a2978b29712123e54d4098c4e83679f83">input_t::source_hmesh_BVH</a></div><div class="ttdeci">BoundingVolumeHierarchy * source_hmesh_BVH</div><div class="ttdef"><b>Definition</b> kernel.h:125</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a2e0e9766f9dd9d594f607e107c855e26"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a2e0e9766f9dd9d594f607e107c855e26">input_t::keep_unsealed_fragments</a></div><div class="ttdeci">bool keep_unsealed_fragments</div><div class="ttdef"><b>Definition</b> kernel.h:141</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a353f1f2c3cc7f006065052026878d7e2"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a353f1f2c3cc7f006065052026878d7e2">output_t::seamed_cut_mesh</a></div><div class="ttdeci">std::shared_ptr&lt; output_mesh_info_t &gt; seamed_cut_mesh</div><div class="ttdef"><b>Definition</b> kernel.h:198</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a4d23d907262b78c2d865f4d52bb65757"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a4d23d907262b78c2d865f4d52bb65757">input_t::keep_fragments_sealed_inside</a></div><div class="ttdeci">bool keep_fragments_sealed_inside</div><div class="ttdef"><b>Definition</b> kernel.h:150</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a537b5e59975d86fe000126788c87b4eb"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a537b5e59975d86fe000126788c87b4eb">floating_polygon_info_t::polygon_normal</a></div><div class="ttdeci">vec3 polygon_normal</div><div class="ttdef"><b>Definition</b> kernel.h:103</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a56c95c706afd7615de473f7e46c6fb35"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a56c95c706afd7615de473f7e46c6fb35">output_t::unsealed_cc</a></div><div class="ttdeci">std::map&lt; sm_frag_location_t, std::vector&lt; std::shared_ptr&lt; output_mesh_info_t &gt; &gt; &gt; unsealed_cc</div><div class="ttdef"><b>Definition</b> kernel.h:191</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a5793da463db7c7b18aab5817d243c875"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a5793da463db7c7b18aab5817d243c875">input_t::enforce_general_position</a></div><div class="ttdeci">bool enforce_general_position</div><div class="ttdef"><b>Definition</b> kernel.h:133</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a6558e59317164c8e7d141f2f8fce00b5"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a6558e59317164c8e7d141f2f8fce00b5">input_t::keep_fragments_partially_cut</a></div><div class="ttdeci">bool keep_fragments_partially_cut</div><div class="ttdef"><b>Definition</b> kernel.h:149</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a69d05b5eabcaa02ad142e51104f16502"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a69d05b5eabcaa02ad142e51104f16502">input_t::keep_inside_patches</a></div><div class="ttdeci">bool keep_inside_patches</div><div class="ttdef"><b>Definition</b> kernel.h:143</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a70dd466fbfb5cfaaff8a0936766247f4"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a70dd466fbfb5cfaaff8a0936766247f4">output_t::seamed_src_mesh</a></div><div class="ttdeci">std::shared_ptr&lt; output_mesh_info_t &gt; seamed_src_mesh</div><div class="ttdef"><b>Definition</b> kernel.h:197</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a719e59e63d8bf7d7c665f69d3213327b"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a719e59e63d8bf7d7c665f69d3213327b">input_t::keep_fragments_sealed_outside_exhaustive</a></div><div class="ttdeci">bool keep_fragments_sealed_outside_exhaustive</div><div class="ttdef"><b>Definition</b> kernel.h:154</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a7bb3038442d8cb6a12416126e3b62d14"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a7bb3038442d8cb6a12416126e3b62d14">floating_polygon_info_t::polygon_normal_largest_component</a></div><div class="ttdeci">int polygon_normal_largest_component</div><div class="ttdef"><b>Definition</b> kernel.h:104</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a7d4c902daa6f0439e388496967885dd9"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a7d4c902daa6f0439e388496967885dd9">output_t::status</a></div><div class="ttdeci">status_t status</div><div class="ttdef"><b>Definition</b> kernel.h:185</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a8307155337693cbe5ebf0f61ea8ffd81"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8307155337693cbe5ebf0f61ea8ffd81">input_t::populate_face_maps</a></div><div class="ttdeci">bool populate_face_maps</div><div class="ttdef"><b>Definition</b> kernel.h:132</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a88f0d79acfc8973750f0c0ac49b661cb"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a88f0d79acfc8973750f0c0ac49b661cb">input_t::cut_hmesh_BVH</a></div><div class="ttdeci">BoundingVolumeHierarchy * cut_hmesh_BVH</div><div class="ttdef"><b>Definition</b> kernel.h:126</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a8ad08f78bc8be7a6cbd0494282ebf00d"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8ad08f78bc8be7a6cbd0494282ebf00d">output_t::detected_floating_polygons</a></div><div class="ttdeci">std::map&lt; fd_t, std::vector&lt; floating_polygon_info_t &gt; &gt; detected_floating_polygons</div><div class="ttdef"><b>Definition</b> kernel.h:209</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a8b2ff5d52c3860c53928326dddc24ff9"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a8b2ff5d52c3860c53928326dddc24ff9">input_t::ps_face_to_potentially_intersecting_others</a></div><div class="ttdeci">const std::map&lt; fd_t, std::vector&lt; fd_t &gt; &gt; * ps_face_to_potentially_intersecting_others</div><div class="ttdef"><b>Definition</b> kernel.h:120</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_ababb18b60ba667267d374ba263e889af"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#ababb18b60ba667267d374ba263e889af">input_t::keep_fragments_above_cutmesh</a></div><div class="ttdeci">bool keep_fragments_above_cutmesh</div><div class="ttdef"><b>Definition</b> kernel.h:147</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_ac2f62986e978053577e509597be851e7"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#ac2f62986e978053577e509597be851e7">input_t::cut_mesh</a></div><div class="ttdeci">std::shared_ptr&lt; hmesh_t &gt; cut_mesh</div><div class="ttdef"><b>Definition</b> kernel.h:117</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_acbacc55f2163529291e5a45671fed3d1"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#acbacc55f2163529291e5a45671fed3d1">input_t::verbose</a></div><div class="ttdeci">bool verbose</div><div class="ttdef"><b>Definition</b> kernel.h:128</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_acddb106c53c82046d8f6c4f85268c497"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#acddb106c53c82046d8f6c4f85268c497">floating_polygon_info_t::polygon_vertices</a></div><div class="ttdeci">std::vector&lt; vec3 &gt; polygon_vertices</div><div class="ttdef"><b>Definition</b> kernel.h:106</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_adc6ef77d23b46f2f9eec5c968e43c030"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#adc6ef77d23b46f2f9eec5c968e43c030">input_t::keep_cutmesh_seam</a></div><div class="ttdeci">bool keep_cutmesh_seam</div><div class="ttdef"><b>Definition</b> kernel.h:139</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_ae375f46b52762e0a296490cf704c47eb"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#ae375f46b52762e0a296490cf704c47eb">point_on_face_plane</a></div><div class="ttdeci">bool point_on_face_plane(const hmesh_t &amp;m, const fd_t &amp;f, const vec3 &amp;p, int &amp;fv_count)</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_af1d9592385500dcceb4384ed823bb850"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af1d9592385500dcceb4384ed823bb850">input_t::general_position_enforcement_count</a></div><div class="ttdeci">int general_position_enforcement_count</div><div class="ttdef"><b>Definition</b> kernel.h:135</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_af5ee3a08c24f72b6d9f88a2a651159d1"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af5ee3a08c24f72b6d9f88a2a651159d1">input_t::keep_outside_patches</a></div><div class="ttdeci">bool keep_outside_patches</div><div class="ttdef"><b>Definition</b> kernel.h:144</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_af6a1bc1df77e026c551054fb7c3752bc"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af6a1bc1df77e026c551054fb7c3752bc">input_t::require_looped_cutpaths</a></div><div class="ttdeci">bool require_looped_cutpaths</div><div class="ttdef"><b>Definition</b> kernel.h:130</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_af9bff8ff1154a04a899276af806b8586"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a></div><div class="ttdeci">status_t</div><div class="ttdef"><b>Definition</b> kernel.h:38</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_af9bff8ff1154a04a899276af806b8586a1919962cb3db319ec5b0563a93a68d8a"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a1919962cb3db319ec5b0563a93a68d8a">status_t::INVALID_MESH_INTERSECTION</a></div><div class="ttdeci">@ INVALID_MESH_INTERSECTION</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_af9bff8ff1154a04a899276af806b8586a4f41dc6e379aa2a8afaaee78c29c85ec"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a4f41dc6e379aa2a8afaaee78c29c85ec">status_t::INVALID_SRC_MESH</a></div><div class="ttdeci">@ INVALID_SRC_MESH</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_af9bff8ff1154a04a899276af806b8586a86987e2e179fda428149b6ccce3fb9ab"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a86987e2e179fda428149b6ccce3fb9ab">status_t::DETECTED_FLOATING_POLYGON</a></div><div class="ttdeci">@ DETECTED_FLOATING_POLYGON</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_af9bff8ff1154a04a899276af806b8586a8737035059b46024b097c7e96031ee2e"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a8737035059b46024b097c7e96031ee2e">status_t::INVALID_CUT_MESH</a></div><div class="ttdeci">@ INVALID_CUT_MESH</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_af9bff8ff1154a04a899276af806b8586a91712b49b91fbf59087df24104715e29"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a91712b49b91fbf59087df24104715e29">status_t::GENERAL_POSITION_VIOLATION</a></div><div class="ttdeci">@ GENERAL_POSITION_VIOLATION</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_af9bff8ff1154a04a899276af806b8586ad0749aaba8b833466dfcbb0428e4f89c"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586ad0749aaba8b833466dfcbb0428e4f89c">status_t::SUCCESS</a></div><div class="ttdeci">@ SUCCESS</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_afee9c1311968896d08db6237842de68d"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#afee9c1311968896d08db6237842de68d">input_t::src_mesh</a></div><div class="ttdeci">std::shared_ptr&lt; hmesh_t &gt; src_mesh</div><div class="ttdef"><b>Definition</b> kernel.h:116</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_aff3651e310bd220d4f65bd450af94f16"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#aff3651e310bd220d4f65bd450af94f16">input_t::keep_fragments_sealed_outside</a></div><div class="ttdeci">bool keep_fragments_sealed_outside</div><div class="ttdef"><b>Definition</b> kernel.h:151</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_afff2632fef27a069a33f81a0b51400f3"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#afff2632fef27a069a33f81a0b51400f3">cm_patch_winding_order_t</a></div><div class="ttdeci">cm_patch_winding_order_t</div><div class="ttdef"><b>Definition</b> kernel.h:96</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_afff2632fef27a069a33f81a0b51400f3a5b39c8b553c821e7cddc6da64b5bd2ee"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#afff2632fef27a069a33f81a0b51400f3a5b39c8b553c821e7cddc6da64b5bd2ee">cm_patch_winding_order_t::DEFAULT</a></div><div class="ttdeci">@ DEFAULT</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_afff2632fef27a069a33f81a0b51400f3a642e0b6684e6165e142c074f1cd8d55c"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#afff2632fef27a069a33f81a0b51400f3a642e0b6684e6165e142c074f1cd8d55c">cm_patch_winding_order_t::REVERSE</a></div><div class="ttdeci">@ REVERSE</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_dd/d1d/structfloating__polygon__info__t"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#dd/d1d/structfloating__polygon__info__t">floating_polygon_info_t</a></div><div class="ttdef"><b>Definition</b> kernel.h:101</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_de/de4/structoutput__mesh__info__t"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#de/de4/structoutput__mesh__info__t">output_mesh_info_t</a></div><div class="ttdef"><b>Definition</b> kernel.h:171</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2timer_8h_html_a94de28d8a4c3b764f6a3bd2097882054"><div class="ttname"><a href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a></div><div class="ttdeci">#define TIMESTACK_POP()</div><div class="ttdef"><b>Definition</b> timer.h:81</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2timer_8h_html_aa7edcadd4024f703ce9677fd1fe4dc84"><div class="ttname"><a href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a></div><div class="ttdeci">#define TIMESTACK_PUSH(name)</div><div class="ttdef"><b>Definition</b> timer.h:80</div></div>
<div class="ttc" id="anamespace_slic3r_1_1sla_1_1anonymous__namespace_02_rotfinder_8cpp_03_html_a9702d7dc6b0a37966d1157909ff81294"><div class="ttname"><a href="../../dd/d3d/namespace_slic3r_1_1sla_1_1anonymous__namespace_02_rotfinder_8cpp_03.html#a9702d7dc6b0a37966d1157909ff81294">Slic3r::sla::anonymous_namespace{Rotfinder.cpp}::normal</a></div><div class="ttdeci">Vec&lt; 3, T &gt; normal(const std::array&lt; Vec&lt; 3, T &gt;, 3 &gt; &amp;tri)</div><div class="ttdef"><b>Definition</b> Rotfinder.cpp:43</div></div>
<div class="ttc" id="anamespaceigl_html_a39d02bea0e57dce707ada6bc3228d22a"><div class="ttname"><a href="../../dc/d25/namespaceigl.html#a39d02bea0e57dce707ada6bc3228d22a">igl::is_boundary_edge</a></div><div class="ttdeci">void is_boundary_edge(const Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;B)</div><div class="ttdef"><b>Definition</b> is_boundary_edge.cpp:16</div></div>
<div class="ttc" id="anamespaceigl_html_a3b5976f2a4f7e21f45466b9151e59c94"><div class="ttname"><a href="../../dc/d25/namespaceigl.html#a3b5976f2a4f7e21f45466b9151e59c94">igl::intersect</a></div><div class="ttdeci">IGL_INLINE void intersect(const M &amp;A, const M &amp;B, M &amp;C)</div><div class="ttdef"><b>Definition</b> intersect.cpp:10</div></div>
<div class="ttc" id="anamespaceigl_html_abd8cd3f9a4ecc153494f4aab80ad881e"><div class="ttname"><a href="../../dc/d25/namespaceigl.html#abd8cd3f9a4ecc153494f4aab80ad881e">igl::dot</a></div><div class="ttdeci">IGL_INLINE double dot(const double *a, const double *b)</div><div class="ttdef"><b>Definition</b> dot.cpp:11</div></div>
<div class="ttc" id="anamespacelibnest2d_1_1shapelike_html_a2cf3480dc2a3b7f0c08c7e0028492210"><div class="ttname"><a href="../../dd/d66/namespacelibnest2d_1_1shapelike.html#a2cf3480dc2a3b7f0c08c7e0028492210">libnest2d::shapelike::vertex</a></div><div class="ttdeci">TPoint&lt; S &gt; &amp; vertex(S &amp;sh, unsigned long idx, const PolygonTag &amp;)</div><div class="ttdef"><b>Definition</b> geometry_traits.hpp:1197</div></div>
<div class="ttc" id="anamespacelibnest2d_1_1shapelike_html_ab0e9f75b95a950d0262d29654d15e123"><div class="ttname"><a href="../../dd/d66/namespacelibnest2d_1_1shapelike.html#ab0e9f75b95a950d0262d29654d15e123">libnest2d::shapelike::cend</a></div><div class="ttdeci">S::const_iterator cend(const S &amp;sh, const PathTag &amp;)</div><div class="ttdef"><b>Definition</b> geometry_traits.hpp:647</div></div>
<div class="ttc" id="anamespacelibnest2d_1_1shapelike_html_ae20480bfb433b47626e2e0e9188f8bb8"><div class="ttname"><a href="../../dd/d66/namespacelibnest2d_1_1shapelike.html#ae20480bfb433b47626e2e0e9188f8bb8">libnest2d::shapelike::cbegin</a></div><div class="ttdeci">S::const_iterator cbegin(const S &amp;sh, const PathTag &amp;)</div><div class="ttdef"><b>Definition</b> geometry_traits.hpp:640</div></div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="../../d8/dcc/namespacestd.html">std</a></div><div class="ttdoc">STL namespace.</div></div>
<div class="ttc" id="anamespacestd_html_af4bc231d061945eb59dbba98a117ece9"><div class="ttname"><a href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a></div><div class="ttdeci">edge_array_iterator_t::difference_type distance(edge_array_iterator_t first, edge_array_iterator_t last)</div><div class="ttdef"><b>Definition</b> hmesh.h:582</div></div>
<div class="ttc" id="astructbounding__box__t_html"><div class="ttname"><a href="../../df/d33/structbounding__box__t.html">bounding_box_t</a></div><div class="ttdef"><b>Definition</b> math.h:593</div></div>
<div class="ttc" id="astructbounding__box__t_html_a509cc2d8470f62eec4927f94e12ddb89"><div class="ttname"><a href="../../df/d33/structbounding__box__t.html#a509cc2d8470f62eec4927f94e12ddb89">bounding_box_t::expand</a></div><div class="ttdeci">void expand(const vector_type &amp;point)</div><div class="ttdef"><b>Definition</b> math.h:620</div></div>
<div class="ttc" id="astructpair_html"><div class="ttname"><a href="../../df/de8/structpair.html">pair</a></div><div class="ttdef"><b>Definition</b> utils.h:230</div></div>
<div class="ttc" id="atestmini_8c_html_ad9e5eed42092079dea4d90550ff5fcf0"><div class="ttname"><a href="../../d7/da4/testmini_8c.html#ad9e5eed42092079dea4d90550ff5fcf0">out</a></div><div class="ttdeci">static unsigned char __LZO_MMODEL out[OUT_LEN]</div><div class="ttdef"><b>Definition</b> testmini.c:58</div></div>
<div class="ttc" id="atpool_8h_html_a48d2e68725f7691f1422697f4c359827"><div class="ttname"><a href="../../df/d05/tpool_8h.html#a48d2e68725f7691f1422697f4c359827">parallel_for</a></div><div class="ttdeci">void parallel_for(thread_pool &amp;pool, const InputStorageIteratorType &amp;first, const InputStorageIteratorType &amp;last, FunctionType &amp;task_func, OutputStorageType &amp;master_thread_output, std::vector&lt; std::future&lt; OutputStorageType &gt; &gt; &amp;futures, const uint32_t min_per_thread=(1&lt;&lt; 10))</div><div class="ttdef"><b>Definition</b> tpool.h:406</div></div>
<div class="ttc" id="atpool_8h_html_ae3cfa32999d5b05486b216557bab41d3"><div class="ttname"><a href="../../df/d05/tpool_8h.html#ae3cfa32999d5b05486b216557bab41d3">parallel_find_in_map_by_key</a></div><div class="ttdeci">Iterator parallel_find_in_map_by_key(thread_pool &amp;pool, Iterator first, Iterator last, KeyType match)</div><div class="ttdef"><b>Definition</b> tpool.h:731</div></div>
<div class="ttc" id="autils_8h_html_a192a6876488933a545c507187414de46"><div class="ttname"><a href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a></div><div class="ttdeci">#define MCUT_ASSERT(a)</div><div class="ttdef"><b>Definition</b> utils.h:62</div></div>
<div class="ttc" id="autils_8h_html_ad365c8c3344c9156ff85f9122be357ac"><div class="ttname"><a href="../../d5/d60/utils_8h.html#ad365c8c3344c9156ff85f9122be357ac">make_pair</a></div><div class="ttdeci">pair&lt; T &gt; make_pair(const T a, const T b)</div><div class="ttdef"><b>Definition</b> utils.h:238</div></div>
<div class="ttc" id="autils_8h_html_ad42d4789f60996516823b4b4cfb9c04d"><div class="ttname"><a href="../../d5/d60/utils_8h.html#ad42d4789f60996516823b4b4cfb9c04d">wrap_integer</a></div><div class="ttdeci">static int wrap_integer(int x, const int lo, const int hi)</div><div class="ttdef"><b>Definition</b> utils.h:102</div></div>
<div class="ttc" id="axmltok__impl_8inc_html_a0daef2d817750da6dd6df041157e8aba"><div class="ttname"><a href="../../d2/d86/xmltok__impl_8inc.html#a0daef2d817750da6dd6df041157e8aba">return</a></div><div class="ttdeci">for(;HAS_CHAR(enc, ptr, end);ptr+=MINBPC(enc)) return</div><div class="ttdef"><b>Definition</b> xmltok_impl.inc:1372</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00390">hmesh_t::add_edge()</a>, <a class="el" href="../../#l00507">hmesh_t::add_face()</a>, <a class="el" href="../../#l00348">hmesh_t::add_vertex()</a>, <a class="el" href="../../df/db1/math_8h.html#a54f69876b05b83a7096e4bac9d0c3b13">compute_line_plane_intersection()</a>, <a class="el" href="../../#l00415">compute_point_in_polygon_test()</a>, <a class="el" href="../../#l00124">compute_polygon_plane_coefficients()</a>, <a class="el" href="../../#l00162">compute_segment_plane_intersection()</a>, <a class="el" href="../../#l00257">compute_segment_plane_intersection_type()</a>, <a class="el" href="../../#l00126">input_t::cut_hmesh_BVH</a>, <a class="el" href="../../#l00117">input_t::cut_mesh</a>, <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a86987e2e179fda428149b6ccce3fb9ab">DETECTED_FLOATING_POLYGON</a>, <a class="el" href="../../#l00209">output_t::detected_floating_polygons</a>, <a class="el" href="../../#l00582">std::distance()</a>, <a class="el" href="../../#l00425">dot_product()</a>, <a class="el" href="../../#l00150">dump_mesh()</a>, <a class="el" href="../../#l00199">hmesh_t::edge()</a>, <a class="el" href="../../#l00855">hmesh_t::edges_begin()</a>, <a class="el" href="../../#l00867">hmesh_t::edges_end()</a>, <a class="el" href="../../#l00133">input_t::enforce_general_position</a>, <a class="el" href="../../#l00620">bounding_box_t&lt; vector_type &gt;::expand()</a>, <a class="el" href="../../#l00211">hmesh_t::face()</a>, <a class="el" href="../../#l00889">hmesh_t::faces_begin()</a>, <a class="el" href="../../#l00901">hmesh_t::faces_end()</a>, <a class="el" href="../../#l00135">input_t::general_position_enforcement_count</a>, <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a91712b49b91fbf59087df24104715e29">GENERAL_POSITION_VIOLATION</a>, <a class="el" href="../../#l00748">hmesh_t::get_faces_around_face()</a>, <a class="el" href="../../#l00741">hmesh_t::get_halfedges_around_face()</a>, <a class="el" href="../../#l00683">hmesh_t::get_vertices_around_face()</a>, <a class="el" href="../../#l00261">hmesh_t::halfedge()</a>, <a class="el" href="../../#l01136">have_same_coordinate()</a>, <a class="el" href="../../#l00340">int</a>, <a class="el" href="../../#l00658">intersect_bounding_boxes()</a>, <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a8737035059b46024b097c7e96031ee2e">INVALID_CUT_MESH</a>, <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a1919962cb3db319ec5b0563a93a68d8a">INVALID_MESH_INTERSECTION</a>, <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a4f41dc6e379aa2a8afaaee78c29c85ec">INVALID_SRC_MESH</a>, <a class="el" href="../../#l00244">hmesh_t::is_border()</a>, <a class="el" href="../../#l01127">is_virtual_face()</a>, <a class="el" href="../../#l00474">length()</a>, <a class="el" href="../../#l01518">linear_projection_sort()</a>, <a class="el" href="../../#l00040">lmsg</a>, <a class="el" href="../../#l00188">output_t::logger</a>, <a class="el" href="../../#l00055">logger_ptr</a>, <a class="el" href="../../#l00134">m0_is_intersection_point()</a>, <a class="el" href="../../#l00238">make_pair()</a>, <a class="el" href="../../#l00062">MCUT_ASSERT</a>, <a class="el" href="../../#l01484">mesh_is_closed()</a>, <a class="el" href="../../#l00480">normalize()</a>, <a class="el" href="../../#l00102">hmesh_t::null_edge()</a>, <a class="el" href="../../#l00107">hmesh_t::null_face()</a>, <a class="el" href="../../#l00097">hmesh_t::null_halfedge()</a>, <a class="el" href="../../#l00092">hmesh_t::null_vertex()</a>, <a class="el" href="../../#l00120">hmesh_t::number_of_edges()</a>, <a class="el" href="../../#l00130">hmesh_t::number_of_faces()</a>, <a class="el" href="../../#l00115">hmesh_t::number_of_vertices()</a>, <a class="el" href="../../#l00152">hmesh_t::opposite()</a>, <a class="el" href="../../#l00406">parallel_for()</a>, <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#ae375f46b52762e0a296490cf704c47eb">point_on_face_plane()</a>, <a class="el" href="../../#l00103">floating_polygon_info_t::polygon_normal</a>, <a class="el" href="../../#l00104">floating_polygon_info_t::polygon_normal_largest_component</a>, <a class="el" href="../../#l00106">floating_polygon_info_t::polygon_vertices</a>, <a class="el" href="../../#l00120">input_t::ps_face_to_potentially_intersecting_others</a>, <a class="el" href="../../#l01399">ps_get_ivtx_registry_entry_faces()</a>, <a class="el" href="../../#l00145">ps_is_cutmesh_face()</a>, <a class="el" href="../../#l00140">ps_is_cutmesh_vertex()</a>, <a class="el" href="../../#l00130">input_t::require_looped_cutpaths</a>, <a class="el" href="../../#l01174">hmesh_t::reserve_for_additional_elements()</a>, <a class="el" href="../../#l00165">logger_t::reset()</a>, <a class="el" href="../../#l00097">SAFE_ACCESS</a>, <a class="el" href="../../#l00143">logger_t::set_reason_for_failure()</a>, <a class="el" href="../../#l00160">logger_t::set_verbose()</a>, <a class="el" href="../../#l00135">hmesh_t::source()</a>, <a class="el" href="../../#l00125">input_t::source_hmesh_BVH</a>, <a class="el" href="../../#l00468">squared_length()</a>, <a class="el" href="../../#l00116">input_t::src_mesh</a>, <a class="el" href="../../#l00185">output_t::status</a>, <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586ad0749aaba8b833466dfcbb0428e4f89c">SUCCESS</a>, <a class="el" href="../../#l00144">hmesh_t::target()</a>, <a class="el" href="../../#l00081">TIMESTACK_POP</a>, <a class="el" href="../../#l00080">TIMESTACK_PUSH</a>, <a class="el" href="../../#l01412">update_neighouring_ps_iface_m0_edge_list()</a>, <a class="el" href="../../#l00128">input_t::verbose</a>, <a class="el" href="../../#l00219">hmesh_t::vertex()</a>, <a class="el" href="../../#l00838">hmesh_t::vertices_begin()</a>, and <a class="el" href="../../#l00850">hmesh_t::vertices_end()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../#l01276">preproc()</a>.</p>
<div id="dynsection-4" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-4-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-4-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-4-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../dd/d24/kernel_8cpp_a16c30c80a68a0e6cab12250e5cd7b0d6_icgraph.svg" width="194" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a9bb440c35b34b7ecd91a6ce4eca6941e" name="a9bb440c35b34b7ecd91a6ce4eca6941e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb440c35b34b7ecd91a6ce4eca6941e">&#9670;&#160;</a></span>dump_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d95/glu-libtess_8h.html#a4292190e3f1f6b373a760c7d9316ad3c">void</a> dump_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fbasename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  151</span>{</div>
<div class="line"><span class="lineno">  152</span>    <span class="keyword">const</span> std::string name = std::string(fbasename) + <span class="stringliteral">&quot;.off&quot;</span>;</div>
<div class="line"><span class="lineno">  153</span> </div>
<div class="line"><span class="lineno">  154</span>    <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">vertex_array_iterator_t</a> v = mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a0bf160ae73193f77064cc3d8f01e63a3">vertices_begin</a>(); v != mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a80ac49a03f1085744f5b121cc4acbf2c">vertices_end</a>(); ++v) {</div>
<div class="line"><span class="lineno">  155</span>    }</div>
<div class="line"><span class="lineno">  156</span> </div>
<div class="line"><span class="lineno">  157</span>    <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">edge_array_iterator_t</a> e = mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a8d7c997988ef348807997c1b35d1ba62">edges_begin</a>(); e != mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a3d290168d74d3af8636faa881a9e3708">edges_end</a>(); ++e) {</div>
<div class="line"><span class="lineno">  158</span>    }</div>
<div class="line"><span class="lineno">  159</span> </div>
<div class="line"><span class="lineno">  160</span>    <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">halfedge_array_iterator_t</a> h = mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#add3cbd7d63a0ab56d19696365e2ecfa7">halfedges_begin</a>(); h != mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a945a607d3e0f69a6ab7c2cfd25377ab7">halfedges_end</a>(); ++h) {</div>
<div class="line"><span class="lineno">  161</span>    }</div>
<div class="line"><span class="lineno">  162</span> </div>
<div class="line"><span class="lineno">  163</span>    <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">face_array_iterator_t</a> face_iter = mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a913e50afe2e1dc220a379b1dbf8050d2">faces_begin</a>(); face_iter != mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a89e4f1f34dda0bdeced26bc71cb4a4fc">faces_end</a>(); ++face_iter) {</div>
<div class="line"><span class="lineno">  164</span> </div>
<div class="line"><span class="lineno">  165</span>        <span class="keyword">const</span> std::vector&lt;halfedge_descriptor_t&gt;&amp; halfedges_around_face = mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a86f122fb5db56b6f79b21b657d3326f9">get_halfedges_around_face</a>(*face_iter);</div>
<div class="line"><span class="lineno">  166</span> </div>
<div class="line"><span class="lineno">  167</span>        <span class="comment">// int num_halfedges = ;</span></div>
<div class="line"><span class="lineno">  168</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">int</span>)halfedges_around_face.size());</div>
<div class="line"><span class="lineno">  169</span> </div>
<div class="line"><span class="lineno">  170</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno">  171</span>        <span class="keywordflow">for</span> (std::vector&lt;halfedge_descriptor_t&gt;::const_iterator h = halfedges_around_face.cbegin();</div>
<div class="line"><span class="lineno">  172</span>             h != halfedges_around_face.cend();</div>
<div class="line"><span class="lineno">  173</span>             ++h) {</div>
<div class="line"><span class="lineno">  174</span>        }</div>
<div class="line"><span class="lineno">  175</span>    }</div>
<div class="line"><span class="lineno">  176</span> </div>
<div class="line"><span class="lineno">  177</span>    <a class="code hl_function" href="../../df/d77/hmesh_8h.html#ac940c967e88ff1195334af48a9586f84">write_off</a>(name.c_str(), mesh);</div>
<div class="line"><span class="lineno">  178</span>}</div>
<div class="ttc" id="aclasshmesh__t_html_a945a607d3e0f69a6ab7c2cfd25377ab7"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#a945a607d3e0f69a6ab7c2cfd25377ab7">hmesh_t::halfedges_end</a></div><div class="ttdeci">halfedge_array_iterator_t halfedges_end() const</div><div class="ttdef"><b>Definition</b> hmesh.cpp:884</div></div>
<div class="ttc" id="aclasshmesh__t_html_add3cbd7d63a0ab56d19696365e2ecfa7"><div class="ttname"><a href="../../d7/d63/classhmesh__t.html#add3cbd7d63a0ab56d19696365e2ecfa7">hmesh_t::halfedges_begin</a></div><div class="ttdeci">halfedge_array_iterator_t halfedges_begin(bool account_for_removed_elems=true) const</div><div class="ttdef"><b>Definition</b> hmesh.cpp:872</div></div>
<div class="ttc" id="ahmesh_8h_html_ac940c967e88ff1195334af48a9586f84"><div class="ttname"><a href="../../df/d77/hmesh_8h.html#ac940c967e88ff1195334af48a9586f84">write_off</a></div><div class="ttdeci">void write_off(const char *fpath, const hmesh_t &amp;mesh)</div><div class="ttdef"><b>Definition</b> hmesh.cpp:1246</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00855">hmesh_t::edges_begin()</a>, <a class="el" href="../../#l00867">hmesh_t::edges_end()</a>, <a class="el" href="../../#l00889">hmesh_t::faces_begin()</a>, <a class="el" href="../../#l00901">hmesh_t::faces_end()</a>, <a class="el" href="../../#l00741">hmesh_t::get_halfedges_around_face()</a>, <a class="el" href="../../#l00872">hmesh_t::halfedges_begin()</a>, <a class="el" href="../../#l00884">hmesh_t::halfedges_end()</a>, <a class="el" href="../../#l00062">MCUT_ASSERT</a>, <a class="el" href="../../#l00838">hmesh_t::vertices_begin()</a>, <a class="el" href="../../#l00850">hmesh_t::vertices_end()</a>, and <a class="el" href="../../#l01246">write_off()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../#l01558">dispatch()</a>.</p>
<div id="dynsection-5" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-5-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-5-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-5-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="../../dd/d24/kernel_8cpp_a9bb440c35b34b7ecd91a6ce4eca6941e_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<div id="dynsection-6" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-6-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-6-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-6-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../dd/d24/kernel_8cpp_a9bb440c35b34b7ecd91a6ce4eca6941e_icgraph.svg" width="334" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a34276907046e706af5626787b2e2b05a" name="a34276907046e706af5626787b2e2b05a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34276907046e706af5626787b2e2b05a">&#9670;&#160;</a></span>extract_connected_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> extract_connected_components </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::size_t, std::vector&lt; std::pair&lt; std::shared_ptr&lt; <a class="el" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> &gt;, <a class="el" href="../../dd/d24/kernel_8cpp.html#d7/dd7/structconnected__component__info__t">connected_component_info_t</a> &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>connected_components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>traced_polygons_base_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mX_traced_polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm_polygons_below_cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sm_polygons_above_cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh_vertex_to_seam_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1_to_m0_sm_ovtx_colored</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a>, <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1_to_m0_cm_ovtx_colored</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>, <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1_to_m0_face_colored</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m0_to_ps_vtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>, <a class="el" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m0_to_ps_face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ps_to_sm_vtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ps_to_sm_face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ps_to_cm_vtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ps_to_cm_face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>sm_vtx_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>sm_face_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>popuplate_vertex_maps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>popuplate_face_maps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keep_fragments_below_cutmesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keep_fragments_above_cutmesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keep_fragments_partially_cut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  419</span>{</div>
<div class="line"><span class="lineno">  420</span> </div>
<div class="line"><span class="lineno">  421</span>    <span class="comment">// the auxilliary halfedge mesh containing vertices and edges referenced by the traced polygons</span></div>
<div class="line"><span class="lineno">  422</span>    <a class="code hl_class" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> mesh = <a class="code hl_variable" href="../../d7/da4/testmini_8c.html#a6355bd7e1f3a9e910ff48e2c374fc62a">in</a>; <span class="comment">// copy</span></div>
<div class="line"><span class="lineno">  423</span>    mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a0c71c904363d4a3932bd674812f8478e">reserve_for_additional_elements</a>((std::uint32_t)mX_traced_polygons.size() / 2);</div>
<div class="line"><span class="lineno">  424</span> </div>
<div class="line"><span class="lineno">  426</span>    <span class="comment">// Insert traced polygons into the auxilliary mesh</span></div>
<div class="line"><span class="lineno">  428</span><span class="comment"></span> </div>
<div class="line"><span class="lineno">  429</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Extract CC: Insert polygons&quot;</span>);</div>
<div class="line"><span class="lineno">  430</span> </div>
<div class="line"><span class="lineno">  431</span><span class="preprocessor">#if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno">  432</span>    {</div>
<div class="line"><span class="lineno">  433</span>        <span class="keyword">typedef</span> std::tuple&lt;</div>
<div class="line"><span class="lineno">  434</span>            std::vector&lt;std::vector&lt;vd_t&gt;&gt; <span class="comment">// &quot;mesh&quot; faces</span></div>
<div class="line"><span class="lineno">  435</span>            &gt;</div>
<div class="line"><span class="lineno">  436</span>            OutputStorageTypesTuple;</div>
<div class="line"><span class="lineno">  437</span>        <span class="keyword">typedef</span> std::vector&lt;std::vector&lt;hd_t&gt;&gt;::const_iterator InputStorageIteratorType;</div>
<div class="line"><span class="lineno">  438</span> </div>
<div class="line"><span class="lineno">  439</span>        <span class="keyword">auto</span> fn_compute_inserted_faces = [&amp;mesh](InputStorageIteratorType block_start_, InputStorageIteratorType block_end_) -&gt; OutputStorageTypesTuple {</div>
<div class="line"><span class="lineno">  440</span>            OutputStorageTypesTuple local_output;</div>
<div class="line"><span class="lineno">  441</span>            std::vector&lt;std::vector&lt;vd_t&gt;&gt;&amp; faces_LOCAL = std::get&lt;0&gt;(local_output);</div>
<div class="line"><span class="lineno">  442</span>            faces_LOCAL.reserve(<a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(block_start_, block_end_));</div>
<div class="line"><span class="lineno">  443</span>            <span class="keywordflow">for</span> (InputStorageIteratorType mX_traced_polygons_iter = block_start_; mX_traced_polygons_iter != block_end_; ++mX_traced_polygons_iter) {</div>
<div class="line"><span class="lineno">  444</span>                <span class="keyword">const</span> std::vector&lt;hd_t&gt;&amp; mX_traced_polygon = *mX_traced_polygons_iter;</div>
<div class="line"><span class="lineno">  445</span> </div>
<div class="line"><span class="lineno">  446</span>                faces_LOCAL.push_back(std::vector&lt;vd_t&gt;());</div>
<div class="line"><span class="lineno">  447</span>                std::vector&lt;vd_t&gt;&amp; polygon_vertices = faces_LOCAL.back();</div>
<div class="line"><span class="lineno">  448</span>                polygon_vertices.reserve(mX_traced_polygon.size());</div>
<div class="line"><span class="lineno">  449</span> </div>
<div class="line"><span class="lineno">  450</span>                <span class="comment">// for each halfedge in polygon</span></div>
<div class="line"><span class="lineno">  451</span>                <span class="keywordflow">for</span> (std::vector&lt;hd_t&gt;::const_iterator mX_traced_polygon_halfedge_iter = mX_traced_polygon.cbegin();</div>
<div class="line"><span class="lineno">  452</span>                     mX_traced_polygon_halfedge_iter != mX_traced_polygon.cend();</div>
<div class="line"><span class="lineno">  453</span>                     ++mX_traced_polygon_halfedge_iter) {</div>
<div class="line"><span class="lineno">  454</span>                    polygon_vertices.push_back(mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(*mX_traced_polygon_halfedge_iter));</div>
<div class="line"><span class="lineno">  455</span>                }</div>
<div class="line"><span class="lineno">  456</span>            }</div>
<div class="line"><span class="lineno">  457</span> </div>
<div class="line"><span class="lineno">  458</span>            <span class="keywordflow">return</span> local_output;</div>
<div class="line"><span class="lineno">  459</span>        };</div>
<div class="line"><span class="lineno">  460</span> </div>
<div class="line"><span class="lineno">  461</span>        std::vector&lt;std::future&lt;OutputStorageTypesTuple&gt;&gt; futures;</div>
<div class="line"><span class="lineno">  462</span>        OutputStorageTypesTuple partial_res;</div>
<div class="line"><span class="lineno">  463</span> </div>
<div class="line"><span class="lineno">  464</span>        <a class="code hl_function" href="../../df/d05/tpool_8h.html#a48d2e68725f7691f1422697f4c359827">parallel_for</a>(</div>
<div class="line"><span class="lineno">  465</span>            scheduler,</div>
<div class="line"><span class="lineno">  466</span>            mX_traced_polygons.cbegin(),</div>
<div class="line"><span class="lineno">  467</span>            mX_traced_polygons.cend(),</div>
<div class="line"><span class="lineno">  468</span>            fn_compute_inserted_faces,</div>
<div class="line"><span class="lineno">  469</span>            partial_res, <span class="comment">// output computed by master thread</span></div>
<div class="line"><span class="lineno">  470</span>            futures);</div>
<div class="line"><span class="lineno">  471</span> </div>
<div class="line"><span class="lineno">  472</span>        <span class="keyword">const</span> std::vector&lt;std::vector&lt;vd_t&gt;&gt;&amp; faces_MASTER_THREAD_LOCAL = std::get&lt;0&gt;(partial_res);</div>
<div class="line"><span class="lineno">  473</span> </div>
<div class="line"><span class="lineno">  474</span>        <span class="keyword">auto</span> merge_local_faces = [&amp;mesh](<span class="keyword">const</span> std::vector&lt;std::vector&lt;vd_t&gt;&gt;&amp; faces_) {</div>
<div class="line"><span class="lineno">  475</span>            <span class="keywordflow">for</span> (std::vector&lt;std::vector&lt;vd_t&gt;&gt;::const_iterator face_iter = faces_.cbegin();</div>
<div class="line"><span class="lineno">  476</span>                 face_iter != faces_.cend();</div>
<div class="line"><span class="lineno">  477</span>                 ++face_iter) {</div>
<div class="line"><span class="lineno">  478</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> f = mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a2784844d96e3180300014869148d7577">add_face</a>(*face_iter);</div>
<div class="line"><span class="lineno">  479</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(f != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>());</div>
<div class="line"><span class="lineno">  480</span>            }</div>
<div class="line"><span class="lineno">  481</span>        };</div>
<div class="line"><span class="lineno">  482</span> </div>
<div class="line"><span class="lineno">  483</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)futures.size(); ++i) {</div>
<div class="line"><span class="lineno">  484</span>            std::future&lt;OutputStorageTypesTuple&gt;&amp; f = futures[i];</div>
<div class="line"><span class="lineno">  485</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(f.valid());</div>
<div class="line"><span class="lineno">  486</span>            OutputStorageTypesTuple future_result = f.get(); <span class="comment">// &quot;get()&quot; is a blocking function</span></div>
<div class="line"><span class="lineno">  487</span> </div>
<div class="line"><span class="lineno">  488</span>            <span class="keyword">const</span> std::vector&lt;std::vector&lt;vd_t&gt;&gt;&amp; faces_FUTURE = std::get&lt;0&gt;(future_result);</div>
<div class="line"><span class="lineno">  489</span> </div>
<div class="line"><span class="lineno">  490</span>            merge_local_faces(faces_FUTURE);</div>
<div class="line"><span class="lineno">  491</span>        }</div>
<div class="line"><span class="lineno">  492</span> </div>
<div class="line"><span class="lineno">  493</span>        <span class="comment">// merge faces computed by master thread at the end to maintain the same order</span></div>
<div class="line"><span class="lineno">  494</span>        <span class="comment">// of the traced polygons</span></div>
<div class="line"><span class="lineno">  495</span>        merge_local_faces(faces_MASTER_THREAD_LOCAL);</div>
<div class="line"><span class="lineno">  496</span>    } <span class="comment">// endif of parallel scope</span></div>
<div class="line"><span class="lineno">  497</span> </div>
<div class="line"><span class="lineno">  498</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">  499</span>    <span class="comment">// for each traced polygon</span></div>
<div class="line"><span class="lineno">  500</span>    <span class="keywordflow">for</span> (std::vector&lt;std::vector&lt;hd_t&gt;&gt;::const_iterator mX_traced_polygons_iter = mX_traced_polygons.cbegin();</div>
<div class="line"><span class="lineno">  501</span>         mX_traced_polygons_iter != mX_traced_polygons.cend();</div>
<div class="line"><span class="lineno">  502</span>         ++mX_traced_polygons_iter) {</div>
<div class="line"><span class="lineno">  503</span> </div>
<div class="line"><span class="lineno">  504</span>        <span class="comment">// const int polygon_idx = (int)std::distance(traced_polygons.cbegin(), traced_sm_polygon_iter);</span></div>
<div class="line"><span class="lineno">  505</span>        <span class="keyword">const</span> std::vector&lt;hd_t&gt;&amp; mX_traced_polygon = *mX_traced_polygons_iter;</div>
<div class="line"><span class="lineno">  506</span> </div>
<div class="line"><span class="lineno">  507</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno">  508</span>        <span class="comment">// gather polygon&#39;s vertices</span></div>
<div class="line"><span class="lineno">  509</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno">  510</span> </div>
<div class="line"><span class="lineno">  511</span>        std::vector&lt;vd_t&gt; polygon_vertices;</div>
<div class="line"><span class="lineno">  512</span>        polygon_vertices.reserve(mX_traced_polygon.size());</div>
<div class="line"><span class="lineno">  513</span> </div>
<div class="line"><span class="lineno">  514</span>        <span class="comment">// for each halfedge in polygon</span></div>
<div class="line"><span class="lineno">  515</span>        <span class="keywordflow">for</span> (std::vector&lt;hd_t&gt;::const_iterator mX_traced_polygon_halfedge_iter = mX_traced_polygon.cbegin();</div>
<div class="line"><span class="lineno">  516</span>             mX_traced_polygon_halfedge_iter != mX_traced_polygon.cend();</div>
<div class="line"><span class="lineno">  517</span>             ++mX_traced_polygon_halfedge_iter) {</div>
<div class="line"><span class="lineno">  518</span>            polygon_vertices.push_back(mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(*mX_traced_polygon_halfedge_iter));</div>
<div class="line"><span class="lineno">  519</span>        }</div>
<div class="line"><span class="lineno">  520</span> </div>
<div class="line"><span class="lineno">  521</span>        <span class="comment">// insert face into halfedge data structure</span></div>
<div class="line"><span class="lineno">  522</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> f = mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a2784844d96e3180300014869148d7577">add_face</a>(polygon_vertices);</div>
<div class="line"><span class="lineno">  523</span> </div>
<div class="line"><span class="lineno">  524</span>        <span class="comment">// we have violated halfedge data structure construction</span></div>
<div class="line"><span class="lineno">  525</span>        <span class="comment">// rules probably because we are refering to a halfedge</span></div>
<div class="line"><span class="lineno">  526</span>        <span class="comment">// and its opposite in one polygon</span></div>
<div class="line"><span class="lineno">  527</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(f != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>());</div>
<div class="line"><span class="lineno">  528</span>    }</div>
<div class="line"><span class="lineno">  529</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  530</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno">  531</span> </div>
<div class="line"><span class="lineno">  533</span>    <span class="comment">// find connected components in &quot;mesh&quot;</span></div>
<div class="line"><span class="lineno">  535</span><span class="comment"></span> </div>
<div class="line"><span class="lineno">  536</span>    <span class="comment">// connected components</span></div>
<div class="line"><span class="lineno">  537</span>    std::map&lt;std::size_t, std::shared_ptr&lt;hmesh_t&gt;&gt; ccID_to_mesh;</div>
<div class="line"><span class="lineno">  538</span>    <span class="comment">// location of each connected component w.r.t cut-mesh (above | below | undefined)</span></div>
<div class="line"><span class="lineno">  539</span>    std::map&lt;std::size_t, sm_frag_location_t&gt; ccID_to_cs_descriptor;</div>
<div class="line"><span class="lineno">  540</span>    <span class="comment">// for each component, we have a map which relates the vertex descriptors (indices) in the</span></div>
<div class="line"><span class="lineno">  541</span>    <span class="comment">// auxilliary halfedge data structure &quot;mesh&quot; to the (local) vertex descriptors in</span></div>
<div class="line"><span class="lineno">  542</span>    <span class="comment">// the connected-component.</span></div>
<div class="line"><span class="lineno">  543</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno">  544</span>    <span class="comment">// the &quot;X&quot; in &quot;...mX_...&quot; stands for &quot;0&quot; or &quot;1&quot; depending on where the current function is called from!</span></div>
<div class="line"><span class="lineno">  545</span>    <span class="comment">// Before &quot;m1&quot; is created in &quot;dispatch&quot;, X = &quot;0&quot;. Afterwards, X == &quot;1&quot; to signify the fact that the</span></div>
<div class="line"><span class="lineno">  546</span>    <span class="comment">// input paramater called &quot;in&quot; (in this function) represents &quot;m0&quot; or &quot;m1&quot;</span></div>
<div class="line"><span class="lineno">  547</span>    std::map&lt;std::size_t, std::unordered_map&lt;vd_t, vd_t&gt;&gt; ccID_to_mX_to_cc_vertex;</div>
<div class="line"><span class="lineno">  548</span>    <span class="comment">// std::map&lt;std::size_t, std::unordered_map&lt;vd_t, vd_t&gt;&gt; ccID_to_cc_to_mX_vertex;</span></div>
<div class="line"><span class="lineno">  549</span>    std::map&lt;std::size_t, std::vector&lt;vd_t&gt;&gt; ccID_to_cc_to_mX_vertex;</div>
<div class="line"><span class="lineno">  550</span>    <span class="comment">// the vertex descriptors [in the cc] which are seam vertices!</span></div>
<div class="line"><span class="lineno">  551</span>    std::map&lt;std::size_t, std::vector&lt;vd_t&gt;&gt; cc_to_seam_vertices;</div>
<div class="line"><span class="lineno">  552</span>    <span class="comment">// here we create a map to tag each polygon in &quot;mesh&quot; with the connected component it belongs to.</span></div>
<div class="line"><span class="lineno">  553</span>    std::vector&lt;int&gt; fccmap;</div>
<div class="line"><span class="lineno">  554</span> </div>
<div class="line"><span class="lineno">  555</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Extract CC: find connected components&quot;</span>);</div>
<div class="line"><span class="lineno">  556</span>    std::vector&lt;int&gt; cc_to_vertex_count;</div>
<div class="line"><span class="lineno">  557</span>    std::vector&lt;int&gt; cc_to_face_count;</div>
<div class="line"><span class="lineno">  558</span>    <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa563464e84f5a01cf43a91cc350fd920">find_connected_components</a>(</div>
<div class="line"><span class="lineno">  559</span>#<span class="keywordflow">if</span> defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</div>
<div class="line"><span class="lineno">  560</span>        scheduler,</div>
<div class="line"><span class="lineno">  561</span>#endif</div>
<div class="line"><span class="lineno">  562</span>        fccmap, mesh, cc_to_vertex_count, cc_to_face_count);</div>
<div class="line"><span class="lineno">  563</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno">  564</span> </div>
<div class="line"><span class="lineno">  565</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno">  566</span> </div>
<div class="line"><span class="lineno">  568</span>    <span class="comment">// Map vertex descriptors to each connected component</span></div>
<div class="line"><span class="lineno">  570</span><span class="comment"></span> </div>
<div class="line"><span class="lineno">  571</span>    <span class="comment">// NOTE: even if the number of connected components is one, we proceed anyway</span></div>
<div class="line"><span class="lineno">  572</span>    <span class="comment">// because each connected connected excludes unused vertices in &quot;mesh&quot;</span></div>
<div class="line"><span class="lineno">  573</span> </div>
<div class="line"><span class="lineno">  574</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Extract CC: Map vertices&quot;</span>);</div>
<div class="line"><span class="lineno">  575</span> </div>
<div class="line"><span class="lineno">  576</span>    <span class="comment">// for each face in the auxilliary mesh (i.e. traced polygon)</span></div>
<div class="line"><span class="lineno">  577</span>    <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">face_array_iterator_t</a> face_iter = mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a913e50afe2e1dc220a379b1dbf8050d2">faces_begin</a>(); face_iter != mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a89e4f1f34dda0bdeced26bc71cb4a4fc">faces_end</a>(); ++face_iter) {</div>
<div class="line"><span class="lineno">  578</span> </div>
<div class="line"><span class="lineno">  579</span>        <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">face_descriptor_t</a> fd = *face_iter;</div>
<div class="line"><span class="lineno">  580</span>        <span class="keyword">const</span> <span class="keywordtype">int</span> face_cc_id = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(fccmap, fd); <span class="comment">// get connected component of face</span></div>
<div class="line"><span class="lineno">  581</span> </div>
<div class="line"><span class="lineno">  582</span>        std::map&lt;std::size_t, std::shared_ptr&lt;hmesh_t&gt;&gt;::iterator ccID_to_mesh_fiter = ccID_to_mesh.find(face_cc_id);</div>
<div class="line"><span class="lineno">  583</span>        <span class="keywordflow">if</span> (ccID_to_mesh_fiter == ccID_to_mesh.end()) {</div>
<div class="line"><span class="lineno">  584</span>            <span class="comment">// create new mesh to store connected component</span></div>
<div class="line"><span class="lineno">  585</span>            std::pair&lt;std::map&lt;std::size_t, std::shared_ptr&lt;hmesh_t&gt;&gt;::iterator, <span class="keywordtype">bool</span>&gt; p = ccID_to_mesh.insert(std::make_pair(face_cc_id, std::shared_ptr&lt;hmesh_t&gt;(<span class="keyword">new</span> <a class="code hl_class" href="../../d7/d63/classhmesh__t.html">hmesh_t</a>)));</div>
<div class="line"><span class="lineno">  586</span>            ccID_to_mesh_fiter = p.first;</div>
<div class="line"><span class="lineno">  587</span>        }</div>
<div class="line"><span class="lineno">  588</span> </div>
<div class="line"><span class="lineno">  589</span>        std::shared_ptr&lt;hmesh_t&gt; cc_mesh = ccID_to_mesh_fiter-&gt;second;</div>
<div class="line"><span class="lineno">  590</span> </div>
<div class="line"><span class="lineno">  591</span>        std::map&lt;std::size_t, std::unordered_map&lt;vd_t, vd_t&gt;&gt;::iterator ccID_to_mX_to_cc_vertex_fiter = ccID_to_mX_to_cc_vertex.find(face_cc_id);</div>
<div class="line"><span class="lineno">  592</span> </div>
<div class="line"><span class="lineno">  593</span>        <span class="keywordflow">if</span> (ccID_to_mX_to_cc_vertex_fiter == ccID_to_mX_to_cc_vertex.end()) {</div>
<div class="line"><span class="lineno">  594</span>            <span class="comment">// create new component descriptor map</span></div>
<div class="line"><span class="lineno">  595</span>            std::pair&lt;std::map&lt;std::size_t, std::unordered_map&lt;vd_t, vd_t&gt;&gt;::iterator, <span class="keywordtype">bool</span>&gt; p = ccID_to_mX_to_cc_vertex.insert(std::make_pair(face_cc_id, std::unordered_map&lt;vd_t, vd_t&gt;()));</div>
<div class="line"><span class="lineno">  596</span>            ccID_to_mX_to_cc_vertex_fiter = p.first;</div>
<div class="line"><span class="lineno">  597</span>        }</div>
<div class="line"><span class="lineno">  598</span> </div>
<div class="line"><span class="lineno">  599</span>        std::unordered_map&lt;vd_t, vd_t&gt;&amp; mX_to_cc_vertex = ccID_to_mX_to_cc_vertex_fiter-&gt;second;</div>
<div class="line"><span class="lineno">  600</span> </div>
<div class="line"><span class="lineno">  601</span>        std::map&lt;std::size_t, std::vector&lt;vd_t&gt;&gt;::iterator ccID_to_cc_to_mX_vertex_fiter = ccID_to_cc_to_mX_vertex.find(face_cc_id);</div>
<div class="line"><span class="lineno">  602</span> </div>
<div class="line"><span class="lineno">  603</span>        <span class="keywordflow">if</span> (ccID_to_cc_to_mX_vertex_fiter == ccID_to_cc_to_mX_vertex.end()) {</div>
<div class="line"><span class="lineno">  604</span>            std::pair&lt;std::map&lt;std::size_t, std::vector&lt;vd_t&gt;&gt;::iterator, <span class="keywordtype">bool</span>&gt; p = ccID_to_cc_to_mX_vertex.insert(std::make_pair(face_cc_id, std::vector&lt;vd_t&gt;()));</div>
<div class="line"><span class="lineno">  605</span>            ccID_to_cc_to_mX_vertex_fiter = p.first;</div>
<div class="line"><span class="lineno">  606</span>        }</div>
<div class="line"><span class="lineno">  607</span> </div>
<div class="line"><span class="lineno">  608</span>        std::vector&lt;vd_t&gt;&amp; cc_to_mX_vertex = ccID_to_cc_to_mX_vertex_fiter-&gt;second;</div>
<div class="line"><span class="lineno">  609</span> </div>
<div class="line"><span class="lineno">  610</span>        std::map&lt;std::size_t, std::vector&lt;vd_t&gt;&gt;::iterator cc_to_seam_vertices_fiter = cc_to_seam_vertices.find(face_cc_id);</div>
<div class="line"><span class="lineno">  611</span> </div>
<div class="line"><span class="lineno">  612</span>        <span class="keywordflow">if</span> (cc_to_seam_vertices_fiter == cc_to_seam_vertices.end()) {</div>
<div class="line"><span class="lineno">  613</span>            std::pair&lt;std::map&lt;std::size_t, std::vector&lt;vd_t&gt;&gt;::iterator, <span class="keywordtype">bool</span>&gt; p = cc_to_seam_vertices.insert(std::make_pair(face_cc_id, std::vector&lt;vd_t&gt;()));</div>
<div class="line"><span class="lineno">  614</span>            cc_to_seam_vertices_fiter = p.first;</div>
<div class="line"><span class="lineno">  615</span>        }</div>
<div class="line"><span class="lineno">  616</span> </div>
<div class="line"><span class="lineno">  617</span>        std::vector&lt;vd_t&gt;&amp; cc_seam_vertices = cc_to_seam_vertices_fiter-&gt;second;</div>
<div class="line"><span class="lineno">  618</span> </div>
<div class="line"><span class="lineno">  619</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno">  620</span>        <span class="comment">// Determine the location of the connected component w.r.t the cut-mesh (above/below/undefined)</span></div>
<div class="line"><span class="lineno">  621</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno">  622</span> </div>
<div class="line"><span class="lineno">  623</span>        <span class="comment">// check if the current face is already marked as &quot;below&quot; (w.r.t the cut-mesh).</span></div>
<div class="line"><span class="lineno">  624</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> cc_is_below_cs = std::binary_search(sm_polygons_below_cs.cbegin(), sm_polygons_below_cs.cend(), <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(fd));</div>
<div class="line"><span class="lineno">  625</span> </div>
<div class="line"><span class="lineno">  626</span>        <span class="keywordflow">if</span> (cc_is_below_cs) {</div>
<div class="line"><span class="lineno">  627</span>            <span class="comment">// try to save the fact that the current connected component is &quot;below&quot;</span></div>
<div class="line"><span class="lineno">  628</span>            std::pair&lt;std::map&lt;std::size_t, sm_frag_location_t&gt;::iterator, <span class="keywordtype">bool</span>&gt; p = ccID_to_cs_descriptor.insert(std::make_pair(face_cc_id, <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1aa25949e21299b84cc33c4b00c740f08f">sm_frag_location_t::BELOW</a>));</div>
<div class="line"><span class="lineno">  629</span>            <span class="comment">// if 1) insertion did not take place (connected component already registered), and</span></div>
<div class="line"><span class="lineno">  630</span>            <span class="comment">// 2) the existing connected component at that entry is marked as &quot;above&quot;:</span></div>
<div class="line"><span class="lineno">  631</span>            <span class="comment">//  --&gt; partial cut: thus, the notion &quot;above&quot;/&quot;below&quot; is undefined</span></div>
<div class="line"><span class="lineno">  632</span>            <span class="keywordflow">if</span> (p.second == <span class="keyword">false</span> &amp;&amp; p.first-&gt;second == <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1ac2d92b81beeac9bfc89fb870c1a20767">sm_frag_location_t::ABOVE</a>) {</div>
<div class="line"><span class="lineno">  633</span>                <span class="comment">// polygon classed as both above and below cs</span></div>
<div class="line"><span class="lineno">  634</span>                <span class="comment">// this is because the connected component contains polygons which are both &quot;above&quot;</span></div>
<div class="line"><span class="lineno">  635</span>                <span class="comment">// and &quot;below&quot; the cutting surface (we have a partial cut)</span></div>
<div class="line"><span class="lineno">  636</span>                p.first-&gt;second = <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1a0db45d2a4141101bdfe48e3314cfbca3">sm_frag_location_t::UNDEFINED</a>;</div>
<div class="line"><span class="lineno">  637</span>            }</div>
<div class="line"><span class="lineno">  638</span>        }</div>
<div class="line"><span class="lineno">  639</span> </div>
<div class="line"><span class="lineno">  640</span>        <span class="comment">// check if connected component is marked as &quot;above&quot;</span></div>
<div class="line"><span class="lineno">  641</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> cc_is_above_cs = std::binary_search(sm_polygons_above_cs.cbegin(), sm_polygons_above_cs.cend(), <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(fd));</div>
<div class="line"><span class="lineno">  642</span> </div>
<div class="line"><span class="lineno">  643</span>        <span class="keywordflow">if</span> (cc_is_above_cs) {</div>
<div class="line"><span class="lineno">  644</span>            <span class="comment">// try to save the fact that the current connected component is tagged &quot;above&quot;</span></div>
<div class="line"><span class="lineno">  645</span>            std::pair&lt;std::map&lt;std::size_t, sm_frag_location_t&gt;::iterator, <span class="keywordtype">bool</span>&gt; p = ccID_to_cs_descriptor.insert(std::make_pair(face_cc_id, <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1ac2d92b81beeac9bfc89fb870c1a20767">sm_frag_location_t::ABOVE</a>));</div>
<div class="line"><span class="lineno">  646</span>            <span class="comment">// if 1) insertion did not take place (connected component is already registered), and</span></div>
<div class="line"><span class="lineno">  647</span>            <span class="comment">// 2) the existing connected component at that entry is marked as &quot;below&quot;:</span></div>
<div class="line"><span class="lineno">  648</span>            <span class="comment">//--&gt; partial cut: connected component has polygon whch are both &quot;above&quot; and &quot;below&quot;</span></div>
<div class="line"><span class="lineno">  649</span>            <span class="keywordflow">if</span> (p.second == <span class="keyword">false</span> &amp;&amp; p.first-&gt;second == <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1aa25949e21299b84cc33c4b00c740f08f">sm_frag_location_t::BELOW</a>) {</div>
<div class="line"><span class="lineno">  650</span>                p.first-&gt;second = <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1a0db45d2a4141101bdfe48e3314cfbca3">sm_frag_location_t::UNDEFINED</a>; <span class="comment">// polygon classed as both above and below cs</span></div>
<div class="line"><span class="lineno">  651</span>            }</div>
<div class="line"><span class="lineno">  652</span>        }</div>
<div class="line"><span class="lineno">  653</span> </div>
<div class="line"><span class="lineno">  654</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno">  655</span>        <span class="comment">// We now map the vertices of the current face from the auxilliary data</span></div>
<div class="line"><span class="lineno">  656</span>        <span class="comment">// structure &quot;mesh&quot; to the (local) connected-component</span></div>
<div class="line"><span class="lineno">  657</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno">  658</span> </div>
<div class="line"><span class="lineno">  659</span><span class="comment">//#define EXTRACT_SEAM_HALFEDGES</span></div>
<div class="line"><span class="lineno">  660</span> </div>
<div class="line"><span class="lineno">  661</span><span class="preprocessor">#ifdef EXTRACT_SEAM_HALFEDGES</span></div>
<div class="line"><span class="lineno">  662</span>        std::vector&lt;halfedge_descriptor_t&gt; cc_seam_halfedges;</div>
<div class="line"><span class="lineno">  663</span>        <span class="keyword">const</span> std::vector&lt;halfedge_descriptor_t&gt;&amp; halfedges_on_face = mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a86f122fb5db56b6f79b21b657d3326f9">get_halfedges_around_face</a>(fd);</div>
<div class="line"><span class="lineno">  664</span>        <span class="keywordtype">bool</span> prev_vertex_belonged_to_seam = <span class="keyword">false</span>; <span class="comment">// previous in face</span></div>
<div class="line"><span class="lineno">  665</span><span class="preprocessor">        #endif</span></div>
<div class="line"><span class="lineno">  666</span>        <span class="comment">// for each vertex around the current face</span></div>
<div class="line"><span class="lineno">  667</span>        <span class="keyword">const</span> std::vector&lt;vertex_descriptor_t&gt; vertices_around_face = mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a765a6f3b7249eb47135d246f6d301102">get_vertices_around_face</a>(fd); <span class="comment">// order according to &quot;halfedges_on_face&quot; (targets)</span></div>
<div class="line"><span class="lineno">  668</span> </div>
<div class="line"><span class="lineno">  669</span>        <span class="keywordflow">for</span> (std::vector&lt;vertex_descriptor_t&gt;::const_iterator face_vertex_iter = vertices_around_face.cbegin();</div>
<div class="line"><span class="lineno">  670</span>             face_vertex_iter != vertices_around_face.cend();</div>
<div class="line"><span class="lineno">  671</span>             ++face_vertex_iter) {</div>
<div class="line"><span class="lineno">  672</span> </div>
<div class="line"><span class="lineno">  673</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ccID_to_mX_to_cc_vertex.find(face_cc_id) != ccID_to_mX_to_cc_vertex.cend());</div>
<div class="line"><span class="lineno">  674</span> </div>
<div class="line"><span class="lineno">  675</span>            <span class="comment">// if vertex is not already mapped from &quot;mesh&quot; to connected component</span></div>
<div class="line"><span class="lineno">  676</span>            <span class="keywordflow">if</span> (mX_to_cc_vertex.find(*face_vertex_iter) == mX_to_cc_vertex.end()) {</div>
<div class="line"><span class="lineno">  677</span> </div>
<div class="line"><span class="lineno">  678</span>                <span class="comment">// MCUT_ASSERT(ccID_to_mesh.find(face_cc_id) != ccID_to_mesh.cend());</span></div>
<div class="line"><span class="lineno">  679</span> </div>
<div class="line"><span class="lineno">  680</span>                <span class="comment">// copy vertex from auxilliary data structure &quot;mesh&quot;, add it into connected component mesh,</span></div>
<div class="line"><span class="lineno">  681</span>                <span class="comment">// and save the vertex&#39;s descriptor in the conected component mesh.</span></div>
<div class="line"><span class="lineno">  682</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> cc_descriptor = cc_mesh-&gt;add_vertex(mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(*face_vertex_iter));</div>
<div class="line"><span class="lineno">  683</span> </div>
<div class="line"><span class="lineno">  684</span>                <span class="comment">// map vertex</span></div>
<div class="line"><span class="lineno">  685</span>                mX_to_cc_vertex.insert(std::make_pair(*face_vertex_iter, cc_descriptor));</div>
<div class="line"><span class="lineno">  686</span>                <span class="keywordflow">if</span> (popuplate_vertex_maps) {</div>
<div class="line"><span class="lineno">  687</span>                    <span class="comment">// SAFE_ACCESS(ccID_to_cc_to_mX_vertex, face_cc_id).insert(std::make_pair(cc_descriptor, *face_vertex_iter));</span></div>
<div class="line"><span class="lineno">  688</span>                    cc_to_mX_vertex.push_back(*face_vertex_iter);</div>
<div class="line"><span class="lineno">  689</span>                }</div>
<div class="line"><span class="lineno">  690</span>                <span class="comment">// check if we need to save vertex as being a seam vertex</span></div>
<div class="line"><span class="lineno">  691</span>                <span class="comment">// std::vector&lt;bool&gt;::const_iterator fiter = mesh_vertex_to_seam_flag.find(*face_vertex_iter);</span></div>
<div class="line"><span class="lineno">  692</span>                <span class="keywordtype">bool</span> is_seam_vertex = (size_t)(*face_vertex_iter) &lt; mesh_vertex_to_seam_flag.size() &amp;&amp; <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(mesh_vertex_to_seam_flag, *face_vertex_iter); <span class="comment">//(size_t)(*face_vertex_iter) &lt; mesh_vertex_to_seam_flag.size(); //fiter != mesh_vertex_to_seam_flag.cend() &amp;&amp; fiter-&gt;second == true;</span></div>
<div class="line"><span class="lineno">  693</span>                </div>
<div class="line"><span class="lineno">  694</span>                <span class="keywordflow">if</span> (is_seam_vertex) {</div>
<div class="line"><span class="lineno">  695</span>                    </div>
<div class="line"><span class="lineno">  696</span>                    cc_seam_vertices.push_back(cc_descriptor);</div>
<div class="line"><span class="lineno">  697</span><span class="preprocessor">#ifdef EXTRACT_SEAM_HALFEDGES</span></div>
<div class="line"><span class="lineno">  698</span>                    <span class="keyword">const</span> <a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> face_vertex_idx = <a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(vertices_around_face.cbegin(), face_vertex_iter);</div>
<div class="line"><span class="lineno">  699</span> </div>
<div class="line"><span class="lineno">  700</span>                    <span class="keyword">const</span> <span class="keywordtype">bool</span> is_first_face_vertex = (face_vertex_idx == 0);</div>
<div class="line"><span class="lineno">  701</span>                    <span class="keywordtype">bool</span> have_seam_halfedge = prev_vertex_belonged_to_seam;</div>
<div class="line"><span class="lineno">  702</span> </div>
<div class="line"><span class="lineno">  703</span>                    <span class="keywordflow">if</span> (is_first_face_vertex) {</div>
<div class="line"><span class="lineno">  704</span>                        <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> last_vtx_descr = (*(vertices_around_face.end() - 1));</div>
<div class="line"><span class="lineno">  705</span>                        <span class="keywordtype">bool</span> last_vertex_is_seam_vertex = (size_t)(last_vtx_descr) &lt; mesh_vertex_to_seam_flag.size() &amp;&amp; <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(mesh_vertex_to_seam_flag, last_vtx_descr); <span class="comment">//(size_t)(*face_vertex_iter) &lt; mesh_vertex_to_seam_flag.size(); //fiter != mesh_vertex_to_seam_flag.cend() &amp;&amp; fiter-&gt;second == true;</span></div>
<div class="line"><span class="lineno">  706</span>                        have_seam_halfedge = (last_vertex_is_seam_vertex);</div>
<div class="line"><span class="lineno">  707</span>                    }</div>
<div class="line"><span class="lineno">  708</span>                    </div>
<div class="line"><span class="lineno">  709</span>                    <span class="keywordflow">if</span> (have_seam_halfedge) {</div>
<div class="line"><span class="lineno">  710</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">halfedge_descriptor_t</a> seam_he = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(halfedges_on_face, face_vertex_idx); <span class="comment">// number of halfedge == number of vertices in face</span></div>
<div class="line"><span class="lineno">  711</span>                        cc_seam_halfedges.push_back(seam_he);</div>
<div class="line"><span class="lineno">  712</span>                    }</div>
<div class="line"><span class="lineno">  713</span><span class="preprocessor">                    #endif</span></div>
<div class="line"><span class="lineno">  714</span>                }</div>
<div class="line"><span class="lineno">  715</span><span class="preprocessor">#ifdef EXTRACT_SEAM_HALFEDGES</span></div>
<div class="line"><span class="lineno">  716</span>                prev_vertex_belonged_to_seam = is_seam_vertex;</div>
<div class="line"><span class="lineno">  717</span><span class="preprocessor">                #endif</span></div>
<div class="line"><span class="lineno">  718</span>            }</div>
<div class="line"><span class="lineno">  719</span>        }</div>
<div class="line"><span class="lineno">  720</span>    } <span class="comment">// for (face_array_iterator_t face_iter = mesh.faces_begin(); face_iter != mesh.faces_end(); ++face_iter)</span></div>
<div class="line"><span class="lineno">  721</span> </div>
<div class="line"><span class="lineno">  722</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno">  723</span> </div>
<div class="line"><span class="lineno">  724</span>    <span class="comment">// bool extractingSeams = (m1_num_vertices_after_srcmesh_partitioning == -1);</span></div>
<div class="line"><span class="lineno">  725</span> </div>
<div class="line"><span class="lineno">  726</span>    <span class="comment">// stores a flag per connected component indicating whether we should</span></div>
<div class="line"><span class="lineno">  727</span>    <span class="comment">// keep this CC or throw it away, as per user flags.</span></div>
<div class="line"><span class="lineno">  728</span>    std::map&lt;size_t, bool&gt; ccID_to_keepFlag;</div>
<div class="line"><span class="lineno">  729</span>    <span class="keywordflow">for</span> (std::map&lt;<span class="keywordtype">size_t</span>, std::shared_ptr&lt;hmesh_t&gt;&gt;::const_iterator it = ccID_to_mesh.cbegin(); it != ccID_to_mesh.cend(); ++it) {</div>
<div class="line"><span class="lineno">  730</span>        <span class="keywordtype">int</span> ccID = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)it-&gt;first;</div>
<div class="line"><span class="lineno">  731</span>        std::map&lt;std::size_t, sm_frag_location_t&gt;::iterator fiter = ccID_to_cs_descriptor.find(ccID);</div>
<div class="line"><span class="lineno">  732</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> isSeam = (fiter == ccID_to_cs_descriptor.cend()); <span class="comment">// Seams have no notion of &quot;location&quot;</span></div>
<div class="line"><span class="lineno">  733</span>        ccID_to_keepFlag[ccID] = isSeam || ((keep_fragments_above_cutmesh &amp;&amp; fiter-&gt;second == <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1ac2d92b81beeac9bfc89fb870c1a20767">sm_frag_location_t::ABOVE</a>) || <span class="comment">//</span></div>
<div class="line"><span class="lineno">  734</span>                                     (keep_fragments_below_cutmesh &amp;&amp; fiter-&gt;second == <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1aa25949e21299b84cc33c4b00c740f08f">sm_frag_location_t::BELOW</a>) || <span class="comment">//</span></div>
<div class="line"><span class="lineno">  735</span>                                     (keep_fragments_partially_cut &amp;&amp; fiter-&gt;second == <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1a0db45d2a4141101bdfe48e3314cfbca3">sm_frag_location_t::UNDEFINED</a>));</div>
<div class="line"><span class="lineno">  736</span>    }</div>
<div class="line"><span class="lineno">  737</span> </div>
<div class="line"><span class="lineno">  739</span>    <span class="comment">// TODO: shift the logic to add vertices into CC to here (like for face below)</span></div>
<div class="line"><span class="lineno">  741</span><span class="comment"></span> </div>
<div class="line"><span class="lineno">  743</span>    <span class="comment">// Insert faces into connected components using mapped vertex descriptors</span></div>
<div class="line"><span class="lineno">  745</span><span class="comment"></span> </div>
<div class="line"><span class="lineno">  746</span>    std::map&lt;size_t, std::vector&lt;fd_t&gt;&gt; ccID_to_cc_to_mX_face;</div>
<div class="line"><span class="lineno">  747</span>    <span class="keywordflow">for</span> (std::map&lt;<span class="keywordtype">size_t</span>, std::shared_ptr&lt;hmesh_t&gt;&gt;::const_iterator it = ccID_to_mesh.cbegin(); it != ccID_to_mesh.cend(); ++it) {</div>
<div class="line"><span class="lineno">  748</span>        <span class="keywordtype">bool</span> userWantsCC = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ccID_to_keepFlag, it-&gt;first);</div>
<div class="line"><span class="lineno">  749</span> </div>
<div class="line"><span class="lineno">  750</span>        <span class="keywordflow">if</span> (!userWantsCC) {</div>
<div class="line"><span class="lineno">  751</span>            <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  752</span>        }</div>
<div class="line"><span class="lineno">  753</span> </div>
<div class="line"><span class="lineno">  754</span>        ccID_to_cc_to_mX_face[it-&gt;first] = std::vector&lt;fd_t&gt;();</div>
<div class="line"><span class="lineno">  755</span>    }</div>
<div class="line"><span class="lineno">  756</span> </div>
<div class="line"><span class="lineno">  757</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Extract CC: Map faces&quot;</span>);</div>
<div class="line"><span class="lineno">  758</span><span class="preprocessor">#if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno">  759</span>    {</div>
<div class="line"><span class="lineno">  760</span>        <span class="keyword">typedef</span> std::tuple&lt;</div>
<div class="line"><span class="lineno">  761</span>            std::vector&lt;std::vector&lt;vd_t&gt;&gt;, <span class="comment">// remapped_faces, // using remapped cc descriptors</span></div>
<div class="line"><span class="lineno">  762</span>            std::vector&lt;int&gt;, <span class="comment">// the cc id of each remapped</span></div>
<div class="line"><span class="lineno">  763</span>            std::vector&lt;fd_t&gt; <span class="comment">// the mX mesh i.e. the halfedge data structure we call &quot;mesh&quot; that is remapped</span></div>
<div class="line"><span class="lineno">  764</span>            &gt;</div>
<div class="line"><span class="lineno">  765</span>            OutputStorageTypesTuple;</div>
<div class="line"><span class="lineno">  766</span>        <span class="keyword">typedef</span> <a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">face_array_iterator_t</a> InputStorageIteratorType;</div>
<div class="line"><span class="lineno">  767</span> </div>
<div class="line"><span class="lineno">  768</span>        <span class="keyword">auto</span> fn_compute_remapped_cc_faces = [&amp;](InputStorageIteratorType block_start_, InputStorageIteratorType block_end_) -&gt; OutputStorageTypesTuple {</div>
<div class="line"><span class="lineno">  769</span>            OutputStorageTypesTuple local_output;</div>
<div class="line"><span class="lineno">  770</span>            <span class="keyword">const</span> <a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> num_elems = (<a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>)<a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(block_start_, block_end_);</div>
<div class="line"><span class="lineno">  771</span>            std::vector&lt;std::vector&lt;vd_t&gt;&gt;&amp; remapped_faces_LOCAL = std::get&lt;0&gt;(local_output);</div>
<div class="line"><span class="lineno">  772</span>            remapped_faces_LOCAL.reserve(num_elems);</div>
<div class="line"><span class="lineno">  773</span>            std::vector&lt;int&gt;&amp; local_remapped_face_to_ccID = std::get&lt;1&gt;(local_output);</div>
<div class="line"><span class="lineno">  774</span>            local_remapped_face_to_ccID.reserve(num_elems);</div>
<div class="line"><span class="lineno">  775</span>            std::vector&lt;fd_t&gt;&amp; local_remapped_face_to_mX_face = std::get&lt;2&gt;(local_output);</div>
<div class="line"><span class="lineno">  776</span>            local_remapped_face_to_mX_face.reserve(num_elems);</div>
<div class="line"><span class="lineno">  777</span>            <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">face_array_iterator_t</a> face_iter = block_start_; face_iter != block_end_; ++face_iter) {</div>
<div class="line"><span class="lineno">  778</span>                <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">face_descriptor_t</a> fd = *face_iter;</div>
<div class="line"><span class="lineno">  779</span>                <span class="keyword">const</span> <span class="keywordtype">size_t</span> cc_id = fccmap[fd]; <span class="comment">// the connected component which contains the current face</span></div>
<div class="line"><span class="lineno">  780</span> </div>
<div class="line"><span class="lineno">  781</span>                <span class="keywordtype">bool</span> userWantsCC = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ccID_to_keepFlag, cc_id);</div>
<div class="line"><span class="lineno">  782</span> </div>
<div class="line"><span class="lineno">  783</span>                <span class="keywordflow">if</span> (!userWantsCC) {</div>
<div class="line"><span class="lineno">  784</span>                    <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  785</span>                }</div>
<div class="line"><span class="lineno">  786</span> </div>
<div class="line"><span class="lineno">  787</span>                remapped_faces_LOCAL.push_back(std::vector&lt;vd_t&gt;());</div>
<div class="line"><span class="lineno">  788</span>                std::vector&lt;vd_t&gt;&amp; remapped_face = remapped_faces_LOCAL.back(); <span class="comment">// using remapped cc descriptors</span></div>
<div class="line"><span class="lineno">  789</span>                local_remapped_face_to_ccID.push_back((<span class="keywordtype">int</span>)cc_id);</div>
<div class="line"><span class="lineno">  790</span>                local_remapped_face_to_mX_face.push_back(fd);</div>
<div class="line"><span class="lineno">  791</span> </div>
<div class="line"><span class="lineno">  792</span>                <span class="comment">// std::map&lt;size_t, std::vector&lt;fd_t&gt;&gt;::iterator ccID_to_cc_to_mX_face_fiter = ccID_to_cc_to_mX_face.find(cc_id);</span></div>
<div class="line"><span class="lineno">  793</span> </div>
<div class="line"><span class="lineno">  794</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ccID_to_cc_to_mX_face.find(cc_id) != ccID_to_cc_to_mX_face.cend());</div>
<div class="line"><span class="lineno">  795</span>                <span class="comment">// std::vector&lt;fd_t&gt; &amp;cc_to_mX_face = ccID_to_cc_to_mX_face_fiter-&gt;second;</span></div>
<div class="line"><span class="lineno">  796</span> </div>
<div class="line"><span class="lineno">  797</span>                <span class="comment">// std::map&lt;std::size_t, std::unordered_map&lt;vd_t, vd_t&gt;&gt;::iterator ccID_to_mX_to_cc_vertex_fiter = ;</span></div>
<div class="line"><span class="lineno">  798</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ccID_to_mX_to_cc_vertex.find(cc_id) != ccID_to_mX_to_cc_vertex.end());</div>
<div class="line"><span class="lineno">  799</span>                std::unordered_map&lt;vd_t, vd_t&gt;&amp; mX_to_cc_vertex = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ccID_to_mX_to_cc_vertex, cc_id);</div>
<div class="line"><span class="lineno">  800</span> </div>
<div class="line"><span class="lineno">  801</span>                <span class="comment">// for each vertex around face</span></div>
<div class="line"><span class="lineno">  802</span>                <span class="keyword">const</span> std::vector&lt;vertex_descriptor_t&gt; vertices_around_face = mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a765a6f3b7249eb47135d246f6d301102">get_vertices_around_face</a>(fd);</div>
<div class="line"><span class="lineno">  803</span> </div>
<div class="line"><span class="lineno">  804</span>                <span class="keywordflow">for</span> (std::vector&lt;vertex_descriptor_t&gt;::const_iterator face_vertex_iter = vertices_around_face.cbegin();</div>
<div class="line"><span class="lineno">  805</span>                     face_vertex_iter != vertices_around_face.cend();</div>
<div class="line"><span class="lineno">  806</span>                     ++face_vertex_iter) {</div>
<div class="line"><span class="lineno">  807</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ccID_to_mX_to_cc_vertex.find(cc_id) != ccID_to_mX_to_cc_vertex.cend());</div>
<div class="line"><span class="lineno">  808</span> </div>
<div class="line"><span class="lineno">  809</span>                    <span class="comment">/*const*/</span> std::unordered_map&lt;vd_t, vd_t&gt;&amp; vertex_map = mX_to_cc_vertex;</div>
<div class="line"><span class="lineno">  810</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m1_sm_descr = *face_vertex_iter;</div>
<div class="line"><span class="lineno">  811</span> </div>
<div class="line"><span class="lineno">  812</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(vertex_map.find(m1_sm_descr) != vertex_map.cend());</div>
<div class="line"><span class="lineno">  813</span> </div>
<div class="line"><span class="lineno">  814</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> cc_descr = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(vertex_map, m1_sm_descr);</div>
<div class="line"><span class="lineno">  815</span>                    remapped_face.push_back(cc_descr);</div>
<div class="line"><span class="lineno">  816</span>                }</div>
<div class="line"><span class="lineno">  817</span>            }</div>
<div class="line"><span class="lineno">  818</span> </div>
<div class="line"><span class="lineno">  819</span>            <span class="keywordflow">return</span> local_output;</div>
<div class="line"><span class="lineno">  820</span>        };</div>
<div class="line"><span class="lineno">  821</span> </div>
<div class="line"><span class="lineno">  822</span>        std::vector&lt;std::future&lt;OutputStorageTypesTuple&gt;&gt; futures;</div>
<div class="line"><span class="lineno">  823</span>        OutputStorageTypesTuple partial_res;</div>
<div class="line"><span class="lineno">  824</span> </div>
<div class="line"><span class="lineno">  825</span>        <a class="code hl_function" href="../../df/d05/tpool_8h.html#a48d2e68725f7691f1422697f4c359827">parallel_for</a>(</div>
<div class="line"><span class="lineno">  826</span>            scheduler,</div>
<div class="line"><span class="lineno">  827</span>            mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a913e50afe2e1dc220a379b1dbf8050d2">faces_begin</a>(),</div>
<div class="line"><span class="lineno">  828</span>            mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a89e4f1f34dda0bdeced26bc71cb4a4fc">faces_end</a>(),</div>
<div class="line"><span class="lineno">  829</span>            fn_compute_remapped_cc_faces,</div>
<div class="line"><span class="lineno">  830</span>            partial_res, <span class="comment">// output computed by master thread</span></div>
<div class="line"><span class="lineno">  831</span>            futures);</div>
<div class="line"><span class="lineno">  832</span> </div>
<div class="line"><span class="lineno">  833</span>        <span class="comment">// remapped_faces</span></div>
<div class="line"><span class="lineno">  834</span>        <span class="keyword">const</span> std::vector&lt;std::vector&lt;vd_t&gt;&gt;&amp; remapped_faces_MASTER_THREAD_LOCAL = std::get&lt;0&gt;(partial_res);</div>
<div class="line"><span class="lineno">  835</span>        <span class="keyword">const</span> std::vector&lt;int&gt;&amp; local_remapped_face_to_ccID_MASTER_THREAD_LOCAL = std::get&lt;1&gt;(partial_res);</div>
<div class="line"><span class="lineno">  836</span>        <span class="keyword">const</span> std::vector&lt;fd_t&gt;&amp; local_remapped_face_to_mX_face_MASTER_THREAD_LOCAL = std::get&lt;2&gt;(partial_res);</div>
<div class="line"><span class="lineno">  837</span> </div>
<div class="line"><span class="lineno">  838</span>        <span class="keyword">auto</span> merge_local_remapped_cc_faces = [](</div>
<div class="line"><span class="lineno">  839</span>                                                 <span class="keyword">const</span> std::vector&lt;std::vector&lt;vd_t&gt;&gt;&amp; remapped_faces_,</div>
<div class="line"><span class="lineno">  840</span>                                                 <span class="keyword">const</span> std::vector&lt;int&gt;&amp; local_remapped_face_to_ccID_,</div>
<div class="line"><span class="lineno">  841</span>                                                 <span class="keyword">const</span> std::vector&lt;fd_t&gt;&amp; local_remapped_face_to_mX_face_,</div>
<div class="line"><span class="lineno">  842</span>                                                 <span class="keyword">const</span> <span class="keywordtype">bool</span> popuplate_face_maps,</div>
<div class="line"><span class="lineno">  843</span>                                                 std::map&lt;size_t, std::shared_ptr&lt;hmesh_t&gt;&gt;&amp; ccID_to_mesh,</div>
<div class="line"><span class="lineno">  844</span>                                                 std::map&lt;size_t, std::vector&lt;fd_t&gt;&gt;&amp; ccID_to_cc_to_mX_face) {</div>
<div class="line"><span class="lineno">  845</span>            <span class="keywordflow">for</span> (std::vector&lt;std::vector&lt;vd_t&gt;&gt;::const_iterator remapped_face_iter = remapped_faces_.cbegin();</div>
<div class="line"><span class="lineno">  846</span>                 remapped_face_iter != remapped_faces_.cend();</div>
<div class="line"><span class="lineno">  847</span>                 ++remapped_face_iter) {</div>
<div class="line"><span class="lineno">  848</span>                <a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> idx = (<a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>)<a class="code hl_function" href="../../d8/dcc/namespacestd.html#af4bc231d061945eb59dbba98a117ece9">std::distance</a>(remapped_faces_.cbegin(), remapped_face_iter);</div>
<div class="line"><span class="lineno">  849</span>                <a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> remapped_face_cc_id = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(local_remapped_face_to_ccID_, idx);</div>
<div class="line"><span class="lineno">  850</span> </div>
<div class="line"><span class="lineno">  851</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ccID_to_mesh.find(remapped_face_cc_id) != ccID_to_mesh.end());</div>
<div class="line"><span class="lineno">  852</span> </div>
<div class="line"><span class="lineno">  853</span>                std::shared_ptr&lt;hmesh_t&gt; cc_mesh = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ccID_to_mesh, remapped_face_cc_id);</div>
<div class="line"><span class="lineno">  854</span>                <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> f = cc_mesh-&gt;add_face(*remapped_face_iter); <span class="comment">// insert the face</span></div>
<div class="line"><span class="lineno">  855</span> </div>
<div class="line"><span class="lineno">  856</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(f != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>());</div>
<div class="line"><span class="lineno">  857</span> </div>
<div class="line"><span class="lineno">  858</span>                <span class="keywordflow">if</span> (popuplate_face_maps) {</div>
<div class="line"><span class="lineno">  859</span>                    <span class="comment">// NOTE: &quot;mX&quot; refers to our halfedge data structure called &quot;mesh&quot; (see single threaded code)</span></div>
<div class="line"><span class="lineno">  860</span>                    std::vector&lt;fd_t&gt;&amp; cc_to_mX_face = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ccID_to_cc_to_mX_face, remapped_face_cc_id);</div>
<div class="line"><span class="lineno">  861</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)f == cc_to_mX_face.size() <span class="comment">/*cc_to_mX_face.count(f) == 0*/</span>);</div>
<div class="line"><span class="lineno">  862</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> fd = local_remapped_face_to_mX_face_[idx];</div>
<div class="line"><span class="lineno">  863</span>                    <span class="comment">// cc_to_mX_face[f] = fd;</span></div>
<div class="line"><span class="lineno">  864</span>                    cc_to_mX_face.push_back(fd);</div>
<div class="line"><span class="lineno">  865</span>                }</div>
<div class="line"><span class="lineno">  866</span>            }</div>
<div class="line"><span class="lineno">  867</span>        };</div>
<div class="line"><span class="lineno">  868</span> </div>
<div class="line"><span class="lineno">  869</span>        merge_local_remapped_cc_faces(</div>
<div class="line"><span class="lineno">  870</span>            remapped_faces_MASTER_THREAD_LOCAL,</div>
<div class="line"><span class="lineno">  871</span>            local_remapped_face_to_ccID_MASTER_THREAD_LOCAL,</div>
<div class="line"><span class="lineno">  872</span>            local_remapped_face_to_mX_face_MASTER_THREAD_LOCAL,</div>
<div class="line"><span class="lineno">  873</span>            popuplate_face_maps,</div>
<div class="line"><span class="lineno">  874</span>            ccID_to_mesh,</div>
<div class="line"><span class="lineno">  875</span>            ccID_to_cc_to_mX_face);</div>
<div class="line"><span class="lineno">  876</span> </div>
<div class="line"><span class="lineno">  877</span>        <span class="comment">// merge thread-local output into global data structures</span></div>
<div class="line"><span class="lineno">  878</span>        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)futures.size(); ++i) {</div>
<div class="line"><span class="lineno">  879</span>            std::future&lt;OutputStorageTypesTuple&gt;&amp; f = futures[i];</div>
<div class="line"><span class="lineno">  880</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(f.valid());</div>
<div class="line"><span class="lineno">  881</span>            OutputStorageTypesTuple future_result = f.get(); <span class="comment">// &quot;get()&quot; is a blocking function</span></div>
<div class="line"><span class="lineno">  882</span> </div>
<div class="line"><span class="lineno">  883</span>            <span class="keyword">const</span> std::vector&lt;std::vector&lt;vd_t&gt;&gt;&amp; remapped_faces_FUTURE = std::get&lt;0&gt;(future_result);</div>
<div class="line"><span class="lineno">  884</span>            <span class="keyword">const</span> std::vector&lt;int&gt;&amp; local_remapped_face_to_ccID_FUTURE = std::get&lt;1&gt;(future_result);</div>
<div class="line"><span class="lineno">  885</span>            <span class="keyword">const</span> std::vector&lt;fd_t&gt;&amp; local_remapped_face_to_mX_face_FUTURE = std::get&lt;2&gt;(future_result);</div>
<div class="line"><span class="lineno">  886</span> </div>
<div class="line"><span class="lineno">  887</span>            merge_local_remapped_cc_faces(</div>
<div class="line"><span class="lineno">  888</span>                remapped_faces_FUTURE,</div>
<div class="line"><span class="lineno">  889</span>                local_remapped_face_to_ccID_FUTURE,</div>
<div class="line"><span class="lineno">  890</span>                local_remapped_face_to_mX_face_FUTURE,</div>
<div class="line"><span class="lineno">  891</span>                popuplate_face_maps,</div>
<div class="line"><span class="lineno">  892</span>                ccID_to_mesh,</div>
<div class="line"><span class="lineno">  893</span>                ccID_to_cc_to_mX_face);</div>
<div class="line"><span class="lineno">  894</span>        }</div>
<div class="line"><span class="lineno">  895</span> </div>
<div class="line"><span class="lineno">  896</span>    } <span class="comment">// end of parallel scope</span></div>
<div class="line"><span class="lineno">  897</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">  898</span>    <span class="comment">// for each face in the auxilliary data structure &quot;mesh&quot; (traced polygon)</span></div>
<div class="line"><span class="lineno">  899</span>    <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">face_array_iterator_t</a> face_iter = mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a913e50afe2e1dc220a379b1dbf8050d2">faces_begin</a>(); face_iter != mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a89e4f1f34dda0bdeced26bc71cb4a4fc">faces_end</a>(); ++face_iter) {</div>
<div class="line"><span class="lineno">  900</span>        <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">face_descriptor_t</a> fd = *face_iter;</div>
<div class="line"><span class="lineno">  901</span>        <span class="keyword">const</span> <span class="keywordtype">size_t</span> cc_id = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(fccmap, fd); <span class="comment">// the connected component which contains the current face</span></div>
<div class="line"><span class="lineno">  902</span> </div>
<div class="line"><span class="lineno">  903</span>        <span class="keywordtype">bool</span> userWantsCC = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ccID_to_keepFlag, cc_id);</div>
<div class="line"><span class="lineno">  904</span> </div>
<div class="line"><span class="lineno">  905</span>        <span class="keywordflow">if</span> (!userWantsCC) {</div>
<div class="line"><span class="lineno">  906</span>            <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  907</span>        }</div>
<div class="line"><span class="lineno">  908</span> </div>
<div class="line"><span class="lineno">  909</span>        std::vector&lt;vd_t&gt; remapped_face; <span class="comment">// using remapped cc descriptors</span></div>
<div class="line"><span class="lineno">  910</span>        std::map&lt;size_t, std::vector&lt;fd_t&gt;&gt;::iterator ccID_to_cc_to_mX_face_fiter = ccID_to_cc_to_mX_face.find(cc_id);</div>
<div class="line"><span class="lineno">  911</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ccID_to_cc_to_mX_face_fiter != ccID_to_cc_to_mX_face.cend());</div>
<div class="line"><span class="lineno">  912</span>        std::vector&lt;fd_t&gt;&amp; cc_to_mX_face = ccID_to_cc_to_mX_face_fiter-&gt;second;</div>
<div class="line"><span class="lineno">  913</span> </div>
<div class="line"><span class="lineno">  914</span>        <span class="comment">// std::map&lt;std::size_t, std::unordered_map&lt;vd_t, vd_t&gt;&gt;::iterator ccID_to_mX_to_cc_vertex_fiter = ;</span></div>
<div class="line"><span class="lineno">  915</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ccID_to_mX_to_cc_vertex.find(cc_id) != ccID_to_mX_to_cc_vertex.end());</div>
<div class="line"><span class="lineno">  916</span>        std::unordered_map&lt;vd_t, vd_t&gt;&amp; mX_to_cc_vertex = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ccID_to_mX_to_cc_vertex, cc_id);</div>
<div class="line"><span class="lineno">  917</span> </div>
<div class="line"><span class="lineno">  918</span>        <span class="comment">// for each vertex around face</span></div>
<div class="line"><span class="lineno">  919</span>        <span class="comment">/*const*/</span> std::vector&lt;vertex_descriptor_t&gt; vertices_around_face = mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a765a6f3b7249eb47135d246f6d301102">get_vertices_around_face</a>(fd);</div>
<div class="line"><span class="lineno">  920</span> </div>
<div class="line"><span class="lineno">  921</span>        <span class="keywordflow">for</span> (std::vector&lt;vertex_descriptor_t&gt;::<span class="comment">/*const_*/</span> iterator face_vertex_iter = vertices_around_face.<a class="code hl_function" href="../../dd/d66/namespacelibnest2d_1_1shapelike.html#a2aeb0374bbb83d0a6452bca14e1bbbda">begin</a>();</div>
<div class="line"><span class="lineno">  922</span>             face_vertex_iter != vertices_around_face.end();</div>
<div class="line"><span class="lineno">  923</span>             ++face_vertex_iter) {</div>
<div class="line"><span class="lineno">  924</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ccID_to_mX_to_cc_vertex.find(cc_id) != ccID_to_mX_to_cc_vertex.cend());</div>
<div class="line"><span class="lineno">  925</span> </div>
<div class="line"><span class="lineno">  926</span>            <span class="comment">/*const*/</span> std::unordered_map&lt;vd_t, vd_t&gt;&amp; vertex_map = mX_to_cc_vertex;</div>
<div class="line"><span class="lineno">  927</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m1_sm_descr = *face_vertex_iter;</div>
<div class="line"><span class="lineno">  928</span> </div>
<div class="line"><span class="lineno">  929</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(vertex_map.find(m1_sm_descr) != vertex_map.cend());</div>
<div class="line"><span class="lineno">  930</span> </div>
<div class="line"><span class="lineno">  931</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> cc_descr = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(vertex_map, m1_sm_descr);</div>
<div class="line"><span class="lineno">  932</span>            remapped_face.push_back(cc_descr);</div>
<div class="line"><span class="lineno">  933</span>        }</div>
<div class="line"><span class="lineno">  934</span> </div>
<div class="line"><span class="lineno">  935</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ccID_to_mesh.find(cc_id) != ccID_to_mesh.end());</div>
<div class="line"><span class="lineno">  936</span> </div>
<div class="line"><span class="lineno">  937</span>        std::shared_ptr&lt;hmesh_t&gt; cc_mesh = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ccID_to_mesh, cc_id);</div>
<div class="line"><span class="lineno">  938</span>        <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> f = cc_mesh-&gt;add_face(remapped_face); <span class="comment">// insert the face</span></div>
<div class="line"><span class="lineno">  939</span> </div>
<div class="line"><span class="lineno">  940</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(f != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>());</div>
<div class="line"><span class="lineno">  941</span> </div>
<div class="line"><span class="lineno">  942</span>        <span class="keywordflow">if</span> (popuplate_face_maps) {</div>
<div class="line"><span class="lineno">  943</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)f == cc_to_mX_face.size() <span class="comment">/*cc_to_mX_face.count(f) == 0*/</span>);</div>
<div class="line"><span class="lineno">  944</span>            <span class="comment">// cc_to_mX_face[f] = fd;</span></div>
<div class="line"><span class="lineno">  945</span>            cc_to_mX_face.push_back(fd);</div>
<div class="line"><span class="lineno">  946</span>        }</div>
<div class="line"><span class="lineno">  947</span>    }</div>
<div class="line"><span class="lineno">  948</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  949</span> </div>
<div class="line"><span class="lineno">  950</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno">  951</span> </div>
<div class="line"><span class="lineno">  952</span>    <span class="comment">// Note: at this stage we have our connected components (meshes) with their</span></div>
<div class="line"><span class="lineno">  953</span>    <span class="comment">// vertices and faces defined</span></div>
<div class="line"><span class="lineno">  954</span> </div>
<div class="line"><span class="lineno">  956</span>    <span class="comment">// Save the output connected components marked with location</span></div>
<div class="line"><span class="lineno">  958</span><span class="comment"></span> </div>
<div class="line"><span class="lineno">  959</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#aa7edcadd4024f703ce9677fd1fe4dc84">TIMESTACK_PUSH</a>(<span class="stringliteral">&quot;Extract CC: save CCs with location properties&quot;</span>);</div>
<div class="line"><span class="lineno">  960</span> </div>
<div class="line"><span class="lineno">  961</span>    <span class="comment">// for each connected component</span></div>
<div class="line"><span class="lineno">  962</span>    <span class="keywordflow">for</span> (std::map&lt;std::size_t, std::shared_ptr&lt;hmesh_t&gt;&gt;::const_iterator cc_iter = ccID_to_mesh.cbegin();</div>
<div class="line"><span class="lineno">  963</span>         cc_iter != ccID_to_mesh.cend();</div>
<div class="line"><span class="lineno">  964</span>         ++cc_iter) {</div>
<div class="line"><span class="lineno">  965</span> </div>
<div class="line"><span class="lineno">  966</span>        <span class="keyword">const</span> std::size_t&amp; cc_id = cc_iter-&gt;first;</div>
<div class="line"><span class="lineno">  967</span>        <span class="keywordtype">bool</span> userWantsCC = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ccID_to_keepFlag, cc_id);</div>
<div class="line"><span class="lineno">  968</span> </div>
<div class="line"><span class="lineno">  969</span>        <span class="keywordflow">if</span> (!userWantsCC) {</div>
<div class="line"><span class="lineno">  970</span>            <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  971</span>        }</div>
<div class="line"><span class="lineno">  972</span> </div>
<div class="line"><span class="lineno">  973</span>        <span class="keyword">const</span> std::shared_ptr&lt;hmesh_t&gt; cc = cc_iter-&gt;second;</div>
<div class="line"><span class="lineno">  974</span> </div>
<div class="line"><span class="lineno">  975</span>        <span class="comment">// The boolean is needed to prevent saving duplicate connected components into the vector &quot;connected_components[cc_id]&quot;.</span></div>
<div class="line"><span class="lineno">  976</span>        <span class="comment">// This can happen because the current function is called for each new cut-mesh polygon that is stitched, during the</span></div>
<div class="line"><span class="lineno">  977</span>        <span class="comment">// polygon stitching phases. In the other times when the current function is called, we are guarranteed that</span></div>
<div class="line"><span class="lineno">  978</span>        <span class="comment">// &quot;connected_components[cc_id]&quot; is empty.</span></div>
<div class="line"><span class="lineno">  979</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno">  980</span>        <span class="comment">// The above has the implication that the newly stitched polygon (during the stitching phase) is added to just [one] of the</span></div>
<div class="line"><span class="lineno">  981</span>        <span class="comment">// discovered connected components (which are of a particular color tag), thus leaving the other connected components to be</span></div>
<div class="line"><span class="lineno">  982</span>        <span class="comment">// discovered as having exactly the same number of polygons as before since no new polygon has been added to them.</span></div>
<div class="line"><span class="lineno">  983</span>        <span class="comment">// So to prevent this connected component dupliction issue, a connected component is only added into &quot;connected_components[cc_id]&quot;</span></div>
<div class="line"><span class="lineno">  984</span>        <span class="comment">// if the following hold:</span></div>
<div class="line"><span class="lineno">  985</span>        <span class="comment">// 1) &quot;connected_components[cc_id]&quot; is empty (making the added connected component new and unique)</span></div>
<div class="line"><span class="lineno">  986</span>        <span class="comment">// 2) the most-recent connected component instance at &quot;connected_components[cc_id].back()&quot; has less faces (in which case, always differing by one)</span></div>
<div class="line"><span class="lineno">  987</span>        <span class="comment">//    than the new connected component we wish to add i.e. &quot;cc&quot;</span></div>
<div class="line"><span class="lineno">  988</span>        <span class="keyword">auto</span> cc_fiter = connected_components.find(cc_id);</div>
<div class="line"><span class="lineno">  989</span>        <span class="keywordtype">bool</span> proceed_to_save_mesh = cc_fiter == connected_components.cend() || cc_fiter-&gt;second.back().first-&gt;number_of_faces() != cc-&gt;number_of_faces();</div>
<div class="line"><span class="lineno">  990</span> </div>
<div class="line"><span class="lineno">  991</span>        <span class="keywordflow">if</span> (proceed_to_save_mesh) {</div>
<div class="line"><span class="lineno">  992</span> </div>
<div class="line"><span class="lineno">  993</span>            <a class="code hl_enumeration" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1">sm_frag_location_t</a> location = <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1a0db45d2a4141101bdfe48e3314cfbca3">sm_frag_location_t::UNDEFINED</a>;</div>
<div class="line"><span class="lineno">  994</span> </div>
<div class="line"><span class="lineno">  995</span>            <span class="keywordflow">if</span> (!sm_polygons_below_cs.empty() &amp;&amp; !sm_polygons_above_cs.empty()) {</div>
<div class="line"><span class="lineno">  996</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ccID_to_cs_descriptor.find(cc_id) != ccID_to_cs_descriptor.cend());</div>
<div class="line"><span class="lineno">  997</span>                location = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ccID_to_cs_descriptor, cc_id);</div>
<div class="line"><span class="lineno">  998</span>            }</div>
<div class="line"><span class="lineno">  999</span> </div>
<div class="line"><span class="lineno"> 1000</span>            <a class="code hl_struct" href="../../dd/d24/kernel_8cpp.html#d7/dd7/structconnected__component__info__t">connected_component_info_t</a> ccinfo;</div>
<div class="line"><span class="lineno"> 1001</span>            ccinfo.<a class="code hl_variable" href="../../dd/d24/kernel_8cpp.html#afa3c2c427f966ebf58df76bf2a70cb2a">location</a> = location;</div>
<div class="line"><span class="lineno"> 1002</span>            ccinfo.<a class="code hl_variable" href="../../dd/d24/kernel_8cpp.html#a468cb4ae49fdbb1d4c3d9f1482d357c8">seam_vertices</a> = std::move(<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(cc_to_seam_vertices, cc_id));</div>
<div class="line"><span class="lineno"> 1003</span> </div>
<div class="line"><span class="lineno"> 1004</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 1005</span>            <span class="comment">// Map vertex and face descriptors to original values in the input source- and cut-mesh</span></div>
<div class="line"><span class="lineno"> 1006</span>            <span class="comment">// For vertices it is only non-intersection points that have defined mapping otherwise</span></div>
<div class="line"><span class="lineno"> 1007</span>            <span class="comment">// the mapped-to value is undefined (hmesh_t::null_vertex())</span></div>
<div class="line"><span class="lineno"> 1008</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 1009</span> </div>
<div class="line"><span class="lineno"> 1010</span>            <span class="keyword">const</span> std::vector&lt;vd_t&gt;&amp; cc_to_mX_vertex = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ccID_to_cc_to_mX_vertex, cc_id);</div>
<div class="line"><span class="lineno"> 1011</span> </div>
<div class="line"><span class="lineno"> 1012</span>            <span class="keywordflow">if</span> (popuplate_vertex_maps) {</div>
<div class="line"><span class="lineno"> 1013</span>                <span class="comment">// map cc vertices to original input mesh</span></div>
<div class="line"><span class="lineno"> 1014</span>                <span class="comment">// -----------------------------------</span></div>
<div class="line"><span class="lineno"> 1015</span>                ccinfo.<a class="code hl_variable" href="../../dd/d24/kernel_8cpp.html#a1bc542fb79db59847263709ec2552648">data_maps</a>.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a9e9fab100b24cb5bbfd775433609548e">vertex_map</a>.resize(cc-&gt;number_of_vertices());</div>
<div class="line"><span class="lineno"> 1016</span>                <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">vertex_array_iterator_t</a> i = cc-&gt;vertices_begin(); i != cc-&gt;vertices_end(); ++i) {</div>
<div class="line"><span class="lineno"> 1017</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> cc_descr = *i;</div>
<div class="line"><span class="lineno"> 1018</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)cc_descr &lt; cc_to_mX_vertex.size() <span class="comment">/*cc_to_mX_vertex.count(cc_descr) == 1*/</span>);</div>
<div class="line"><span class="lineno"> 1019</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> mX_descr = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(cc_to_mX_vertex, cc_descr);</div>
<div class="line"><span class="lineno"> 1020</span> </div>
<div class="line"><span class="lineno"> 1021</span>                    <span class="comment">// NOTE: &quot;m1_to_m0_sm_ovtx_colored&quot; contains only non-intersection points from the source mesh</span></div>
<div class="line"><span class="lineno"> 1022</span>                    <span class="comment">// std::vector&lt;vd_t&gt;::const_iterator m1_to_m0_sm_ovtx_colored_fiter = m1_to_m0_sm_ovtx_colored.find(mX_descr);</span></div>
<div class="line"><span class="lineno"> 1023</span> </div>
<div class="line"><span class="lineno"> 1024</span>                    <span class="keywordtype">bool</span> is_m1_sm_overtex = (size_t)mX_descr &lt; m1_to_m0_sm_ovtx_colored.size(); <span class="comment">// m1_to_m0_sm_ovtx_colored_fiter != m1_to_m0_sm_ovtx_colored.cend();</span></div>
<div class="line"><span class="lineno"> 1025</span>                    <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> m0_descr = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ab448d0b9684fd2f648195b2e5edb83f2">hmesh_t::null_vertex</a>(); <span class="comment">// NOTE: two cut-mesh &quot;m1&quot; original vertices may map to one &quot;m0&quot; vertex (due to winding order duplication)</span></div>
<div class="line"><span class="lineno"> 1026</span> </div>
<div class="line"><span class="lineno"> 1027</span>                    <span class="keywordflow">if</span> (is_m1_sm_overtex) {</div>
<div class="line"><span class="lineno"> 1028</span>                        m0_descr = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m1_to_m0_sm_ovtx_colored, mX_descr); <span class="comment">// m1_to_m0_sm_ovtx_colored_fiter-&gt;second;</span></div>
<div class="line"><span class="lineno"> 1029</span>                    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!m1_to_m0_cm_ovtx_colored.empty()) { <span class="comment">// are we in the stitching stage..? (calling with &quot;m1&quot;)</span></div>
<div class="line"><span class="lineno"> 1030</span>                        <span class="comment">// Lets search through the map &quot;m1_to_m0_cm_ovtx_colored&quot;</span></div>
<div class="line"><span class="lineno"> 1031</span> </div>
<div class="line"><span class="lineno"> 1032</span>                        <span class="comment">// NOTE: &quot;m1_to_m0_cm_ovtx_colored&quot; contains only non-intersection points from the cut mesh</span></div>
<div class="line"><span class="lineno"> 1033</span>                        std::unordered_map&lt;vd_t, vd_t&gt;::const_iterator m1_to_m0_cm_ovtx_colored_fiter = m1_to_m0_cm_ovtx_colored.find(mX_descr);</div>
<div class="line"><span class="lineno"> 1034</span> </div>
<div class="line"><span class="lineno"> 1035</span>                        <span class="keywordtype">bool</span> is_m1_cm_overtex = m1_to_m0_cm_ovtx_colored_fiter != m1_to_m0_cm_ovtx_colored.cend();</div>
<div class="line"><span class="lineno"> 1036</span> </div>
<div class="line"><span class="lineno"> 1037</span>                        <span class="keywordflow">if</span> (is_m1_cm_overtex) {</div>
<div class="line"><span class="lineno"> 1038</span>                            m0_descr = m1_to_m0_cm_ovtx_colored_fiter-&gt;second;</div>
<div class="line"><span class="lineno"> 1039</span>                        }</div>
<div class="line"><span class="lineno"> 1040</span>                    }</div>
<div class="line"><span class="lineno"> 1041</span> </div>
<div class="line"><span class="lineno"> 1042</span>                    <span class="keywordflow">if</span> (m0_descr == <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ab448d0b9684fd2f648195b2e5edb83f2">hmesh_t::null_vertex</a>()) { <span class="comment">// if still not found, then we are strictly &quot;mX&quot; polygons is &quot;m0&quot; polygons</span></div>
<div class="line"><span class="lineno"> 1043</span>                        m0_descr = mX_descr;</div>
<div class="line"><span class="lineno"> 1044</span>                    }</div>
<div class="line"><span class="lineno"> 1045</span> </div>
<div class="line"><span class="lineno"> 1046</span>                    <span class="keyword">const</span> <span class="keywordtype">bool</span> vertex_is_in_input_mesh_or_is_intersection_point = (m0_descr != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ab448d0b9684fd2f648195b2e5edb83f2">hmesh_t::null_vertex</a>()); <span class="comment">// i.e. is it an original vertex (its not an intersection point/along cut-path)</span></div>
<div class="line"><span class="lineno"> 1047</span> </div>
<div class="line"><span class="lineno"> 1048</span>                    <span class="keywordflow">if</span> (vertex_is_in_input_mesh_or_is_intersection_point) {</div>
<div class="line"><span class="lineno"> 1049</span>                        <span class="comment">// std::map&lt;vd_t, vd_t&gt;::const_iterator m0_to_ps_vtx_fiter = m0_to_ps_vtx.find(m0_descr);</span></div>
<div class="line"><span class="lineno"> 1050</span>                        <span class="keywordtype">bool</span> vertex_is_in_input_mesh = (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)m0_descr &lt; (<span class="keywordtype">int</span>)m0_to_ps_vtx.size(); <span class="comment">// m0_to_ps_vtx_fiter != m0_to_ps_vtx.cend();</span></div>
<div class="line"><span class="lineno"> 1051</span>                        <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> input_mesh_descr = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ab448d0b9684fd2f648195b2e5edb83f2">hmesh_t::null_vertex</a>(); <span class="comment">// i.e. source-mesh or cut-mesh</span></div>
<div class="line"><span class="lineno"> 1052</span> </div>
<div class="line"><span class="lineno"> 1053</span>                        <span class="keywordflow">if</span> (vertex_is_in_input_mesh) {</div>
<div class="line"><span class="lineno"> 1054</span>                            <span class="comment">// MCUT_ASSERT(m0_to_ps_vtx.count(m0_descr) == 1);</span></div>
<div class="line"><span class="lineno"> 1055</span>                            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> ps_descr = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_ps_vtx, m0_descr); <span class="comment">// m0_to_ps_vtx_fiter-&gt;second; // SAFE_ACCESS(m0_to_ps_vtx, m0_descr);</span></div>
<div class="line"><span class="lineno"> 1056</span>                            <span class="comment">// we don&#39;t know whether it belongs to cut-mesh patch or source-mesh, so check</span></div>
<div class="line"><span class="lineno"> 1057</span>                            <span class="keyword">const</span> <span class="keywordtype">bool</span> is_cutmesh_vtx = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a426849b7f7105963c5e2767bdd31b155">ps_is_cutmesh_vertex</a>(ps_descr, sm_vtx_cnt);</div>
<div class="line"><span class="lineno"> 1058</span>                            <span class="keywordflow">if</span> (is_cutmesh_vtx) {</div>
<div class="line"><span class="lineno"> 1059</span>                                input_mesh_descr = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_to_cm_vtx, ps_descr);</div>
<div class="line"><span class="lineno"> 1060</span>                                <span class="comment">// add an offset which allows users to deduce which birth/origin mesh (source or cut mesh) a vertex (map value) belongs to.</span></div>
<div class="line"><span class="lineno"> 1061</span>                                input_mesh_descr = <span class="keyword">static_cast&lt;</span><a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a><span class="keyword">&gt;</span>(input_mesh_descr + sm_vtx_cnt);</div>
<div class="line"><span class="lineno"> 1062</span>                            } <span class="keywordflow">else</span> { <span class="comment">// source-mesh vertex</span></div>
<div class="line"><span class="lineno"> 1063</span>                                input_mesh_descr = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_to_sm_vtx, ps_descr);</div>
<div class="line"><span class="lineno"> 1064</span>                            }</div>
<div class="line"><span class="lineno"> 1065</span>                        }</div>
<div class="line"><span class="lineno"> 1066</span> </div>
<div class="line"><span class="lineno"> 1067</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ccinfo.<a class="code hl_variable" href="../../dd/d24/kernel_8cpp.html#a1bc542fb79db59847263709ec2552648">data_maps</a>.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a9e9fab100b24cb5bbfd775433609548e">vertex_map</a>, cc_descr) == <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ab448d0b9684fd2f648195b2e5edb83f2">hmesh_t::null_vertex</a>() <span class="comment">/*ccinfo.data_maps.vertex_map.count(cc_descr) == 0*/</span>);</div>
<div class="line"><span class="lineno"> 1068</span>                        ccinfo.<a class="code hl_variable" href="../../dd/d24/kernel_8cpp.html#a1bc542fb79db59847263709ec2552648">data_maps</a>.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a9e9fab100b24cb5bbfd775433609548e">vertex_map</a>[cc_descr] = input_mesh_descr;</div>
<div class="line"><span class="lineno"> 1069</span>                    }</div>
<div class="line"><span class="lineno"> 1070</span>                }</div>
<div class="line"><span class="lineno"> 1071</span>            } <span class="comment">// if (popuplate_vertex_maps) {</span></div>
<div class="line"><span class="lineno"> 1072</span> </div>
<div class="line"><span class="lineno"> 1073</span>            <span class="keywordflow">if</span> (popuplate_face_maps) {</div>
<div class="line"><span class="lineno"> 1074</span>                <span class="comment">// map face to original input mesh</span></div>
<div class="line"><span class="lineno"> 1075</span>                <span class="comment">// -----------------------------------</span></div>
<div class="line"><span class="lineno"> 1076</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(ccID_to_cc_to_mX_face.count(cc_id) == 1);</div>
<div class="line"><span class="lineno"> 1077</span> </div>
<div class="line"><span class="lineno"> 1078</span>                std::vector&lt;fd_t&gt;&amp; cc_to_mX_face = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ccID_to_cc_to_mX_face, cc_id);</div>
<div class="line"><span class="lineno"> 1079</span>                ccinfo.<a class="code hl_variable" href="../../dd/d24/kernel_8cpp.html#a1bc542fb79db59847263709ec2552648">data_maps</a>.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#ad3bc443e258d2e060b4df3ad508c7a41">face_map</a>.resize(cc-&gt;number_of_faces());</div>
<div class="line"><span class="lineno"> 1080</span>                <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">face_array_iterator_t</a> f = cc-&gt;faces_begin(); f != cc-&gt;faces_end(); ++f) {</div>
<div class="line"><span class="lineno"> 1081</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> cc_descr = *f;</div>
<div class="line"><span class="lineno"> 1082</span>                    <span class="comment">// account for the fact that the parameter &quot;mX_traced_polygons&quot; may contain only a subset of traced polygons</span></div>
<div class="line"><span class="lineno"> 1083</span>                    <span class="comment">// need this to compute correct polygon index to access std::maps</span></div>
<div class="line"><span class="lineno"> 1084</span>                    <span class="comment">// const fd_t cc_descr_offsetted(traced_polygons_base_offset + static_cast&lt;int&gt;(cc_descr));</span></div>
<div class="line"><span class="lineno"> 1085</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)cc_descr &lt; cc_to_mX_face.size() <span class="comment">/*cc_to_mX_face.count(cc_descr) == 1*/</span>);</div>
<div class="line"><span class="lineno"> 1086</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> mX_descr = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(cc_to_mX_face, cc_descr);</div>
<div class="line"><span class="lineno"> 1087</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> offsetted_mX_descr(traced_polygons_base_offset + <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(mX_descr)); <span class="comment">// global traced polygon index</span></div>
<div class="line"><span class="lineno"> 1088</span>                    <span class="keywordtype">int</span> m0_descr = -1;</div>
<div class="line"><span class="lineno"> 1089</span> </div>
<div class="line"><span class="lineno"> 1090</span>                    <span class="keywordflow">if</span> (m1_to_m0_face_colored.size() &gt; 0) { <span class="comment">// are we calling from during the patch stitching phase..?</span></div>
<div class="line"><span class="lineno"> 1091</span>                        <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> m1_descr = offsetted_mX_descr;</div>
<div class="line"><span class="lineno"> 1092</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m1_to_m0_face_colored.count(mX_descr) == 1);</div>
<div class="line"><span class="lineno"> 1093</span>                        m0_descr = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m1_to_m0_face_colored, m1_descr);</div>
<div class="line"><span class="lineno"> 1094</span>                    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 1095</span>                        m0_descr = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(offsetted_mX_descr);</div>
<div class="line"><span class="lineno"> 1096</span>                    }</div>
<div class="line"><span class="lineno"> 1097</span> </div>
<div class="line"><span class="lineno"> 1098</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_to_ps_face.count(m0_descr) == 1);</div>
<div class="line"><span class="lineno"> 1099</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> ps_descr = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_ps_face, m0_descr); <span class="comment">// every traced polygon can be mapped back to an input mesh polygon</span></div>
<div class="line"><span class="lineno"> 1100</span>                    <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> input_mesh_descr = <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>();</div>
<div class="line"><span class="lineno"> 1101</span> </div>
<div class="line"><span class="lineno"> 1102</span>                    <span class="keyword">const</span> <span class="keywordtype">bool</span> from_cutmesh_face = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aaf65fb11520f9cb197774e79efeddfbb">ps_is_cutmesh_face</a>(ps_descr, sm_face_count);</div>
<div class="line"><span class="lineno"> 1103</span>                    <span class="keywordflow">if</span> (from_cutmesh_face) {</div>
<div class="line"><span class="lineno"> 1104</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">int</span>)ps_descr &lt; (<span class="keywordtype">int</span>)ps_to_cm_face.size());</div>
<div class="line"><span class="lineno"> 1105</span>                        input_mesh_descr = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_to_cm_face, ps_descr);</div>
<div class="line"><span class="lineno"> 1106</span>                        <span class="comment">// add an offset which allows users to deduce which birth/origin mesh (source or cut mesh) a face (map value) belongs to.</span></div>
<div class="line"><span class="lineno"> 1107</span>                        input_mesh_descr = <span class="keyword">static_cast&lt;</span><a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a><span class="keyword">&gt;</span>(input_mesh_descr + sm_face_count);</div>
<div class="line"><span class="lineno"> 1108</span>                    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 1109</span>                        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">int</span>)ps_descr &lt; (<span class="keywordtype">int</span>)ps_to_sm_face.size());</div>
<div class="line"><span class="lineno"> 1110</span>                        input_mesh_descr = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ps_to_sm_face, ps_descr);</div>
<div class="line"><span class="lineno"> 1111</span>                    }</div>
<div class="line"><span class="lineno"> 1112</span> </div>
<div class="line"><span class="lineno"> 1113</span>                    <span class="comment">// map to input mesh face</span></div>
<div class="line"><span class="lineno"> 1114</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ccinfo.<a class="code hl_variable" href="../../dd/d24/kernel_8cpp.html#a1bc542fb79db59847263709ec2552648">data_maps</a>.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#ad3bc443e258d2e060b4df3ad508c7a41">face_map</a>, cc_descr) == <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>() <span class="comment">/* (ccinfo.data_maps.face_map.count(cc_descr) == 0*/</span>);</div>
<div class="line"><span class="lineno"> 1115</span>                    ccinfo.<a class="code hl_variable" href="../../dd/d24/kernel_8cpp.html#a1bc542fb79db59847263709ec2552648">data_maps</a>.<a class="code hl_variable" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#ad3bc443e258d2e060b4df3ad508c7a41">face_map</a>[cc_descr] = input_mesh_descr;</div>
<div class="line"><span class="lineno"> 1116</span>                }</div>
<div class="line"><span class="lineno"> 1117</span>            } <span class="comment">// if (popuplate_face_maps) {</span></div>
<div class="line"><span class="lineno"> 1118</span> </div>
<div class="line"><span class="lineno"> 1119</span>            connected_components[cc_id].emplace_back(cc, std::move(ccinfo));</div>
<div class="line"><span class="lineno"> 1120</span>        }</div>
<div class="line"><span class="lineno"> 1121</span>    }</div>
<div class="line"><span class="lineno"> 1122</span>    <a class="code hl_define" href="../../d9/d9a/mcut_2include_2mcut_2internal_2timer_8h.html#a94de28d8a4c3b764f6a3bd2097882054">TIMESTACK_POP</a>();</div>
<div class="line"><span class="lineno"> 1123</span> </div>
<div class="line"><span class="lineno"> 1124</span>    <span class="keywordflow">return</span> (mesh);</div>
<div class="line"><span class="lineno"> 1125</span>}</div>
<div class="ttc" id="akernel_8cpp_html_a1bc542fb79db59847263709ec2552648"><div class="ttname"><a href="../../dd/d24/kernel_8cpp.html#a1bc542fb79db59847263709ec2552648">connected_component_info_t::data_maps</a></div><div class="ttdeci">output_mesh_data_maps_t data_maps</div><div class="ttdef"><b>Definition</b> kernel.cpp:363</div></div>
<div class="ttc" id="akernel_8cpp_html_a468cb4ae49fdbb1d4c3d9f1482d357c8"><div class="ttname"><a href="../../dd/d24/kernel_8cpp.html#a468cb4ae49fdbb1d4c3d9f1482d357c8">connected_component_info_t::seam_vertices</a></div><div class="ttdeci">std::vector&lt; vd_t &gt; seam_vertices</div><div class="ttdef"><b>Definition</b> kernel.cpp:361</div></div>
<div class="ttc" id="akernel_8cpp_html_aa563464e84f5a01cf43a91cc350fd920"><div class="ttname"><a href="../../dd/d24/kernel_8cpp.html#aa563464e84f5a01cf43a91cc350fd920">find_connected_components</a></div><div class="ttdeci">int find_connected_components(std::vector&lt; int &gt; &amp;fccmap, const hmesh_t &amp;mesh, std::vector&lt; int &gt; &amp;cc_to_vertex_count, std::vector&lt; int &gt; &amp;cc_to_face_count)</div><div class="ttdef"><b>Definition</b> kernel.cpp:227</div></div>
<div class="ttc" id="akernel_8cpp_html_afa3c2c427f966ebf58df76bf2a70cb2a"><div class="ttname"><a href="../../dd/d24/kernel_8cpp.html#afa3c2c427f966ebf58df76bf2a70cb2a">connected_component_info_t::location</a></div><div class="ttdeci">sm_frag_location_t location</div><div class="ttdef"><b>Definition</b> kernel.cpp:359</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a40e02a0f5aec11abce73c46fe0ff41f1"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1">sm_frag_location_t</a></div><div class="ttdeci">sm_frag_location_t</div><div class="ttdef"><b>Definition</b> kernel.h:87</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a40e02a0f5aec11abce73c46fe0ff41f1a0db45d2a4141101bdfe48e3314cfbca3"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1a0db45d2a4141101bdfe48e3314cfbca3">sm_frag_location_t::UNDEFINED</a></div><div class="ttdeci">@ UNDEFINED</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a40e02a0f5aec11abce73c46fe0ff41f1aa25949e21299b84cc33c4b00c740f08f"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1aa25949e21299b84cc33c4b00c740f08f">sm_frag_location_t::BELOW</a></div><div class="ttdeci">@ BELOW</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a40e02a0f5aec11abce73c46fe0ff41f1ac2d92b81beeac9bfc89fb870c1a20767"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1ac2d92b81beeac9bfc89fb870c1a20767">sm_frag_location_t::ABOVE</a></div><div class="ttdeci">@ ABOVE</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a9e9fab100b24cb5bbfd775433609548e"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a9e9fab100b24cb5bbfd775433609548e">output_mesh_data_maps_t::vertex_map</a></div><div class="ttdeci">std::vector&lt; vd_t &gt; vertex_map</div><div class="ttdef"><b>Definition</b> kernel.h:163</div></div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_ad3bc443e258d2e060b4df3ad508c7a41"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#ad3bc443e258d2e060b4df3ad508c7a41">output_mesh_data_maps_t::face_map</a></div><div class="ttdeci">std::vector&lt; fd_t &gt; face_map</div><div class="ttdef"><b>Definition</b> kernel.h:168</div></div>
<div class="ttc" id="anamespacelibnest2d_1_1shapelike_html_a2aeb0374bbb83d0a6452bca14e1bbbda"><div class="ttname"><a href="../../dd/d66/namespacelibnest2d_1_1shapelike.html#a2aeb0374bbb83d0a6452bca14e1bbbda">libnest2d::shapelike::begin</a></div><div class="ttdeci">S::iterator begin(S &amp;sh, const PathTag &amp;)</div><div class="ttdef"><b>Definition</b> geometry_traits.hpp:627</div></div>
<div class="ttc" id="atestmini_8c_html_a6355bd7e1f3a9e910ff48e2c374fc62a"><div class="ttname"><a href="../../d7/da4/testmini_8c.html#a6355bd7e1f3a9e910ff48e2c374fc62a">in</a></div><div class="ttdeci">static unsigned char __LZO_MMODEL in[IN_LEN]</div><div class="ttdef"><b>Definition</b> testmini.c:57</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1ac2d92b81beeac9bfc89fb870c1a20767">ABOVE</a>, <a class="el" href="../../#l00507">hmesh_t::add_face()</a>, <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1aa25949e21299b84cc33c4b00c740f08f">BELOW</a>, <a class="el" href="../../#l00363">connected_component_info_t::data_maps</a>, <a class="el" href="../../#l00582">std::distance()</a>, <a class="el" href="../../#l00168">output_mesh_data_maps_t::face_map</a>, <a class="el" href="../../#l00889">hmesh_t::faces_begin()</a>, <a class="el" href="../../#l00901">hmesh_t::faces_end()</a>, <a class="el" href="../../#l00227">find_connected_components()</a>, <a class="el" href="../../#l00741">hmesh_t::get_halfedges_around_face()</a>, <a class="el" href="../../#l00683">hmesh_t::get_vertices_around_face()</a>, <a class="el" href="../../#l00057">in</a>, <a class="el" href="../../#l00340">int</a>, <a class="el" href="../../#l00359">connected_component_info_t::location</a>, <a class="el" href="../../#l00062">MCUT_ASSERT</a>, <a class="el" href="../../#l00107">hmesh_t::null_face()</a>, <a class="el" href="../../#l00092">hmesh_t::null_vertex()</a>, <a class="el" href="../../#l00406">parallel_for()</a>, <a class="el" href="../../#l00145">ps_is_cutmesh_face()</a>, <a class="el" href="../../#l00140">ps_is_cutmesh_vertex()</a>, <a class="el" href="../../#l01174">hmesh_t::reserve_for_additional_elements()</a>, <a class="el" href="../../#l00097">SAFE_ACCESS</a>, <a class="el" href="../../#l00361">connected_component_info_t::seam_vertices</a>, <a class="el" href="../../#l00144">hmesh_t::target()</a>, <a class="el" href="../../#l00081">TIMESTACK_POP</a>, <a class="el" href="../../#l00080">TIMESTACK_PUSH</a>, <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1a0db45d2a4141101bdfe48e3314cfbca3">UNDEFINED</a>, <a class="el" href="../../#l00219">hmesh_t::vertex()</a>, and <a class="el" href="../../#l00163">output_mesh_data_maps_t::vertex_map</a>.</p>
<div id="dynsection-7" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-7-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-7-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-7-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="../../dd/d24/kernel_8cpp_a34276907046e706af5626787b2e2b05a_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="aa563464e84f5a01cf43a91cc350fd920" name="aa563464e84f5a01cf43a91cc350fd920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa563464e84f5a01cf43a91cc350fd920">&#9670;&#160;</a></span>find_connected_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> find_connected_components </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fccmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cc_to_vertex_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cc_to_face_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  235</span>{</div>
<div class="line"><span class="lineno">  236</span>    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a35ce6de1cc36d41e9eb48edb3e23e795">number_of_vertices</a>() &gt;= 3);</div>
<div class="line"><span class="lineno">  237</span>    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ac759578dea5f6dd7eebcef3f1a5af705">number_of_edges</a>() &gt;= 3);</div>
<div class="line"><span class="lineno">  238</span>    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a08178cf3f846017dbec208b96c970ac7">number_of_faces</a>() &gt;= 1);</div>
<div class="line"><span class="lineno">  239</span> </div>
<div class="line"><span class="lineno">  240</span>    <span class="comment">/*</span></div>
<div class="line"><span class="lineno">  241</span><span class="comment">        for each node u:</span></div>
<div class="line"><span class="lineno">  242</span><span class="comment">            if u is not visited :</span></div>
<div class="line"><span class="lineno">  243</span><span class="comment">                visited[u] = true</span></div>
<div class="line"><span class="lineno">  244</span><span class="comment">                connected_component += 1</span></div>
<div class="line"><span class="lineno">  245</span><span class="comment">                dfs(u)</span></div>
<div class="line"><span class="lineno">  246</span><span class="comment">    */</span></div>
<div class="line"><span class="lineno">  247</span>    std::vector&lt;int&gt; visited(mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a35ce6de1cc36d41e9eb48edb3e23e795">number_of_vertices</a>(), -1); <span class="comment">// if vertex does not exist, then its not visited</span></div>
<div class="line"><span class="lineno">  248</span>    <span class="keywordtype">int</span> connected_component_id = -1;</div>
<div class="line"><span class="lineno">  249</span>    std::vector&lt;bool&gt; queued(mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a35ce6de1cc36d41e9eb48edb3e23e795">number_of_vertices</a>(), <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno">  250</span>    std::queue&lt;vd_t&gt; queue; <span class="comment">// .. to discover all vertices of current connected component</span></div>
<div class="line"><span class="lineno">  251</span> </div>
<div class="line"><span class="lineno">  252</span>    std::vector&lt;vd_t&gt; vertices_of_v;</div>
<div class="line"><span class="lineno">  253</span>    std::vector&lt;vd_t&gt; vertices_of_u;</div>
<div class="line"><span class="lineno">  254</span> </div>
<div class="line"><span class="lineno">  255</span>    <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">vertex_array_iterator_t</a> u = mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a0bf160ae73193f77064cc3d8f01e63a3">vertices_begin</a>(); u != mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a80ac49a03f1085744f5b121cc4acbf2c">vertices_end</a>(); ++u) {</div>
<div class="line"><span class="lineno">  256</span>        <span class="keywordflow">if</span> (visited[*u] == -1) {</div>
<div class="line"><span class="lineno">  257</span>            connected_component_id += 1;</div>
<div class="line"><span class="lineno">  258</span>            visited[*u] = connected_component_id;</div>
<div class="line"><span class="lineno">  259</span>            queued[*u] = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  260</span> </div>
<div class="line"><span class="lineno">  261</span>            cc_to_vertex_count.push_back(1); <span class="comment">// each discovered cc has at least one vertex</span></div>
<div class="line"><span class="lineno">  262</span> </div>
<div class="line"><span class="lineno">  263</span>            vertices_of_u.clear();</div>
<div class="line"><span class="lineno">  264</span>            mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ae892c101bd2816b0e18cf2e0405c16cb">get_vertices_around_vertex</a>(vertices_of_u, *u);</div>
<div class="line"><span class="lineno">  265</span> </div>
<div class="line"><span class="lineno">  266</span>            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)vertices_of_u.size(); ++i) {</div>
<div class="line"><span class="lineno">  267</span>                <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> vou = vertices_of_u[i];</div>
<div class="line"><span class="lineno">  268</span>                queue.push(vou);</div>
<div class="line"><span class="lineno">  269</span>                queued[vou] = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  270</span>            }</div>
<div class="line"><span class="lineno">  271</span> </div>
<div class="line"><span class="lineno">  272</span>            <span class="keywordflow">while</span> (!queue.empty()) {</div>
<div class="line"><span class="lineno">  273</span>                <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> v = queue.front(); <span class="comment">// current</span></div>
<div class="line"><span class="lineno">  274</span>                queue.pop();</div>
<div class="line"><span class="lineno">  275</span> </div>
<div class="line"><span class="lineno">  276</span>                <span class="keywordflow">if</span> (visited[v] == -1) <span class="comment">// v not yet associated with a cc</span></div>
<div class="line"><span class="lineno">  277</span>                {</div>
<div class="line"><span class="lineno">  278</span>                    visited[v] = connected_component_id;</div>
<div class="line"><span class="lineno">  279</span>                    cc_to_vertex_count[connected_component_id] += 1;</div>
<div class="line"><span class="lineno">  280</span> </div>
<div class="line"><span class="lineno">  281</span>                    vertices_of_v.clear();</div>
<div class="line"><span class="lineno">  282</span>                    mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ae892c101bd2816b0e18cf2e0405c16cb">get_vertices_around_vertex</a>(vertices_of_v, v);</div>
<div class="line"><span class="lineno">  283</span> </div>
<div class="line"><span class="lineno">  284</span>                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)vertices_of_v.size(); ++i) {</div>
<div class="line"><span class="lineno">  285</span>                        <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> vov = vertices_of_v[i];</div>
<div class="line"><span class="lineno">  286</span>                        <span class="keywordflow">if</span> (visited[vov] == -1 || queued[vov] == <span class="keyword">false</span>) {</div>
<div class="line"><span class="lineno">  287</span>                            queue.push(vertices_of_v[i]);</div>
<div class="line"><span class="lineno">  288</span>                            queued[vov] = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  289</span>                        }</div>
<div class="line"><span class="lineno">  290</span>                    }</div>
<div class="line"><span class="lineno">  291</span>                }</div>
<div class="line"><span class="lineno">  292</span>            }</div>
<div class="line"><span class="lineno">  293</span> </div>
<div class="line"><span class="lineno">  294</span>            <span class="comment">// dfs_cc(*u, mesh, visited, connected_component_id);</span></div>
<div class="line"><span class="lineno">  295</span>        }</div>
<div class="line"><span class="lineno">  296</span>    }</div>
<div class="line"><span class="lineno">  297</span> </div>
<div class="line"><span class="lineno">  298</span>    fccmap.clear();</div>
<div class="line"><span class="lineno">  299</span>    fccmap.resize(mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a08178cf3f846017dbec208b96c970ac7">number_of_faces</a>());</div>
<div class="line"><span class="lineno">  300</span>    <span class="keywordtype">int</span> num_connected_components = (connected_component_id + 1); <span class="comment">// number of CCs</span></div>
<div class="line"><span class="lineno">  301</span>    cc_to_face_count.resize(num_connected_components);</div>
<div class="line"><span class="lineno">  302</span><span class="preprocessor">#if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno">  303</span>    <span class="keyword">auto</span> fn_set_cc_to_face_count = [](std::vector&lt;int&gt;::iterator block_start_, std::vector&lt;int&gt;::iterator block_end_) {</div>
<div class="line"><span class="lineno">  304</span>        <span class="keywordflow">for</span> (std::vector&lt;int&gt;::iterator it = block_start_; it != block_end_; ++it) {</div>
<div class="line"><span class="lineno">  305</span>            *it = 0;</div>
<div class="line"><span class="lineno">  306</span>        }</div>
<div class="line"><span class="lineno">  307</span>    };</div>
<div class="line"><span class="lineno">  308</span> </div>
<div class="line"><span class="lineno">  309</span>    <a class="code hl_function" href="../../df/d05/tpool_8h.html#a48d2e68725f7691f1422697f4c359827">parallel_for</a>(</div>
<div class="line"><span class="lineno">  310</span>        scheduler,</div>
<div class="line"><span class="lineno">  311</span>        cc_to_face_count.begin(),</div>
<div class="line"><span class="lineno">  312</span>        cc_to_face_count.end(),</div>
<div class="line"><span class="lineno">  313</span>        fn_set_cc_to_face_count);</div>
<div class="line"><span class="lineno">  314</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">  315</span>    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>)cc_to_face_count.size(); ++i) {</div>
<div class="line"><span class="lineno">  316</span>        cc_to_face_count[i] = 0;</div>
<div class="line"><span class="lineno">  317</span>    }</div>
<div class="line"><span class="lineno">  318</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  319</span> </div>
<div class="line"><span class="lineno">  320</span>    fccmap.reserve(mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a08178cf3f846017dbec208b96c970ac7">number_of_faces</a>());</div>
<div class="line"><span class="lineno">  321</span> </div>
<div class="line"><span class="lineno">  322</span><span class="preprocessor">#if defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno">  323</span>    <span class="keyword">auto</span> fn_map_faces = [&amp;](<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">face_array_iterator_t</a> block_start_, <a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">face_array_iterator_t</a> block_end_) {</div>
<div class="line"><span class="lineno">  324</span>        <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">face_array_iterator_t</a> f = block_start_; f != block_end_; ++f) {</div>
<div class="line"><span class="lineno">  325</span>            <span class="keyword">const</span> std::vector&lt;vertex_descriptor_t&gt; vertices = mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a765a6f3b7249eb47135d246f6d301102">get_vertices_around_face</a>(*f);</div>
<div class="line"><span class="lineno">  326</span> </div>
<div class="line"><span class="lineno">  327</span>            <span class="keywordtype">int</span> face_cc_id = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(visited, vertices.front());</div>
<div class="line"><span class="lineno">  328</span> </div>
<div class="line"><span class="lineno">  329</span>            <span class="comment">// all vertices belong to the same conn comp</span></div>
<div class="line"><span class="lineno">  330</span>            fccmap[*f] = face_cc_id;</div>
<div class="line"><span class="lineno">  331</span> </div>
<div class="line"><span class="lineno">  332</span>            cc_to_face_count[face_cc_id] += 1;</div>
<div class="line"><span class="lineno">  333</span>        }</div>
<div class="line"><span class="lineno">  334</span>    };</div>
<div class="line"><span class="lineno">  335</span> </div>
<div class="line"><span class="lineno">  336</span>    <a class="code hl_function" href="../../df/d05/tpool_8h.html#a48d2e68725f7691f1422697f4c359827">parallel_for</a>(</div>
<div class="line"><span class="lineno">  337</span>        scheduler,</div>
<div class="line"><span class="lineno">  338</span>        mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a913e50afe2e1dc220a379b1dbf8050d2">faces_begin</a>(),</div>
<div class="line"><span class="lineno">  339</span>        mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a89e4f1f34dda0bdeced26bc71cb4a4fc">faces_end</a>(),</div>
<div class="line"><span class="lineno">  340</span>        fn_map_faces);</div>
<div class="line"><span class="lineno">  341</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">  342</span>    <span class="comment">// map each face to a connected component</span></div>
<div class="line"><span class="lineno">  343</span>    <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">face_array_iterator_t</a> f = mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a913e50afe2e1dc220a379b1dbf8050d2">faces_begin</a>(); f != mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a89e4f1f34dda0bdeced26bc71cb4a4fc">faces_end</a>(); ++f) {</div>
<div class="line"><span class="lineno">  344</span>        <span class="keyword">const</span> std::vector&lt;vertex_descriptor_t&gt; vertices = mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a765a6f3b7249eb47135d246f6d301102">get_vertices_around_face</a>(*f);</div>
<div class="line"><span class="lineno">  345</span> </div>
<div class="line"><span class="lineno">  346</span>        <span class="keywordtype">int</span> face_cc_id = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(visited, vertices.front());</div>
<div class="line"><span class="lineno">  347</span> </div>
<div class="line"><span class="lineno">  348</span>        <span class="comment">// all vertices belong to the same conn comp</span></div>
<div class="line"><span class="lineno">  349</span>        fccmap[*f] = face_cc_id;</div>
<div class="line"><span class="lineno">  350</span> </div>
<div class="line"><span class="lineno">  351</span>        cc_to_face_count[face_cc_id] += 1;</div>
<div class="line"><span class="lineno">  352</span>    }</div>
<div class="line"><span class="lineno">  353</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  354</span> </div>
<div class="line"><span class="lineno">  355</span>    <span class="keywordflow">return</span> num_connected_components;</div>
<div class="line"><span class="lineno">  356</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00889">hmesh_t::faces_begin()</a>, <a class="el" href="../../#l00901">hmesh_t::faces_end()</a>, <a class="el" href="../../#l00683">hmesh_t::get_vertices_around_face()</a>, <a class="el" href="../../#l00713">hmesh_t::get_vertices_around_vertex()</a>, <a class="el" href="../../#l00340">int</a>, <a class="el" href="../../#l00062">MCUT_ASSERT</a>, <a class="el" href="../../#l00120">hmesh_t::number_of_edges()</a>, <a class="el" href="../../#l00130">hmesh_t::number_of_faces()</a>, <a class="el" href="../../#l00115">hmesh_t::number_of_vertices()</a>, <a class="el" href="../../#l00406">parallel_for()</a>, <a class="el" href="../../#l00097">SAFE_ACCESS</a>, <a class="el" href="../../#l00838">hmesh_t::vertices_begin()</a>, and <a class="el" href="../../#l00850">hmesh_t::vertices_end()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../#l00353">check_input_mesh()</a>, and <a class="el" href="../../#l00384">extract_connected_components()</a>.</p>
<div id="dynsection-8" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-8-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-8-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-8-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="../../dd/d24/kernel_8cpp_aa563464e84f5a01cf43a91cc350fd920_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<div id="dynsection-9" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-9-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-9-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-9-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../dd/d24/kernel_8cpp_aa563464e84f5a01cf43a91cc350fd920_icgraph.svg" width="566" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a9c800ed2d7c13bb98e4f4fb2be59b53e" name="a9c800ed2d7c13bb98e4f4fb2be59b53e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c800ed2d7c13bb98e4f4fb2be59b53e">&#9670;&#160;</a></span>have_same_coordinate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool have_same_coordinate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a>, <a class="el" href="../../df/db1/math_8h.html#aad22bf610529d452b5b6ba5b758cb39c">vec3</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>bin_vertices_sorted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>coordinate_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1140</span>{</div>
<div class="line"><span class="lineno"> 1141</span>    <span class="comment">// for each vertex, compare to all others in vector (compare by given component)</span></div>
<div class="line"><span class="lineno"> 1142</span>    <span class="keywordtype">bool</span> is_duplicate = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 1143</span>    <span class="keywordflow">for</span> (std::vector&lt;std::pair&lt;vd_t, vec3&gt;&gt;::const_iterator i = bin_vertices_sorted.begin(); i != bin_vertices_sorted.end(); ++i) {</div>
<div class="line"><span class="lineno"> 1144</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a>&amp; vertex_i_coordinates = i-&gt;second;</div>
<div class="line"><span class="lineno"> 1145</span>        <span class="keyword">const</span> <span class="keywordtype">double</span> vertex_i_coordinate = vertex_i_coordinates[coordinate_index];</div>
<div class="line"><span class="lineno"> 1146</span>        <span class="keywordtype">bool</span> vertex_i_coordinate_is_duplicate = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 1147</span> </div>
<div class="line"><span class="lineno"> 1148</span>        <span class="keywordflow">for</span> (std::vector&lt;std::pair&lt;vd_t, vec3&gt;&gt;::const_iterator j = bin_vertices_sorted.begin(); j != bin_vertices_sorted.end(); ++j) {</div>
<div class="line"><span class="lineno"> 1149</span>            <span class="keywordflow">if</span> (j == i) {</div>
<div class="line"><span class="lineno"> 1150</span>                <span class="keywordflow">continue</span>; <span class="comment">// same vertex, skip</span></div>
<div class="line"><span class="lineno"> 1151</span>            }</div>
<div class="line"><span class="lineno"> 1152</span> </div>
<div class="line"><span class="lineno"> 1153</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a>&amp; vertex_j_coordinates = j-&gt;second;</div>
<div class="line"><span class="lineno"> 1154</span>            <span class="keyword">const</span> <span class="keywordtype">double</span> vertex_j_coordinate = vertex_j_coordinates[coordinate_index];</div>
<div class="line"><span class="lineno"> 1155</span>            vertex_i_coordinate_is_duplicate = (vertex_i_coordinate == vertex_j_coordinate);</div>
<div class="line"><span class="lineno"> 1156</span> </div>
<div class="line"><span class="lineno"> 1157</span>            <span class="keywordflow">if</span> (vertex_i_coordinate_is_duplicate) {</div>
<div class="line"><span class="lineno"> 1158</span>                is_duplicate = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1159</span>                <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1160</span>            }</div>
<div class="line"><span class="lineno"> 1161</span>        }</div>
<div class="line"><span class="lineno"> 1162</span> </div>
<div class="line"><span class="lineno"> 1163</span>        <span class="keywordflow">if</span> (is_duplicate) {</div>
<div class="line"><span class="lineno"> 1164</span>            <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1165</span>        }</div>
<div class="line"><span class="lineno"> 1166</span>    }</div>
<div class="line"><span class="lineno"> 1167</span> </div>
<div class="line"><span class="lineno"> 1168</span>    <span class="keywordflow">return</span> is_duplicate;</div>
<div class="line"><span class="lineno"> 1169</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="../../#l01558">dispatch()</a>.</p>
<div id="dynsection-10" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-10-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-10-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-10-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../dd/d24/kernel_8cpp_a9c800ed2d7c13bb98e4f4fb2be59b53e_icgraph.svg" width="398" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a0a7bbc0e3b52fd64237a4e3525cbc09e" name="a0a7bbc0e3b52fd64237a4e3525cbc09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7bbc0e3b52fd64237a4e3525cbc09e">&#9670;&#160;</a></span>is_virtual_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_virtual_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a> &amp;&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1128</span>{</div>
<div class="line"><span class="lineno"> 1129</span>    <span class="keywordflow">return</span> (face == <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>());</div>
<div class="line"><span class="lineno"> 1130</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00107">hmesh_t::null_face()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../#l01558">dispatch()</a>.</p>
<div id="dynsection-11" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-11-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-11-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-11-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../dd/d24/kernel_8cpp_a0a7bbc0e3b52fd64237a4e3525cbc09e_cgraph.svg" width="296" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div id="dynsection-12" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-12-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-12-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-12-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../dd/d24/kernel_8cpp_a0a7bbc0e3b52fd64237a4e3525cbc09e_icgraph.svg" width="347" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a1b55223f27099f06cf4ef4442552eb3e" name="a1b55223f27099f06cf4ef4442552eb3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b55223f27099f06cf4ef4442552eb3e">&#9670;&#160;</a></span>linear_projection_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &gt; linear_projection_sort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a>, <a class="el" href="../../df/db1/math_8h.html#aad22bf610529d452b5b6ba5b758cb39c">vec3</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1519</span>{</div>
<div class="line"><span class="lineno"> 1520</span>    <span class="comment">/*</span></div>
<div class="line"><span class="lineno"> 1521</span><span class="comment">1. pick one point as the origin</span></div>
<div class="line"><span class="lineno"> 1522</span><span class="comment">2. pick any other point as the vector destination point</span></div>
<div class="line"><span class="lineno"> 1523</span><span class="comment">3. compute normalize vector from &lt;1&gt; to &lt;2&gt;</span></div>
<div class="line"><span class="lineno"> 1524</span><span class="comment">4. for each point in list of all points</span></div>
<div class="line"><span class="lineno"> 1525</span><span class="comment">    a) compute unnormalized vector from &lt;1&gt; to &lt;4&gt;</span></div>
<div class="line"><span class="lineno"> 1526</span><span class="comment">    b) project a) onto 3) using scalar product, and save result in list</span></div>
<div class="line"><span class="lineno"> 1527</span><span class="comment">5. sort points according to scalar products values from &lt;4b&gt;</span></div>
<div class="line"><span class="lineno"> 1528</span><span class="comment">*/</span></div>
<div class="line"><span class="lineno"> 1529</span>    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(points.size() &gt;= 2);</div>
<div class="line"><span class="lineno"> 1530</span>    <span class="keyword">const</span> std::vector&lt;std::pair&lt;vd_t, vec3&gt;&gt;::const_iterator origin = points.cbegin();</div>
<div class="line"><span class="lineno"> 1531</span>    <span class="keyword">const</span> std::vector&lt;std::pair&lt;vd_t, vec3&gt;&gt;::const_iterator dst = points.cbegin() + 1;</div>
<div class="line"><span class="lineno"> 1532</span> </div>
<div class="line"><span class="lineno"> 1533</span>    <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a> orig_to_dst_vec = <a class="code hl_function" href="../../df/db1/math_8h.html#a1d24f16459340cb796ff7bf6b7094108">normalize</a>(origin-&gt;second - dst-&gt;second);</div>
<div class="line"><span class="lineno"> 1534</span> </div>
<div class="line"><span class="lineno"> 1535</span>    std::vector&lt;std::pair&lt;vd_t, double&gt;&gt; point_projections;</div>
<div class="line"><span class="lineno"> 1536</span> </div>
<div class="line"><span class="lineno"> 1537</span>    <span class="keywordflow">for</span> (std::vector&lt;std::pair&lt;vd_t, vec3&gt;&gt;::const_iterator i = points.cbegin(); i != points.cend(); ++i) {</div>
<div class="line"><span class="lineno"> 1538</span>        <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a> orig_to_point_vec = (origin-&gt;second - i-&gt;second);</div>
<div class="line"><span class="lineno"> 1539</span>        point_projections.emplace_back(i-&gt;first, <a class="code hl_function" href="../../df/db1/math_8h.html#a0b6cff67f1f57a1096b42782cf5397da">dot_product</a>(orig_to_point_vec, orig_to_dst_vec));</div>
<div class="line"><span class="lineno"> 1540</span>    }</div>
<div class="line"><span class="lineno"> 1541</span> </div>
<div class="line"><span class="lineno"> 1542</span>    std::sort(point_projections.begin(), point_projections.end(),</div>
<div class="line"><span class="lineno"> 1543</span>        [&amp;](<span class="keyword">const</span> std::pair&lt;vd_t, double&gt;&amp; a, <span class="keyword">const</span> std::pair&lt;vd_t, double&gt;&amp; b) {</div>
<div class="line"><span class="lineno"> 1544</span>            return a.second &lt; b.second;</div>
<div class="line"><span class="lineno"> 1545</span>        });</div>
<div class="line"><span class="lineno"> 1546</span> </div>
<div class="line"><span class="lineno"> 1547</span>    std::vector&lt;vd_t&gt; sorted_descriptors;</div>
<div class="line"><span class="lineno"> 1548</span>    <span class="keywordflow">for</span> (std::vector&lt;std::pair&lt;vd_t, double&gt;&gt;::const_iterator i = point_projections.cbegin(); i != point_projections.cend(); ++i) {</div>
<div class="line"><span class="lineno"> 1549</span>        sorted_descriptors.push_back(i-&gt;first);</div>
<div class="line"><span class="lineno"> 1550</span>    }</div>
<div class="line"><span class="lineno"> 1551</span> </div>
<div class="line"><span class="lineno"> 1552</span>    <span class="keywordflow">return</span> sorted_descriptors;</div>
<div class="line"><span class="lineno"> 1553</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00425">dot_product()</a>, <a class="el" href="../../#l00062">MCUT_ASSERT</a>, and <a class="el" href="../../#l00480">normalize()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../#l01558">dispatch()</a>.</p>
<div id="dynsection-13" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-13-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-13-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-13-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="../../dd/d24/kernel_8cpp_a1b55223f27099f06cf4ef4442552eb3e_cgraph.svg" width="100%" height="383"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<div id="dynsection-14" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-14-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-14-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-14-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../dd/d24/kernel_8cpp_a1b55223f27099f06cf4ef4442552eb3e_icgraph.svg" width="386" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aa7de49b10bd8663a91f01e3beef776ff" name="aa7de49b10bd8663a91f01e3beef776ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7de49b10bd8663a91f01e3beef776ff">&#9670;&#160;</a></span>m0_is_intersection_point()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool m0_is_intersection_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &amp;&#160;</td>
          <td class="paramname"><em>ps_vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>ps_vtx_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  135</span>{</div>
<div class="line"><span class="lineno">  136</span>    <span class="keywordflow">return</span> ((<span class="keywordtype">int</span>)ps_vd) &gt;= ps_vtx_cnt;</div>
<div class="line"><span class="lineno">  137</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="../../#l01558">dispatch()</a>, and <a class="el" href="../../#l01184">resolve_intersection_point_descriptor()</a>.</p>
<div id="dynsection-15" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-15-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-15-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-15-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../dd/d24/kernel_8cpp_aa7de49b10bd8663a91f01e3beef776ff_icgraph.svg" width="439" height="102"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ab4b4325eac03e592fece787fdf95fec8" name="ab4b4325eac03e592fece787fdf95fec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b4325eac03e592fece787fdf95fec8">&#9670;&#160;</a></span>m0_is_polygon_boundary_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool m0_is_polygon_boundary_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d77/hmesh_8h.html#a92abe1b30dc402b94e53318479d8b242">ed_t</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>m0_num_cutpath_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1179</span>{</div>
<div class="line"><span class="lineno"> 1180</span>    <span class="keywordflow">return</span> (<a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>)e &gt;= m0_num_cutpath_edges;</div>
<div class="line"><span class="lineno"> 1181</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad0e7884ca4d03bad54f0f83d198676e5" name="ad0e7884ca4d03bad54f0f83d198676e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e7884ca4d03bad54f0f83d198676e5">&#9670;&#160;</a></span>m0_is_polygon_boundary_halfedge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool m0_is_polygon_boundary_halfedge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>m0_num_cutpath_halfedges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1174</span>{</div>
<div class="line"><span class="lineno"> 1175</span>    <span class="keywordflow">return</span> (<a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>)h &gt;= m0_num_cutpath_halfedges;</div>
<div class="line"><span class="lineno"> 1176</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="../../#l01184">resolve_intersection_point_descriptor()</a>.</p>
<div id="dynsection-16" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-16-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-16-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-16-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../dd/d24/kernel_8cpp_ad0e7884ca4d03bad54f0f83d198676e5_icgraph.svg" width="364" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a7095d6c7279faa9121a2a2722a51a814" name="a7095d6c7279faa9121a2a2722a51a814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7095d6c7279faa9121a2a2722a51a814">&#9670;&#160;</a></span>mark_seam_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d95/glu-libtess_8h.html#a4292190e3f1f6b373a760c7d9316ad3c">void</a> mark_seam_vertices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh_seam_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>ps_num_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>m1_num_vertices_after_srcmesh_partitioning</em> = <code>std::numeric_limits&lt;<a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&gt;<a class="el" href="../../df/db1/math_8h.html#a5083c48fbfb60dd70808789479f4db53">::max</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  373</span>{</div>
<div class="line"><span class="lineno">  374</span>    mesh_seam_vertices.resize(mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a35ce6de1cc36d41e9eb48edb3e23e795">number_of_vertices</a>());</div>
<div class="line"><span class="lineno">  375</span>    <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">vertex_array_iterator_t</a> i = mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a0bf160ae73193f77064cc3d8f01e63a3">vertices_begin</a>();</div>
<div class="line"><span class="lineno">  376</span>         i != mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a80ac49a03f1085744f5b121cc4acbf2c">vertices_end</a>();</div>
<div class="line"><span class="lineno">  377</span>         ++i) {</div>
<div class="line"><span class="lineno">  378</span>        <span class="keyword">const</span> <span class="keywordtype">int</span> idx = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(*i);</div>
<div class="line"><span class="lineno">  379</span>        mesh_seam_vertices[*i] = (idx &gt;= ps_num_vertices &amp;&amp; idx &lt; m1_num_vertices_after_srcmesh_partitioning);</div>
<div class="line"><span class="lineno">  380</span>    }</div>
<div class="line"><span class="lineno">  381</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00115">hmesh_t::number_of_vertices()</a>, <a class="el" href="../../#l00838">hmesh_t::vertices_begin()</a>, and <a class="el" href="../../#l00850">hmesh_t::vertices_end()</a>.</p>
<div id="dynsection-17" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-17-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-17-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-17-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../dd/d24/kernel_8cpp_a7095d6c7279faa9121a2a2722a51a814_cgraph.svg" width="559" height="216"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ae88bf8cfd20dbb5a5910da29eb700947" name="ae88bf8cfd20dbb5a5910da29eb700947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88bf8cfd20dbb5a5910da29eb700947">&#9670;&#160;</a></span>mesh_is_closed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mesh_is_closed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1489</span>{</div>
<div class="line"><span class="lineno"> 1490</span>    <span class="keywordtype">bool</span> all_halfedges_incident_to_face = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1491</span><span class="preprocessor">#if 0 </span><span class="comment">// defined(MCUT_WITH_COMPUTE_HELPER_THREADPOOL)</span></div>
<div class="line"><span class="lineno"> 1492</span>    {</div>
<div class="line"><span class="lineno"> 1493</span>        printf(<span class="stringliteral">&quot;mesh=%d\n&quot;</span>, (<span class="keywordtype">int</span>)mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a38154c743bff113eea931e14eaea6ddd">number_of_halfedges</a>());</div>
<div class="line"><span class="lineno"> 1494</span>        all_halfedges_incident_to_face = <a class="code hl_function" href="../../df/d05/tpool_8h.html#a7d03b3a593c675f5c23c24158cc01acc">parallel_find_if</a>(</div>
<div class="line"><span class="lineno"> 1495</span>                                             scheduler,</div>
<div class="line"><span class="lineno"> 1496</span>                                             mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#add3cbd7d63a0ab56d19696365e2ecfa7">halfedges_begin</a>(),</div>
<div class="line"><span class="lineno"> 1497</span>                                             mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a945a607d3e0f69a6ab7c2cfd25377ab7">halfedges_end</a>(),</div>
<div class="line"><span class="lineno"> 1498</span>                                             [&amp;](<a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h) {</div>
<div class="line"><span class="lineno"> 1499</span>                                                 const fd_t f = mesh.face(h);</div>
<div class="line"><span class="lineno"> 1500</span>                                                 return (f == hmesh_t::null_face());</div>
<div class="line"><span class="lineno"> 1501</span>                                             })</div>
<div class="line"><span class="lineno"> 1502</span>            == mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a945a607d3e0f69a6ab7c2cfd25377ab7">halfedges_end</a>();</div>
<div class="line"><span class="lineno"> 1503</span>    }</div>
<div class="line"><span class="lineno"> 1504</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno"> 1505</span>    <span class="keywordflow">for</span> (<a class="code hl_class" href="../../d8/d9b/classarray__iterator__t.html">halfedge_array_iterator_t</a> iter = mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#add3cbd7d63a0ab56d19696365e2ecfa7">halfedges_begin</a>(); iter != mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a945a607d3e0f69a6ab7c2cfd25377ab7">halfedges_end</a>(); ++iter) {</div>
<div class="line"><span class="lineno"> 1506</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> f = mesh.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(*iter);</div>
<div class="line"><span class="lineno"> 1507</span>        <span class="keywordflow">if</span> (f == <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>()) {</div>
<div class="line"><span class="lineno"> 1508</span>            all_halfedges_incident_to_face = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 1509</span>            <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1510</span>        }</div>
<div class="line"><span class="lineno"> 1511</span>    }</div>
<div class="line"><span class="lineno"> 1512</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 1513</span>    <span class="keywordflow">return</span> all_halfedges_incident_to_face;</div>
<div class="line"><span class="lineno"> 1514</span>}</div>
<div class="ttc" id="atpool_8h_html_a7d03b3a593c675f5c23c24158cc01acc"><div class="ttname"><a href="../../df/d05/tpool_8h.html#a7d03b3a593c675f5c23c24158cc01acc">parallel_find_if</a></div><div class="ttdeci">Iterator parallel_find_if(thread_pool &amp;pool, Iterator first, Iterator last, UnaryPredicate predicate)</div><div class="ttdef"><b>Definition</b> tpool.h:812</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00107">hmesh_t::null_face()</a>, and <a class="el" href="../../#l00812">parallel_find_if()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../#l01558">dispatch()</a>.</p>
<div id="dynsection-18" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-18-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-18-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-18-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="../../dd/d24/kernel_8cpp_ae88bf8cfd20dbb5a5910da29eb700947_cgraph.svg" width="100%" height="514"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<div id="dynsection-19" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-19-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-19-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-19-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../dd/d24/kernel_8cpp_ae88bf8cfd20dbb5a5910da29eb700947_icgraph.svg" width="358" height="36"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="abcaa230eb10486e26a5167bae360d451" name="abcaa230eb10486e26a5167bae360d451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcaa230eb10486e26a5167bae360d451">&#9670;&#160;</a></span>ps_get_ivtx_registry_entry_faces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a> &gt; ps_get_ivtx_registry_entry_faces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> &amp;&#160;</td>
          <td class="paramname"><em>ps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a92abe1b30dc402b94e53318479d8b242">ed_t</a>, <a class="el" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ivtx_registry_entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1400</span>{</div>
<div class="line"><span class="lineno"> 1401</span>    <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h0 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(ivtx_registry_entry.first, 0);</div>
<div class="line"><span class="lineno"> 1402</span>    <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> h1 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(ivtx_registry_entry.first, 1);</div>
<div class="line"><span class="lineno"> 1403</span>    <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> h0_face = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(h0);</div>
<div class="line"><span class="lineno"> 1404</span>    <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> h1_face = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(h1);</div>
<div class="line"><span class="lineno"> 1405</span> </div>
<div class="line"><span class="lineno"> 1406</span>    <span class="keywordflow">return</span> { ivtx_registry_entry.second, h0_face, h1_face };</div>
<div class="line"><span class="lineno"> 1407</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00211">hmesh_t::face()</a>, and <a class="el" href="../../#l00261">hmesh_t::halfedge()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../#l01558">dispatch()</a>, and <a class="el" href="../../#l01412">update_neighouring_ps_iface_m0_edge_list()</a>.</p>
<div id="dynsection-20" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-20-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-20-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-20-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../dd/d24/kernel_8cpp_abcaa230eb10486e26a5167bae360d451_cgraph.svg" width="530" height="86"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<div id="dynsection-21" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-21-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-21-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-21-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../dd/d24/kernel_8cpp_abcaa230eb10486e26a5167bae360d451_icgraph.svg" width="590" height="80"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="aaf65fb11520f9cb197774e79efeddfbb" name="aaf65fb11520f9cb197774e79efeddfbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf65fb11520f9cb197774e79efeddfbb">&#9670;&#160;</a></span>ps_is_cutmesh_face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ps_is_cutmesh_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a> &amp;&#160;</td>
          <td class="paramname"><em>ps_fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>sm_face_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  146</span>{</div>
<div class="line"><span class="lineno">  147</span>    <span class="keywordflow">return</span> ((<span class="keywordtype">int</span>)ps_fd) &gt;= sm_face_count;</div>
<div class="line"><span class="lineno">  148</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="../../#l01558">dispatch()</a>, <a class="el" href="../../#l00384">extract_connected_components()</a>, and <a class="el" href="../../#l01184">resolve_intersection_point_descriptor()</a>.</p>
<div id="dynsection-22" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-22-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-22-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-22-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../dd/d24/kernel_8cpp_aaf65fb11520f9cb197774e79efeddfbb_icgraph.svg" width="519" height="151"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a426849b7f7105963c5e2767bdd31b155" name="a426849b7f7105963c5e2767bdd31b155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426849b7f7105963c5e2767bdd31b155">&#9670;&#160;</a></span>ps_is_cutmesh_vertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ps_is_cutmesh_vertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &amp;&#160;</td>
          <td class="paramname"><em>ps_vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>sm_vtx_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  141</span>{</div>
<div class="line"><span class="lineno">  142</span>    <span class="keywordflow">return</span> ((<span class="keywordtype">int</span>)ps_vd) &gt;= sm_vtx_cnt;</div>
<div class="line"><span class="lineno">  143</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="../../#l01558">dispatch()</a>, <a class="el" href="../../#l00384">extract_connected_components()</a>, and <a class="el" href="../../#l01184">resolve_intersection_point_descriptor()</a>.</p>
<div id="dynsection-23" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-23-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-23-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-23-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../dd/d24/kernel_8cpp_a426849b7f7105963c5e2767bdd31b155_icgraph.svg" width="530" height="151"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="a0299dc00caf656e5713f528574c77a02" name="a0299dc00caf656e5713f528574c77a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0299dc00caf656e5713f528574c77a02">&#9670;&#160;</a></span>resolve_intersection_point_descriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> resolve_intersection_point_descriptor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> &amp;&#160;</td>
          <td class="paramname"><em>ps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> &amp;&#160;</td>
          <td class="paramname"><em>m0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a> &amp;&#160;</td>
          <td class="paramname"><em>m0_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &amp;&#160;</td>
          <td class="paramname"><em>m0_h_tgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &amp;&#160;</td>
          <td class="paramname"><em>m1_h_tgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>m0_h_is_ox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>m0_h_to_ply</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a>, std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ivtx_to_incoming_hlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a>, bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>m0_sm_ihe_to_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a92abe1b30dc402b94e53318479d8b242">ed_t</a>, <a class="el" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>m0_ivtx_to_intersection_registry_entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a>, <a class="el" href="../../df/d77/hmesh_8h.html#a4b0f01185c259735e74598aa7cb52fc2">hd_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m0_to_m1_ihe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m0_to_ps_vtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>ps_vtx_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>sm_vtx_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>sm_face_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/d38/lzoconf_8h.html#a61569f2965b7a369eb10b6d75d410d11">int</a>&#160;</td>
          <td class="paramname"><em>m0_num_cutpath_halfedges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1203</span>{</div>
<div class="line"><span class="lineno"> 1204</span>    <span class="comment">// the descriptor instance we want to return</span></div>
<div class="line"><span class="lineno"> 1205</span>    <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> resolved_inst = m1_h_tgt;</div>
<div class="line"><span class="lineno"> 1206</span> </div>
<div class="line"><span class="lineno"> 1207</span>    <span class="comment">// First, we get list of all other halfedges in (in &quot;m0&quot;) whose target-vertex</span></div>
<div class="line"><span class="lineno"> 1208</span>    <span class="comment">// is the same as the target of the current halfedge</span></div>
<div class="line"><span class="lineno"> 1209</span>    <span class="keyword">const</span> std::vector&lt;hd_t&gt;&amp; incoming = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(ivtx_to_incoming_hlist, m0_h_tgt);</div>
<div class="line"><span class="lineno"> 1210</span> </div>
<div class="line"><span class="lineno"> 1211</span>    <span class="comment">// the minimum number of halfedges whose target is &quot;m0_h_tgt&quot;</span></div>
<div class="line"><span class="lineno"> 1212</span>    <span class="comment">// this &quot;minimum&quot; case come from interior edges</span></div>
<div class="line"><span class="lineno"> 1213</span>    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(incoming.size() &gt;= 2);</div>
<div class="line"><span class="lineno"> 1214</span> </div>
<div class="line"><span class="lineno"> 1215</span>    <span class="comment">// Second, we will now filter &quot;incoming&quot; (those pointing to &quot;m0_h_tgt&quot;) by</span></div>
<div class="line"><span class="lineno"> 1216</span>    <span class="comment">// keeping only the halfedges which are:</span></div>
<div class="line"><span class="lineno"> 1217</span>    <span class="comment">// 1) Processed/transformed (so that we can use it to infer what to do with &quot;resolved_inst&quot;)</span></div>
<div class="line"><span class="lineno"> 1218</span>    <span class="comment">// 2) are incident to a traced polygon, and</span></div>
<div class="line"><span class="lineno"> 1219</span>    <span class="comment">// 3) used by a traced polygon of the src-mesh</span></div>
<div class="line"><span class="lineno"> 1220</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 1221</span>    <span class="comment">// The remaining halfedges will be the ones we can use to infer the correct value of &quot;resolved_inst&quot;</span></div>
<div class="line"><span class="lineno"> 1222</span> </div>
<div class="line"><span class="lineno"> 1223</span>    std::vector&lt;hd_t&gt; halfedges_across_cut_path = incoming;</div>
<div class="line"><span class="lineno"> 1224</span> </div>
<div class="line"><span class="lineno"> 1225</span>    <span class="comment">// for each halfedge across the cut-path</span></div>
<div class="line"><span class="lineno"> 1226</span>    <span class="keywordflow">for</span> (std::vector&lt;hd_t&gt;::iterator halfedge_across_cut_path_iter = halfedges_across_cut_path.begin();</div>
<div class="line"><span class="lineno"> 1227</span>         halfedge_across_cut_path_iter != halfedges_across_cut_path.end();) {</div>
<div class="line"><span class="lineno"> 1228</span> </div>
<div class="line"><span class="lineno"> 1229</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> s = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a49ab80e240a5f3555bde8db61739d685">source</a>(*halfedge_across_cut_path_iter);</div>
<div class="line"><span class="lineno"> 1230</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> t = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(*halfedge_across_cut_path_iter);</div>
<div class="line"><span class="lineno"> 1231</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> s_is_ivtx = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(s, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 1232</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> t_is_ivtx = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(t, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 1233</span> </div>
<div class="line"><span class="lineno"> 1234</span>        <span class="comment">// check if the halfedge is only next to the cut-mesh</span></div>
<div class="line"><span class="lineno"> 1235</span> </div>
<div class="line"><span class="lineno"> 1236</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> is_ox_cs_h = (!s_is_ivtx &amp;&amp; <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a426849b7f7105963c5e2767bdd31b155">ps_is_cutmesh_vertex</a>(<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_ps_vtx, s), sm_vtx_cnt));</div>
<div class="line"><span class="lineno"> 1237</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> is_xo_cs_h = (!t_is_ivtx &amp;&amp; <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#a426849b7f7105963c5e2767bdd31b155">ps_is_cutmesh_vertex</a>(<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_ps_vtx, t), sm_vtx_cnt));</div>
<div class="line"><span class="lineno"> 1238</span>        <span class="keywordtype">bool</span> is_strictly_cs_h = is_ox_cs_h || is_xo_cs_h; <span class="comment">// check if halfedge is used only by a cut-surface polygon</span></div>
<div class="line"><span class="lineno"> 1239</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> is_xx = s_is_ivtx &amp;&amp; t_is_ivtx;</div>
<div class="line"><span class="lineno"> 1240</span> </div>
<div class="line"><span class="lineno"> 1241</span>        <span class="keywordflow">if</span> (!is_strictly_cs_h &amp;&amp; is_xx) {</div>
<div class="line"><span class="lineno"> 1242</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 1243</span>                <span class="comment">//const hd_t s_ps_h = SAFE_ACCESS(m0_ivtx_to_ps_edge, s);</span></div>
<div class="line"><span class="lineno"> 1244</span>                <span class="comment">//const hd_t t_ps_h = SAFE_ACCESS(m0_ivtx_to_ps_edge, t);</span></div>
<div class="line"><span class="lineno"> 1245</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)s - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(s) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 1246</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> s_ps_e = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, s - ps_vtx_cnt).first; <span class="comment">//  SAFE_ACCESS(m0_ivtx_to_ps_edge, s); //  ps.edge(s_ps_h);</span></div>
<div class="line"><span class="lineno"> 1247</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)t - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(t) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 1248</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> t_ps_e = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, t - ps_vtx_cnt).first; <span class="comment">//SAFE_ACCESS(m0_ivtx_to_ps_edge, t); // ps.edge(t_ps_h);</span></div>
<div class="line"><span class="lineno"> 1249</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno"> 1250</span>            <span class="keyword">const</span> <span class="keywordtype">bool</span> is_boundary_halfedge = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#ad0e7884ca4d03bad54f0f83d198676e5">m0_is_polygon_boundary_halfedge</a>(</div>
<div class="line"><span class="lineno"> 1251</span>                *halfedge_across_cut_path_iter,</div>
<div class="line"><span class="lineno"> 1252</span>                m0_num_cutpath_halfedges);</div>
<div class="line"><span class="lineno"> 1253</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 1254</span>            <span class="keyword">const</span> <span class="keywordtype">bool</span> oh_is_exterior = is_boundary_halfedge; <span class="comment">//(s_ps_e == t_ps_e);                                                   // lays on exterior of ps polygon</span></div>
<div class="line"><span class="lineno"> 1255</span> </div>
<div class="line"><span class="lineno"> 1256</span>            <span class="keywordflow">if</span> (oh_is_exterior) {</div>
<div class="line"><span class="lineno"> 1257</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)s - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(s) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 1258</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> s_ps_e = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, (std::size_t)s - ps_vtx_cnt).first; <span class="comment">//  SAFE_ACCESS(m0_ivtx_to_ps_edge, s); //  ps.edge(s_ps_h);</span></div>
<div class="line"><span class="lineno"> 1259</span> </div>
<div class="line"><span class="lineno"> 1260</span>                <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> s_ps_h0 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(s_ps_e, 0); <span class="comment">// could alternatively use t_ps_e since both he&#39;s are part of same edge</span></div>
<div class="line"><span class="lineno"> 1261</span>                <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> incident_face = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(s_ps_h0);</div>
<div class="line"><span class="lineno"> 1262</span> </div>
<div class="line"><span class="lineno"> 1263</span>                <span class="keywordflow">if</span> (incident_face == <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>()) {</div>
<div class="line"><span class="lineno"> 1264</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> s_ps_h1 = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a323ceb33e1af67dc8ce0defc2774a3e6">halfedge</a>(s_ps_e, 1);</div>
<div class="line"><span class="lineno"> 1265</span>                    incident_face = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#aa952ea0298d27de614e443c65ee15155">face</a>(s_ps_h1);</div>
<div class="line"><span class="lineno"> 1266</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(incident_face != <a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af78eb5785020a91476b847187b3b2b1a">hmesh_t::null_face</a>());</div>
<div class="line"><span class="lineno"> 1267</span>                }</div>
<div class="line"><span class="lineno"> 1268</span> </div>
<div class="line"><span class="lineno"> 1269</span>                <span class="comment">// TODO: use &quot;ps_is_cutmesh_vertex&quot; since it will require using much less queries on ps</span></div>
<div class="line"><span class="lineno"> 1270</span>                is_strictly_cs_h = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aaf65fb11520f9cb197774e79efeddfbb">ps_is_cutmesh_face</a>(incident_face, sm_face_count);</div>
<div class="line"><span class="lineno"> 1271</span>            }</div>
<div class="line"><span class="lineno"> 1272</span>        }</div>
<div class="line"><span class="lineno"> 1273</span> </div>
<div class="line"><span class="lineno"> 1274</span>        <span class="comment">// if</span></div>
<div class="line"><span class="lineno"> 1275</span>        <span class="comment">// 1) halfedge strictly belongs to the cut-mesh, OR</span></div>
<div class="line"><span class="lineno"> 1276</span>        <span class="comment">// 2) halfedge is not used for tracing, OR</span></div>
<div class="line"><span class="lineno"> 1277</span>        <span class="comment">// 3) halfedge has not been processed</span></div>
<div class="line"><span class="lineno"> 1278</span>        <span class="keywordflow">if</span> (is_strictly_cs_h || <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 1279</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, *halfedge_across_cut_path_iter).<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a809275ccd755fb7b88661d952134b14d">size</a>() == 0 <span class="comment">/*m0_h_to_ply.find(*halfedge_across_cut_path_iter) == m0_h_to_ply.end()*/</span> || <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 1280</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_sm_ihe_to_flag, *halfedge_across_cut_path_iter) == <span class="keyword">false</span>) { <span class="comment">// is halfedge incident to a traced polygon and is it processed..?</span></div>
<div class="line"><span class="lineno"> 1281</span>            halfedge_across_cut_path_iter = halfedges_across_cut_path.erase(halfedge_across_cut_path_iter);</div>
<div class="line"><span class="lineno"> 1282</span>        } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 1283</span>            ++halfedge_across_cut_path_iter; <span class="comment">// next</span></div>
<div class="line"><span class="lineno"> 1284</span>        }</div>
<div class="line"><span class="lineno"> 1285</span>    }</div>
<div class="line"><span class="lineno"> 1286</span> </div>
<div class="line"><span class="lineno"> 1287</span>    <span class="comment">// there exists not transformed halfedges connected to the current halfedge</span></div>
<div class="line"><span class="lineno"> 1288</span>    <span class="keywordflow">if</span> (halfedges_across_cut_path.empty()) {</div>
<div class="line"><span class="lineno"> 1289</span>        <span class="keywordflow">return</span> resolved_inst; <span class="comment">// return the original descriptor</span></div>
<div class="line"><span class="lineno"> 1290</span>    }</div>
<div class="line"><span class="lineno"> 1291</span> </div>
<div class="line"><span class="lineno"> 1292</span>    <span class="comment">// At this, point we have found a number of halfedges which share &quot;m0_h_tgt&quot;</span></div>
<div class="line"><span class="lineno"> 1293</span>    <span class="comment">// with the current halfedge. So we need to decide what value (instance) of</span></div>
<div class="line"><span class="lineno"> 1294</span>    <span class="comment">// &quot;m0_h_tgt&quot; we should assign &quot;resolved_inst&quot;</span></div>
<div class="line"><span class="lineno"> 1295</span> </div>
<div class="line"><span class="lineno"> 1296</span>    <span class="comment">// We classify &quot;halfedges_across_cut_path&quot; into two sets:</span></div>
<div class="line"><span class="lineno"> 1297</span>    <span class="comment">// 1) &quot;halfedges_on_same_side&quot; (... as m0_h )</span></div>
<div class="line"><span class="lineno"> 1298</span>    <span class="comment">// 2) &quot;halfedges_across_cut_path&quot; (other-side)</span></div>
<div class="line"><span class="lineno"> 1299</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 1300</span> </div>
<div class="line"><span class="lineno"> 1301</span>    std::vector&lt;hd_t&gt; halfedges_on_same_side;</div>
<div class="line"><span class="lineno"> 1302</span> </div>
<div class="line"><span class="lineno"> 1303</span>    <span class="keywordflow">if</span> (m0_h_is_ox) {</div>
<div class="line"><span class="lineno"> 1304</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 1305</span>        <span class="comment">// check if the opposite halfedge has been transformed</span></div>
<div class="line"><span class="lineno"> 1306</span>        <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 1307</span> </div>
<div class="line"><span class="lineno"> 1308</span>        <span class="comment">// get opposite halfedge of the current halfedge (m0_h)</span></div>
<div class="line"><span class="lineno"> 1309</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> opp = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(m0_h);</div>
<div class="line"><span class="lineno"> 1310</span> </div>
<div class="line"><span class="lineno"> 1311</span>        <span class="keywordflow">if</span> (<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, opp).<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a809275ccd755fb7b88661d952134b14d">size</a>() &gt; 0 <span class="comment">/*m0_h_to_ply.find(opp) != m0_h_to_ply.end()*/</span>) { <span class="comment">// was the opposite halfedge used to trace a polygon</span></div>
<div class="line"><span class="lineno"> 1312</span>            <span class="comment">// get the previous of the opposite halfedge (because it is one of the &quot;incoming&quot; halfedges)</span></div>
<div class="line"><span class="lineno"> 1313</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> prv_opp = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#ab4bb1cdfa7306e352d20eb92417580ed">prev</a>(opp);</div>
<div class="line"><span class="lineno"> 1314</span> </div>
<div class="line"><span class="lineno"> 1315</span>            <span class="keywordflow">if</span> (<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_sm_ihe_to_flag, prv_opp)) { <span class="comment">// is halfedge processed</span></div>
<div class="line"><span class="lineno"> 1316</span>                halfedges_on_same_side.push_back(prv_opp);</div>
<div class="line"><span class="lineno"> 1317</span>                <span class="comment">// prv_opp is guarranteed to be in halfedges_on_same_side becz halfedges_across_cut_path is simply a vec of all incoming hes</span></div>
<div class="line"><span class="lineno"> 1318</span>                halfedges_across_cut_path.erase(std::find(halfedges_across_cut_path.begin(), halfedges_across_cut_path.end(), prv_opp));</div>
<div class="line"><span class="lineno"> 1319</span>            }</div>
<div class="line"><span class="lineno"> 1320</span>        }</div>
<div class="line"><span class="lineno"> 1321</span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, m0_h).<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a809275ccd755fb7b88661d952134b14d">size</a>() == 0 <span class="comment">/*m0_h_to_ply.find(m0_h) == m0_h_to_ply.end()*/</span>) <span class="comment">// edge-case when src-mesh is not watertight (e.g. test 21)</span></div>
<div class="line"><span class="lineno"> 1322</span>    {</div>
<div class="line"><span class="lineno"> 1323</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(halfedges_across_cut_path.size() == 1);</div>
<div class="line"><span class="lineno"> 1324</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; h = halfedges_across_cut_path.front();</div>
<div class="line"><span class="lineno"> 1325</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; h_proc = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_m1_ihe, h);</div>
<div class="line"><span class="lineno"> 1326</span>        <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> h_tgt = m1.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(h_proc);</div>
<div class="line"><span class="lineno"> 1327</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> tgt_copy = m1.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a0d2a1a79406b7352af07d4fc56707782">add_vertex</a>(m1.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(h_tgt)); <span class="comment">// make a copy</span></div>
<div class="line"><span class="lineno"> 1328</span> </div>
<div class="line"><span class="lineno"> 1329</span>        resolved_inst = tgt_copy;</div>
<div class="line"><span class="lineno"> 1330</span>    } <span class="keywordflow">else</span> { <span class="comment">// then halfedge is either xx or xo (see the conditions with which function is called)</span></div>
<div class="line"><span class="lineno"> 1331</span> </div>
<div class="line"><span class="lineno"> 1332</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> nxt = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a9d7a7440367b78413f762626d2d7dd43">next</a>(m0_h);</div>
<div class="line"><span class="lineno"> 1333</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a> opp_nxt = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#af601050effa9292ffac4274918113712">opposite</a>(nxt);</div>
<div class="line"><span class="lineno"> 1334</span> </div>
<div class="line"><span class="lineno"> 1335</span>        <span class="comment">// MCUT_ASSERT(opp_nxt != hmesh_t::null_halfedge());</span></div>
<div class="line"><span class="lineno"> 1336</span> </div>
<div class="line"><span class="lineno"> 1337</span>        <span class="comment">// if halfedge incident to traced polygon and is it processed</span></div>
<div class="line"><span class="lineno"> 1338</span>        <span class="keywordflow">if</span> (<a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_h_to_ply, opp_nxt).<a class="code hl_variable" href="../../de/d38/lzoconf_8h.html#a809275ccd755fb7b88661d952134b14d">size</a>() &gt; 0 <span class="comment">/*m0_h_to_ply.find(opp_nxt) != m0_h_to_ply.end()*/</span> &amp;&amp; <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_sm_ihe_to_flag, opp_nxt)) {</div>
<div class="line"><span class="lineno"> 1339</span> </div>
<div class="line"><span class="lineno"> 1340</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> nxt_src = m0_h_tgt; <span class="comment">// i.e. m0.source(nxt);</span></div>
<div class="line"><span class="lineno"> 1341</span>            <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> nxt_tgt = m0.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(nxt);</div>
<div class="line"><span class="lineno"> 1342</span>            <span class="keyword">const</span> <span class="keywordtype">bool</span> nxt_src_is_itvx = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(nxt_src, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 1343</span>            <span class="keyword">const</span> <span class="keywordtype">bool</span> nxt_tgt_is_itvx = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#aa7de49b10bd8663a91f01e3beef776ff">m0_is_intersection_point</a>(nxt_tgt, ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 1344</span>            <span class="keyword">const</span> <span class="keywordtype">bool</span> nxt_is_xx = nxt_src_is_itvx &amp;&amp; nxt_tgt_is_itvx;</div>
<div class="line"><span class="lineno"> 1345</span>            <span class="keywordtype">bool</span> on_same_side = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1346</span> </div>
<div class="line"><span class="lineno"> 1347</span>            <span class="keywordflow">if</span> (nxt_is_xx) {</div>
<div class="line"><span class="lineno"> 1348</span><span class="preprocessor">#if 0</span></div>
<div class="line"><span class="lineno"> 1349</span>                    <span class="comment">//const hd_t nxt_src_ps_h = SAFE_ACCESS(m0_ivtx_to_ps_edge, nxt_src);</span></div>
<div class="line"><span class="lineno"> 1350</span>                    <span class="comment">//const hd_t nxt_tgt_ps_h = SAFE_ACCESS(m0_ivtx_to_ps_edge, nxt_tgt);</span></div>
<div class="line"><span class="lineno"> 1351</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)nxt_src - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(nxt_src) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 1352</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> nxt_src_ps_e = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, nxt_src - ps_vtx_cnt).first; <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_edge, nxt_src); // ps.edge(nxt_src_ps_h);</span></div>
<div class="line"><span class="lineno"> 1353</span>                    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)nxt_tgt - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(nxt_tgt) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 1354</span>                    <span class="keyword">const</span> <a class="code hl_class" href="../../da/dd7/classedge__descriptor__t.html">ed_t</a> nxt_tgt_ps_e = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, nxt_tgt - ps_vtx_cnt).first; <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_edge, nxt_tgt); // ps.edge(nxt_tgt_ps_h);</span></div>
<div class="line"><span class="lineno"> 1355</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno"> 1356</span>                <span class="keyword">const</span> <span class="keywordtype">bool</span> is_boundary_halfedge = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#ad0e7884ca4d03bad54f0f83d198676e5">m0_is_polygon_boundary_halfedge</a>(</div>
<div class="line"><span class="lineno"> 1357</span>                    nxt,</div>
<div class="line"><span class="lineno"> 1358</span>                    m0_num_cutpath_halfedges);</div>
<div class="line"><span class="lineno"> 1359</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno"> 1360</span>                <span class="keyword">const</span> <span class="keywordtype">bool</span> nxt_is_exterior = is_boundary_halfedge; <span class="comment">//(nxt_src_ps_e == nxt_tgt_ps_e); // lays on exterior of ps polygon</span></div>
<div class="line"><span class="lineno"> 1361</span> </div>
<div class="line"><span class="lineno"> 1362</span>                on_same_side = nxt_is_exterior;</div>
<div class="line"><span class="lineno"> 1363</span>            }</div>
<div class="line"><span class="lineno"> 1364</span> </div>
<div class="line"><span class="lineno"> 1365</span>            <span class="keywordflow">if</span> (on_same_side) {</div>
<div class="line"><span class="lineno"> 1366</span>                halfedges_on_same_side.push_back(opp_nxt);</div>
<div class="line"><span class="lineno"> 1367</span>                halfedges_across_cut_path.erase(std::find(halfedges_across_cut_path.begin(), halfedges_across_cut_path.end(), opp_nxt));</div>
<div class="line"><span class="lineno"> 1368</span>            }</div>
<div class="line"><span class="lineno"> 1369</span>        }</div>
<div class="line"><span class="lineno"> 1370</span>    }</div>
<div class="line"><span class="lineno"> 1371</span> </div>
<div class="line"><span class="lineno"> 1372</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 1373</span>    <span class="comment">// Decide what to do with target(h) i.e. determine the correct value for &quot;resolved_inst&quot;</span></div>
<div class="line"><span class="lineno"> 1374</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 1375</span> </div>
<div class="line"><span class="lineno"> 1376</span>    <span class="keywordflow">if</span> (!halfedges_on_same_side.empty()) { <span class="comment">// do we already have a halfedge on the [same side] which is tranformed...?</span></div>
<div class="line"><span class="lineno"> 1377</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; ss_h = halfedges_on_same_side.front(); <span class="comment">// we can retrieve any one</span></div>
<div class="line"><span class="lineno"> 1378</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; ss_h_proc = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_m1_ihe, ss_h); <span class="comment">// m1 version</span></div>
<div class="line"><span class="lineno"> 1379</span>        resolved_inst = m1.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(ss_h_proc); <span class="comment">// update reference</span></div>
<div class="line"><span class="lineno"> 1380</span>    } <span class="keywordflow">else</span> { <span class="comment">// do we already have a halfedge on the [other side] which is tranformed...?</span></div>
<div class="line"><span class="lineno"> 1381</span> </div>
<div class="line"><span class="lineno"> 1382</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(!halfedges_across_cut_path.empty());</div>
<div class="line"><span class="lineno"> 1383</span> </div>
<div class="line"><span class="lineno"> 1384</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; h = halfedges_across_cut_path.front();</div>
<div class="line"><span class="lineno"> 1385</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(m0_to_m1_ihe.find(h) != m0_to_m1_ihe.cend());</div>
<div class="line"><span class="lineno"> 1386</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d9/d0a/classhalfedge__descriptor__t.html">hd_t</a>&amp; h_proc = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_to_m1_ihe, h);</div>
<div class="line"><span class="lineno"> 1387</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>)h_proc &lt; (<a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>)m1.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a38154c743bff113eea931e14eaea6ddd">number_of_halfedges</a>());</div>
<div class="line"><span class="lineno"> 1388</span>        <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> h_tgt = m1.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a7500af9f9f2d3b485dc144609ce25c2f">target</a>(h_proc);</div>
<div class="line"><span class="lineno"> 1389</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>)h_tgt &lt; (<a class="code hl_typedef" href="../../db/dc9/_shiny_prereqs_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>)m1.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a35ce6de1cc36d41e9eb48edb3e23e795">number_of_vertices</a>());</div>
<div class="line"><span class="lineno"> 1390</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../dd/d64/classvec3__.html">vec3</a> <a class="code hl_function" href="../../dd/d66/namespacelibnest2d_1_1shapelike.html#a2cf3480dc2a3b7f0c08c7e0028492210">vertex</a> = m1.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a64e5954a3578fded55d07fa8d5ec7bc0">vertex</a>(h_tgt);</div>
<div class="line"><span class="lineno"> 1391</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../de/dc8/classvertex__descriptor__t.html">vd_t</a> tgt_copy = m1.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a0d2a1a79406b7352af07d4fc56707782">add_vertex</a>(vertex); <span class="comment">// make a copy</span></div>
<div class="line"><span class="lineno"> 1392</span> </div>
<div class="line"><span class="lineno"> 1393</span>        resolved_inst = tgt_copy;</div>
<div class="line"><span class="lineno"> 1394</span>    }</div>
<div class="line"><span class="lineno"> 1395</span> </div>
<div class="line"><span class="lineno"> 1396</span>    <span class="keywordflow">return</span> resolved_inst;</div>
<div class="line"><span class="lineno"> 1397</span>};</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00348">hmesh_t::add_vertex()</a>, <a class="el" href="../../#l00211">hmesh_t::face()</a>, <a class="el" href="../../#l00261">hmesh_t::halfedge()</a>, <a class="el" href="../../#l00134">m0_is_intersection_point()</a>, <a class="el" href="../../#l01173">m0_is_polygon_boundary_halfedge()</a>, <a class="el" href="../../#l00062">MCUT_ASSERT</a>, <a class="el" href="../../#l00172">hmesh_t::next()</a>, <a class="el" href="../../#l00107">hmesh_t::null_face()</a>, <a class="el" href="../../#l00125">hmesh_t::number_of_halfedges()</a>, <a class="el" href="../../#l00115">hmesh_t::number_of_vertices()</a>, <a class="el" href="../../#l00152">hmesh_t::opposite()</a>, <a class="el" href="../../#l00164">hmesh_t::prev()</a>, <a class="el" href="../../#l00145">ps_is_cutmesh_face()</a>, <a class="el" href="../../#l00140">ps_is_cutmesh_vertex()</a>, <a class="el" href="../../#l00097">SAFE_ACCESS</a>, <a class="el" href="../../#l00378">size</a>, <a class="el" href="../../#l00135">hmesh_t::source()</a>, <a class="el" href="../../#l00144">hmesh_t::target()</a>, and <a class="el" href="../../#l00219">hmesh_t::vertex()</a>.</p>
<div id="dynsection-24" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-24-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-24-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-24-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="../../dd/d24/kernel_8cpp_a0299dc00caf656e5713f528574c77a02_cgraph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>

</div>
</div>
<a id="aaeec0701cfd56cb95323d088cd3d39e1" name="aaeec0701cfd56cb95323d088cd3d39e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeec0701cfd56cb95323d088cd3d39e1">&#9670;&#160;</a></span>to_string() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956">cm_patch_location_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   74</span>{</div>
<div class="line"><span class="lineno">   75</span>    std::string s;</div>
<div class="line"><span class="lineno">   76</span>    <span class="keywordflow">switch</span> (v) {</div>
<div class="line"><span class="lineno">   77</span>    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956a554a7418c4c0dafd902ebd377b87c80c">cm_patch_location_t::INSIDE</a>:</div>
<div class="line"><span class="lineno">   78</span>        s = <span class="stringliteral">&quot;i&quot;</span>;</div>
<div class="line"><span class="lineno">   79</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">   80</span>    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956a93da25bafef6761717afc6b25c17ea16">cm_patch_location_t::OUTSIDE</a>:</div>
<div class="line"><span class="lineno">   81</span>        s = <span class="stringliteral">&quot;o&quot;</span>;</div>
<div class="line"><span class="lineno">   82</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">   83</span>    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956a0db45d2a4141101bdfe48e3314cfbca3">cm_patch_location_t::UNDEFINED</a>:</div>
<div class="line"><span class="lineno">   84</span>        s = <span class="stringliteral">&quot;u&quot;</span>;</div>
<div class="line"><span class="lineno">   85</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">   86</span>    }</div>
<div class="line"><span class="lineno">   87</span>    <span class="keywordflow">return</span> s;</div>
<div class="line"><span class="lineno">   88</span>}</div>
<div class="ttc" id="amcut_2include_2mcut_2internal_2kernel_8h_html_a09475ec58d62ab7e47b2e880a6909956a0db45d2a4141101bdfe48e3314cfbca3"><div class="ttname"><a href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956a0db45d2a4141101bdfe48e3314cfbca3">cm_patch_location_t::UNDEFINED</a></div><div class="ttdeci">@ UNDEFINED</div></div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956a554a7418c4c0dafd902ebd377b87c80c">INSIDE</a>, <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956a93da25bafef6761717afc6b25c17ea16">OUTSIDE</a>, and <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a09475ec58d62ab7e47b2e880a6909956a0db45d2a4141101bdfe48e3314cfbca3">UNDEFINED</a>.</p>

</div>
</div>
<a id="a9f43e5a2eced0af01dc1143d0e70bc64" name="a9f43e5a2eced0af01dc1143d0e70bc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f43e5a2eced0af01dc1143d0e70bc64">&#9670;&#160;</a></span>to_string() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#afff2632fef27a069a33f81a0b51400f3">cm_patch_winding_order_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  120</span>{</div>
<div class="line"><span class="lineno">  121</span>    std::string s;</div>
<div class="line"><span class="lineno">  122</span>    <span class="keywordflow">switch</span> (v) {</div>
<div class="line"><span class="lineno">  123</span>    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#afff2632fef27a069a33f81a0b51400f3a5b39c8b553c821e7cddc6da64b5bd2ee">cm_patch_winding_order_t::DEFAULT</a>:</div>
<div class="line"><span class="lineno">  124</span>        s = <span class="stringliteral">&quot;def&quot;</span>;</div>
<div class="line"><span class="lineno">  125</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  126</span>    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#afff2632fef27a069a33f81a0b51400f3a642e0b6684e6165e142c074f1cd8d55c">cm_patch_winding_order_t::REVERSE</a>:</div>
<div class="line"><span class="lineno">  127</span>        s = <span class="stringliteral">&quot;rev&quot;</span>;</div>
<div class="line"><span class="lineno">  128</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  129</span>    }</div>
<div class="line"><span class="lineno">  130</span>    <span class="keywordflow">return</span> s;</div>
<div class="line"><span class="lineno">  131</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#afff2632fef27a069a33f81a0b51400f3a5b39c8b553c821e7cddc6da64b5bd2ee">DEFAULT</a>, and <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#afff2632fef27a069a33f81a0b51400f3a642e0b6684e6165e142c074f1cd8d55c">REVERSE</a>.</p>

</div>
</div>
<a id="ac170ee95cd3318133c47c23a4a4412b8" name="ac170ee95cd3318133c47c23a4a4412b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac170ee95cd3318133c47c23a4a4412b8">&#9670;&#160;</a></span>to_string() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1">sm_frag_location_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   57</span>{</div>
<div class="line"><span class="lineno">   58</span>    std::string s;</div>
<div class="line"><span class="lineno">   59</span>    <span class="keywordflow">switch</span> (v) {</div>
<div class="line"><span class="lineno">   60</span>    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1ac2d92b81beeac9bfc89fb870c1a20767">sm_frag_location_t::ABOVE</a>:</div>
<div class="line"><span class="lineno">   61</span>        s = <span class="stringliteral">&quot;a&quot;</span>;</div>
<div class="line"><span class="lineno">   62</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">   63</span>    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1aa25949e21299b84cc33c4b00c740f08f">sm_frag_location_t::BELOW</a>:</div>
<div class="line"><span class="lineno">   64</span>        s = <span class="stringliteral">&quot;b&quot;</span>;</div>
<div class="line"><span class="lineno">   65</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">   66</span>    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1a0db45d2a4141101bdfe48e3314cfbca3">sm_frag_location_t::UNDEFINED</a>:</div>
<div class="line"><span class="lineno">   67</span>        s = <span class="stringliteral">&quot;u&quot;</span>;</div>
<div class="line"><span class="lineno">   68</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">   69</span>    }</div>
<div class="line"><span class="lineno">   70</span>    <span class="keywordflow">return</span> s;</div>
<div class="line"><span class="lineno">   71</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1ac2d92b81beeac9bfc89fb870c1a20767">ABOVE</a>, <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1aa25949e21299b84cc33c4b00c740f08f">BELOW</a>, and <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#a40e02a0f5aec11abce73c46fe0ff41f1a0db45d2a4141101bdfe48e3314cfbca3">UNDEFINED</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../#l00225">WipingPanel::WipingPanel()</a>, <a class="el" href="../../#l01276">preproc()</a>, <a class="el" href="../../#l00406">igl::xml::serialization_xml::serialize()</a>, and <a class="el" href="../../#l00441">igl::xml::serialization_xml::serialize()</a>.</p>
<div id="dynsection-25" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-25-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-25-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-25-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../dd/d24/kernel_8cpp_ac170ee95cd3318133c47c23a4a4412b8_icgraph.svg" width="306" height="216"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<a id="ae26a7aae724ffde0eb556f68a46d59af" name="ae26a7aae724ffde0eb556f68a46d59af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26a7aae724ffde0eb556f68a46d59af">&#9670;&#160;</a></span>to_string() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   91</span>{</div>
<div class="line"><span class="lineno">   92</span>    std::string s;</div>
<div class="line"><span class="lineno">   93</span>    <span class="keywordflow">switch</span> (v) {</div>
<div class="line"><span class="lineno">   94</span>    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586ad0749aaba8b833466dfcbb0428e4f89c">status_t::SUCCESS</a>:</div>
<div class="line"><span class="lineno">   95</span>        s = <span class="stringliteral">&quot;SUCCESS&quot;</span>;</div>
<div class="line"><span class="lineno">   96</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">   97</span>    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a4f41dc6e379aa2a8afaaee78c29c85ec">status_t::INVALID_SRC_MESH</a>:</div>
<div class="line"><span class="lineno">   98</span>        s = <span class="stringliteral">&quot;INVALID_SRC_MESH&quot;</span>;</div>
<div class="line"><span class="lineno">   99</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  100</span>    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a8737035059b46024b097c7e96031ee2e">status_t::INVALID_CUT_MESH</a>:</div>
<div class="line"><span class="lineno">  101</span>        s = <span class="stringliteral">&quot;INVALID_CUT_MESH&quot;</span>;</div>
<div class="line"><span class="lineno">  102</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  103</span>    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a1919962cb3db319ec5b0563a93a68d8a">status_t::INVALID_MESH_INTERSECTION</a>:</div>
<div class="line"><span class="lineno">  104</span>        s = <span class="stringliteral">&quot;INVALID_MESH_INTERSECTION&quot;</span>;</div>
<div class="line"><span class="lineno">  105</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  106</span>    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a91712b49b91fbf59087df24104715e29">status_t::GENERAL_POSITION_VIOLATION</a>:</div>
<div class="line"><span class="lineno">  107</span>        s = <span class="stringliteral">&quot;GENERAL_POSITION_VIOLATION&quot;</span>;</div>
<div class="line"><span class="lineno">  108</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  109</span>    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a86987e2e179fda428149b6ccce3fb9ab">status_t::DETECTED_FLOATING_POLYGON</a>:</div>
<div class="line"><span class="lineno">  110</span>        s = <span class="stringliteral">&quot;DETECTED_FLOATING_POLYGON&quot;</span>;</div>
<div class="line"><span class="lineno">  111</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  112</span>        <span class="comment">// case status_t::FACE_VERTEX_INTERSECTION:</span></div>
<div class="line"><span class="lineno">  113</span>        <span class="comment">//     s = &quot;FACE_VERTEX_INTERSECTION&quot;;</span></div>
<div class="line"><span class="lineno">  114</span>        <span class="comment">//     break;</span></div>
<div class="line"><span class="lineno">  115</span>    }</div>
<div class="line"><span class="lineno">  116</span>    <span class="keywordflow">return</span> s;</div>
<div class="line"><span class="lineno">  117</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a86987e2e179fda428149b6ccce3fb9ab">DETECTED_FLOATING_POLYGON</a>, <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a91712b49b91fbf59087df24104715e29">GENERAL_POSITION_VIOLATION</a>, <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a8737035059b46024b097c7e96031ee2e">INVALID_CUT_MESH</a>, <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a1919962cb3db319ec5b0563a93a68d8a">INVALID_MESH_INTERSECTION</a>, <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586a4f41dc6e379aa2a8afaaee78c29c85ec">INVALID_SRC_MESH</a>, and <a class="el" href="../../d5/d50/mcut_2include_2mcut_2internal_2kernel_8h.html#af9bff8ff1154a04a899276af806b8586ad0749aaba8b833466dfcbb0428e4f89c">SUCCESS</a>.</p>

</div>
</div>
<a id="a263f562fbe3843b93d07f1b41eb4362e" name="a263f562fbe3843b93d07f1b41eb4362e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263f562fbe3843b93d07f1b41eb4362e">&#9670;&#160;</a></span>update_neighouring_ps_iface_m0_edge_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d95/glu-libtess_8h.html#a4292190e3f1f6b373a760c7d9316ad3c">void</a> update_neighouring_ps_iface_m0_edge_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &amp;&#160;</td>
          <td class="paramname"><em>src_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d77/hmesh_8h.html#a4a483cf58ff6b716fbeba2dc8c76ffa1">vd_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tgt_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d7/d63/classhmesh__t.html">hmesh_t</a> &amp;&#160;</td>
          <td class="paramname"><em>ps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a>&#160;</td>
          <td class="paramname"><em>sm_face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a>&#160;</td>
          <td class="paramname"><em>cs_face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a92abe1b30dc402b94e53318479d8b242">ed_t</a>, <a class="el" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>m0_ivtx_to_intersection_registry_entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; <a class="el" href="../../df/d77/hmesh_8h.html#ac664ff0579ccea0a9ca27aaf2ffdcfcd">fd_t</a>, std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a92abe1b30dc402b94e53318479d8b242">ed_t</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ps_iface_to_m0_edge_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="../../df/d77/hmesh_8h.html#a92abe1b30dc402b94e53318479d8b242">ed_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m0_cutpath_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1421</span>{</div>
<div class="line"><span class="lineno"> 1422</span>    <span class="keyword">const</span> <span class="keywordtype">int</span> ps_vtx_cnt = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a35ce6de1cc36d41e9eb48edb3e23e795">number_of_vertices</a>();</div>
<div class="line"><span class="lineno"> 1423</span>    <span class="comment">// for all neighbours of &quot;sm_face&quot; and &quot;cs_face&quot;</span></div>
<div class="line"><span class="lineno"> 1424</span>    <span class="comment">//  if the face is in the registry of src and tgt vertex</span></div>
<div class="line"><span class="lineno"> 1425</span>    <span class="comment">//      get edge list of face</span></div>
<div class="line"><span class="lineno"> 1426</span>    <span class="comment">//      if list does not already contain new edge</span></div>
<div class="line"><span class="lineno"> 1427</span>    <span class="comment">//          add new edge to list</span></div>
<div class="line"><span class="lineno"> 1428</span> </div>
<div class="line"><span class="lineno"> 1429</span>    std::vector&lt;fd_t&gt; neighbouring_ifaces;</div>
<div class="line"><span class="lineno"> 1430</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> neigh_face : { sm_face, cs_face }) {</div>
<div class="line"><span class="lineno"> 1431</span>        <span class="keyword">const</span> std::vector&lt;face_descriptor_t&gt; faces_around_face = ps.<a class="code hl_function" href="../../d7/d63/classhmesh__t.html#a197264c917b7fb5ddc007909ae89d372">get_faces_around_face</a>(neigh_face);</div>
<div class="line"><span class="lineno"> 1432</span>        neighbouring_ifaces.insert(neighbouring_ifaces.end(), faces_around_face.cbegin(), faces_around_face.cend());</div>
<div class="line"><span class="lineno"> 1433</span>    }</div>
<div class="line"><span class="lineno"> 1434</span> </div>
<div class="line"><span class="lineno"> 1435</span>    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)src_vertex - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(src_vertex) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 1436</span>    <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt;&amp; src_vertex_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, (std::size_t)src_vertex - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 1437</span>    <span class="keyword">const</span> std::vector&lt;fd_t&gt; src_registry = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#abcaa230eb10486e26a5167bae360d451">ps_get_ivtx_registry_entry_faces</a>(ps, src_vertex_ipair); <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_faces, src_vertex);</span></div>
<div class="line"><span class="lineno"> 1438</span> </div>
<div class="line"><span class="lineno"> 1439</span>    <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>((<span class="keywordtype">size_t</span>)tgt_vertex - ps_vtx_cnt &lt; m0_ivtx_to_intersection_registry_entry.size() <span class="comment">/*m0_ivtx_to_intersection_registry_entry.find(tgt_vertex) != m0_ivtx_to_intersection_registry_entry.cend()*/</span>);</div>
<div class="line"><span class="lineno"> 1440</span>    <span class="keyword">const</span> std::pair&lt;ed_t, fd_t&gt;&amp; tgt_vertex_ipair = <a class="code hl_define" href="../../d5/d60/utils_8h.html#af39e5a34a17cb0b2960384bdb2654831">SAFE_ACCESS</a>(m0_ivtx_to_intersection_registry_entry, (std::size_t)tgt_vertex - ps_vtx_cnt);</div>
<div class="line"><span class="lineno"> 1441</span>    <span class="keyword">const</span> std::vector&lt;fd_t&gt; tgt_registry = <a class="code hl_function" href="../../dd/d24/kernel_8cpp.html#abcaa230eb10486e26a5167bae360d451">ps_get_ivtx_registry_entry_faces</a>(ps, tgt_vertex_ipair); <span class="comment">// SAFE_ACCESS(m0_ivtx_to_ps_faces, tgt_vertex);</span></div>
<div class="line"><span class="lineno"> 1442</span> </div>
<div class="line"><span class="lineno"> 1443</span>    <span class="comment">// for each face that is a neighbour to either sm-face or cm-face</span></div>
<div class="line"><span class="lineno"> 1444</span>    <span class="keywordflow">for</span> (std::vector&lt;fd_t&gt;::const_iterator neigh_face_it = neighbouring_ifaces.cbegin();</div>
<div class="line"><span class="lineno"> 1445</span>         neigh_face_it != neighbouring_ifaces.cend();</div>
<div class="line"><span class="lineno"> 1446</span>         ++neigh_face_it) {</div>
<div class="line"><span class="lineno"> 1447</span>        <span class="keyword">const</span> <a class="code hl_class" href="../../d1/dc7/classface__descriptor__t.html">fd_t</a> iface = *neigh_face_it;</div>
<div class="line"><span class="lineno"> 1448</span> </div>
<div class="line"><span class="lineno"> 1449</span>        <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(iface != sm_face &amp;&amp; iface != cs_face);</div>
<div class="line"><span class="lineno"> 1450</span> </div>
<div class="line"><span class="lineno"> 1451</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> in_src_reg = std::find(src_registry.cbegin(), src_registry.cend(), iface) != src_registry.cend();</div>
<div class="line"><span class="lineno"> 1452</span>        <span class="keyword">const</span> <span class="keywordtype">bool</span> in_tgt_reg = std::find(tgt_registry.cbegin(), tgt_registry.cend(), iface) != tgt_registry.cend();</div>
<div class="line"><span class="lineno"> 1453</span> </div>
<div class="line"><span class="lineno"> 1454</span>        <span class="keywordflow">if</span> (in_src_reg &amp;&amp; in_tgt_reg) {</div>
<div class="line"><span class="lineno"> 1455</span>            std::unordered_map&lt;fd_t, std::vector&lt;ed_t&gt;&gt;::iterator fiter = ps_iface_to_m0_edge_list.find(iface);</div>
<div class="line"><span class="lineno"> 1456</span>            <span class="keywordtype">bool</span> iface_associated_with_some_edges = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1457</span>            <span class="keywordflow">if</span> (fiter == ps_iface_to_m0_edge_list.cend()) {</div>
<div class="line"><span class="lineno"> 1458</span>                <span class="comment">// insert</span></div>
<div class="line"><span class="lineno"> 1459</span>                std::pair&lt;std::unordered_map&lt;fd_t, std::vector&lt;ed_t&gt;&gt;::iterator, <span class="keywordtype">bool</span>&gt; p = ps_iface_to_m0_edge_list.insert(std::make_pair(iface, std::vector&lt;ed_t&gt;()));</div>
<div class="line"><span class="lineno"> 1460</span>                <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(p.second == <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno"> 1461</span>                fiter = p.first;</div>
<div class="line"><span class="lineno"> 1462</span>                iface_associated_with_some_edges = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 1463</span>            }</div>
<div class="line"><span class="lineno"> 1464</span> </div>
<div class="line"><span class="lineno"> 1465</span>            <a class="code hl_define" href="../../d5/d60/utils_8h.html#a192a6876488933a545c507187414de46">MCUT_ASSERT</a>(fiter != ps_iface_to_m0_edge_list.cend());</div>
<div class="line"><span class="lineno"> 1466</span> </div>
<div class="line"><span class="lineno"> 1467</span>            std::vector&lt;ed_t&gt;&amp; iface_m0_edge_list = fiter-&gt;second;</div>
<div class="line"><span class="lineno"> 1468</span> </div>
<div class="line"><span class="lineno"> 1469</span>            <span class="keywordtype">bool</span> associate_iface_with_edge = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1470</span>            <span class="keywordflow">if</span> (iface_associated_with_some_edges) {</div>
<div class="line"><span class="lineno"> 1471</span>                <span class="keywordtype">bool</span> edge_already_associated_with_iface = std::find(iface_m0_edge_list.cbegin(), iface_m0_edge_list.cend(), m0_cutpath_edges.back()) != iface_m0_edge_list.cend();</div>
<div class="line"><span class="lineno"> 1472</span>                associate_iface_with_edge = !(edge_already_associated_with_iface);</div>
<div class="line"><span class="lineno"> 1473</span>            }</div>
<div class="line"><span class="lineno"> 1474</span> </div>
<div class="line"><span class="lineno"> 1475</span>            <span class="keywordflow">if</span> (associate_iface_with_edge) {</div>
<div class="line"><span class="lineno"> 1476</span>                iface_m0_edge_list.push_back(m0_cutpath_edges.back());</div>
<div class="line"><span class="lineno"> 1477</span>            }</div>
<div class="line"><span class="lineno"> 1478</span>        }</div>
<div class="line"><span class="lineno"> 1479</span>    }</div>
<div class="line"><span class="lineno"> 1480</span>}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="../../#l00748">hmesh_t::get_faces_around_face()</a>, <a class="el" href="../../#l00062">MCUT_ASSERT</a>, <a class="el" href="../../#l00115">hmesh_t::number_of_vertices()</a>, <a class="el" href="../../#l01399">ps_get_ivtx_registry_entry_faces()</a>, and <a class="el" href="../../#l00097">SAFE_ACCESS</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../#l01558">dispatch()</a>.</p>
<div id="dynsection-26" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-26-trigger" src="../../closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-26-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-26-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="../../dd/d24/kernel_8cpp_a263f562fbe3843b93d07f1b41eb4362e_cgraph.svg" width="100%" height="586"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
</div>
<div id="dynsection-27" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-27-trigger" src="../../closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-27-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-27-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../dd/d24/kernel_8cpp_a263f562fbe3843b93d07f1b41eb4362e_icgraph.svg" width="403" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a22191ac3d02f34a43e21432ad2289f14" name="a22191ac3d02f34a43e21432ad2289f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22191ac3d02f34a43e21432ad2289f14">&#9670;&#160;</a></span>logger_ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d0d/classlogger__t.html">logger_t</a>* logger_ptr = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="../../#l01558">dispatch()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="../../dir_dcca113433f6f432fc72a906d81d6a67.html">mcut</a></li><li class="navelem"><a class="el" href="../../dir_1df28f6a00ea7ea1acb056de0f6aea60.html">source</a></li><li class="navelem"><a class="el" href="../../dd/d24/kernel_8cpp.html">kernel.cpp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
